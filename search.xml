<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS Position</title>
    <url>/2021/11/07/CSS-Position/</url>
    <content><![CDATA[<p><code>position</code> 是 <code>css</code> 中一个非常重要的属性。它的作用是将元素在网页中定位。而设定值总共有 5 个。分别是 <code>static</code>、<code>absolute</code>、<code>relative</code>、<code>fixed</code> 以及 <code>sticky</code></p>
<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p><code>HTML</code> 里面所有元素的 <code>position</code> 默认值都是 <code>static</code></p>
<p><code>static</code> 会跟随 HTML 排版的流程(flow)移动(最常见的 HTML 排版格式)(元素从上到下，非重叠的排列)<br><code>static</code>的元素对于 top、left、right、bottom 设定值不会生效</p>
<p>例子代码：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">/* html文件 */</span><br>&lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;parent&quot;</span>&gt;<br>  Parent<br>  &lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;child-one child&quot;</span>&gt;<br>    One<br>  &lt;/div&gt;<br>  &lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;child-two child&quot;</span>&gt;<br>    Two<br>  &lt;/div&gt;<br>  &lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;child-three child&quot;</span>&gt;<br>    Three<br>  &lt;/div&gt;<br>&lt;/div&gt;<br><br><span class="hljs-comment">/* css文件 */</span><br><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span>;<br>  <span class="hljs-attribute">background-color</span>: hsl(<span class="hljs-number">200</span>, <span class="hljs-number">80%</span>, <span class="hljs-number">50%</span>);<br>&#125;<br><br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.child-one</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: hsl(<span class="hljs-number">0</span>, <span class="hljs-number">80%</span>, <span class="hljs-number">50%</span>);<br>&#125;<br><br><span class="hljs-selector-class">.child-two</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: hsl(<span class="hljs-number">50</span>, <span class="hljs-number">80%</span>, <span class="hljs-number">50%</span>);<br>&#125;<br><br><span class="hljs-selector-class">.child-three</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: hsl(<span class="hljs-number">100</span>, <span class="hljs-number">80%</span>, <span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>效果显示：<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-07-at-1.06.35-PM.72mf9nnxe9k0.png" alt="static效果"></p>
<h5 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h5><p><code>relative</code> 也会跟随 HTML 排版的流程(flow)移动。<strong>但是它比<code>static</code>多了 top、left、right、bottom 的设定。</strong><br>并且使用 relative 的模块的位置移动不影响其他模块(如果是使用了位置移动，则该模块脱离了文档流，似乎不太纯粹…)</p>
<blockquote>
<p>注意点：<code>relative</code> 事实上<strong>最好不要使用</strong>位置的移动，不然容易造成显示的混乱</p>
</blockquote>
<p>除此之外，**<code>relative</code>最重要的一个功能是在它里面的<code>absolute</code>元素会根据<code>relative</code>的位置去定位**</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* css文件 */</span><br>// 其余代码部分和上述一样<br><br><span class="hljs-selector-class">.child-one</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">hsl</span>(<span class="hljs-number">0</span>, <span class="hljs-number">80%</span>, <span class="hljs-number">50%</span>);<br>  <span class="hljs-comment">/*  进行relative操作  */</span><br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">5px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-07-at-1.11.21-PM.1bun6g5kxrwg.png" alt="relative效果"></p>
<h5 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h5><p>现在来看一下代码：<br>(其余代码和 static 那节没有变化)</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.child-one</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">hsl</span>(<span class="hljs-number">0</span>, <span class="hljs-number">80%</span>, <span class="hljs-number">50%</span>);<br>  <span class="hljs-attribute">position</span>: absolute;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-07-at-1.24.10-PM.3bbsxkssqvi0.png" alt="absolute效果1"></p>
<p>可见，<code>One</code> 这个<code>div元素</code>失去了宽度。原因是，<code>absolute</code>属性完完全全的让当前元素脱离了文档流, 对于其他没有设置为<code>absolute</code>的元素来说，<code>One</code>这个元素好似不存在！</p>
<blockquote>
<p><strong>注意点</strong>：事实上,我上面已说，<code>relative</code>不适合用位置移动。而<code>absolute</code>却是<strong>非常适合</strong>使用位置移动的！！</p>
</blockquote>
<p><code>absolute</code>这种方式会非常方便在你想在某个位置固定住一个元素，而其他元素不会影响这个被固定住的元素 (完全脱离文档流 + 位置的移动)</p>
<blockquote>
<p>还有一个<strong>注意点</strong>：absolute 的位置移动是相对于父元素的(非 static、absolute)。如果父元素是(static、absolute)的，则会进行找父元素的父元素进行看是否符合条件(非 static、absolute)。如果都不符合条件，则根据最顶层元素来进行位置的移动…</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.child-one</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">hsl</span>(<span class="hljs-number">0</span>, <span class="hljs-number">80%</span>, <span class="hljs-number">50%</span>);<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-07-at-1.39.17-PM.4d2dsj8a49w.png" alt="absolute效果2"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">hsl</span>(<span class="hljs-number">200</span>, <span class="hljs-number">80%</span>, <span class="hljs-number">50%</span>);<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.child-one</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">hsl</span>(<span class="hljs-number">0</span>, <span class="hljs-number">80%</span>, <span class="hljs-number">50%</span>);<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-07-at-1.41.30-PM.5stck9to3m00.png" alt="absolute效果3"></p>
<p><strong>(absolute + relative 是绝配)</strong></p>
<h5 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h5><p><code>fixed</code> 与 <code>absolute</code> 很相似。不同的地方有以下两个</p>
<ol>
<li><code>fixed</code> 会定位到荧幕中的固定位置。所以即使卷动页面，也会一直保持在那个位置</li>
<li>即使放在<code>relative</code>页面，<code>fixed</code>元素也会根据页面，即 body 去定位，不会根据 relative 去定位(这是要在 fiex 设定了 top、left、right、bottom 等属性时才会出现的效果)</li>
</ol>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/* HTML文件 */</span><br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;<br>  Parent<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;child-one child&quot;</span>&gt;<br>    One<br>  &lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;child-two child&quot;</span>&gt;<br>    Two<br>  &lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;child-three child&quot;</span>&gt;<br>    Three<br>  &lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt; * <span class="hljs-number">100</span><br>&lt;/<span class="hljs-keyword">div</span>&gt;<br><br><span class="hljs-comment">/* css文件 */</span><br>.child-one &#123;<br>  background-color: hsl(<span class="hljs-number">0</span>, <span class="hljs-number">80</span>%, <span class="hljs-number">50</span>%);<br>  position: fixed;<br>  bottom: <span class="hljs-number">10</span>px;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-07-at-1.59.31-PM.5f6b4g3m13w0.gif" alt="fixed效果显示"></p>
<p>如果是 <code>absolute</code>。<code>absolute</code> 元素所在的容器(父元素)有卷轴的话，它就会随着卷动而移动<br><strong>(这是 fixed 和 absolute 二者最大的不同)</strong></p>
<h4 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a>sticky</h4><p>sticky 是完美结合了 <code>relative</code> 和 <code>fixed</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* css文件 */</span><br><span class="hljs-selector-class">.child-one</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">hsl</span>(<span class="hljs-number">0</span>, <span class="hljs-number">80%</span>, <span class="hljs-number">50%</span>);<br>  <span class="hljs-attribute">position</span>: sticky;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>外表看似和 relative 效果差不多。可真正滚动滑条的时候就大大的不同了<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-07-at-2.11.58-PM.4gp9o7g2tf60.gif" alt="sticky效果"></p>
<h5 id="sticky-效果图"><a href="#sticky-效果图" class="headerlink" title="sticky 效果图"></a>sticky 效果图</h5><p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-07-at-4.45.31-PM.3ysiy6q3te40.gif" alt="sticky效果图1"><br><a href="https://codepen.io/bruce-shuai/pen/yLoKqqR?editors=1100">对应代码</a></p>
]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS-in-JS</title>
    <url>/2021/10/10/CSS-in-JS/</url>
    <content><![CDATA[<blockquote>
<p>注意：css 模块与 webpack 的相关内容有待补充！</p>
</blockquote>
<p><code>CSS-in-JS</code> 不是指某一个具体的库，是指<strong>组织 CSS 代码的一种方式</strong>，代表库有 <a href="https://styled-components.com/">styled-component</a> 和 <a href="https://emotion.sh/docs/introduction">emotion</a>。</p>
<h4 id="传统-CSS-的缺陷"><a href="#传统-CSS-的缺陷" class="headerlink" title="传统 CSS 的缺陷"></a>传统 CSS 的缺陷</h4><ol>
<li><p>缺乏模块组织<br>在传统的 JS 和 CSS 中其实都没有<strong>模块</strong>的概念，后来在 JS 界陆续有了 CommonJS 和 ECMAScript Module, 以及<code>webpack</code>为主的模块打包工具渐渐的成熟。而<code>CSS-in-JS</code>就可以用<strong>模块化的方式</strong>组织 CSS，<strong>依托与 JS 的模块化方案</strong>。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> styled <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@emotion/styled&#x27;</span>;<br><br><span class="hljs-comment">// styled 其实就是一个模块</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Button = styled.button<span class="hljs-string">`</span><br><span class="hljs-string"> color: turquoise;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure></li>
<li><p>缺乏作用域<br>传统的 <code>CSS</code> 只有一个<code>全局作用域</code>，比如说一个 class 可以匹配全局的任意元素。随着项目成长，CSS 会变得越来越难以组织，最终导致失控。<code>CSS-in-JS</code> 可以通过生成独特的选择符，来实现作用域的效果。</p>
</li>
</ol>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.css-1c4ktv6</span> &gt;* &#123;   <span class="hljs-comment">// 1c4ktv6是哈希</span><br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">0</span> <span class="hljs-meta">!important</span>;<br>  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">0</span> <span class="hljs-meta">!important</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> css = <span class="hljs-function"><span class="hljs-params">styleBlock</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> className = someHash(styleBlock);<br>  <span class="hljs-keyword">const</span> styleEl = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;style&#x27;</span>);<br>  styleEl.textContent = <span class="hljs-string">`</span><br><span class="hljs-string">    .<span class="hljs-subst">$&#123;className&#125;</span> &#123;</span><br><span class="hljs-string">      <span class="hljs-subst">$&#123;styleBlock&#125;</span></span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">  `</span>;<br>  <span class="hljs-built_in">document</span>.head.appendChild(styleEl);<br>  <span class="hljs-keyword">return</span> className;<br>&#125;<br><span class="hljs-keyword">const</span> className = css(<span class="hljs-string">`</span><br><span class="hljs-string">  color: red;</span><br><span class="hljs-string">  padding: 20px;</span><br><span class="hljs-string">`</span>);<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>隐式依赖，让样式难以追踪</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-class">.target</span> <span class="hljs-selector-class">.name</span> <span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><br><span class="hljs-selector-tag">body</span> <span class="hljs-selector-id">#container</span> <span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">color</span>: green<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!doctype <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;container&#x27;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;target&#x27;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;name&#x27;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是啥颜色？<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    // 这会让人懵逼的...<br>     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>那么这个 h1 元素最终显式为什么颜色？加入你想要追踪这个影响这个 h1 的样式，怎么追踪？</p>
<p>而 CSS-in-JS 的方案就简单直接、易于追踪：</p>
<figure class="highlight hsp"><table><tr><td class="code"><pre><code class="hljs hsp">export const <span class="hljs-keyword">Title</span> = styled.h1`<br>  <span class="hljs-keyword">color</span>: green<span class="hljs-comment">;</span><br>`<br>&lt;<span class="hljs-keyword">Title</span>&gt;<br>  我是啥颜色？<br>&lt;/<span class="hljs-keyword">Title</span>&gt;<br></code></pre></td></tr></table></figure>

<ol start="4">
<li><p>没有变量<br>传统的 CSS 规则里没有变量…(其实有–var 变量)，但是在 CSS-in-JS 中可以方便地控制变量：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">const</span> Container = styled.<span class="hljs-keyword">div</span>(props =&gt; (&#123;<br> <span class="hljs-keyword">display</span>: <span class="hljs-string">&#x27;flex&#x27;</span>,<br> flexDirection: props.column &amp;&amp; <span class="hljs-string">&#x27;column&#x27;</span><br>&#125;))<br></code></pre></td></tr></table></figure></li>
<li><p>CSS 选择器与 HTML 元素高度耦合</p>
</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-class">.target</span> <span class="hljs-selector-class">.name</span> <span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-selector-tag">body</span> <span class="hljs-selector-id">#container</span> <span class="hljs-selector-tag">h1</span> &#123;<br>    <span class="hljs-attribute">color</span>: green<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!doctype <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;container&#x27;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;target&#x27;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;name&#x27;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是啥颜色？<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>如果你想把 h1 改成 h2，必须要同时改动 CSS 和 HTML。而在 CSS-in-JS 中，HTML 和 CSS 是结合在一起的，易于修改。(这其实是在程序层次上需要极力去避免的…)</p>
<hr>
<h4 id="Emotion-介绍"><a href="#Emotion-介绍" class="headerlink" title="Emotion 介绍"></a>Emotion 介绍</h4><p>Emotion 是目前最受欢迎的 CSS-in-JS 库之一，它还对 React 作了很好的适应，可以方便地创建 styled component，也支持写行内样式：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/** @jsx jsx */</span><br><span class="hljs-keyword">import</span> &#123; jsx &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@emotion/react&#x27;</span>;<br><br>render(<br>  &lt;<span class="hljs-keyword">div</span><br>    css=&#123;&#123;<br>      backgroundColor: <span class="hljs-string">&#x27;hotpink&#x27;</span>,<br>      <span class="hljs-string">&#x27;&amp;:hover&#x27;</span>: &#123;<br>        color: <span class="hljs-string">&#x27;lightgreen&#x27;</span><br>      &#125;<br>    &#125;&#125;<br>  &gt;<br>    <span class="hljs-keyword">This</span> has a hotpink background.<br>  &lt;/<span class="hljs-keyword">div</span>&gt;<br><br>)<br></code></pre></td></tr></table></figure>

<p>这种写法比起 React 自带的 style 的写法功能更强大，比如可以处理级联、伪类等 style 处理的不了的情况：</p>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">color:</span> <span class="hljs-string">&quot;red&quot;</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&gt;</span>&#123;keyword&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS-随笔一</title>
    <url>/2021/10/18/CSS-%E9%9A%8F%E7%AC%94%E4%B8%80/</url>
    <content><![CDATA[<hr>
<h4 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h4><p>关于 <code>display:hidden</code> 这类能隐藏元素的方法区别:<br><a href="https://75.team/post/five-ways-to-hide-elements-in-css.html">用 CSS 隐藏页面元素的 5 种方法</a></p>
<h4 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h4><p>关于 button 和 flex 搭配的特殊情况<br><a href="https://www.cnblogs.com/zhuzhenwei918/p/6389567.html">这是一篇关于父子元素继承的博客</a></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// css</span><br>  <span class="hljs-selector-class">.BigBox</span> &#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">flex-direction</span>: column;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span>;<br>    <span class="hljs-attribute">background</span>: red;<br>  &#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">// html</span><br>  &lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">BigBox</span>&quot;&gt;<br>    &lt;<span class="hljs-symbol">button</span> <span class="hljs-symbol">type</span>=&quot;<span class="hljs-symbol">button</span>&quot;&gt;点击我&lt;/<span class="hljs-symbol">button</span>&gt;<br>  &lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure>

<p>效果如下：<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-18-at-10.07.07-AM.5g0xixkr2380.png" alt="flex+btn-1"></p>
<p>这个按钮的 width 和 BigBox 盒子的宽度一样</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">// html</span><br>  &lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">BigBox</span>&quot;&gt;<br>    &lt;<span class="hljs-symbol">div</span>&gt;<br>    &lt;<span class="hljs-symbol">button</span> <span class="hljs-symbol">type</span>=&quot;<span class="hljs-symbol">button</span>&quot;&gt;点击我&lt;/<span class="hljs-symbol">button</span>&gt;<br>    &lt;/<span class="hljs-symbol">div</span>&gt;<br>  &lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-18-at-10.09.32-AM.5ulg5xqki2s0.png" alt="flex+btn-2"><br>显然 button 的宽度变为内联的那种效果。根据内容来扩大自己的宽度</p>
<p>事实上， <code>flex</code> 对于 内联元素都有拉伸的效果(毕竟 <code>flex</code> 叫弹性盒子…)。那如何规避 <code>flex</code> 的弹性效果呢？</p>
<ol>
<li>就是上述的在内联元素的外层套一个 <code>div</code>(块级盒子)。</li>
<li>可以在 flex 的子元素(内联元素，在 flex 里内联元素特殊)设置<code>width</code> 和 <code>height</code>(例如此题就是给 button 设置长度和宽度)</li>
<li>通过 <code>margin:auto</code> 这种也可以消除拉伸状态</li>
</ol>
<figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts">  .<span class="hljs-class">BigBox </span>&#123;<br><span class="hljs-symbol">    display:</span> flex;<br>    flex-direction: column;<br><span class="hljs-symbol">    width:</span> <span class="hljs-number">200</span>px;<br><span class="hljs-symbol">    height:</span> <span class="hljs-number">150</span>px;<br><span class="hljs-symbol">    background:</span> red;<br>  &#125;<br>  <span class="hljs-class">button </span>&#123;<br><span class="hljs-symbol">    margin:</span> <span class="hljs-number">0</span> auto;<br>  &#125;<br>  <span class="hljs-params">&lt;/style&gt;</span><br><span class="hljs-params">&lt;/head&gt;</span><br><span class="hljs-params">&lt;body&gt;</span><br>  <span class="hljs-params">&lt;div class=&quot;BigBox&quot;&gt;</span><br>    <span class="hljs-params">&lt;button type=&quot;button&quot;&gt;</span>点击我<span class="hljs-params">&lt;/button&gt;</span><br>  <span class="hljs-params">&lt;/div&gt;</span><br><span class="hljs-params">&lt;/body&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-18-at-11.06.51-AM.5llejkgdkig0.png" alt="效果如下"></p>
<ol start="4">
<li>还有的办法就是消除 <code>flex</code> 的默认拉伸效果</li>
</ol>
<figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts">  .<span class="hljs-class">BigBox </span>&#123;<br><span class="hljs-symbol">    display:</span> flex;<br>    flex-direction: column;<br><span class="hljs-symbol">    width:</span> <span class="hljs-number">200</span>px;<br><span class="hljs-symbol">    height:</span> <span class="hljs-number">150</span>px;<br><span class="hljs-symbol">    background:</span> red;<br>  &#125;<br>  <span class="hljs-class">button </span>&#123;<br>    <span class="hljs-comment">/* align-items属性某个子元素在交叉轴上的对齐方式 */</span><br>    <span class="hljs-comment">/* align-items 默认属性 stretch */</span><br>    align-self: center;<br>  &#125;<br>  <span class="hljs-params">&lt;/style&gt;</span><br><span class="hljs-params">&lt;/head&gt;</span><br><span class="hljs-params">&lt;body&gt;</span><br>  <span class="hljs-params">&lt;div class=&quot;BigBox&quot;&gt;</span><br>    <span class="hljs-params">&lt;button type=&quot;button&quot;&gt;</span>点击我<span class="hljs-params">&lt;/button&gt;</span><br>  <span class="hljs-params">&lt;/div&gt;</span><br><span class="hljs-params">&lt;/body&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-18-at-11.06.51-AM.5llejkgdkig0.png" alt="效果如下"></p>
<h4 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h4><p>关于 radio + button 的玩法总结：<br><a href="https://play.tailwindcss.com/FLrfGpKId1">radio + button 内容 –&gt; 使用的 tailwindcss</a></p>
<p>关键点 1：<code>radio</code> 标签的使用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 单选按钮让用户只选择有限数量的选项之一 --&gt;</span><br><span class="hljs-comment">&lt;!-- 所以 name 要保持一致 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;tab&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iPhone-13-pro&quot;</span> <span class="hljs-attr">checked</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;tab&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iPhone-13&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;tab&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iPhone-se&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-10-18-at-12.06.02-PM.tmocxv39y3k.gif" alt="radio效果图"></p>
<p>关键点 2：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/General_sibling_combinator">通用兄弟选择器的使用(~)</a> 搭配 <code>:checked</code></p>
<figure class="highlight dust"><table><tr><td class="code"><pre><code class="hljs dust"><span class="xml">元素1~元素2 </span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable"></span><br><span class="hljs-template-variable">&#125;</span><span class="xml"></span><br><span class="xml">表示选择元素1 下面所有的元素2</span><br><span class="xml">但是~层级问题始终有点迷~</span><br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">    <span class="hljs-selector-id">#iPhone-13-pro</span><span class="hljs-selector-pseudo">:checked</span> ~ <span class="hljs-selector-class">.iphone</span> <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">1</span>) &#123;</span><br><span class="css">      <span class="hljs-attribute">color</span>: red;</span><br><span class="css">    &#125;</span><br><span class="css">    <span class="hljs-selector-id">#iPhone-13</span><span class="hljs-selector-pseudo">:checked</span> ~ <span class="hljs-selector-class">.iphone</span> <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>) &#123;</span><br><span class="css">      <span class="hljs-attribute">color</span>: red;</span><br><span class="css">    &#125;</span><br><span class="css">    <span class="hljs-selector-id">#iPhone-se</span><span class="hljs-selector-pseudo">:checked</span> ~ <span class="hljs-selector-class">.iphone</span> <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">3</span>) &#123;</span><br><span class="css">      <span class="hljs-attribute">color</span>: red;</span><br><span class="css">    &#125;</span><br><span class="css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 单选按钮让用户只选择有限数量的选项之一 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- 所以 name 要保持一致 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;tab&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iPhone-13-pro&quot;</span> <span class="hljs-attr">checked</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;tab&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iPhone-13&quot;</span>  /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;tab&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iPhone-se&quot;</span> /&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;iphone&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>iphone 13 pro<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>iphone 13<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>iphone se<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-10-18-at-12.22.39-PM.5x922m5shww0.gif" alt="radio 效果 2"></p>
<p>关键点三： <code>label标签</code>的使用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">    <span class="hljs-comment">/* label[属性] 很牛 */</span></span><br><span class="css">    // 注意 ~ 必须是左右两边是最后得同层级的才行</span><br><span class="css">    <span class="hljs-selector-id">#iPhone-13-pro</span><span class="hljs-selector-pseudo">:checked</span> ~ <span class="hljs-selector-class">.iphone</span> <span class="hljs-selector-tag">label</span><span class="hljs-selector-attr">[for=<span class="hljs-string">&quot;iPhone-13-pro&quot;</span>]</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">color</span>: red;</span><br><span class="css">    &#125;</span><br><span class="css">    <span class="hljs-selector-id">#iPhone-13</span><span class="hljs-selector-pseudo">:checked</span> ~ <span class="hljs-selector-class">.iphone</span> <span class="hljs-selector-tag">label</span><span class="hljs-selector-attr">[for=<span class="hljs-string">&quot;iPhone-13&quot;</span>]</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">color</span>: red;</span><br><span class="css">    &#125;</span><br><span class="css">    <span class="hljs-selector-id">#iPhone-se</span><span class="hljs-selector-pseudo">:checked</span> ~ <span class="hljs-selector-class">.iphone</span> <span class="hljs-selector-tag">label</span><span class="hljs-selector-attr">[for=<span class="hljs-string">&quot;iPhone-se&quot;</span>]</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">color</span>: red;</span><br><span class="css">    &#125;</span><br><span class="css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 单选按钮让用户只选择有限数量的选项之一 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- 所以 name 要保持一致 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;tab&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iPhone-13-pro&quot;</span> <span class="hljs-attr">checked</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;tab&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iPhone-13&quot;</span>  /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;tab&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iPhone-se&quot;</span> /&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;iphone&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;iPhone-13-pro&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>iphone 13 pro<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;iPhone-13&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>iphone 13<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;iPhone-se&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>iphone se<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-10-18-at-12.32.02-PM.27m3tsv2zp34.gif" alt="radio 效果3"></p>
<p>关键点四：<code>隐藏radio</code>利用 <code>display:none</code>属性。<br>(<a href="#%E9%97%AE%E9%A2%98%E4%B8%80">display:none</a>)</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;tab&quot;</span> <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;iPhone-13-pro&quot;</span> <span class="hljs-attribute">style</span>=<span class="hljs-string">&quot;display: none;&quot;</span> checked /&gt;<br>&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;tab&quot;</span> <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;iPhone-13&quot;</span>  <span class="hljs-attribute">style</span>=<span class="hljs-string">&quot;display: none;&quot;</span> /&gt;<br>&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;tab&quot;</span> <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;iPhone-se&quot;</span> <span class="hljs-attribute">style</span>=<span class="hljs-string">&quot;display: none;&quot;</span>/&gt;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-10-18-at-12.37.56-PM.4j6vcoxrlnu0.gif" alt="效果四"></p>
<h4 id="设置侧边滑动块"><a href="#设置侧边滑动块" class="headerlink" title="设置侧边滑动块"></a>设置侧边滑动块</h4><p><a href="https://www.youtube.com/watch?v=v_8CmC6cwUs&t=305s">视频</a></p>
<h4 id="神坑“margin-auto”"><a href="#神坑“margin-auto”" class="headerlink" title="神坑“margin:auto”"></a>神坑“margin:auto”</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">margin:</span> <span class="hljs-number">0</span> <span class="hljs-string">auto;</span> <span class="hljs-string">/*水平居中对齐*/</span><br><span class="hljs-attr">margin:</span> <span class="hljs-string">auto;</span> <span class="hljs-string">/*上下左右auto</span> <span class="hljs-string">但是上下左右不起作用</span> <span class="hljs-string">还是水平居中对齐*/</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">但是在</span> <span class="hljs-string">flex(grid)</span> <span class="hljs-string">items</span> <span class="hljs-string">上的</span> <span class="hljs-attr">margin:</span> <span class="hljs-string">auto</span> <span class="hljs-string">不仅对水平方向有效，对垂直方向同样有效</span><br></code></pre></td></tr></table></figure>

<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> style=<span class="hljs-string">&quot;height: 200px; width: 200px; background: red;&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> style=<span class="hljs-string">&quot;height: 50px; width: 50px; background: yellow; margin: auto&quot;</span>&gt;块级&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<p>效果为：<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-23-at-12.08.50-AM.7kaaythbtjk0.png" alt="神坑margin:auto-1"></p>
<hr>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> style=<span class="hljs-string">&quot;display:grid; height: 200px; width: 200px; background: red;&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> style=<span class="hljs-string">&quot;height: 50px; width: 50px; background: yellow; margin: auto&quot;</span>&gt;块级&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-23-at-12.10.18-AM.1t4jj2z6k2gw.png" alt="神坑margin:auto-2"></p>
]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>Dynamic Module</title>
    <url>/2021/11/06/Dynamic-Module/</url>
    <content><![CDATA[<h3 id="Dynamic-Module"><a href="#Dynamic-Module" class="headerlink" title="Dynamic Module"></a>Dynamic Module</h3><p>进入按需加载(需要的时候才加载代码)的时代…让页面加载的速度更快…</p>
<p>看看案例：<br>如下是普通的模块导入：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">/* html 代码片段 */<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./script.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">/* script.js 代码片段 */</span><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">User</span>, &#123;printUser&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./user.js&#x27;</span>;<br><br>const <span class="hljs-keyword">user</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">User</span>(<span class="hljs-string">&#x27;Bruce&#x27;</span>, <span class="hljs-string">&#x27;Cook&#x27;</span>)<br>printUser(<span class="hljs-keyword">user</span>);<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* user.js 代码片段 */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">first, last</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.first = first;<br>    <span class="hljs-built_in">this</span>.last = last;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printUser</span>(<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;user.first&#125;</span> <span class="hljs-subst">$&#123;user.last&#125;</span>`</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>打印结果为 Bruce Cook</p>
</blockquote>
<p>文件运行逻辑： 先下载 script.js 文件，然后立刻下载 user.js 文件 (如果是 webpack 打包，可能会有一点点的变化)<br>但无论如何。只要页面进行加载，这些文件就会被下载…</p>
<p>但是<code>Dynamic Module</code>就如同前面所说是按需加载(需要的时候才加载代码)的</p>
<p><strong>import 变成一个函数</strong></p>
<figure class="highlight elm"><table><tr><td class="code"><pre><code class="hljs elm"><span class="hljs-number">1.</span> <span class="hljs-keyword">import</span>(&#x27;文件相对路径&#x27;)<br>-&gt; <span class="hljs-keyword">import</span>(&#x27;./user.js&#x27;)<br><span class="hljs-number">2.</span> <span class="hljs-keyword">import</span>函数返回一个promise<br>-&gt; <span class="hljs-keyword">import</span>(&#x27;./user.js&#x27;).then(module =&gt; &#123;     // 这里会提供该文件的所有module信息<br>  console.log(module)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-06-at-11.25.17-AM.63cc4nodfyo0.png" alt="module信息"></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">3.</span> 解构 <span class="hljs-keyword">then</span> 中的参数module<br><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./user.js&#x27;</span>).<span class="hljs-keyword">then</span>((&#123;<span class="hljs-keyword">default</span>: <span class="hljs-keyword">User</span>, printUser&#125;) =&gt; &#123;<br>  console.log(<span class="hljs-string">&#x27;User&#x27;</span>, <span class="hljs-keyword">User</span>);<br>  console.log(<span class="hljs-string">&#x27;printUser&#x27;</span>, printUser);<br>&#125;)<br>注意上面的<span class="hljs-keyword">default</span>: <span class="hljs-keyword">User</span> 其实就和下述方式导出<span class="hljs-keyword">User</span> 很相似<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">User</span>, printUser &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./user.js&#x27;</span><br></code></pre></td></tr></table></figure>

<p>现在 我们的代码模块是动态导入的，而非静态导入<br>来看看整体代码</p>
<h4 id="Dynamic-Module-的优势之一：页面加载更快"><a href="#Dynamic-Module-的优势之一：页面加载更快" class="headerlink" title="Dynamic Module 的优势之一：页面加载更快"></a>Dynamic Module 的优势之一：页面加载更快</h4><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">/* html 代码片段 */<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./script.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* script.js 代码片段 */</span><br><span class="hljs-comment">// 5s 后才会加载这个模块...</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./user.js&#x27;</span>).then(<span class="hljs-function">(<span class="hljs-params">&#123;<span class="hljs-keyword">default</span>:User, printUser&#125;</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&#x27;Bruce&#x27;</span>, <span class="hljs-string">&#x27;Cook&#x27;</span>)<br>    printUser(user);<br>  &#125;)<br>&#125;, <span class="hljs-number">5000</span>)<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* user.js 代码片段 */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">first, last</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.first = first;<br>    <span class="hljs-built_in">this</span>.last = last;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printUser</span>(<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;user.first&#125;</span> <span class="hljs-subst">$&#123;user.last&#125;</span>`</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码让你的页面加载速度会更上一层楼！！</p>
<h4 id="Dynamic-Module-的优势之二：如果你有一系列的文件。但根据不同用户只需要其中一个文件的时候"><a href="#Dynamic-Module-的优势之二：如果你有一系列的文件。但根据不同用户只需要其中一个文件的时候" class="headerlink" title="Dynamic Module 的优势之二：如果你有一系列的文件。但根据不同用户只需要其中一个文件的时候"></a>Dynamic Module 的优势之二：如果你有一系列的文件。但根据不同用户只需要其中一个文件的时候</h4><p>这里最能显示出<code>Dynamic Module</code>这个优势的是，不同国家语言文件！</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">文件目录：<br>  |- index.html<br>  |- script.js<br>  |- en-translations.js   <span class="hljs-regexp">//</span> 英语文件<br>  |- sp-translations.js   <span class="hljs-regexp">//</span> 西班牙语文件<br>  |- fr-translations.js   <span class="hljs-regexp">//</span> 法语文件<br></code></pre></td></tr></table></figure>

<p>如果使用静态导入方式：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/* html 代码片段 */</span><br>&lt;script <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;module&quot;</span> defer src=<span class="hljs-string">&quot;./script.js&quot;</span>&gt;&lt;/script&gt;<br><br><span class="hljs-comment">/* script.js文件 */</span><br><span class="hljs-keyword">import</span> englishTranslations <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./en-translations.js&#x27;</span><br><span class="hljs-keyword">import</span> spanishTranslations <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./sp-translations.js&#x27;</span><br><span class="hljs-keyword">import</span> frenchTranslations <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./fr-translations.js&#x27;</span><br><br><span class="hljs-keyword">const</span> user = &#123; <span class="hljs-attr">locale</span>: <span class="hljs-string">&#x27;en&#x27;</span> &#125;<br><span class="hljs-keyword">let</span> translations;<br><span class="hljs-keyword">switch</span> (user.locale) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;sp&#x27;</span>:<br>    translations = spanishTranslations<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;fr&#x27;</span>:<br>    translations = frenchTranslations<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">default</span>:<br>    translations = englishTranslations<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(translations.HI)<br><br><span class="hljs-comment">/* en-translations.js */</span><br><span class="hljs-keyword">const</span> translations = &#123;<br>  <span class="hljs-attr">HI</span>: <span class="hljs-string">&#x27;hi&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> translations;<br><br><span class="hljs-comment">/* sp-translations.js */</span><br><span class="hljs-keyword">const</span> translations = &#123;<br>  <span class="hljs-attr">HI</span>: <span class="hljs-string">&#x27;hola&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> translations;<br><br><span class="hljs-comment">/* fr-translations.js */</span><br><span class="hljs-keyword">const</span> translations = &#123;<br>  <span class="hljs-attr">HI</span>: <span class="hljs-string">&#x27;salut&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> translations;<br></code></pre></td></tr></table></figure>

<p>试想，如果我要弄 20 个国家的语言…我还用静态导入的方式，页面加载有多慢，代码文件上传体积有多大</p>
<p>现在我使用 <code>dynamic module</code> 来实现一下代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* script.js文件 */</span><br><span class="hljs-keyword">import</span> englishTranslations <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./en-translations.js&#x27;</span><br><span class="hljs-keyword">import</span> spanishTranslations <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./sp-translations.js&#x27;</span><br><span class="hljs-keyword">import</span> frenchTranslations <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./fr-translations.js&#x27;</span><br><br><br><br><span class="hljs-keyword">const</span> user = &#123; <span class="hljs-attr">locale</span>: <span class="hljs-string">&#x27;en&#x27;</span> &#125;<br><span class="hljs-comment">// 牛逼，还可以使用模板字符串</span><br><span class="hljs-keyword">import</span>(<span class="hljs-string">`./<span class="hljs-subst">$&#123;user.locale&#125;</span>-translations.js`</span>)<br>.catch(<span class="hljs-function">() =&gt;</span> &#123;   <span class="hljs-comment">// 这里是用来解决默认选项问题的(当不存在想要的user.locale时会触发)</span><br>  <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./en-translations.js&#x27;</span>)<br>&#125;)<br>.then(<span class="hljs-function">(<span class="hljs-params">&#123;<span class="hljs-keyword">default</span>:translations&#125;</span>) =&gt;</span> &#123;  <span class="hljs-comment">// 这里使用重命名的方式</span><br>  <span class="hljs-built_in">console</span>.log(translations.HI)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>显然，上述的<code>dynamic module</code> 让代码更加的简洁了…并且性能会更高</p>
<p><strong>再来一个例子</strong></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">文件目录：<br>  <span class="hljs-string">|- index.html</span><br>  <span class="hljs-string">|- script.js</span><br>  <span class="hljs-string">|- rectangle.js</span><br>  <span class="hljs-string">|- triangle.js</span><br></code></pre></td></tr></table></figure>

<figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">/* script.js文件 */</span><br><span class="hljs-keyword">import</span> renderRectangle from <span class="hljs-string">&#x27;./rectangle.js&#x27;</span>;<br><span class="hljs-keyword">import</span> renderTriangle from <span class="hljs-string">&#x27;./triangle.js&#x27;</span>;<br><br><span class="hljs-keyword">const</span> shapes = [<br>  &#123; type: <span class="hljs-string">&#x27;rectangle&#x27;</span> &#125;,<br>  &#123; type: <span class="hljs-string">&#x27;triangle&#x27;</span> &#125;,<br>  &#123; type: <span class="hljs-string">&#x27;rectangle&#x27;</span> &#125;<br>]<br><br><span class="hljs-built_in">shape</span>.forEach(<span class="hljs-built_in">shape</span> =&gt; &#123;<br>  <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">shape</span>.type) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;rectangle&#x27;</span>:<br>      renderRectangle(<span class="hljs-built_in">shape</span>)<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;triangle&#x27;</span>:<br>      renderTriangle(<span class="hljs-built_in">shape</span>)<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* triangle.js */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderShape</span>(<span class="hljs-params">shape</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Render Triangle&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">/* rectangle.js */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderShape</span>(<span class="hljs-params">shape</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Render Rectangle&#x27;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>用 <code>dynamic module</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> shapes = [<br>  &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;rectangle&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;triangle&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;rectangle&#x27;</span> &#125;<br>]<br><br>shape.forEach(<span class="hljs-function"><span class="hljs-params">shape</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">import</span>(<span class="hljs-string">`./<span class="hljs-subst">$&#123;shape.<span class="hljs-keyword">type</span>&#125;</span>.js`</span>).then(<span class="hljs-function">(<span class="hljs-params">&#123;<span class="hljs-keyword">default</span>:render&#125;</span>) =&gt;</span> &#123;<br>      render(shape)<br>    &#125;)<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>我们可以使用 <code>await/async</code> 来更进一步来解决问题</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> shapes = [<br>  &#123; <span class="hljs-keyword">type</span>: <span class="hljs-string">&#x27;rectangle&#x27;</span> &#125;,<br>  &#123; <span class="hljs-keyword">type</span>: <span class="hljs-string">&#x27;triangle&#x27;</span> &#125;,<br>  &#123; <span class="hljs-keyword">type</span>: <span class="hljs-string">&#x27;rectangle&#x27;</span> &#125;<br>]<br><br>shape.forEach(async shape =&gt; &#123;<br>    <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">default</span>: render&#125; = await <span class="hljs-keyword">import</span>(<span class="hljs-string">`./$&#123;shape.type&#125;.js`</span>);<br>    render(shape)<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>高级</tag>
      </tags>
  </entry>
  <entry>
    <title>Emotion的安装和基本使用</title>
    <url>/2021/10/10/Emotion%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>更细节的操作应该看官网指导：<br><a href="https://emotion.sh/docs/introduction">Emotion 官网</a></p>
<h5 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h5><p>针对 react 框架</p>
<blockquote>
<p>npm i @emotion/react<br>npm i @emotion/styled @emotion/react</p>
</blockquote>
]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>高级</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP状态码</title>
    <url>/2021/10/22/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    <content><![CDATA[<p><a href="https://www.restapitutorial.com/httpstatuscodes.html">HTTP Status Codes</a></p>
]]></content>
      <categories>
        <category>程序员基本素养</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>JS Module</title>
    <url>/2021/11/04/JS-Module/</url>
    <content><![CDATA[<p><code>ES Module</code> 让 js 代码逻辑更清晰，灵活性更强，更方便代码的管理</p>
<p>为了方便理解 Module。创建一个文件夹即目录</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">/* module文件夹 */<br>    <span class="hljs-string">|-index.html</span><br>    <span class="hljs-string">|-main.js</span><br>    <span class="hljs-string">|-user.js</span><br></code></pre></td></tr></table></figure>

<p>首先来看看<code>user.js</code>文件的内容</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> <span class="hljs-keyword">User</span> &#123;<br>  constructor(<span class="hljs-type">name</span>, age) &#123;<br>    this.name = <span class="hljs-type">name</span>;<br>    this.age = age;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">function</span> printName(<span class="hljs-keyword">user</span>) &#123;<br>  console.log(`<span class="hljs-keyword">User</span>’s <span class="hljs-type">name</span> <span class="hljs-keyword">is</span> $&#123;<span class="hljs-keyword">user</span>.age&#125;`);<br>&#125;<br><span class="hljs-keyword">function</span> printAge(<span class="hljs-keyword">user</span>) &#123;<br>  console.log(`<span class="hljs-keyword">User</span> <span class="hljs-keyword">is</span> $&#123;<span class="hljs-keyword">user</span>.age&#125; years <span class="hljs-built_in">old</span>`);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当前<code>main.js</code>为一个空文件</p>
<p><code>index.html</code> 仅用 srcipt 标签导入<code>main.js</code>文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>当前想把<code>user.js</code>文件的内容以模块的方式导出给<code>main.js</code></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">// 使用export <span class="hljs-keyword">default</span>  <span class="hljs-comment">---&gt; 似乎这个只能使用一次</span><br>export <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-keyword">User</span> &#123;<br>  constructor(<span class="hljs-type">name</span>, age) &#123;<br>    this.name = <span class="hljs-type">name</span>;<br>    this.age = age;<br>  &#125;<br>&#125;<br><br>// 其余使用 export 导出 (无<span class="hljs-keyword">default</span>)<br>export <span class="hljs-keyword">function</span> printName(<span class="hljs-keyword">user</span>) &#123;<br>  console.log(`<span class="hljs-keyword">User</span>’s <span class="hljs-type">name</span> <span class="hljs-keyword">is</span> $&#123;<span class="hljs-keyword">user</span>.age&#125;`);<br>&#125;<br><br>export <span class="hljs-keyword">function</span> printAge(<span class="hljs-keyword">user</span>) &#123;<br>  console.log(`<span class="hljs-keyword">User</span> <span class="hljs-keyword">is</span> $&#123;<span class="hljs-keyword">user</span>.age&#125; years <span class="hljs-built_in">old</span>`);<br>&#125;<br><br>// 当然，前面也可以不用写 export <span class="hljs-keyword">default</span>、export 。直接在文件结尾部分如下方式写<br>// export <span class="hljs-keyword">default</span> <span class="hljs-keyword">User</span><br>// export &#123;printAge, printName&#125;<br></code></pre></td></tr></table></figure>

<p><code>main.js</code>文件导入模块</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 针对以export default方式导出的代码<br><span class="hljs-regexp">//</span> import User from <span class="hljs-string">&#x27;user.js&#x27;</span>;   <span class="hljs-regexp">//</span> 这叫绝对路径<br><span class="hljs-regexp">//</span> import User from <span class="hljs-string">&#x27;./user.js&#x27;</span>; <span class="hljs-regexp">//</span> 这叫相对路径<br><br><span class="hljs-regexp">//</span> 针对以export方式导出的代码<br>import &#123;printName, printAge&#125; from <span class="hljs-string">&#x27;./user.js&#x27;</span>;<br><br><span class="hljs-regexp">//</span> 注意：可以给导入的模块重命名<br><span class="hljs-regexp">//</span> 对于 export default 导出的模块，命名方式如下<br><span class="hljs-regexp">//</span> import U from <span class="hljs-string">&#x27;./user.js&#x27;</span>   <span class="hljs-regexp">//</span> U 是新名称 但代表的还是user.js文件的User模块<br><br><span class="hljs-regexp">//</span> 对于 export 导出的模块，命名方式如下<br><span class="hljs-regexp">//</span> import &#123;printName as printUserName, printAge&#125; from <span class="hljs-string">&#x27;./user.js&#x27;</span> <span class="hljs-regexp">//</span> printName名字改为了printUserName<br></code></pre></td></tr></table></figure>

<p><strong>重点：</strong>对于<code>index.html</code> 利用<code>script</code>标签导入<code>main.js</code>文件。并且有<code>ES Module</code>能力, 是有讲究的<br><strong>并且这个不是 react 代码，没有 webpack 配置。所以导入文件的时候后缀名一定要加。例如 ./user 这是错误的。应该改为 ./user.js</strong></p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli">&lt;script type=<span class="hljs-string">&quot;module&quot;</span> defer src=<span class="hljs-string">&quot;./main.js&quot;</span>&gt;&lt;<span class="hljs-string">/script</span>&gt;    <span class="hljs-string">//</span> type=<span class="hljs-string">&quot;module&quot;</span> 是必写的。defer是<span class="hljs-string">...</span>???<br></code></pre></td></tr></table></figure>

<p>并且启动代码时不能以本地文件的方式启动：不然报错如下</p>
<blockquote>
<p>Origin null is not allowed by Access-Control-Allow-Origin.</p>
</blockquote>
<p>所以最好以 vscode 插件 Live Server 的(开启服务器的)方式打开</p>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>JS-随笔一</title>
    <url>/2021/10/18/JS-%E9%9A%8F%E7%AC%94%E4%B8%80/</url>
    <content><![CDATA[<h4 id="问题一：Promise-中-catch-消化异常"><a href="#问题一：Promise-中-catch-消化异常" class="headerlink" title="问题一：Promise 中.catch 消化异常"></a>问题一：Promise 中.catch 消化异常</h4><p>看代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">let</span> data = <span class="hljs-number">100</span>;</span><br><span class="javascript">    resolve(data);</span><br><span class="javascript">  &#125;).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;data&#x27;</span>, data);</span><br><span class="javascript">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(data)</span><br><span class="javascript">    <span class="hljs-comment">// catch 用来消化异常</span></span><br><span class="javascript">  &#125;).catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;error&#x27;</span>, error);</span><br><span class="javascript">    <span class="hljs-comment">// 抛出错误，打断程序运行</span></span><br><span class="javascript">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error)</span><br><span class="javascript">  &#125;)</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-18-at-4.52.26-PM.1xab0wcem3ls.png" alt="promise-reject"></p>
<h4 id="问题二：Object-fromEntries-的使用方式"><a href="#问题二：Object-fromEntries-的使用方式" class="headerlink" title="问题二：Object.fromEntries() 的使用方式"></a>问题二：Object.fromEntries() 的使用方式</h4><p>Object.fromEntries()是用来创建对象的… 用二维数组或者一个 map 作为参数…<br>用代码来体验一下(注意：要提供键值对才行…)</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// Map</span><br><span class="hljs-keyword">const</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br><br>myMap.<span class="hljs-keyword">set</span>(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;dom&#x27;</span>);<br>myMap.<span class="hljs-keyword">set</span>(<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">60</span>);<br><br><span class="hljs-keyword">const</span> myObj = <span class="hljs-built_in">Object</span>.fromEntries(myMap)<br><span class="hljs-comment">// 生成了一个对象...</span><br>console.log(myObj)   <span class="hljs-comment">// &#123;name: &#x27;dom&#x27;, age: 60&#125;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 二维数组<br>const myArr = [<br>  [<span class="hljs-string">&#x27;search&#x27;</span>, <span class="hljs-string">&#x27;dogs&#x27;</span>],<br>  [<span class="hljs-string">&#x27;page&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>]<br>];<br>const myObj = Object.fromEntries(myArr);<br>console.log(myObj);   <span class="hljs-regexp">//</span> &#123;search: <span class="hljs-string">&#x27;dogs&#x27;</span>, page: <span class="hljs-string">&#x27;2&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Generators-的使用方法"><a href="#Generators-的使用方法" class="headerlink" title="Generators 的使用方法"></a>Generators 的使用方法</h4><p><a href="https://www.youtube.com/watch?v=IJ6EgdiI_wU">相关类型中比较好的视频</a></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua">// * 表示这是个generator函数...<br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">simpleGenerator</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-built_in">yield</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">yield</span> <span class="hljs-number">2</span>;<br>  <span class="hljs-built_in">yield</span> <span class="hljs-number">3</span>;<br>&#125;<br><br>const generatorObject = simpleGenerator();<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;generatorObject&#x27;</span>, generatorObject);  // 会打印一个复杂的对象(我们只需要关注这个对象里的<span class="hljs-built_in">next</span>属性)<br>const obj = generatorObject.<span class="hljs-built_in">next</span>()<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;obj&#x27;</span>, obj)  // &#123;value: <span class="hljs-number">1</span>, done: <span class="hljs-literal">false</span>&#125;<br>console.<span class="hljs-built_in">log</span>(generatorObject.<span class="hljs-built_in">next</span>())  // &#123;value: <span class="hljs-number">2</span>, done: <span class="hljs-literal">false</span>&#125;<br>console.<span class="hljs-built_in">log</span>(generatorObject.<span class="hljs-built_in">next</span>())  // &#123;value: <span class="hljs-number">3</span>, done: <span class="hljs-literal">false</span>&#125;<br>console.<span class="hljs-built_in">log</span>(generatorObject.<span class="hljs-built_in">next</span>())  // &#123;value: undefined, done: <span class="hljs-literal">true</span>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">simpleGenerator</span><span class="hljs-params">()</span></span> &#123;<br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;before 1&#x27;</span>)<br>  <span class="hljs-built_in">yield</span> <span class="hljs-number">1</span>;<br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;after 1&#x27;</span>)<br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;before 2&#x27;</span>)<br>  <span class="hljs-built_in">yield</span> <span class="hljs-number">2</span>;<br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;after 2&#x27;</span>)<br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;before 3&#x27;</span>)<br>  <span class="hljs-built_in">yield</span> <span class="hljs-number">3</span>;<br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;after 3&#x27;</span>)<br>&#125;<br><br>const generatorObject = simpleGenerator();<br>// 自己逐条去打印下面的东西就会有所感悟...<br>console.<span class="hljs-built_in">log</span>(generatorObject.<span class="hljs-built_in">next</span>())<br>console.<span class="hljs-built_in">log</span>(generatorObject.<span class="hljs-built_in">next</span>())<br>console.<span class="hljs-built_in">log</span>(generatorObject.<span class="hljs-built_in">next</span>())<br>console.<span class="hljs-built_in">log</span>(generatorObject.<span class="hljs-built_in">next</span>())<br></code></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">simpleGenerator</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-built_in">yield</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">yield</span> <span class="hljs-number">2</span>;<br>  <span class="hljs-built_in">yield</span> <span class="hljs-number">3</span>;<br>&#125;<br><br>const generatorObject = simpleGenerator();<br>console.<span class="hljs-built_in">log</span>(generatorObject.<span class="hljs-built_in">next</span>())<br>console.<span class="hljs-built_in">log</span>(generatorObject.<span class="hljs-built_in">next</span>())<br>const generatorObject2 = simpleGenerator();<br>console.<span class="hljs-built_in">log</span>(generatorObject2.<span class="hljs-built_in">next</span>())<br>console.<span class="hljs-built_in">log</span>(generatorObject2.<span class="hljs-built_in">next</span>())<br></code></pre></td></tr></table></figure>

<p>// generator 的常用例子</p>
<ol>
<li>有控制的无限循环</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">generateId</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> id = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;id&#x27;</span>, id)<br>    <span class="hljs-keyword">yield</span> id;<br>    id++;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> generatorObject = generateId();<br><span class="hljs-built_in">console</span>.log(generatorObject.next())<br><span class="hljs-built_in">console</span>.log(generatorObject.next())<br><span class="hljs-comment">// ... 可以无限写下去 所以写id的话，你想弄多少个就弄多少个...</span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li>iterator…</li>
</ol>
<figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">generator</span><span class="hljs-params">(array)</span></span> &#123;<br>  <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>    <span class="hljs-built_in">yield</span> array[i];<br>  &#125;<br>&#125;<br><br>const generatorObject = generator([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]);<br>console.<span class="hljs-built_in">log</span>(generatorObject.<span class="hljs-built_in">next</span>())<br>console.<span class="hljs-built_in">log</span>(generatorObject.<span class="hljs-built_in">next</span>())<br>console.<span class="hljs-built_in">log</span>(generatorObject.<span class="hljs-built_in">next</span>())<br>console.<span class="hljs-built_in">log</span>(generatorObject.<span class="hljs-built_in">next</span>())<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>return &amp; throw</li>
</ol>
<figure class="highlight livescript"><table><tr><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">function</span>* generateId() &#123;<br>  <span class="hljs-keyword">let</span> id = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;id&#x27;</span>, id)<br>    <span class="hljs-keyword">yield</span> id;<br>    id++;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> generatorObject = generateId();<br><span class="hljs-built_in">console</span>.log(generatorObject.next())<br><span class="hljs-built_in">console</span>.log(generatorObject.<span class="hljs-keyword">return</span>(<span class="hljs-number">10</span>))<br><span class="hljs-built_in">console</span>.log(generatorObject.<span class="hljs-keyword">throw</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;hi&#x27;</span>)))<br></code></pre></td></tr></table></figure>

<h4 id="iterator-的理解和学习…"><a href="#iterator-的理解和学习…" class="headerlink" title="iterator 的理解和学习…"></a>iterator 的理解和学习…</h4><p>在 js 中<code>array</code>、<code>Map</code>是默认可以<code>iterable</code>的<br>部署了<code>iterator</code>的具备一个特点 就是能够通过 for……of 进行遍历…</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">var a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">for</span>(v of a) &#123;console.log(v)&#125;<br><span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br><span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br><span class="hljs-regexp">//</span> <span class="hljs-number">3</span><br><br>a[Symbol.iterator]     <span class="hljs-regexp">//</span> 是一个函数(可以用来检测是否部署了iterator)<br>var i = a[Symbol.iterator]();<br>console.log(<span class="hljs-string">&#x27;i&#x27;</span>, i);   <span class="hljs-regexp">//</span> i 是一个Iterator (具备<span class="hljs-keyword">next</span>()方法)<br><br></code></pre></td></tr></table></figure>

<figure class="highlight autoit"><table><tr><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-comment">;</span><br><span class="hljs-keyword">const</span> numbersIterator = numbers[Symbol.iterator]()<span class="hljs-comment">;  // 变成generator了...</span><br><br>console.<span class="hljs-built_in">log</span>(numbersIterator.<span class="hljs-keyword">next</span>().value)<span class="hljs-comment">;</span><br>console.<span class="hljs-built_in">log</span>(numbersIterator.<span class="hljs-keyword">next</span>().value)<span class="hljs-comment">;</span><br>console.<span class="hljs-built_in">log</span>(numbersIterator.<span class="hljs-keyword">next</span>().value)<span class="hljs-comment">;</span><br>console.<span class="hljs-built_in">log</span>(numbersIterator.<span class="hljs-keyword">next</span>().value)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>来点例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 自己生成一个iterator</span><br><span class="hljs-comment">// 1, 4, 9, 16, 25</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">squared</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> n = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 闭包玩法...</span><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-function"><span class="hljs-title">next</span>(<span class="hljs-params"></span>)</span> &#123;   <span class="hljs-comment">// 这是对象的一个属性...</span><br>      n++;<br>      <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">5</span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>          <span class="hljs-attr">value</span>: n * n,<br>          <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span><br>        &#125;;<br>      &#125;<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span>,<br>        <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> squaredIterator = squared();<br><span class="hljs-built_in">console</span>.log(squaredIterator.next());<br><span class="hljs-built_in">console</span>.log(squaredIterator.next());<br><span class="hljs-built_in">console</span>.log(squaredIterator.next());<br><span class="hljs-built_in">console</span>.log(squaredIterator.next());<br></code></pre></td></tr></table></figure>

<h4 id="js-中关于函数相关的注意点"><a href="#js-中关于函数相关的注意点" class="headerlink" title="js 中关于函数相关的注意点"></a>js 中关于函数相关的注意点</h4><ol>
<li>console.dir 使用</li>
</ol>
<figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span><span class="hljs-params">(value)</span></span> &#123;<br>  console.<span class="hljs-built_in">log</span>(value)<br>&#125;<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">print</span>)  // 这样打印出的内容很范：ƒ <span class="hljs-built_in">print</span>(value) &#123;<br>  console.<span class="hljs-built_in">log</span>(value)<br>&#125;<br>console.dir(<span class="hljs-built_in">print</span>)  // ƒ <span class="hljs-built_in">print</span>(value)<br>arguments: null<br>caller: null<br>length: <span class="hljs-number">1</span><br>name: <span class="hljs-string">&quot;print&quot;</span><br>prototype: &#123;constructor: ƒ&#125;<br><span class="hljs-string">[[FunctionLocation]]</span>: VM193:<span class="hljs-number">1</span><br><span class="hljs-string">[[Prototype]]</span>: ƒ ()<br><span class="hljs-string">[[Scopes]]</span>: Scopes[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>函数其实就非常类似于普通的对象…(可以放在任何地方。可以为函数添加任何属性)唯一的不同就是函数要使用() 来调用，并且可以传参数 —&gt; 但是对象好像没有作用域、而函数是有作用域的…??</li>
</ol>
<figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span><span class="hljs-params">(value)</span></span> &#123;<br>  console.<span class="hljs-built_in">log</span>(value);<br>&#125;<br><br>// 我可以给函数增添属性<br><span class="hljs-built_in">print</span>.hi = <span class="hljs-string">&#x27;hi&#x27;</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;print.name&#x27;</span>, <span class="hljs-built_in">print</span>.name)<br><br>// 函数作为参数...<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useCallback</span><span class="hljs-params">(callback)</span></span> &#123;<br>  callback(<span class="hljs-string">&#x27;Hello&#x27;</span>)<br>&#125;<br><br>useCallback(<span class="hljs-built_in">print</span>)<br></code></pre></td></tr></table></figure>

<h4 id="强制转换一个对象中-某一属性的类型为-number"><a href="#强制转换一个对象中-某一属性的类型为-number" class="headerlink" title="强制转换一个对象中 某一属性的类型为 number"></a>强制转换一个对象中 某一属性的类型为 number</h4><p>有时候，我们得到的对象 其属性全部都为字符串类型。但是我们希望有些类型应该为 number 类型<br>例如：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-keyword">id</span>: <span class="hljs-string">&#x27;1&#x27;</span>,<br>  name: <span class="hljs-string">&#x27;帅得乱七八糟&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>解决办法：</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">const</span> newObj = &#123;<br>  ...obj,<br>  <span class="hljs-attribute">id:</span><span class="hljs-string"> Number</span>(obj.id) || <span class="hljs-literal">undefined</span> <span class="hljs-comment">// 不想id：0 这种情况...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="数组中查找指定元素的下标方法：indexOf"><a href="#数组中查找指定元素的下标方法：indexOf" class="headerlink" title="数组中查找指定元素的下标方法：indexOf"></a>数组中查找指定元素的下标方法：indexOf</h4><p>例如：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">let question = [<span class="hljs-string">&#x27;错误&#x27;</span>, <span class="hljs-string">&#x27;错误&#x27;</span>, <span class="hljs-string">&#x27;正确&#x27;</span>, <span class="hljs-string">&#x27;错误&#x27;</span>];<br><br>let findIndex = question.indexOf(<span class="hljs-string">&#x27;正确&#x27;</span>)  <span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br><br><span class="hljs-regexp">//</span> 如果找不到就会直接返回 -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<h4 id="自定义获取页面-url-的方法"><a href="#自定义获取页面-url-的方法" class="headerlink" title="自定义获取页面 url 的方法"></a>自定义获取页面 url 的方法</h4><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">function</span> getParameter(parameterName) &#123;<br>  <span class="hljs-regexp">//</span> window.location.search 获取当前url的参数(包括 ?)<br>  <span class="hljs-regexp">//</span> URLSearchParams 更多操作: https:<span class="hljs-regexp">//</span>developer.mozilla.org<span class="hljs-regexp">/zh-CN/</span>docs<span class="hljs-regexp">/Web/</span>API/URLSearchParams<br>  let parameters = new URLSearchParams(window.location.search)<br>  return parameters.get(parameterName);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="你不知道的-10-大-js-隐晦但有效的知识点"><a href="#你不知道的-10-大-js-隐晦但有效的知识点" class="headerlink" title="你不知道的 10 大 js 隐晦但有效的知识点"></a>你不知道的 10 大 js 隐晦但有效的知识点</h4><h5 id="的极限操作"><a href="#的极限操作" class="headerlink" title="?? 的极限操作"></a>?? 的极限操作</h5><h5 id="对控制台的神奇操作"><a href="#对控制台的神奇操作" class="headerlink" title="对控制台的神奇操作"></a>对控制台的神奇操作</h5><h5 id="的无敌操作"><a href="#的无敌操作" class="headerlink" title="?. 的无敌操作"></a>?. 的无敌操作</h5><h5 id="script-搭配-defer-的王者操作"><a href="#script-搭配-defer-的王者操作" class="headerlink" title="script 搭配 defer 的王者操作"></a>script 搭配 defer 的王者操作</h5><h5 id="自创块级作用域"><a href="#自创块级作用域" class="headerlink" title="自创块级作用域"></a>自创块级作用域</h5><figure class="highlight nim"><table><tr><td class="code"><pre><code class="hljs nim">switch (a) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">const</span> <span class="hljs-literal">result</span> = a * <span class="hljs-number">2</span>;<br>    console.log(<span class="hljs-literal">result</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>    <span class="hljs-keyword">const</span> <span class="hljs-literal">result</span> = a / <span class="hljs-number">2</span>;<br>    console.log(<span class="hljs-literal">result</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>    <span class="hljs-keyword">const</span> <span class="hljs-literal">result</span> = a + <span class="hljs-number">2</span>;<br>    console.log(<span class="hljs-literal">result</span>);<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述内容会报错…</p>
<p>下面用块级作用域解决问题</p>
<figure class="highlight nim"><table><tr><td class="code"><pre><code class="hljs nim">switch (a) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-literal">result</span> = a * <span class="hljs-number">2</span>;<br>    console.log(<span class="hljs-literal">result</span>);<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-literal">result</span> = a / <span class="hljs-number">2</span>;<br>    console.log(<span class="hljs-literal">result</span>);<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-literal">result</span> = a + <span class="hljs-number">2</span>;<br>    console.log(<span class="hljs-literal">result</span>);<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="不要误会-null-和-undefined-这两者的作用！"><a href="#不要误会-null-和-undefined-这两者的作用！" class="headerlink" title="不要误会 null 和 undefined 这两者的作用！"></a>不要误会 null 和 undefined 这两者的作用！</h4><blockquote>
<p>Everything is undefined until you define it</p>
</blockquote>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>)  <span class="hljs-regexp">//</span> <span class="hljs-literal">true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> === <span class="hljs-literal">undefined</span>) <span class="hljs-regexp">//</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>

<p><code>null</code> 表示这个东西没有值(no value)，不存在<br>(变量是不会自己变成 <code>null</code> 的。除非是程序员自己把它设置为 <code>null</code>)<br>所以，一个好习惯是当一个变量明确没有值的时候应该设置为 <code>null</code>。特别是前后端进行数据交互的时候<br>举个例子：在 <code>JSON</code> 化内容的时候需要注意</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">JSON</span>.stringify(&#123;foo:<span class="hljs-literal">undefined</span>&#125;)   <span class="hljs-regexp">//</span> &#123;&#125;<br><span class="hljs-built_in">JSON</span>.stringify(&#123;foo:<span class="hljs-literal">null</span>&#125;)        <span class="hljs-regexp">//</span> &#123;<span class="hljs-string">&quot;foo&quot;</span>:<span class="hljs-literal">null</span>&#125;<br></code></pre></td></tr></table></figure>

<p><code>undefined</code> 就相当于一个变量未被定义(没有赋任何值)…</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a;<br><span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure>

<p>下面这里举了把 <code>null</code> 或 <code>undefined</code> 赋值给变量的情况</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-literal">null</span>;<br><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// null</span><br><br>a = <span class="hljs-literal">undefined</span>;<br><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure>

<p>这样做的原因是为了重置一个变量。通过将变量设置为<code>undefined</code>，你传递了该变量不再包含任何有用信息的消息，而如果该值为<code>null</code>，则你明确表示某些操作的结果没有值。</p>
<blockquote>
<p>尽管 <code>null</code> 和 <code>undefined</code> 都表示 <strong>no value</strong> 但使用的目的是不一样的</p>
</blockquote>
<h4 id="最好不要使用-else"><a href="#最好不要使用-else" class="headerlink" title="最好不要使用 else"></a>最好不要使用 else</h4><h4 id="灵活的使用数组-对象解构"><a href="#灵活的使用数组-对象解构" class="headerlink" title="灵活的使用数组/对象解构"></a>灵活的使用数组/对象解构</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">const</span> alphabet = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>];<br><span class="hljs-keyword">const</span> nunmbers = [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>];<br><br><span class="hljs-keyword">const</span> [a, , c, ...rest] = alphabet;<br>console.<span class="hljs-built_in">log</span>(a);<br>console.<span class="hljs-built_in">log</span>(c);<br>console.<span class="hljs-built_in">log</span>(rest);<br><br><span class="hljs-keyword">const</span> newArray = [...alphabet, ...numbers]<br>console.<span class="hljs-built_in">log</span>(newArray)<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sumAndMultiply</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-comment">// return [a + b, a * b]</span><br>  <span class="hljs-keyword">return</span> [a + b, a * b, a / b]<br>&#125;<br><span class="hljs-keyword">const</span> [sum, multiply, division = <span class="hljs-string">&#x27;No division&#x27;</span>] = sumAndMultiply(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);   <span class="hljs-comment">// sum, multiply 是自己随意拟定的名字</span><br><span class="hljs-built_in">console</span>.log(sum);<br><span class="hljs-built_in">console</span>.log(multiply);<br><span class="hljs-built_in">console</span>.log(division)<br></code></pre></td></tr></table></figure>

<p>解构的真正威力是用在<strong>对象</strong>上~</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> personOne = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;帅得乱七八糟&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">21</span>,<br>  <span class="hljs-attr">address</span>: &#123;<br>    <span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;Somewhere&#x27;</span>,<br>    <span class="hljs-attr">state</span>: <span class="hljs-string">&#x27;One of them&#x27;</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> personTwo = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;帅得歪瓜裂枣&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">22</span>,<br>  <span class="hljs-attr">address</span>: &#123;<br>    <span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;Somewhere&#x27;</span>,<br>    <span class="hljs-attr">state</span>: <span class="hljs-string">&#x27;Another one of them&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">favoriteFood</span>: <span class="hljs-string">&#x27;Watermelon&#x27;</span><br>&#125;<br><br><span class="hljs-comment">// const &#123;name, age&#125; = personTwo;   // 这个和数组解构有点不一样... 这里取出来的名字要和对象原来的属性一一对应才行...</span><br><span class="hljs-comment">// 如果想改名字 方法如下</span><br><span class="hljs-keyword">const</span> &#123;<span class="hljs-attr">name</span>: SecondName, age, favoriteFood = <span class="hljs-string">&#x27;Rice&#x27;</span>&#125; = personTwo;<br><br><span class="hljs-built_in">console</span>.log(name);        <span class="hljs-comment">// &#x27;&#x27;</span><br><span class="hljs-built_in">console</span>.log(SecondName);  <span class="hljs-comment">// &#x27;帅得歪瓜裂枣&#x27;</span><br><span class="hljs-built_in">console</span>.log(age);<br><span class="hljs-built_in">console</span>.log(favoriteFood)<br><br><span class="hljs-keyword">const</span> &#123;name, ...rest&#125; = personOne;<br><span class="hljs-keyword">const</span> &#123;<span class="hljs-attr">address</span>:&#123;city&#125;&#125; = personOne;<br><span class="hljs-built_in">console</span>.log(name);<br><span class="hljs-built_in">console</span>.log(rest);<br><span class="hljs-built_in">console</span>.log(city);  <span class="hljs-comment">// Somewhere</span><br><br><span class="hljs-keyword">const</span> personThree = &#123;...personOne, ...personTwo&#125;;   <span class="hljs-comment">// 前者属性覆盖后者</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;personThree&#x27;</span>, personThree)<br><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printUser</span>(<span class="hljs-params">&#123;name, age&#125;</span>) </span>&#123;  <span class="hljs-comment">// 解构大法...而不会再用user.name  user.age</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Name is:<span class="hljs-subst">$&#123;name&#125;</span>. Age is <span class="hljs-subst">$&#123;age&#125;</span>`</span>)<br>&#125;<br><br>printUser<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>JS sort 玩法</title>
    <url>/2021/10/23/JS-sort-%E7%8E%A9%E6%B3%95/</url>
    <content><![CDATA[<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">let vals = [<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>];<br>vals.sort();         <span class="hljs-regexp">//</span> 不会反悔新的数组，而是对自己本身进行修改...<br>console.log(vals);   <span class="hljs-regexp">//</span>  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure>

<p>似乎默认是按照字母顺序进行排序</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><code class="hljs sqf">let vals = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>];<br>vals.<span class="hljs-built_in">sort</span>();<br>console.<span class="hljs-built_in">log</span>(vals)   <span class="hljs-comment">// [10, 2, &#x27;A&#x27;, &#x27;a&#x27;]</span><br></code></pre></td></tr></table></figure>

<p>并且 sort 只会默认排序 <code>number</code>、<code>string</code> 这两种类型。 比如<code>对象类型</code>就不会有任何的变化…</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">let</span> vals = [&#123;x: <span class="hljs-number">10</span>, y:<span class="hljs-number">20</span>&#125;, &#123;x: <span class="hljs-number">20</span>, y:<span class="hljs-number">40</span>&#125;]<br>vals.sort();<br>console.log(<span class="hljs-built_in">vals</span>)   <span class="hljs-comment">// 没有丝毫变化...</span><br></code></pre></td></tr></table></figure>

<p><strong>如果想让 sort 具备灵活的比较功能就需要自己去设置比较函数</strong></p>
<p>比较函数需要两个参数…</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compare</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> b.y - a.y;<br>&#125;<br><span class="hljs-keyword">let</span> vals = [&#123;<span class="hljs-attr">x</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">y</span>:<span class="hljs-number">20</span>&#125;, &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">y</span>:<span class="hljs-number">40</span>&#125;]<br>vals.sort(compare);  <span class="hljs-comment">// 放置的是回调函数 不能选择执行...</span><br><span class="hljs-built_in">console</span>.log(vals)    <span class="hljs-comment">// 没有丝毫变化...</span><br></code></pre></td></tr></table></figure>

<p><a href="https://www.w3schools.com/js/js_array_sort.asp">简洁的文档</a></p>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>高级</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON 基础知识 &amp; Ajax 基础知识</title>
    <url>/2021/10/08/JSON&amp;Ajax%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h4 id="为什么我们要把对象转化为字符串？"><a href="#为什么我们要把对象转化为字符串？" class="headerlink" title="为什么我们要把对象转化为字符串？"></a>为什么我们要把对象转化为字符串？</h4><ol>
<li><p>在网页开发的时候，我们需要把<code>对象信息</code>进行长期保存, 因此我们需要把这些信息传递给<code>服务器</code>。所以，需要通过把对象(变量)转化为字符串才能传递给<code>服务器</code>。</p>
</li>
<li><p>我们采用的是<code>http协议</code>即超文本传输协议(其本质就是由文本的形式进行传输)</p>
</li>
<li><p>JSON 字符串是绝大多数编程语言都支持的…</p>
</li>
</ol>
<h4 id="JSON-字符串的特征"><a href="#JSON-字符串的特征" class="headerlink" title="JSON 字符串的特征"></a>JSON 字符串的特征</h4><ol>
<li><strong>属性名称</strong>必须加<strong>双引号</strong> (因为人家默认规定的字符串外层是<code>单引号</code>，所以内层必须是<code>双引号</code>)</li>
<li><strong>属性值</strong>如果是字符串则必须加<strong>双引号</strong></li>
<li>对象当中的<code>方法(函数)</code>不会被转化为字符串</li>
</ol>
<p>(注意： JSON 本质就是字符串！！)</p>
<h4 id="JSON-和-对象的相互转换："><a href="#JSON-和-对象的相互转换：" class="headerlink" title="JSON 和 对象的相互转换："></a>JSON 和 对象的相互转换：</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xiaoming&#x27;</span>,<br>  <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;boy&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>  <span class="hljs-function"><span class="hljs-title">say</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;想吃, 想喝, 想爱&#x27;</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 把对象转为JSON字符串</span><br><span class="hljs-keyword">let</span> str1 = <span class="hljs-built_in">JSON</span>.stringify(obj);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;obj&#x27;</span>, obj);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;str1&#x27;</span>, str1);   <span class="hljs-comment">// 纯粹的字符串且没有say方法</span><br><br><span class="hljs-comment">// 把数组转为JSON字符串</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">100</span>, &#123;<span class="hljs-attr">key</span>: <span class="hljs-number">100</span>, <span class="hljs-attr">obj</span>: &#123;&#125;, <span class="hljs-attr">str</span>: <span class="hljs-string">&#x27;测试&#x27;</span>&#125;]<br><span class="hljs-keyword">let</span> str2 = <span class="hljs-built_in">JSON</span>.stringify(arr);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;arr&#x27;</span>, arr);<br><span class="hljs-comment">// 内部的字符串元素全部被强制转化为双引号,数值不加引号，</span><br><span class="hljs-comment">// 对象元素进行深层改造(加双引号..),而且不再是对象，而是字符串了...</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;str2&#x27;</span>, str2);<br></code></pre></td></tr></table></figure>

<figure class="highlight openscad"><table><tr><td class="code"><pre><code class="hljs openscad"><span class="hljs-comment">// JSON字符串转成对象</span><br><span class="hljs-comment">// JSON 字符串外层是单引号哦!!</span><br><span class="hljs-built_in">let</span> <span class="hljs-built_in">str</span> = &#x27;&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>: <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">18</span>&#125;&#x27;<br><span class="hljs-built_in">let</span> obj = JSON.parse(<span class="hljs-built_in">str</span>);<br>console.<span class="hljs-built_in">log</span>(&#x27;obj.name&#x27;, obj.name);   <span class="hljs-comment">// 小明</span><br></code></pre></td></tr></table></figure>

<hr>
<h4 id="手写-ajax-核心方法"><a href="#手写-ajax-核心方法" class="headerlink" title="手写 ajax 核心方法"></a>手写 ajax 核心方法</h4><p>哈哈, 以不负责任的态度来说 🤪</p>
<blockquote>
<p><code>前端</code> 是用来显示数据的<br><code>后端</code> 是用来提供数据的</p>
</blockquote>
<p>所以，前端有一个非常重要的工作是向后端索要<code>数据</code>并将数据进行页面显示</p>
<p>如何向后端索要数据呢？</p>
<h5 id="书写-ajxa-4-个核心步骤"><a href="#书写-ajxa-4-个核心步骤" class="headerlink" title="书写 ajxa 4 个核心步骤"></a>书写 ajxa 4 个核心步骤</h5><blockquote>
<p>4 个步骤！但要注意执行顺序哦！</p>
</blockquote>
<ol>
<li>创建一个请求对象, js 提供的构造函数 XMLHttpRequest(分开记忆：XML Http Request)</li>
</ol>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-constructor">XMLHttpRequest()</span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li><p>设置请求的数据得到返回时的处理函数</p>
<blockquote>
<p>xhr.onloadend(分开记忆：on load end) –&gt; 执行方式有点类似 onclick 这类函数</p>
</blockquote>
</li>
</ol>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">xhr.onloadend = <span class="hljs-keyword">function</span>() &#123;<br>  <span class="hljs-regexp">//</span> 该数据全是服务器返回的json字符串<br>  <span class="hljs-regexp">//</span> 请求的数据放在哪了？请求的数据其实放在了请求对象上面<br>  xhr.responseText<br>  <span class="hljs-regexp">//</span> 进行转化<br>  let stus = JSON.parse(xhr.responseText)<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>设置请求信息</li>
</ol>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">向谁请求：<br>例如 http:<span class="hljs-regexp">//</span>www.jd.com、http:<span class="hljs-regexp">//</span>www.baidu.com<br>xhr.open(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/todos&#x27;</span>)<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>发送请求</li>
</ol>
<figure class="highlight autoit"><table><tr><td class="code"><pre><code class="hljs autoit">xhr.<span class="hljs-built_in">send</span>()<br></code></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 整体操作如下：</span><br><br><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-constructor">XMLHttpRequest()</span>;<br>xhr.oploadend = <span class="hljs-keyword">function</span><span class="hljs-literal">()</span> &#123;<br>  <span class="hljs-keyword">let</span> stus = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JSON</span>.</span></span>parse(xhr.responseTest)<br>  show<span class="hljs-constructor">Table(<span class="hljs-params">stus</span>)</span><br>&#125;<br>xhr.<span class="hljs-keyword">open</span>(&#x27;get&#x27;, &#x27;https:<span class="hljs-comment">//jsonplaceholder.typicode.com/todos&#x27;);</span><br>xhr.send<span class="hljs-literal">()</span>;<br></code></pre></td></tr></table></figure>

<head>
  ..
  <script src="//cdn.jsdelivr.net/npm/@waline/client"></script>
  ...
</head>
<body>
  ...
  <div id="waline"></div>
  <script>
    Waline({
      el: '#waline',
       avatar: 'monsterid',
      serverURL: 'https://blog-api-9sizcti78-bruce-shuai.vercel.app/',
    });
  </script>
</body>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>React-随笔一</title>
    <url>/2021/10/18/React-%E9%9A%8F%E7%AC%94%E4%B8%80/</url>
    <content><![CDATA[<h4 id="推荐一个-vscode-的插件-针对-react-的-贼好用…"><a href="#推荐一个-vscode-的插件-针对-react-的-贼好用…" class="headerlink" title="推荐一个 vscode 的插件 针对 react 的(贼好用…)"></a>推荐一个 vscode 的插件 针对 react 的(贼好用…)</h4><p>ES7 React/Redux/GraphQL/React-Native snippets</p>
<p><code>rfc</code></p>
<h4 id="问题一：错误边界"><a href="#问题一：错误边界" class="headerlink" title="问题一：错误边界"></a>问题一：错误边界</h4><p>在<code>react</code>的渲染过程中如果出现了异常。那么整个组件树都会被卸载掉…(在开发环境下能够看见报错的原因…但是真正上线后。用户只能看见白茫茫的一片。其余什么也看不见…)<br><a href="https://reactjs.org/docs/error-boundaries.html">错误边界问题</a><br>注意，错误边界的实现是一定要使用<code>class component</code>来实现的。这也是<code>class 组件</code>和<code>函数组件</code>的区别。<br><a href="https://codesandbox.io/s/gong-ju-lei-oef90?file=/src/utils/error-bundary.tsx">我在 codesandbox 里写的一个 error-bundary 库</a></p>
<p>—&gt; 在思考这题的时候有两个小问题<br>—&gt; <a href="https://stackoverflow.com/questions/58123398/when-to-use-jsx-element-vs-reactnode-vs-reactelement">ReactNode 和 ReactElement 的区别</a><br>—&gt; <a href="https://www.newline.co/@bespoyasov/how-to-define-props-with-children-in-react-typescript-app--56bd18be">PropsWithChildren 的用法</a> 其实就是 <code>react官方</code> 自己定义的一个<code>type utility</code>。类似<code>omit</code>这类<code>type utility</code></p>
<h4 id="问题二：自定义-hook，动态改变文档标题-即浏览器最上面的-title-以及闭包在-react-hook-中常见的坑…"><a href="#问题二：自定义-hook，动态改变文档标题-即浏览器最上面的-title-以及闭包在-react-hook-中常见的坑…" class="headerlink" title="问题二：自定义 hook，动态改变文档标题(即浏览器最上面的 title)(以及闭包在 react hook 中常见的坑…)"></a>问题二：自定义 hook，动态改变文档标题(即浏览器最上面的 title)(以及闭包在 react hook 中常见的坑…)</h4><ol>
<li>自定义 hook，动态改变文档标题 有两套方案：<ol>
<li>使用第三方库 <a href="https://github.com/nfl/react-helmet">react-helmet</a></li>
<li>自己写一个 hook</li>
</ol>
</li>
</ol>
<h4 id="问题三：-无限渲染问题-针对-useEffect…"><a href="#问题三：-无限渲染问题-针对-useEffect…" class="headerlink" title="问题三： 无限渲染问题(针对 useEffect…)"></a>问题三： 无限渲染问题(针对 useEffect…)</h4><p><a href="https://github.com/welldone-software/why-did-you-render">一个查找无限渲染原因的库-why-did-you-render</a></p>
<p>下面是自己写的一个无限死循环组件</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> React, &#123; useEffect, useState &#125; from <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> InfiniteLoop = () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> obj = &#123; name: <span class="hljs-string">&quot;bruce&quot;</span> &#125;; <span class="hljs-comment">// 按引用赋值</span><br>  <span class="hljs-keyword">const</span> [<span class="hljs-built_in">num</span>, setNum] = useState(<span class="hljs-number">0</span>);<br><br>  useEffect(() =&gt; &#123;<br>    console.log(<span class="hljs-string">&quot;effect&quot;</span>);<br>    <span class="hljs-comment">// num + 1 造成页面的重新渲染...</span><br>    <span class="hljs-comment">// 重新渲染后又会num + 1 又是重新渲染...</span><br>    <span class="hljs-comment">// 无限死循环...</span><br>    setNum(<span class="hljs-built_in">num</span> + <span class="hljs-number">1</span>);<br>  &#125;, [obj]);  <span class="hljs-comment">// 如果这里的依赖项是一个不变且不是引用类型的值，就不会触发useEffect，也就不会造成无限死循环...</span><br><br>  <span class="hljs-keyword">return</span> &lt;div&gt;<span class="hljs-built_in">num</span>: &#123;<span class="hljs-built_in">num</span>&#125;&lt;/div&gt;;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="问题四：组件类型透传-这是结合了-TS-以及-其他组件库例如-antd-来写的…"><a href="#问题四：组件类型透传-这是结合了-TS-以及-其他组件库例如-antd-来写的…" class="headerlink" title="问题四：组件类型透传(这是结合了 TS 以及 其他组件库例如(antd))来写的…"></a>问题四：组件类型透传(这是结合了 TS 以及 其他组件库例如(antd))来写的…</h4><p>在日常 react 项目开发中，我们可能会遇见这样的一个问题。例如：我们要自定义一个 select 组件。如下</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> IdSelectProps &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span>;<br>  onChange: <span class="hljs-function">(<span class="hljs-params">value?: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>  options?: &#123; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; id: <span class="hljs-built_in">number</span> &#125;[];<br>&#125;<br><br><span class="hljs-keyword">const</span> IdSelect = <span class="hljs-function">(<span class="hljs-params">&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">  value,</span></span><br><span class="hljs-params"><span class="hljs-function">  onChange,</span></span><br><span class="hljs-params"><span class="hljs-function">  options</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;: IdSelectProps</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span></span></span><br><span class="hljs-tag"><span class="xml">      <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;toNumber(value)&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">      <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;(e)</span> =&gt;</span> onChange(toNumber(e.target.value) || undefined)&#125;</span><br><span class="xml">    &gt;</span><br><span class="xml">      &#123;defaultOptionName ? (</span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;0&#125;</span>&gt;</span>&#123;defaultOptionName&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><br><span class="xml">      ) : null&#125;</span><br><span class="xml">      &#123;options?.map((option) =&gt; &#123;</span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;option.name&#125;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;option.id&#125;</span>&gt;</span></span><br><span class="xml">          &#123;option.name&#125;</span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>;</span><br><span class="xml">      &#125;)&#125;</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>现在有出现一个问题。就是我想扩展我这个<code>IdSelect</code>组件。但是我如果一个一个的去更改组件的类型接口非常麻烦<br>而恰好在<code>antd库</code>里又有一个现有的<code>Select组件</code>功能齐全。我就想把我的组件和 Select 组件的<code>props的各种类型</code>结合起来。如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; Select &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;antd&#x27;</span>;  <span class="hljs-comment">// 导入antd里的Select组件</span><br><br><span class="hljs-comment">// React.ComponentProps 帮助我们获取一个组件的 props 类型声明</span><br><span class="hljs-keyword">type</span> SelectProps = React.ComponentProps&lt;<span class="hljs-keyword">typeof</span> Select&gt;<br><br><span class="hljs-comment">// Omit 是为了防止SelectProps类型中有些属性和IdSelectProps的属性发生冲突</span><br><span class="hljs-keyword">interface</span> IdSelectProps <span class="hljs-keyword">extends</span> Omit&lt;SelectProps, &#x27;value&#x27; | &#x27;onChange&#x27; | &#x27;option&#x27;&gt;&#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span>;<br>  onChange: <span class="hljs-function">(<span class="hljs-params">value?: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>  options?: &#123; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; id: <span class="hljs-built_in">number</span> &#125;[];<br>&#125;<br><br><span class="hljs-comment">// ... 后续代码一些正常</span><br></code></pre></td></tr></table></figure>

<p>这样之后，我的 <code>IdSelect</code> 组件的类型属性就会丰富很多…</p>
]]></content>
      <categories>
        <category>React篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript Array 笔记</title>
    <url>/2021/10/20/JavaScript-Array-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>看代码</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><code class="hljs sqf">const <span class="hljs-built_in">items</span> = [<br>  &#123;<span class="hljs-built_in">name</span>: <span class="hljs-string">&#x27;Bike&#x27;</span>,     price: <span class="hljs-number">100</span>&#125;,<br>  &#123;<span class="hljs-built_in">name</span>: <span class="hljs-string">&#x27;TV&#x27;</span>,       price: <span class="hljs-number">200</span>&#125;,<br>  &#123;<span class="hljs-built_in">name</span>: <span class="hljs-string">&#x27;Album&#x27;</span>,    price: <span class="hljs-number">10</span>&#125;,<br>  &#123;<span class="hljs-built_in">name</span>: <span class="hljs-string">&#x27;Book&#x27;</span>,     price: <span class="hljs-number">5</span>&#125;,<br>  &#123;<span class="hljs-built_in">name</span>: <span class="hljs-string">&#x27;Phone&#x27;</span>,    price: <span class="hljs-number">500</span>&#125;,<br>  &#123;<span class="hljs-built_in">name</span>: <span class="hljs-string">&#x27;Computer&#x27;</span>, price: <span class="hljs-number">1000</span>&#125;,<br>  &#123;<span class="hljs-built_in">name</span>: <span class="hljs-string">&#x27;Keyboard&#x27;</span>, price: <span class="hljs-number">25</span>&#125;,<br>]<br></code></pre></td></tr></table></figure>

<h4 id="filter-–-gt-返回一个新的数组-对于排除原来数组的某些元素有奇效"><a href="#filter-–-gt-返回一个新的数组-对于排除原来数组的某些元素有奇效" class="headerlink" title="filter –&gt; 返回一个新的数组(对于排除原来数组的某些元素有奇效)"></a>filter –&gt; 返回一个新的数组(对于排除原来数组的某些元素有奇效)</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> filteredItems = items.filter(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> item.price &lt;= <span class="hljs-number">100</span>;     <span class="hljs-comment">// boolean</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<h4 id="map-–-gt-返回一个新的数组-对于修改或展现原来数组的每一个元素部分内容而闻名"><a href="#map-–-gt-返回一个新的数组-对于修改或展现原来数组的每一个元素部分内容而闻名" class="headerlink" title="map –&gt; 返回一个新的数组(对于修改或展现原来数组的每一个元素部分内容而闻名)"></a>map –&gt; 返回一个新的数组(对于修改或展现原来数组的每一个元素部分内容而闻名)</h4><figure class="highlight xquery"><table><tr><td class="code"><pre><code class="hljs xquery">const itemNames = items.<span class="hljs-keyword">map</span>((<span class="hljs-type">item</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">item</span><span class="hljs-built_in">.name</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<h4 id="find-–-gt-返回原来数组中的某个特定元素-对于查找原来数组特定元素有奇效。不过只要查找到一个元素后，就不会继续往后查找了"><a href="#find-–-gt-返回原来数组中的某个特定元素-对于查找原来数组特定元素有奇效。不过只要查找到一个元素后，就不会继续往后查找了" class="headerlink" title="find –&gt; 返回原来数组中的某个特定元素(对于查找原来数组特定元素有奇效。不过只要查找到一个元素后，就不会继续往后查找了)"></a>find –&gt; 返回原来数组中的某个特定元素(对于查找原来数组特定元素有奇效。不过只要查找到一个元素后，就不会继续往后查找了)</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> foundItem = items.find(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> item.name === <span class="hljs-string">&#x27;Book&#x27;</span>    <span class="hljs-comment">// boolean</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<h4 id="forEach-–-gt-不返回新内容。会对原数组继续修改"><a href="#forEach-–-gt-不返回新内容。会对原数组继续修改" class="headerlink" title="forEach –&gt; 不返回新内容。会对原数组继续修改"></a>forEach –&gt; 不返回新内容。会对原数组继续修改</h4><figure class="highlight sqf"><table><tr><td class="code"><pre><code class="hljs sqf"><span class="hljs-built_in">items</span>.<span class="hljs-keyword">forEach</span>(item =&gt; &#123;<br>  item.<span class="hljs-built_in">name</span> = <span class="hljs-string">&#x27;jack&#x27;</span><br>  console.<span class="hljs-built_in">log</span>(item.<span class="hljs-built_in">name</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>

<h4 id="some-–-gt-返回一个布尔值-用于查看数组中是否有满足特定条件的元素"><a href="#some-–-gt-返回一个布尔值-用于查看数组中是否有满足特定条件的元素" class="headerlink" title="some –&gt; 返回一个布尔值(用于查看数组中是否有满足特定条件的元素)"></a>some –&gt; 返回一个布尔值(用于查看数组中是否有满足特定条件的元素)</h4><figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">const hasInexpensiveItems = items.some(<span class="hljs-function"><span class="hljs-params">(item)</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> item.price &lt;= <span class="hljs-number">100</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<h4 id="every-–-gt-返回一个布尔值-类似-some，但是是查看数组中是否每一个元素都满足特定条件"><a href="#every-–-gt-返回一个布尔值-类似-some，但是是查看数组中是否每一个元素都满足特定条件" class="headerlink" title="every –&gt; 返回一个布尔值(类似 some，但是是查看数组中是否每一个元素都满足特定条件)"></a>every –&gt; 返回一个布尔值(类似 some，但是是查看数组中是否每一个元素都满足特定条件)</h4><figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">const hasInexpensiveItems = items.every(<span class="hljs-function"><span class="hljs-params">(item)</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> item.price &lt;= <span class="hljs-number">100</span><br>&#125;)<br><br></code></pre></td></tr></table></figure>

<h4 id="reduce-–-gt-返回一个值-常用于计算数组元素中某个属性的和"><a href="#reduce-–-gt-返回一个值-常用于计算数组元素中某个属性的和" class="headerlink" title="reduce –&gt; 返回一个值(常用于计算数组元素中某个属性的和)"></a>reduce –&gt; 返回一个值(常用于计算数组元素中某个属性的和)</h4><figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">const total = items.reduce(<span class="hljs-function"><span class="hljs-params">(currentTotal, item)</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> currentTotal + item.price<br>&#125;, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>

<p><strong>Reduce 具体讲解</strong></p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima">const numbers = [<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-built_in">let</span> <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> n of numbers) &#123;<br>    <span class="hljs-built_in">sum</span> += n;<br>&#125;<br><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">sum</span>);   // <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<p>–&gt; 使用 reduce</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">const</span> numbers = [1, -1, 2, 3]<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 两个参数</span><br><span class="hljs-comment"> * 参数一：回调函数 (此回调函数必须有返回值。且返回值赋值新一次迭代的accmulator)</span><br><span class="hljs-comment"> * 参数二：一个值, 作为accmulator的初始值 (如果参数二不写，则数组第一个元素作为accmulator的初始值)</span><br><span class="hljs-comment"> * 效果： 迭代调用reduce的数组的每一个元素 即 currentValue(从数组第一个元素开始)</span><br><span class="hljs-comment"> */</span><br>let <span class="hljs-keyword">sum</span> = numbers.reduce((accmulator, currentValue) =&gt; &#123;<br>  <span class="hljs-comment">// 注意：这里是要有返回值才行的...</span><br>  <span class="hljs-comment">// 返回值赋值给accmulator</span><br>  <span class="hljs-keyword">return</span> accmulator + currentValue<br>&#125;, 0)<br><br><span class="hljs-comment">// 上述执行过程</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *    accmulator: 0     currentValue: 1</span><br><span class="hljs-comment"> *    accmulator: 1     currentValue: -1</span><br><span class="hljs-comment"> *    accmulator: 0     currentValue: 2</span><br><span class="hljs-comment"> *    accmulator: 2     currentValue: 3</span><br><span class="hljs-comment"> *    accmulator: 5     打断施法...</span><br><span class="hljs-comment"> */</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">sum</span>);   <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure>

<h4 id="includes-—-解决简单版的-find-问题。参数为简单数组。返回布尔值"><a href="#includes-—-解决简单版的-find-问题。参数为简单数组。返回布尔值" class="headerlink" title="includes — 解决简单版的 find 问题。参数为简单数组。返回布尔值"></a>includes — 解决简单版的 find 问题。参数为简单数组。返回布尔值</h4><figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">const</span> items = [1, 2, 3, 4, 5]<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">total</span> = items.includes(2)<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>SOLID Design Principles</title>
    <url>/2021/11/04/SOLID-Design-Principles/</url>
    <content><![CDATA[<h3 id="Single-Responsibility-Principle-唯一的-负责-原则"><a href="#Single-Responsibility-Principle-唯一的-负责-原则" class="headerlink" title="Single Responsibility Principle (唯一的 负责 原则)"></a>Single Responsibility Principle (唯一的 负责 原则)</h3><p>一个函数或一个类只能有一个原因去进行自身代码更改…<br>在 js 中用多函数(每个函数只能有一个功能)以及<code>ES Module</code>模块化来实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CalorieTracker</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">maxCalories</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.maxCalories = maxCalories;<br>    <span class="hljs-built_in">this</span>.currentCalories = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">trackCalories</span>(<span class="hljs-params">calorieCount</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.currentCalories += calorieCount;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.currentCalories &gt; <span class="hljs-built_in">this</span>.maxCalories) &#123;<br>      <span class="hljs-built_in">this</span>.logCalorieSurplus()<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">logCalorieSurplus</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Max calories exceeded&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述这个类看似非常正常完美…但事实上是有局限性的…<br>我们可以看见…这个类有两个方法：<code>trackCalories</code>、<code>logCalorieSurplus</code>。 我可以在这个类修改这两个函数…需求来了我有可能会在这个类中修改<code>trackCalories</code>函数或者修改<code>logCalorieSurplus</code>函数。但是当一个类有非常多这样的类。那么需求一来我就去修改这些…只会让代码变得非常臃肿且不好维护。更严重的是代码<strong>复用性</strong>太差</p>
<p><code>Single Responsibility Principle</code> 的原则是一个函数或一个类只能有一个原因去解析自身代码修改</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><code class="hljs coq">之前的文件夹：<br>   |<span class="hljs-type">- CalorieTracker</span>.js<br><br>利用ES <span class="hljs-keyword">Module</span>的特性<br><br>升级后的文件夹：<br>   |<span class="hljs-type">- CalorieTracker</span>.js<br>   |<span class="hljs-type">- logger</span>.js<br></code></pre></td></tr></table></figure>

<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">/* logger.js */</span><br><span class="hljs-function"><span class="hljs-title">logCalorieSurplus</span><span class="hljs-params">(info)</span></span> &#123;<br>  console<span class="hljs-selector-class">.log</span>(info)<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/* CalorieTracker.js */</span><br><span class="hljs-keyword">import</span> logCalorieSurplus from <span class="hljs-string">&#x27;./logger.js&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CalorieTracker</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span>(maxCalories) &#123;<br>    <span class="hljs-keyword">this</span>.maxCalories = maxCalories;<br>    <span class="hljs-keyword">this</span>.currentCalories = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  trackCalories(calorieCount) &#123;<br>    <span class="hljs-keyword">this</span>.currentCalories += calorieCount;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.currentCalories &gt; <span class="hljs-keyword">this</span>.maxCalories) &#123;<br>      logCalorieSurplus(<span class="hljs-string">&#x27;Max calories exceeded&#x27;</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在 <code>logCalorieSurplus</code> 已经模块化…可以在任何文件中去使用…复用性大大提高</p>
<p>而且现在的<code>CalorieTracker</code>只需管理<code>trackCalories</code>这一个函数… <code>logCalorieSurplus</code>函数也只会因自身想改变而改变… 都遵循了<strong>Single Responsibility Principle (唯一的 负责 原则)</strong></p>
<h3 id="Open-Closed-Principle"><a href="#Open-Closed-Principle" class="headerlink" title="Open/Closed Principle"></a>Open/Closed Principle</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> printQuiz(questions) &#123;<br>  questions.<span class="hljs-keyword">forEach</span>(question =&gt; &#123;<br>    console.log(question.<span class="hljs-keyword">type</span>);<br>    switch (question.<span class="hljs-keyword">type</span>) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;boolean&#x27;</span>:<br>        console.log(<span class="hljs-string">&#x27;1. True&#x27;</span>);<br>        console.log(<span class="hljs-string">&#x27;2. False&#x27;</span>);<br>        break;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;multipleChoice&#x27;</span>:<br>        question.<span class="hljs-keyword">options</span>.<span class="hljs-keyword">forEach</span>((<span class="hljs-keyword">option</span>, <span class="hljs-keyword">index</span>) =&gt; &#123;<br>          console.log(`$&#123;<span class="hljs-keyword">index</span> + <span class="hljs-number">1</span>&#125;. $&#123;<span class="hljs-keyword">option</span>&#125;`);<br>        &#125;)<br>        break;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;text&#x27;</span>:<br>        console.log(<span class="hljs-string">&#x27;Answer:____________________&#x27;</span>);<br>        break;<br>    &#125;<br>    console.log(<span class="hljs-string">&#x27;+++++++++&#x27;</span>);<br>  &#125;)<br>&#125;<br><br>const questions = [<br>  &#123;<br>    <span class="hljs-keyword">type</span>: <span class="hljs-string">&#x27;boolean&#x27;</span>,<br>    description: <span class="hljs-string">&#x27;This video is useful.&#x27;</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-keyword">type</span>: <span class="hljs-string">&#x27;multipleChoice&#x27;</span>,<br>    description: <span class="hljs-string">&#x27;What is your favorite language?&#x27;</span>,<br>    <span class="hljs-keyword">options</span>: [<span class="hljs-string">&#x27;CSS&#x27;</span>, <span class="hljs-string">&#x27;HTML&#x27;</span>, <span class="hljs-string">&#x27;JS&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>]<br>  &#125;,<br>  &#123;<br>    <span class="hljs-keyword">type</span>: <span class="hljs-string">&#x27;text&#x27;</span>,<br>    description: <span class="hljs-string">&#x27;Describe your favorite JS feature.&#x27;</span><br>  &#125;<br>]<br><br>printQuiz(questions);<br></code></pre></td></tr></table></figure>

<p>上述代码看着非常正常…但是还是思考下…如果当<code>questions</code>的数组元素增加，则既要更改<code>questions</code>的内容，又要更改<code>printQuiz</code>。 灵活性相当的差劲…</p>
<p>开始升级…</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ------------- 问题 ---------------</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BooleanQuestion</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">description</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.description = description;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">printQuestionChoices</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1. True&#x27;</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2. False&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultipleChoiceQuestion</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">description, options</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.description = description<br>    <span class="hljs-built_in">this</span>.options = options<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">printQuestionChoices</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.options.forEach(<span class="hljs-function">(<span class="hljs-params">option, index</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;index + <span class="hljs-number">1</span>&#125;</span>. <span class="hljs-subst">$&#123;option&#125;</span>`</span>);<br>    &#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestQuestion</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">description</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.description = description;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">printQuestionChoices</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Answer:____________________&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printQuiz</span>(<span class="hljs-params">questions</span>) </span>&#123;<br>  questions.forEach(<span class="hljs-function"><span class="hljs-params">question</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(question.description);<br>    question.printQuestionChoices()<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;&#x27;</span>);<br>  &#125;)<br>&#125;<br><br><span class="hljs-keyword">const</span> questions = [<br>  <span class="hljs-keyword">new</span> BooleanQuestion(<span class="hljs-string">&#x27;This video is useful.&#x27;</span>),<br>  <span class="hljs-keyword">new</span> MultipleChoiceQuestion(<br>    <span class="hljs-string">&#x27;What is your favorite language?&#x27;</span>,<br>    [<span class="hljs-string">&#x27;CSS&#x27;</span>, <span class="hljs-string">&#x27;HTML&#x27;</span>, <span class="hljs-string">&#x27;JS&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>]<br>  ),<br>  <span class="hljs-keyword">new</span> TestQuestion(<span class="hljs-string">&#x27;Describe your favorite JS feature.&#x27;</span>)<br>]<br>printQuiz(questions);<br></code></pre></td></tr></table></figure>

<p>现在，我对<code>question</code>的<strong>增删改查</strong>变得易如反掌…<br>将长长的 <strong>switch…case</strong> 打断…</p>
<blockquote>
<p>当前感觉 Open/Closed Principle 就是用来解决 长长的’switch…case 的…’</p>
</blockquote>
<h3 id="Liskov-Substitution-Principle"><a href="#Liskov-Substitution-Principle" class="headerlink" title="Liskov Substitution Principle"></a>Liskov Substitution Principle</h3><p>—&gt; 这个原则似乎更加的偏向面向对象…</p>
]]></content>
      <categories>
        <category>Clean Code篇</category>
      </categories>
      <tags>
        <tag>优质代码</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript-随笔一</title>
    <url>/2021/10/20/TypeScript-%E9%9A%8F%E7%AC%94%E4%B8%80/</url>
    <content><![CDATA[<h4 id="as-const-的妙用！"><a href="#as-const-的妙用！" class="headerlink" title="as const 的妙用！"></a>as const 的妙用！</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">const <span class="hljs-selector-tag">a</span> = <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;jack&#x27;</span>, 12, &#123;gender: <span class="hljs-string">&#x27;male&#x27;</span>&#125;]</span>  <span class="hljs-comment">// ts 会默认认为这个a是数组,所以里面的元素类型都应该是保持一致的才行...</span><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-20-at-9.26.54-AM.44u177wjacg0.png" alt="未添加as const"></p>
<p>如果要本身的原始类型则加上<code>as const</code></p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> a = [<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-number">12</span>, &#123;gender: <span class="hljs-string">&#x27;male&#x27;</span>&#125;] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-20-at-9.28.46-AM.4pkaih8rjje0.png" alt="添加as const"></p>
<hr>
<p>再来一个例子：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> a = [<span class="hljs-string">&#x27;12&#x27;</span>]          <span class="hljs-comment">// const a: string[]</span><br><span class="hljs-keyword">const</span> b = [<span class="hljs-string">&#x27;12&#x27;</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span> <span class="hljs-comment">// const b: readonly [&quot;12&quot;]</span><br></code></pre></td></tr></table></figure>

<p>注意：有了<code>as const</code>后,属性类型变成 <code>readonly</code></p>
<h4 id="给已经存在的-react-项目添加-ts"><a href="#给已经存在的-react-项目添加-ts" class="headerlink" title="给已经存在的 react 项目添加 ts"></a>给已经存在的 react 项目添加 ts</h4><p><a href="https://create-react-app.dev/docs/adding-typescript/">安装教程</a></p>
<h4 id="注意：给-react-项目添加-ts-后。对于-ts-后缀和-tsx-后缀是有讲究的"><a href="#注意：给-react-项目添加-ts-后。对于-ts-后缀和-tsx-后缀是有讲究的" class="headerlink" title="注意：给 react 项目添加 ts 后。对于 ts 后缀和 tsx 后缀是有讲究的"></a>注意：给 react 项目添加 ts 后。对于 ts 后缀和 tsx 后缀是有讲究的</h4><p>例如：<code>src/index.js</code> –&gt; 改为 ts 版本应该为 –&gt; <code>src/index.tsx(不是 ts)</code> 因为如果是 <code>ts</code> 的话 <code>&lt;React.StrictMode&gt;</code>这里会报错…需要的是 <code>tsx</code> 语法…</p>
]]></content>
      <categories>
        <category>TypeScript篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>Set和Map基本使用方法</title>
    <url>/2021/10/09/Set%E5%92%8CMap%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p><code>Map</code> <strong>(有道翻译)</strong> v.映射<br>的确，<code>Map</code> 强调的就是<strong>对应关系</strong><br>记住两个<strong>关键点</strong>：</p>
<ol>
<li>无序, 但有下标且下标唯一</li>
<li>键值对</li>
</ol>
<h5 id="Map-的基本用法"><a href="#Map-的基本用法" class="headerlink" title="Map 的基本用法"></a>Map 的基本用法</h5><p>（一）创建</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> m1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br></code></pre></td></tr></table></figure>

<p>（二）设置 (Map 可不像对象，键只能放字符，Map 的键可以是各种类型的值（包括对象）都可以当作键，如果你需要“键值对”的数据结构，Map 比 Object 更合适。)</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><code class="hljs lasso">m1.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;a1&#x27;</span>, <span class="hljs-string">&#x27;帅得乱七八糟&#x27;</span>)<br>m1.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;a2&#x27;</span>, <span class="hljs-string">&#x27;帅得歪瓜裂枣&#x27;</span>)<br>m1.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;a3&#x27;</span>, <span class="hljs-string">&#x27;帅得一塌糊涂&#x27;</span>)<br>m1.<span class="hljs-built_in">set</span>(() =&gt; &#123; console.<span class="hljs-keyword">log</span>(<span class="hljs-string">&#x27;func&#x27;</span>)&#125;, <span class="hljs-string">&#x27;小呆呆能找到女朋友&#x27;</span> )  <span class="hljs-comment">// 错误</span><br><span class="hljs-comment">// 对于除了字符串类型，最好是赋值到一个变量后再放入set里面去</span><br><span class="hljs-keyword">let</span> b = () =&gt; &#123; console.<span class="hljs-keyword">log</span>(<span class="hljs-string">&#x27;func&#x27;</span>)&#125;;<br>m1.<span class="hljs-built_in">set</span>(b, <span class="hljs-string">&#x27;小呆呆能找到女朋友&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>（三）获取</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver">console.<span class="hljs-built_in">log</span>(m1.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;a2&#x27;</span>));   <span class="hljs-comment"> // 帅得歪瓜裂枣</span><br>console.<span class="hljs-built_in">log</span>(m1.<span class="hljs-built_in">get</span>(b));      <span class="hljs-comment"> // &#x27;小呆呆能找到女朋友&#x27;</span><br></code></pre></td></tr></table></figure>

<p>（四）判断 —&gt; 只能放入键</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">console.<span class="hljs-built_in">log</span>(m1.has(<span class="hljs-string">&#x27;a2&#x27;</span>));         <span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-literal">true</span><br>console.<span class="hljs-built_in">log</span>(m1.has(<span class="hljs-string">&#x27;帅得一塌糊涂&#x27;</span>)); <span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>

<p>（五）删除</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">m1.<span class="hljs-keyword">delete</span>(<span class="hljs-string">&#x27;a3&#x27;</span>)<br>console.log(m1.has(<span class="hljs-string">&#x27;a3&#x27;</span>));  <span class="hljs-regexp">//</span> false<br></code></pre></td></tr></table></figure>

<p>（六）清空</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">m1.<span class="hljs-built_in">clear</span>();<br>console.<span class="hljs-built_in">log</span>(m1)<br></code></pre></td></tr></table></figure>

<p>（七）键值对个数</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing">m1.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;a1&#x27;</span>, <span class="hljs-string">&#x27;帅得乱七八糟&#x27;</span>)<br>m1.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;a2&#x27;</span>, <span class="hljs-string">&#x27;帅得歪瓜裂枣&#x27;</span>)<br>m1.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;a3&#x27;</span>, <span class="hljs-string">&#x27;帅得一塌糊涂&#x27;</span>)<br>console.<span class="hljs-built_in">log</span>(m1.<span class="hljs-built_in">size</span>)   <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure>

<p><strong>再次强调！！</strong> <code>Map</code> 比 <code>对象</code>强的地方在于 <code>Map</code> 的下标(键)比<code>对象</code>的键更灵活，可以是任何类型!</p>
<p>（八）遍历 Map (注意：遍历其实就是迭代)</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">m1.<span class="hljs-keyword">forEach</span>((item, <span class="hljs-keyword">index</span>) =&gt; console.log(item, <span class="hljs-keyword">index</span>))   //item只会显示值不会显示键而 <span class="hljs-keyword">index</span> 会显示出键，不会显示值<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><blockquote>
<p>巧记： for…of(遍历数组) for…in(遍历对象)</p>
</blockquote>
<p>事实上最好别拿 for…in 来遍历数组(for…of 同理，别拿来遍历对象)</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">let arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr.name = <span class="hljs-string">&#x27;我是谁&#x27;</span>;    <span class="hljs-regexp">//</span> 如果有人脑残，在arr中又以这样的方式增添了属性<br><br><span class="hljs-keyword">for</span> (let key <span class="hljs-keyword">in</span> arr) &#123;<br>  console.log(key);   <span class="hljs-regexp">//</span> 不仅arr下标打印还会把name也遍历了...<br>&#125;<br><br><span class="hljs-keyword">for</span> (let key of arr) &#123;<br>  <span class="hljs-regexp">//</span> <span class="hljs-keyword">for</span> of 相较于 forEach map 这些方法 能够有中断遍历功能<br>  <span class="hljs-regexp">//</span> <span class="hljs-keyword">break</span>;<br>  console.log(key);   <span class="hljs-regexp">//</span> 会遍历真正的数组元素。name 不会遍历<br>&#125;<br>let obj = &#123;<br>  name: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>  sex: <span class="hljs-string">&#x27;男&#x27;</span>,<br>  age: <span class="hljs-number">19</span><br>&#125;<br><br><span class="hljs-regexp">//</span> 遍历对象<br><span class="hljs-keyword">for</span> (let k <span class="hljs-keyword">in</span> obj) &#123;<br>  <span class="hljs-regexp">//</span> 如果是obj.k 以为是obj的k属性。但没有在obj里设置k<br>  <span class="hljs-regexp">//</span> 但要注意：如果是obj[k] k会被当成字符串的属性 例如 obj[<span class="hljs-string">&#x27;key&#x27;</span>]<br>  console.log(k, obj[k]);<br>&#125;<br><br>console.log(obj[<span class="hljs-string">&#x27;name&#x27;</span>]);   <span class="hljs-regexp">//</span> 小明<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p><strong>Set 容器(集合)</strong> ：无序 不可重复的多个 value 的集合体(不是键值对哦！)<br>理解为特殊数组，元素值不重复</p>
<p>其实和上面的 Map 的方法一样, 无外乎增删改查</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">// 创建一个空集合</span><br>let set1 = <span class="hljs-keyword">new</span> Set();<br><br><span class="hljs-comment">// 添加元素</span><br>set1.<span class="hljs-built_in">add</span>(<span class="hljs-string">&#x27;a&#x27;</span>)<br>set1.<span class="hljs-built_in">add</span>(<span class="hljs-string">&#x27;c&#x27;</span>)<br><br>console.<span class="hljs-built_in">log</span>(set1);<br>console.<span class="hljs-built_in">log</span>(set1.has(<span class="hljs-string">&#x27;b&#x27;</span>));  <span class="hljs-comment">// 集合中是否含有 &#x27;b&#x27;</span><br>set1.delete(<span class="hljs-string">&#x27;c&#x27;</span>);    <span class="hljs-comment">// 删除 &#x27;c&#x27;</span><br>set1.<span class="hljs-built_in">add</span>(<span class="hljs-string">&#x27;a&#x27;</span>);       <span class="hljs-comment">// 因为重复，所以只保留一个</span><br>console.<span class="hljs-built_in">log</span>(set1);<br>console.<span class="hljs-built_in">log</span>(set1.<span class="hljs-built_in">size</span>);   <span class="hljs-comment">// 元素个数</span><br>set1.<span class="hljs-built_in">clear</span>();        <span class="hljs-comment">// 清空集合</span><br>console.<span class="hljs-built_in">log</span>(set1);<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>async/await</title>
    <url>/2021/10/31/async-await/</url>
    <content><![CDATA[<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p><code>Promise</code> n. 许诺，允诺；希望<br>这个单词其实和真实生活中的<strong>承诺</strong>非常像<br>我承诺要做什么什么… 总共会得到两种结果<br>一种是承诺得以实现(<code>resolved</code>) 一种是承诺没有被实现(<code>rejected</code>)<br><code>Promise</code> 接受一个参数，该参数必须是一个函数,并且这个函数有两个参数(<code>resolve</code>, <code>reject</code>)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span> + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (a === <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-comment">// resolve 可以传入任何我想传入的内容(任何类型)</span><br>    resolve(<span class="hljs-string">&#x27;Success&#x27;</span>)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// reject 可以传入任何我想传入的内容(任何类型)</span><br>    reject(<span class="hljs-string">&#x27;Failed&#x27;</span>);<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p><code>then</code> 的内容(参数)执行的是 <code>resolve</code> 传入的内容。即 p 完成它的承诺后，然后做什么什么事<br><code>catch</code> 的内容(参数)执行的是 <code>reject</code> 传入的内容。即 p 没有完成它的承诺，然后会做什么什么事</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">p.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(message)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;This is in the then&#x27;</span> + message);<br>&#125;).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">(message)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;This is in the catch&#x27;</span> + message);<br>&#125;)<br></code></pre></td></tr></table></figure>

<p><strong>举个例子来看看 Promise 给我们带来的变化…</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> userLeft = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">const</span> userWatchingCatMeme = <span class="hljs-literal">false</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">watchTutorialCallback</span>(<span class="hljs-params">callback, errorCallback</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (userLeft) &#123;<br>    errorCallback(&#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;User Left&#x27;</span>,<br>      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;:(&#x27;</span><br>    &#125;)<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (userWatchingCatMeme) &#123;<br>    errorCallback(&#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;User Watching Cat Meme&#x27;</span>,<br>      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;WebDevSimplified &lt; Cat&#x27;</span><br>    &#125;)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    callback(<span class="hljs-string">&#x27;Thumbs up and Subscribe&#x27;</span>)<br>  &#125;<br>&#125;<br>watchTutorialCallback(<span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Success &#x27;</span> + message);<br>&#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(error.name + <span class="hljs-string">&#x27; &#x27;</span> + error.message);<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>—————-用 Promise 来改造—————-</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span> 避免烦人的回调函数...<br>function watchTutorialPromise() &#123;<br>  let p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (userLeft) &#123;<br>      reject(&#123;<br>        name: <span class="hljs-string">&#x27;User Left&#x27;</span>,<br>        message: <span class="hljs-string">&#x27;:(&#x27;</span><br>      &#125;)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (userWatchingCatMeme) &#123;<br>      reject(&#123;<br>        name: <span class="hljs-string">&#x27;User Watching Cat Meme&#x27;</span>,<br>        message: <span class="hljs-string">&#x27;WebDevSimplified &lt; Cat&#x27;</span><br>      &#125;)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      resolve(<span class="hljs-string">&#x27;Thumbs up and Subscribe&#x27;</span>)<br>    &#125;<br>  &#125;)<br>  p.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(message)</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Success &#x27;</span> + message);<br>  &#125;).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">(error)</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(error.name + <span class="hljs-string">&#x27; &#x27;</span> + error.message);<br>  &#125;)<br>&#125;<br>watchTutorialPromise();<br></code></pre></td></tr></table></figure>

<p>————Promise 的其他一些功能————</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">const recordVideoOne = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>  <span class="hljs-regexp">//</span> resolve(<span class="hljs-string">&#x27;Video 1 Recorded&#x27;</span>)<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span> &#123;resolve(<span class="hljs-string">&#x27;Video 1 Recorded&#x27;</span>)&#125;, <span class="hljs-number">3000</span>);<br>&#125;)<br>const recordVideoTwo = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>  resolve(<span class="hljs-string">&#x27;Video 2 Recorded&#x27;</span>)<br>&#125;)<br>const recordVideoThree = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>  resolve(<span class="hljs-string">&#x27;Video 3 Recorded&#x27;</span>)<br>&#125;)<br><br><span class="hljs-regexp">//</span> 同时获取三个数据 (放入的参数是一个数组哦！)<br><span class="hljs-built_in">Promise</span>.all([<br>  recordVideoOne,<br>  recordVideoTwo,<br>  recordVideoThree<br>]).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(messages)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Promise.all&#x27;</span>, messages);<br>&#125;)<br><br><span class="hljs-regexp">//</span> 数据谁先到就用谁的<br><span class="hljs-built_in">Promise</span>.race([<br>  recordVideoOne,<br>  recordVideoTwo,<br>  recordVideoThree<br>]).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(messages)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Promise.race&#x27;</span>, messages);<br>&#125;)<br></code></pre></td></tr></table></figure>

<h4 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async/Await"></a>Async/Await</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeRequest</span>(<span class="hljs-params">location</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Making Request to <span class="hljs-subst">$&#123;location&#125;</span>`</span>);<br>    <span class="hljs-keyword">if</span> (location === <span class="hljs-string">&#x27;Google&#x27;</span>) &#123;<br>      resolve(<span class="hljs-string">&#x27;Google says hi&#x27;</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      reject(<span class="hljs-string">&#x27;We can only talk to Google&#x27;</span>)<br>    &#125;<br>  &#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processRequest</span>(<span class="hljs-params">response</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Processing response&#x27;</span>);<br>    resolve(<span class="hljs-string">`Extra Information + <span class="hljs-subst">$&#123;response&#125;</span>`</span>)<br>  &#125;)<br>&#125;<br><br>makeRequest(<span class="hljs-string">&#x27;Google&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Response Received&#x27;</span>);<br>  <span class="hljs-keyword">return</span> processRequest(response)<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">processResponse</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(processResponse);<br>&#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(err);<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>利用 <code>async</code> 和 <code>await</code> 来化简上述的代码</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">async</span> function doWork() &#123;<br>  <span class="hljs-regexp">//</span> <span class="hljs-keyword">try</span>……<span class="hljs-keyword">catch</span> 来解决<span class="hljs-built_in">Promise</span>.<span class="hljs-keyword">catch</span> 这种问题....<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-regexp">//</span> <span class="hljs-keyword">await</span> 放在会异步的代码前面。不放的话，返回的是<span class="hljs-built_in">Promise</span> 而非 <span class="hljs-built_in">Promise</span> 执行的结果...<br>    <span class="hljs-regexp">//</span> 当执行到<span class="hljs-keyword">await</span>的时候，程序会识别出<span class="hljs-keyword">await</span>后面是异步函数。然后就会跳出去执行其他同步函数。当<span class="hljs-keyword">await</span>的异步函数执行完且当前已无(<span class="hljs-keyword">async</span>函数外的)同步代码的时候，就会调回来继续执行后续代码<br>    <span class="hljs-regexp">//</span> 以及<span class="hljs-keyword">await</span> 必须要有<span class="hljs-keyword">async</span>来搭配才行...<br>    <span class="hljs-regexp">//</span> <span class="hljs-keyword">await</span> 就像在说 要等待 makeRequest 执行完后 才能继续往下运行(这里的往下运行是指的将结果赋值个变量response以及执行下一行代码...不是跳出去执行<span class="hljs-keyword">async</span>函数外部的同步代码)<br>    const response = <span class="hljs-keyword">await</span> makeRequest(<span class="hljs-string">&#x27;Google&#x27;</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Response Received&#x27;</span>);<br>    <span class="hljs-regexp">//</span> 等待processRequest执行完后，才会把结果赋值给processedResponse，才会往下一步执行<br>    const processedResponse = <span class="hljs-keyword">await</span> processRequest(response);<br>    <span class="hljs-built_in">console</span>.log(processedResponse);<br>  &#125; <span class="hljs-keyword">catch</span>(err) &#123;<br>    <span class="hljs-built_in">console</span>.log(err);<br>  &#125;<br>&#125;<br>doWork();<br></code></pre></td></tr></table></figure>

<p>为了推论上述的 await 代码跳转问题。有了下述代码论证</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>);<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2&#x27;</span>);<br>  <span class="hljs-comment">// fetch是异步请求。所以执行栈先跳转到当前async函数外面的同步代码并且fetch以及其附带的then、catch执行完后继续执行赋值代码给data以及完成下一行代码</span><br>  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/todos/1&#x27;</span>)<br>  .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())<br>  .then(<span class="hljs-function"><span class="hljs-params">json</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(json))<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3&#x27;</span>);<br>&#125;<br>func1();<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func2</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// console.log(&#x27;4&#x27;);是同步代码</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;4&#x27;</span>);<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/todos/2&#x27;</span>)<br>  .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())<br>  .then(<span class="hljs-function"><span class="hljs-params">json</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(json))<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;5&#x27;</span>);<br>&#125;<br>func2();<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;6&#x27;</span>);<br><span class="hljs-comment">// 执行结果顺序：</span><br><span class="hljs-comment">// 1、 2、 4、 6、 api_1、 3、 api_2、 5</span><br><span class="hljs-comment">// 或者 1、 2、 4、 6、 api_2、 5、 api_1、 3 (因为可能第二个接口请求数据更快所以更快完成await代码...)</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>axios 使用方法</title>
    <url>/2021/10/25/axios-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://axios-http.com/zh/docs/intro">官方文档</a><br><code>Axios</code> 是一个基于 <code>promise</code> 网络请求库，作用于 <code>node.js</code> 和<code>浏览器</code>中。 它是 isomorphic 的(即同一套代码可以运行在<code>浏览器</code>和 <code>node.js</code> 中)。在服务端它使用原生 <code>node.js</code> http 模块, 而在客户端 (浏览端) 则使用 <code>XMLHttpRequests</code>。</p>
<blockquote>
<p>这个不像<code>fetch</code>。<code>axios</code> 是需要在项目中额外安装的</p>
</blockquote>
<p>下面的代码段全是基于此篇代码所写：<a href="https://github.com/Bruce-shuai/axios-study">axios-study</a></p>
<h3 id="Axios-基本玩法"><a href="#Axios-基本玩法" class="headerlink" title="Axios 基本玩法"></a>Axios 基本玩法</h3><blockquote>
<p><code>即 增、删、改、查</code></p>
</blockquote>
<h4 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h4><p>3 种书写方法(大同小异，推荐第二种，更直观…)</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">/* 方法<span class="hljs-number">1</span> */<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTodo</span><span class="hljs-params">()</span> &#123;</span><br>  axios(&#123;<br>    method: <span class="hljs-string">&#x27;GET&#x27;</span>,<br>    ur<span class="hljs-variable">l:</span> <span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/todos&#x27;</span>,<br>    // 参数项： _limit 应该是后端自己做的...<br>    param<span class="hljs-variable">s:</span> &#123;<br>      _limi<span class="hljs-variable">t:5</span><br>    &#125;<br>  &#125;)<br>  .then(<span class="hljs-keyword">res</span> =&gt; console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;res&#x27;</span>, <span class="hljs-keyword">res</span>.data))<br>  .<span class="hljs-keyword">catch</span>(err =&gt; console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;err&#x27;</span>, err))<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">/* 方法<span class="hljs-number">2</span> */<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTodo</span><span class="hljs-params">()</span> &#123;</span><br>  axios.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/todos&#x27;</span>, &#123;<br>    param<span class="hljs-variable">s:</span> &#123;<br>      _limi<span class="hljs-variable">t:</span> <span class="hljs-number">5</span><br>    &#125;<br>  &#125;)<br>  .then(<span class="hljs-keyword">res</span> =&gt; console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;res&#x27;</span>, <span class="hljs-keyword">res</span>.data))<br>  .<span class="hljs-keyword">catch</span>(err =&gt; console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;err&#x27;</span>, err))<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">/* 方法3 */</span><br>function getTodo() &#123;<br>  <span class="hljs-comment">// 因为get方法是默认方法，可以省略get的书写</span><br>  <span class="hljs-comment">// _limit=5是参数 直接以键值对的方式作为url参数来写入(这也是get 方法的用途...)</span><br>  axios(&#x27;https:<span class="hljs-comment">//jsonplaceholder.typicode.com/todos?_limit=5)</span><br>  .then(res =&gt; console.<span class="hljs-built_in">log</span>(&#x27;res&#x27;, res.data))<br>  .catch(<span class="hljs-keyword">err</span> =&gt; console.<span class="hljs-built_in">log</span>(&#x27;<span class="hljs-keyword">err</span>&#x27;, <span class="hljs-keyword">err</span>))<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h4><p>两种书写方法(推荐第二种书写方法…)</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// POST REQUEST</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">postTodo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  axios(&#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/todos&#x27;</span>,<br>    <span class="hljs-comment">// 不是params哦~ 这是POST的特殊之处...</span><br>    data: &#123;<br>      <span class="hljs-comment">// 这些属性是自己随意拟定的...</span><br>      title: <span class="hljs-string">&#x27;New To Do&#x27;</span>,<br>      <span class="hljs-attr">complete</span>: <span class="hljs-literal">false</span>,<br>    &#125;<br>  &#125;)<br>  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> console.log(<span class="hljs-string">&#x27;res&#x27;</span>, res.data))<br>  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> console.log(<span class="hljs-string">&#x27;err&#x27;</span>, err))<br></code></pre></td></tr></table></figure>

<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">postTodo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 下述方法同上</span><br>  axios.post(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/todos&#x27;</span>, &#123;<br>    <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;New To Do&#x27;</span>,<br>    <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span>,<br>  &#125;)<br>  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> console.log(<span class="hljs-string">&#x27;res&#x27;</span>, res.data))<br>  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> console.log(<span class="hljs-string">&#x27;err&#x27;</span>, err))<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="PUT-PATCH-方法"><a href="#PUT-PATCH-方法" class="headerlink" title="PUT/PATCH 方法"></a>PUT/PATCH 方法</h4><ul>
<li>PUT/PATCH 注意 PUT 一般是更换整体 而 PATCH 一般是更换局部内容</li>
<li>注意 一般使用 PUT 或 PATCH 都是要有参数具体指定修改哪一个内容的</li>
<li>所以 PUT 既要指定 params 属性 又要修改 data 属性</li>
</ul>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">putTodo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  axios(&#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;PUT&#x27;</span>,<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/todos/1&#x27;</span>,<br>    <span class="hljs-comment">// 不是params哦~</span><br>    data: &#123;<br>      <span class="hljs-comment">// 这些属性是自己随意拟定的...</span><br>      title: <span class="hljs-string">&#x27;Update To Do&#x27;</span>,<br>      <span class="hljs-attr">completed</span>: <span class="hljs-literal">true</span>,<br>    &#125;<br>  &#125;)<br>  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> console.log(<span class="hljs-string">&#x27;res&#x27;</span>, res.data))<br>  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> console.log(<span class="hljs-string">&#x27;err&#x27;</span>, err))<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="DELETE-方法"><a href="#DELETE-方法" class="headerlink" title="DELETE 方法"></a>DELETE 方法</h4><p><code>DELETE</code> 这个只需指定<code>params</code> 而没有<code>data</code>属性</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deleteTodo</span><span class="hljs-params">()</span>&#123;</span><br>  axios(&#123;<br>    method: <span class="hljs-string">&#x27;DELETE&#x27;</span>,<br>    ur<span class="hljs-variable">l:</span> <span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/todos/1&#x27;</span>,<br>  &#125;)<br>  .then(<span class="hljs-keyword">res</span> =&gt; console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;res&#x27;</span>, <span class="hljs-keyword">res</span>.data))<br>  .<span class="hljs-keyword">catch</span>(err =&gt; console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;err&#x27;</span>, err))<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Axios-高级玩法"><a href="#Axios-高级玩法" class="headerlink" title="Axios 高级玩法"></a>Axios 高级玩法</h3><h4 id="并发请求"><a href="#并发请求" class="headerlink" title="并发请求"></a>并发请求</h4><p><code>SIMULATANEOUS DATA</code> (同时请求多种数据)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getData</span>(<span class="hljs-params"></span>) </span>&#123;<br>  axios<br>  .all([<br>    axios.get(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/todos&#x27;</span>),<br>    axios.get(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/posts&#x27;</span>)<br>  ])<br>  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(res[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">console</span>.log(res[<span class="hljs-number">1</span>]);<br>  &#125;)<br>  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(err));<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 方法同上</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getData</span>(<span class="hljs-params"></span>) </span>&#123;<br>axios.<br>all([<br>  axios.get(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/todos&#x27;</span>),<br>  axios.get(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/posts&#x27;</span>)<br>]).then(axios.spread(<span class="hljs-function">(<span class="hljs-params">todos,posts</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(todos);<br>  <span class="hljs-built_in">console</span>.log(posts)<br>&#125;))<br>.catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(err))<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="INTERCEPTING-REQUESTS-amp-RESPONSES"><a href="#INTERCEPTING-REQUESTS-amp-RESPONSES" class="headerlink" title="INTERCEPTING REQUESTS &amp; RESPONSES"></a>INTERCEPTING REQUESTS &amp; RESPONSES</h4><p>拦截器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">axios.interceptors.request.use(<br>  <span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<br>      <span class="hljs-string">`<span class="hljs-subst">$&#123;config.method.toUpperCase()&#125;</span> request sent to <span class="hljs-subst">$&#123;config.url&#125;</span> at <span class="hljs-subst">$&#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime()&#125;</span>`</span><br>    )<br>    <span class="hljs-keyword">return</span> config;<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error);<br>  &#125;<br>)<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>clean Code</title>
    <url>/2021/11/04/clean-Code/</url>
    <content><![CDATA[<h3 id="停止使用继承-迎接函数式组合"><a href="#停止使用继承-迎接函数式组合" class="headerlink" title="停止使用继承, 迎接函数式组合"></a>停止使用继承, 迎接函数式组合</h3><h4 id="继承法"><a href="#继承法" class="headerlink" title="继承法"></a>继承法</h4><p>试想用 class 的方法来完成一个继承问题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monster</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">attack</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span> attacked`</span>);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">walk</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span> walked`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建一个飞行的怪物类(利用传统的继承方法)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyingMonster</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Monster</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">fly</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span> flew`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建一个游泳的怪物类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwimmingMonster</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Monster</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">swim</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span> swam`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> bear = <span class="hljs-keyword">new</span> Monster(<span class="hljs-string">&#x27;bear&#x27;</span>);<br>bear.walk();<br>bear.attack();<br><br><span class="hljs-keyword">const</span> eagle = <span class="hljs-keyword">new</span> FlyingMonster(<span class="hljs-string">&#x27;eagle&#x27;</span>);<br>eagle.walk();<br>eagle.attack();<br>eagle.fly();<br><br><span class="hljs-keyword">const</span> shark = <span class="hljs-keyword">new</span> SwimmingMonster(<span class="hljs-string">&#x27;shark&#x27;</span>);<br>shark.walk();<br>shark.attack();<br>shark.swim();<br></code></pre></td></tr></table></figure>

<p>上述一些都比较的正常…<br>但是现在有个问题。如果我想创建一个即能够游泳又可以飞行的怪物类怎么办？<br>只能凉凉，js 只能支持单继承…<br>class FlyingSwimmingMonster extends FlyingMonster … ❌</p>
<h4 id="组合大法"><a href="#组合大法" class="headerlink" title="组合大法"></a>组合大法</h4><p>现在抛开传统的类继承方法<br>以函数式编程的思维来解决问题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个游泳函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swimmer</span>(<span class="hljs-params">&#123;name&#125;</span>) </span>&#123;<br>  <span class="hljs-comment">// 返回的是一个对象</span><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">swim</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span> swam`</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建一个飞行函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flyer</span>(<span class="hljs-params">&#123;name&#125;</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">fly</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span> fly`</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 现在我想创建一个能够产生会游泳的怪物的函数</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swimmingMonsterCreator</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> monster = &#123;<span class="hljs-attr">name</span>: name&#125;<br>  <span class="hljs-comment">// 这里的解构用得挺好</span><br>  <span class="hljs-keyword">return</span> &#123;<br>    ...monster,<br>    ...swimmer(monster)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 现在我想创建一个既可以游泳又可以飞行的怪物的函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SwimmingFlyingMonsterCreator</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> monster = &#123;<span class="hljs-attr">name</span>: name&#125;<br>  <span class="hljs-keyword">return</span> &#123;<br>    ...monster,<br>    ...swimmer(monster),<br>    ...flyer(monster)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj1 = swimmingMonsterCreator(<span class="hljs-string">&#x27;Monster&#x27;</span>);<br>obj1.swim();<br><br><span class="hljs-keyword">const</span> obj2 = SwimmingFlyingMonsterCreator(<span class="hljs-string">&#x27;Monster2&#x27;</span>)<br>obj2.swim();<br>obj2.fly();<br></code></pre></td></tr></table></figure>

<p>可见…组合的方法，非常方便且灵活~</p>
]]></content>
      <categories>
        <category>Clean Code篇</category>
      </categories>
      <tags>
        <tag>优质代码</tag>
      </tags>
  </entry>
  <entry>
    <title>css-color hsl</title>
    <url>/2021/11/06/css-color-hsl/</url>
    <content><![CDATA[<p>不多说…以后如果是自己来控制颜色，就采用 hsl()方法，而不是使用#十六进制、rgba、rgb 这种颜色控制…</p>
<p>hsl 的优势，下面我一一列举</p>
<h4 id="hsl-能让你具体把握住当前你想要的颜色大致是什么颜色"><a href="#hsl-能让你具体把握住当前你想要的颜色大致是什么颜色" class="headerlink" title="hsl 能让你具体把握住当前你想要的颜色大致是什么颜色"></a>hsl 能让你具体把握住当前你想要的颜色大致是什么颜色</h4><p>如果是十六进制、或者 rgb 你是不好掌握当前是什么颜色的。例如</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">/* css样式 */</span><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">40px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">40px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><span class="hljs-selector-class">.sixteen</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#3b3b3a</span>;         <span class="hljs-comment">// 你能看出这是什么颜色？？</span><br>&#125;<br><span class="hljs-selector-class">.rgb</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: rgb(<span class="hljs-number">59</span>, <span class="hljs-number">59</span>, <span class="hljs-number">58</span>); <span class="hljs-comment">// 你能看出这是什么颜色？？</span><br>&#125;<br><br><span class="hljs-comment">/* html样式 */</span><br>&lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;sixteen box&quot;</span>&gt;&lt;/div&gt;<br>&lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;rgb box&quot;</span>&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<p><strong>现在开始重点</strong><br><code>hsl</code> –&gt; <code>hue(色彩)</code>、<code>saturation(色彩饱和度)</code>、<code>lightness(明亮度)</code> 由这三者来控制</p>
<p><code>hue</code>的范围在 0<del>360<br><code>saturation</code>的范围在 0</del>100%<br><code>lightness</code>的范围在 0~100%</p>
<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-06-at-4.02.10-PM.7a8g6h4qx7w0.png" alt="hue"><br>hue 为 0 的时候是红色 为 360 的时候是紫色。刚好一圈…<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-06-at-4.03.59-PM.1j8w24mrjxz4.png" alt="saturation"><br>saturation 为 100%的时候是正常饱和色度<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-06-at-4.04.46-PM.2vzblim4bai0.png" alt="lightness"><br>lightness 为 50%的时候是正常亮度 0% 永远是黑色 100% 永远是白色</p>
<h4 id="hsl-的使用案例"><a href="#hsl-的使用案例" class="headerlink" title="hsl 的使用案例"></a>hsl 的使用案例</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">/* css样式 */</span><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">80px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">80px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.hsl</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: hsl(<span class="hljs-number">0</span>, <span class="hljs-number">100%</span>, <span class="hljs-number">50%</span>)<br>&#125;<br><span class="hljs-selector-class">.hsl</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: hsl(<span class="hljs-number">0</span>, <span class="hljs-number">100%</span>, <span class="hljs-number">30%</span>)  <span class="hljs-comment">/* 颜色会更暗 */</span><br>&#125;<br><br><span class="hljs-comment">/* html样式 */</span><br>&lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;hsl box&quot;</span>&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-06-at-4.09.56-PM.7bpmbivvdrg0.gif" alt="hsl效果显示1"></p>
<p>试想，如果使用的是十六进制或者 rgb。想要颜色更暗淡…是有多麻烦…</p>
<p><strong>下面结合 css variable 来让功能更加的强大</strong></p>
<figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">/* css样式 */</span><br>.<span class="hljs-built_in">box</span> &#123;<br>  <span class="hljs-built_in">width</span>: <span class="hljs-number">80</span>px;<br>  <span class="hljs-built_in">height</span>: <span class="hljs-number">80</span>px;<br>  margin: <span class="hljs-number">10</span>px;<br>&#125;<br><br>.hsl &#123;<br>  --<span class="hljs-built_in">hue</span>: <span class="hljs-number">200</span>;<br>  --<span class="hljs-built_in">saturation</span>: <span class="hljs-number">100</span>%;<br>  --lightness: <span class="hljs-number">50</span>%;<br>    <span class="hljs-built_in">background</span>-<span class="hljs-built_in">color</span>: hsl(var(--<span class="hljs-built_in">hue</span>), var(--<span class="hljs-built_in">saturation</span>), var(--lightness))<br>&#125;<br>.hsl:hover &#123;<br>  --lightness: <span class="hljs-number">30</span>%<br>&#125;<br><br><span class="hljs-comment">/* html样式 */</span><br>&lt;div class=<span class="hljs-string">&quot;hsl box&quot;</span>&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-06-at-4.17.09-PM.6pt7vgotqk40.gif" alt="hsl效果显示2"></p>
<p>这样，对于控制颜色更加的方便灵活了。</p>
]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>高级</tag>
      </tags>
  </entry>
  <entry>
    <title>css 命名艺术</title>
    <url>/2021/11/06/css-%E5%91%BD%E5%90%8D%E8%89%BA%E6%9C%AF/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>优质代码</tag>
      </tags>
  </entry>
  <entry>
    <title>css variable</title>
    <url>/2021/11/06/css-variable/</url>
    <content><![CDATA[<p>如果你想使用<code>CSS Variable</code>。大多数情况下，你可以把<code>CSS Variable</code>放在<code>:root</code>或者<code>html</code>选择器上。因为<code>CSS Variable</code>其实也和其他的 css 属性无太多区别…放在<strong>文件顶部</strong>其属性可以被后续选择器继承或覆盖属性等等操作。</p>
<h4 id="CSS-Variable定义方法"><a href="#CSS-Variable定义方法" class="headerlink" title="CSS Variable定义方法"></a><code>CSS Variable</code>定义方法</h4><blockquote>
<p><code>--dataName</code> 格式。 名字前有两条横杠</p>
</blockquote>
<p>例如：<code>--div-background-color</code>、<code>--text-color</code></p>
<h4 id="CSS-Variable使用方法"><a href="#CSS-Variable使用方法" class="headerlink" title="CSS Variable使用方法"></a><code>CSS Variable</code>使用方法</h4><blockquote>
<p>css 属性: var(–dataName)</p>
</blockquote>
<p>重点在于 var(),这个是让<code>CSS Variable</code>发挥作用的关键步骤</p>
<h4 id="下面进行代码实战"><a href="#下面进行代码实战" class="headerlink" title="下面进行代码实战"></a>下面进行代码实战</h4><p>CSS 变量用法灵活~<br>无任何 css 修饰的情况下</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/* html代码段 */</span><br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;one&quot;</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span>&gt;<span class="hljs-number">1</span>-<span class="hljs-number">1</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span>&gt;<span class="hljs-number">1</span>-<span class="hljs-number">2</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span>&gt;<span class="hljs-number">1</span>-<span class="hljs-number">3</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;two&quot;</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span>&gt;<span class="hljs-number">2</span>-<span class="hljs-number">1</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span>&gt;<span class="hljs-number">2</span>-<span class="hljs-number">2</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<p>页面显示效果：<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-06-at-8.10.05-AM.3qstbnzfywu0.png" alt="页面显示效果1"></p>
<p>好！ 现在样式修饰。 注意一下，我如何使用的 <code>css 代码段</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* css代码段 */</span><br><span class="hljs-selector-pseudo">:root</span> &#123;<br>  --<span class="hljs-selector-tag">div</span>-<span class="hljs-attribute">background-color</span>: red;<br>  --text-<span class="hljs-attribute">color</span>: black;<br>  --<span class="hljs-selector-tag">div</span>-<span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  --<span class="hljs-selector-tag">div</span>-<span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">var</span>(--div-background-color);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/* html代码段 */</span><br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;one&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;<span class="hljs-number">1</span>-<span class="hljs-number">1</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;<span class="hljs-number">1</span>-<span class="hljs-number">2</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;<span class="hljs-number">1</span>-<span class="hljs-number">3</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;two&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;<span class="hljs-number">2</span>-<span class="hljs-number">1</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;<span class="hljs-number">2</span>-<span class="hljs-number">2</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-06-at-8.31.02-AM.5x1yurh3ff80.png" alt="页面显示效果2"></p>
<h4 id="CSS-Variable-属性值覆盖"><a href="#CSS-Variable-属性值覆盖" class="headerlink" title="CSS Variable 属性值覆盖"></a><code>CSS Variable</code> 属性值覆盖</h4><p>好，现在我来展示一下<code>CSS Variable</code>属性<strong>覆盖效果</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-pseudo">:root</span> &#123;<br>  --<span class="hljs-selector-tag">div</span>-<span class="hljs-attribute">background-color</span>: red;<br>  --text-<span class="hljs-attribute">color</span>: black;<br>  --<span class="hljs-selector-tag">div</span>-<span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  --<span class="hljs-selector-tag">div</span>-<span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">var</span>(--div-background-color);<br>&#125;<br><span class="hljs-selector-class">.one</span> &#123;<br>  --<span class="hljs-selector-tag">div</span>-<span class="hljs-attribute">background-color</span>: blue;   // 此时，--<span class="hljs-selector-tag">div</span>-<span class="hljs-attribute">background-color</span>变量的值是blue，覆盖上了上述的red(仅限所有被<span class="hljs-selector-class">.one</span> 所在元素及元素包裹的部分)<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-06-at-8.35.11-AM.2kv9gq9zriw0.png" alt="页面显示效果3"></p>
<h4 id="CSS-Variable优势之修改一次全局生效…"><a href="#CSS-Variable优势之修改一次全局生效…" class="headerlink" title="CSS Variable优势之修改一次全局生效…"></a><code>CSS Variable</code>优势之修改一次全局生效…</h4><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-pseudo">:root</span> &#123;<br>  --<span class="hljs-selector-tag">div</span>-<span class="hljs-attribute">background-color</span>: red;<br>  --text-<span class="hljs-attribute">color</span>: black;<br>  --<span class="hljs-selector-tag">div</span>-<span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  --<span class="hljs-selector-tag">div</span>-<span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">var</span>(--div-background-color);<br>&#125;<br><br><span class="hljs-selector-class">.one</span> &#123;<br>  --<span class="hljs-selector-tag">div</span>-<span class="hljs-attribute">background-color</span>: blue;<br>  --text-<span class="hljs-attribute">color</span>: white;<br>&#125;<br><br>// one-one 和 one-two 都拥有了css 变量效果。<br>// 如果我修改<span class="hljs-selector-pseudo">:root</span> 中--<span class="hljs-selector-tag">div</span>-<span class="hljs-attribute">padding</span>值。则one-one 和 one-two对应<span class="hljs-attribute">padding</span>都会跟着变化<br><span class="hljs-selector-class">.one-one</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-built_in">var</span>(--div-padding);<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-built_in">var</span>(--div-margin);<br>&#125;<br><br><span class="hljs-selector-class">.one-two</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-built_in">var</span>(--div-padding);<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-built_in">var</span>(--div-margin);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/* html代码段 */</span><br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;one&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;one-one child&quot;</span>&gt;<span class="hljs-number">1</span>-<span class="hljs-number">1</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;one-two child&quot;</span>&gt;<span class="hljs-number">1</span>-<span class="hljs-number">2</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;<span class="hljs-number">1</span>-<span class="hljs-number">3</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;two&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;<span class="hljs-number">2</span>-<span class="hljs-number">1</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;<span class="hljs-number">2</span>-<span class="hljs-number">2</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-06-at-8.45.55-AM.7iz1ichqsao0.png" alt="页面显示效果4"></p>
<h4 id="CSS-Variable优势之专属回调函数，用于CSS-Variable未被定义时"><a href="#CSS-Variable优势之专属回调函数，用于CSS-Variable未被定义时" class="headerlink" title="CSS Variable优势之专属回调函数，用于CSS Variable未被定义时"></a><code>CSS Variable</code>优势之专属回调函数，用于<code>CSS Variable</code>未被定义时</h4><p>接着上面的例子来讲：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-pseudo">:root</span> &#123;<br>  --<span class="hljs-selector-tag">div</span>-<span class="hljs-attribute">background-color</span>: red;<br>  --text-<span class="hljs-attribute">color</span>: black;<br>  --<span class="hljs-selector-tag">div</span>-<span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  --<span class="hljs-selector-tag">div</span>-<span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><br><span class="hljs-comment">/* 放置一个未被定义的css变量 --background-color */</span><br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-comment">/* pink 属于默认值。当--background-color未被定义时，pink显示效果 */</span><br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">var</span>(--background-color, pink)<br>&#125;<br><br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">var</span>(--div-background-color);<br>  <span class="hljs-attribute">color</span>:<span class="hljs-built_in">var</span>(--text-color);<br>&#125;<br><br><span class="hljs-selector-class">.one</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: blue;<br>  --text-<span class="hljs-attribute">color</span>: white;<br>&#125;<br><br><span class="hljs-selector-class">.one-one</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-built_in">var</span>(--div-padding);<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-built_in">var</span>(--div-margin);<br>&#125;<br><br><span class="hljs-selector-class">.one-two</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-built_in">var</span>(--div-padding);<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-built_in">var</span>(--div-margin);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意：<code>CSS Variable</code> 未被定义的问题可以用 JS 来解决…</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// JS 代码段</span><br>document.get<span class="hljs-constructor">ElementById(&#x27;<span class="hljs-params">dark</span>-<span class="hljs-params">theme</span>-<span class="hljs-params">btn</span>&#x27;)</span>.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">click</span>&#x27;, ()</span> =&gt; &#123;<br>  document.documentElement.style.set<span class="hljs-constructor">Property(&#x27;--<span class="hljs-params">background</span>-<span class="hljs-params">color</span>&#x27;, &#x27;#333&#x27;)</span><br>&#125;)<br>document.get<span class="hljs-constructor">ElementById(&#x27;<span class="hljs-params">light</span>-<span class="hljs-params">theme</span>-<span class="hljs-params">btn</span>&#x27;)</span>.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">click</span>&#x27;, ()</span> =&gt; &#123;<br>  document.documentElement.style.set<span class="hljs-constructor">Property(&#x27;--<span class="hljs-params">background</span>-<span class="hljs-params">color</span>&#x27;, &#x27;#<span class="hljs-params">fff</span>&#x27;)</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">/* html 代码段 */<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;one&quot;</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;one-one child&quot;</span>&gt;<span class="hljs-number">1</span><span class="hljs-number">-1</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;one-two child&quot;</span>&gt;<span class="hljs-number">1</span><span class="hljs-number">-2</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;<span class="hljs-number">1</span><span class="hljs-number">-3</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;two&quot;</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;<span class="hljs-number">2</span><span class="hljs-number">-1</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;<span class="hljs-number">2</span><span class="hljs-number">-2</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;button <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;dark-theme-btn&quot;</span>&gt;Dark-Theme&lt;/button&gt;<br>  &lt;button <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;light-theme-btn&quot;</span>&gt;Light-Theme&lt;/button&gt;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-06-at-9.15.52-AM.3bf5galhx4w0.gif" alt="页面效果展示5"></p>
]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>高级</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/10/06/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>post请求和get请求的区别</title>
    <url>/2021/10/09/post%E8%AF%B7%E6%B1%82%E5%92%8Cget%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h4 id="1-有哪些请求方式？"><a href="#1-有哪些请求方式？" class="headerlink" title="1.有哪些请求方式？"></a>1.有哪些请求方式？</h4><ul>
<li>get</li>
<li>post</li>
<li>put</li>
<li>patch</li>
<li>delete<br>…</li>
</ul>
<h4 id="2-get-请求和-post-请求的区别"><a href="#2-get-请求和-post-请求的区别" class="headerlink" title="2.get 请求和 post 请求的区别"></a>2.get 请求和 post 请求的区别</h4><p><strong>get 请求</strong><br>1）一般用来从服务器获取数据 (有时候会在 url 里增添参数 表示获取有一定限制(筛选数据)的数据)<br>2）1 中提到可以在 url 里添加参数，但这样做的话，安全性，隐私性就比较差。并且参数的长度是有限制的(不然，如果无限长，url 的长度就无限长…非常恐怖…)<br>3）当 发送 get 请求时，刷新浏览器或回退页面是没有影响的(只要 url 没有发生变化，就不会影响 get 请求发送)<br>4）get 请求可以缓存 (这是什么东西？有待查询) (因为 get 请求的数据一般是公开的…大家都可以看的东西)<br>5）get 请求会保留在浏览器历史记录当中<br>6）get 请求可以被收藏为书签(因为直接收藏 url 就可以了 url 带上了参数)<br>7）get 请求只能进行 url 编码(‘Content-type’: ‘application/x-www-form-urlencoded’)<br>8）get 请求通常是通过 url 地址栏发送请求<br><strong>post 请求</strong><br>1）一般用于提交数据到后台 (比如登录、注册时的操作)<br>2）post 请求的参数放在 请求的 body 中。所以不会再 url 中展示，相对而言比 get 要更加的安全<br>3）发送 post 请求过程中，回退页面，请求重新发送(因为参数会发送变化)<br>4）post 请求不会被缓存 (post 的请求的数据一般来说都是比较私密的…)<br>5）post 不会保存在浏览器历史记录当中<br>6）post 请求不可以被收藏为书签(post 参数放在 body 里面的。书签无法找到对应的参数…)<br>7）post 请求支持多种编码方式(例如 url：’application/x-www-form-urlencoded’ 表单提交：’multipart/form-data’ …有待补充)<br>8）post 请求通常是表单发送请求</p>
<p><strong>get 和 post 请求比较深入的一些区别如下</strong></p>
<ul>
<li>post 请求和 get 请求都是 http 的请求方式。底层都是 tcp/ip 协议。get 产生一个 tcp 数据包。post 产生两个数据包(但是 firefox 只发送一个)<br>有个问题是，这个发送一个数据包或发送两个数据包的区别和意义是什么呢？<br>(在网络好的时候，发一次数据包和发两次数据包 其实效果都差不多。但是当网络条件很差的时候，发一次数据包的效果肯定比发两次数据包的速度要快！)</li>
<li>get 请求会把 http header 和 data 一起发送出去，服务端反应 200。post 请求先发送 header，等服务端响应了 100 再继续发送 data。服务端再响应 200</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>react中常犯的错误</title>
    <url>/2021/11/01/react%E4%B8%AD%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<h3 id="useState-篇"><a href="#useState-篇" class="headerlink" title="useState 篇"></a>useState 篇</h3><h4 id="使用-useState-的时候，打印出来的结果往往是上一次渲染的结果-例如"><a href="#使用-useState-的时候，打印出来的结果往往是上一次渲染的结果-例如" class="headerlink" title="使用 useState 的时候，打印出来的结果往往是上一次渲染的结果 例如"></a>使用 useState 的时候，打印出来的结果往往是上一次渲染的结果 例如</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">App.js<br><span class="hljs-keyword">import</span> &#123;useState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">decrement</span>(<span class="hljs-params"></span>) </span>&#123;<br>    setCount(count - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 打印出的内容总是比当前的要慢一拍...</span><br>    <span class="hljs-built_in">console</span>.log(count);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">increment</span>(<span class="hljs-params"></span>) </span>&#123;<br>    setCount(count + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">console</span>.log(count);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;decrement&#125;</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      &#123;count&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;increment&#125;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-02-at-8.31.55-AM.1dmn8iq4rlwg.gif" alt="总是打印上一次渲染的结果"></p>
<p>解决办法 1：<code>setState</code>里面放入函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">decrement</span>(<span class="hljs-params"></span>) </span>&#123;<br>    setCount(<span class="hljs-function"><span class="hljs-params">prevCount</span> =&gt;</span> &#123;<br>      <span class="hljs-comment">// 可以打印出当前值来...</span><br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;current&#x27;</span>, prevCount - <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">return</span> prevCount - <span class="hljs-number">1</span><br>    &#125;)<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">increment</span>(<span class="hljs-params"></span>) </span>&#123;<br>    setCount(<span class="hljs-function"><span class="hljs-params">prevCount</span> =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;current&#x27;</span>, prevCount + <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">return</span> prevCount + <span class="hljs-number">1</span>;<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;decrement&#125;</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      &#123;count&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;increment&#125;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-02-at-8.35.50-AM.1mr4db5n7sjk.gif" alt="展示解决问题后的效果"></p>
<p>解决办法 2： 利用 <code>useEffect</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">decrement</span>(<span class="hljs-params"></span>) </span>&#123;<br>    setCount(count - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;count&#x27;</span>, count);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">increment</span>(<span class="hljs-params"></span>) </span>&#123;<br>    setCount(count + <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-comment">// 注意一件事情：useEffect似乎总是在当次渲染最后的阶段才会执行</span><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(count);<br>  &#125;, [count])<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;decrement&#125;</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      &#123;count&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;increment&#125;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-02-at-8.52.02-AM.5p7kn57e3oc0.gif" alt="解决问题的效果"></p>
<h4 id="使用-useState-的时候，同一个地方多次使用-useState…但是最后只打印一次的结果"><a href="#使用-useState-的时候，同一个地方多次使用-useState…但是最后只打印一次的结果" class="headerlink" title="使用 useState 的时候，同一个地方多次使用 useState…但是最后只打印一次的结果"></a>使用 useState 的时候，同一个地方多次使用 useState…但是最后只打印一次的结果</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">App()</span> &#123;<br>  const <span class="hljs-literal">[<span class="hljs-identifier">count</span>, <span class="hljs-identifier">setCount</span>]</span> = use<span class="hljs-constructor">State(0)</span>;<br><br>  <span class="hljs-keyword">function</span> decrement<span class="hljs-literal">()</span> &#123;<br>    set<span class="hljs-constructor">Count(<span class="hljs-params">count</span> - 1)</span>;<br>    set<span class="hljs-constructor">Count(<span class="hljs-params">count</span> - 1)</span>;<br>    set<span class="hljs-constructor">Count(<span class="hljs-params">count</span> - 1)</span>;<br>    set<span class="hljs-constructor">Count(<span class="hljs-params">count</span> - 1)</span>;<br>    console.log(count);<br>  &#125;<br>  <span class="hljs-keyword">function</span> increment<span class="hljs-literal">()</span> &#123;<br>    set<span class="hljs-constructor">Count(<span class="hljs-params">count</span> + 1)</span>;<br>    set<span class="hljs-constructor">Count(<span class="hljs-params">count</span> + 1)</span>;<br>    set<span class="hljs-constructor">Count(<span class="hljs-params">count</span> + 1)</span>;<br>    set<span class="hljs-constructor">Count(<span class="hljs-params">count</span> + 1)</span>;<br>    console.log(count);<br>  &#125;<br><br>  return (<br>    &lt;&gt;<br>      &lt;button onClick=&#123;decrement&#125;&gt;-&lt;/button&gt;<br>      &#123;count&#125;<br>      &lt;button onClick=&#123;increment&#125;&gt;+&lt;/button&gt;<br>    &lt;/&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-02-at-8.38.52-AM.43efrxnf3uc0.gif" alt="效果如图"></p>
<p>解决办法： 还是在<code>setState</code>中放函数来解决</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">function</span></span> App() &#123;<br>  const [<span class="hljs-built_in">count</span>, setCount] = useState(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span></span> decrement() &#123;<br>    setCount(<span class="hljs-built_in">count</span> =&gt; <span class="hljs-built_in">count</span> - <span class="hljs-number">1</span>);<br>    setCount(<span class="hljs-built_in">count</span> =&gt; <span class="hljs-built_in">count</span> - <span class="hljs-number">1</span>);<br>    setCount(<span class="hljs-built_in">count</span> =&gt; <span class="hljs-built_in">count</span> - <span class="hljs-number">1</span>);<br>    setCount(<span class="hljs-built_in">count</span> =&gt; &#123;<br>      console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">count</span> - <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">count</span> - <span class="hljs-number">1</span><br>    &#125;);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span></span> increment() &#123;<br>    setCount(<span class="hljs-built_in">count</span> =&gt; <span class="hljs-built_in">count</span> + <span class="hljs-number">1</span>);<br>    setCount(<span class="hljs-built_in">count</span> =&gt; <span class="hljs-built_in">count</span> + <span class="hljs-number">1</span>);<br>    setCount(<span class="hljs-built_in">count</span> =&gt; <span class="hljs-built_in">count</span> + <span class="hljs-number">1</span>);<br>    setCount(<span class="hljs-built_in">count</span> =&gt; &#123;<br>      console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">count</span> + <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">count</span> + <span class="hljs-number">1</span><br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    &lt;&gt;<br>      &lt;button onClick=&#123;decrement&#125;&gt;-&lt;/button&gt;<br>      &#123;<span class="hljs-built_in">count</span>&#125;<br>      &lt;button onClick=&#123;increment&#125;&gt;+&lt;/button&gt;<br>    &lt;/&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-02-at-8.43.37-AM.a9jurgtg8ww.gif" alt="解决问题后的效果"></p>
<h3 id="useEffect-篇"><a href="#useEffect-篇" class="headerlink" title="useEffect 篇"></a>useEffect 篇</h3><h4 id="useEffect-执行不受控制-依赖项为对象"><a href="#useEffect-执行不受控制-依赖项为对象" class="headerlink" title="useEffect 执行不受控制(依赖项为对象)"></a>useEffect 执行不受控制(依赖项为对象)</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;useState, useEffect&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [name, setName] = useState(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <span class="hljs-keyword">const</span> [dark, setDark] = useState(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">const</span> age = <span class="hljs-number">24</span>;<br>  <span class="hljs-keyword">const</span> user = &#123;age, name&#125;;<br><br>  <span class="hljs-keyword">const</span> BtnStyle = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">padding</span>: <span class="hljs-string">&#x27;2px&#x27;</span>,<br>      <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;dark ? <span class="hljs-string">&#x27;black&#x27;</span> : <span class="hljs-string">&#x27;white&#x27;</span>&#125;</span>`</span>,<br>      <span class="hljs-attr">color</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;dark ? <span class="hljs-string">&#x27;white&#x27;</span> :  <span class="hljs-string">&#x27;black&#x27;</span> &#125;</span>`</span><br>    &#125;<br>  &#125;<br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;user&#x27;</span>, user);<br>  &#125;, [user])<br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      &#123;/* input 标签和onChange事件是绝配哦！ */&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;(e)</span> =&gt;</span> &#123;setName(e.target.value)&#125;&#125;/&gt;</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;setDark(dark =&gt; !dark)&#125;&#125;</span><br><span class="xml">        style=&#123;BtnStyle()&#125;</span><br><span class="xml">      &gt;Toggle Theme<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-02-at-10.04.01-AM.6po73dr6gz00.gif" alt="问题如图"></p>
<p>我点击<code>Toggle Theme</code>。按道理来说，不应该打印 user。但因为 user 是对象。前后两次渲染生成的 user 的地址不一样所以会导致 useEffect 的重新执行。</p>
<p>解决办法 <code>useMemo</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [name, setName] = useState(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <span class="hljs-keyword">const</span> [dark, setDark] = useState(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">const</span> age = <span class="hljs-number">24</span>;<br><br>  <span class="hljs-comment">// 只有age 或者 name 变化的时候，才会有新的user生成。</span><br>  <span class="hljs-comment">// 不然，重复的渲染也不会有新的user生成</span><br>  <span class="hljs-keyword">const</span> user = useMemo(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;age, name&#125;<br>  &#125;, [age, name])<br><br>  <span class="hljs-keyword">const</span> BtnStyle = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">padding</span>: <span class="hljs-string">&#x27;2px&#x27;</span>,<br>      <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;dark ? <span class="hljs-string">&#x27;black&#x27;</span> : <span class="hljs-string">&#x27;white&#x27;</span>&#125;</span>`</span>,<br>      <span class="hljs-attr">color</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;dark ? <span class="hljs-string">&#x27;white&#x27;</span> :  <span class="hljs-string">&#x27;black&#x27;</span> &#125;</span>`</span><br>    &#125;<br>  &#125;<br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;user&#x27;</span>, user);<br>  &#125;, [user])   <span class="hljs-comment">// 当然，依赖项改为user的内部属性即[name, age]也可以，但是不够灵活</span><br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      &#123;/* input 标签和onChange事件是绝配哦！ */&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;(e)</span> =&gt;</span> &#123;setName(e.target.value)&#125;&#125;/&gt;</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;setDark(dark =&gt; !dark)&#125;&#125;</span><br><span class="xml">        style=&#123;BtnStyle()&#125;</span><br><span class="xml">      &gt;Toggle Theme<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-02-at-10.12.54-AM.3hitoqy72fo0.gif" alt="解决问题后的效果图"></p>
]]></content>
      <categories>
        <category>React篇</category>
      </categories>
      <tags>
        <tag>高级</tag>
      </tags>
  </entry>
  <entry>
    <title>tailwindcss-注意项</title>
    <url>/2021/10/23/tailwindcss-%E6%B3%A8%E6%84%8F%E9%A1%B9/</url>
    <content><![CDATA[<blockquote>
<p>当前版本：<code>v2.2.15</code></p>
</blockquote>
<p>我 TM 发现，当前版本似乎是不支持<code>rotate3d</code>的。<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/3B9771F637F41E091B4FCE198208DFD9.76wwwpk22l40.png" alt="不支持y轴旋转"></p>
<p>不知道有什么解决办法没…???</p>
<p>有解决办法：自己去自定义功能</p>
<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-23-at-9.53.54-AM.5u636vtv5gk0.png" alt="自定义功能"></p>
<hr>
<blockquote>
<p>tailwindcss 新特性：<code>JIT</code></p>
</blockquote>
<p>按需加载~也是在性能层次上的升级…<br><a href="https://tailwindcss.com/docs/just-in-time-mode">文档</a></p>
<h4 id="tailwindcss-和-antd-结合在-react-项目中使用"><a href="#tailwindcss-和-antd-结合在-react-项目中使用" class="headerlink" title="tailwindcss 和 antd 结合在 react 项目中使用"></a>tailwindcss 和 antd 结合在 react 项目中使用</h4><p>注意：tailwindcss 和 antd 是能够良好的适配的。只不过最好 tailwindcss 开启 <code>!important</code><br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-26-at-8.23.00-PM.65an1pz1gzg0.png" alt="tailwindcss-antd"></p>
]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>高级</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇文章掌握性能优化大法之防抖和节流</title>
    <url>/2021/10/13/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%8E%8C%E6%8F%A1%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%A4%A7%E6%B3%95%E4%B9%8B%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<p>相信一提到前端性能优化，大家脑子里就会一下映射出许多内容。例如：懒加载、CDN 缓存、DOM 优化、图片优化、Webpack 的优化配置…但今天我想谈论的一个性能优化点是<strong>防抖</strong>和<strong>节流</strong>函数，因为它俩够“小巧”，但发挥的作用却不容小觑！</p>
<p>在实际写项目的时候，我们会发现，一些事件总是会被频繁触发。例如鼠标事件、键盘事件、scroll 事件…</p>
<p>举个小例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">let</span> input = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;[name=&quot;username&quot;]&#x27;</span>)</span><br><span class="javascript">  input.addEventListener(<span class="hljs-string">&#x27;keyup&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.value)</span><br><span class="javascript">  &#125;)</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e1b22b590194ef58b3cf9ce2853aaa0~tplv-k3u1fbpfcp-watermark.image" alt="debounce1.gif"></p>
<p>由上述非常简短的代码及效果图，我们就可以发现，频繁的触发回调是真的要命 😭😭😭,它不仅会造成大量的计算引发页面卡顿还会造成频繁的网络请求导致不必要的流量浪费以及极低的用户体验…为了规避这类情况，我们急需控制回调的触发频率，让回调函数被触发的次数恰到好处！因此，防抖函数和节流函数闪亮登场 ✨</p>
<hr>
<h3 id="防抖函数-debounce"><a href="#防抖函数-debounce" class="headerlink" title="防抖函数(debounce)"></a>防抖函数(debounce)</h3><h4 id="防抖函数核心逻辑"><a href="#防抖函数核心逻辑" class="headerlink" title="防抖函数核心逻辑"></a>防抖函数核心逻辑</h4><p>人为设定一段<strong>延迟时间</strong>，用于延迟执行<strong>回调函数 A</strong>。如果在延迟时间内，用户反复触发这个<strong>回调函数 A</strong>，则只会重复刷新延迟时间，而频繁被触发的<strong>回调函数 A</strong>中，<strong>仅最后一次触发的回调函数 A 是能被执行的</strong>。</p>
<h4 id="写防抖函数的五大要素"><a href="#写防抖函数的五大要素" class="headerlink" title="写防抖函数的五大要素"></a>写防抖函数的五大要素</h4><p>好了，上文已经讲解了防抖函数的核心逻辑，现在大家来熟悉一下写防抖函数的五大要素，从而方便理解下文真正的防抖函数 💪🏻</p>
<ul>
<li><ol>
<li>需要使用闭包</li>
</ol>
</li>
<li><ol start="2">
<li>需要 setTimeout、clearTimeout 的灵活运用</li>
</ol>
</li>
<li><ol start="3">
<li>防抖函数的第一个参数为需要被触发的回调函数</li>
</ol>
</li>
<li><ol start="4">
<li>防抖函数会返回一个函数</li>
</ol>
</li>
<li><ol start="5">
<li>回调函数的 this 指向需要和防抖函数返回的这个函数 this 指向保持一致</li>
</ol>
</li>
</ul>
<h4 id="手写防抖函数"><a href="#手写防抖函数" class="headerlink" title="手写防抖函数"></a>手写防抖函数</h4><p>请大家在看代码的同时注意我的注释！！！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// fnA 是要被触发的回调函数   delay是延迟时间</span><br><span class="hljs-keyword">let</span> debounce = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fnA, delay</span>) </span>&#123;<br>    <span class="hljs-comment">// timer是定时器，如果在延迟时间内频繁触发回调函数A，则会重复刷新延迟时间timer</span><br>    <span class="hljs-comment">// 注意：这里会运用到闭包！！(请不了解闭包基础知识的朋友先去看一下闭包基础知识后再继续看这篇博客)</span><br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">// 防抖函数会返回一个函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-comment">// 锁定当前this的指向，方便控制fnA的this指向和这个返回函数的this指向保持一致</span><br>        <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">this</span>;<br>        <span class="hljs-comment">// 保留调用防抖函数时传入的参数</span><br>        <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">arguments</span>;<br><br>        <span class="hljs-comment">// 如果在延迟时间内频繁触发回调函数A，则重复刷新延迟时间timer</span><br>        <span class="hljs-keyword">if</span> (timer) &#123;<br>            <span class="hljs-built_in">clearTimeout</span>(timer);<br>        &#125;<br>        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-comment">// 将fn的this指向和防抖函数返回的这个函数的this指向保持一致</span><br>            fnA.call(context, ...arguments)<br>        &#125;, delay)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>好啦，手写代码完成。接下来，我们试一试防抖函数</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">let</span> input = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;[name=&quot;username&quot;]&#x27;</span>)</span><br><span class="javascript">  <span class="hljs-comment">// 注意：addEventListener的this总是当前正在处理事件的那个DOM对象</span></span><br><span class="javascript">  input.addEventListener(<span class="hljs-string">&#x27;keyup&#x27;</span>, debounce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.value)</span><br><span class="javascript">  &#125;, <span class="hljs-number">2000</span>))</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71fab3e4f6044064b640a1fa5964349d~tplv-k3u1fbpfcp-watermark.image" alt="debounce2.gif"></p>
<p>快速输入 12345677 后，需再等待 2s 才会执行真正的回调函数。这就是防抖函数发挥的真正作用！消除了过多而不必要的回调函数。</p>
<p><strong>附赠一个化简版的<code>debounce</code></strong></p>
<p>这个版本的<code>debounce</code>使用了箭头函数，原理和上面的<code>debounce</code>是一样的。(关于此题的箭头函数使用，也许本篇博客的<strong>彩蛋 2</strong>能给你一个提示)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> debounce = <span class="hljs-function">(<span class="hljs-params">fn, delay</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...<span class="hljs-built_in">arguments</span></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;arguments&#x27;</span>, <span class="hljs-built_in">arguments</span>)<br>    <span class="hljs-keyword">if</span> (timer) &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timer);<br>    &#125;<br>    <span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;测试&#x27;</span><br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      fn.call(<span class="hljs-built_in">this</span>, ...arguments)<br>    &#125;, delay)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="节流函数-throttle"><a href="#节流函数-throttle" class="headerlink" title="节流函数(throttle)"></a>节流函数(throttle)</h3><h4 id="节流函数的核心逻辑"><a href="#节流函数的核心逻辑" class="headerlink" title="节流函数的核心逻辑"></a>节流函数的核心逻辑</h4><p>人为设定一段间隔时间，<strong>当第一次触发回调函数 A 时，回调函数 A 被立即执行并且开始计时</strong>。在这段间隔时间内，无论用户触发多少次<strong>回调函数 A</strong>，都不会被执行。</p>
<h4 id="写节流函数的五大要素"><a href="#写节流函数的五大要素" class="headerlink" title="写节流函数的五大要素"></a>写节流函数的五大要素</h4><p>事实上，节流的五大要素和防抖非常相似(只有第二点有区别)，所以当看懂防抖函数的代码后，在手写节流代码时就显得比较轻松了！</p>
<ul>
<li><ol>
<li>需要使用闭包</li>
</ol>
</li>
<li><ol start="2">
<li>结合时间戳来判断时间间隔</li>
</ol>
</li>
<li><ol start="3">
<li>节流函数的第一个参数为需要被触发的回调函数</li>
</ol>
</li>
<li><ol start="4">
<li>节流函数会返回一个函数</li>
</ol>
</li>
<li><ol start="5">
<li>回调函数的 this 指向需要和节流函数返回的这个函数 this 指向保持一致</li>
</ol>
</li>
</ul>
<h4 id="手写节流函数"><a href="#手写节流函数" class="headerlink" title="手写节流函数"></a>手写节流函数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"> <span class="hljs-comment">// fnA 表示回调函数A， interval表示间隔时间</span><br> <span class="hljs-keyword">let</span> throttle = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fnA, interval</span>) </span>&#123;<br>  <span class="hljs-comment">// last 运用闭包知识</span><br>  <span class="hljs-comment">// last 为上一次触发回调的时间, 初始化为0 方便第一次触发事件就能运行回调函数</span><br>  <span class="hljs-keyword">let</span> last = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 返回一个函数</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 记录当前的时间戳</span><br>    <span class="hljs-keyword">let</span> now = <span class="hljs-built_in">Date</span>.now();<br>    <span class="hljs-comment">// 保留调用节流函数时传入的参数</span><br>    <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">arguments</span>;<br>    <span class="hljs-comment">// 回调函数的this指向需要和节流函数返回的这个函数this指向保持一致</span><br>    <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-comment">// 通过时间差来判断再一次触发的回调函数是否还在这段时间间隔内</span><br>    <span class="hljs-keyword">if</span> (now - last &gt;= interval) &#123;<br>      last = now;<br>      fnA.call(context, ...args)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>代码效果：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd4d3d0f930b4882b09c4a52ff1d071c~tplv-k3u1fbpfcp-watermark.image" alt="throttle1.gif"></p>
<p>事实上，防抖和节流函数的相似度是非常高的, 相信大家在理解完我手写防抖和节流函数时所提及的 5 大要素以及我的代码注释后，能够对防抖和节流函数感到更加亲切！剩下的就是靠你自己手写一下代码，让代码真正变成你自己拥有的。</p>
<p>本篇文章可能会有作者笔误或理解错误的地方，请大家多多指出！ 如果这篇文章对你有帮助的话，还请给这篇文章点一个赞吧 💕</p>
<hr>
<p>下面的三个彩蛋实则是我在写这篇博客时突然想到的三个关于 this 和作用域比较有意思的点，如果大家有兴趣，不妨看一看！</p>
<h5 id="彩蛋-1"><a href="#彩蛋-1" class="headerlink" title="彩蛋 1"></a>彩蛋 1</h5><p>在上述防抖函数中，我使用到了 setTimeout。而事实上对于<code>setTimeout</code>的<code>this</code>指向，其实也是有一些学问在里面的。<br>给大家送福利！在下述三种情况，this 会 100%指向 window</p>
<ul>
<li>立即执行函数(IIFE)</li>
<li>setTimeout 中传入的函数(非箭头函数)</li>
<li>setInterval 中传入的函数(非箭头函数)</li>
</ul>
<h5 id="彩蛋-2"><a href="#彩蛋-2" class="headerlink" title="彩蛋 2"></a>彩蛋 2</h5><p>对于 setTimeout 的箭头函数的思考</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;帅得乱七八糟&#x27;</span><br><br><span class="hljs-keyword">var</span> me = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;帅得歪瓜裂枣&#x27;</span>,<br>  <span class="hljs-attr">hello1</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 箭头函数中的 this，和你如何调用它无关，由你书写它的位置决定</span><br>  <span class="hljs-comment">// 这里的this的作用域是hello1函数作用域。所以，谁调用hello1，这里的this就指向谁</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-comment">// 指向me</span><br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`你好，我是<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>`</span>)<br>    &#125;)<br>  &#125;,<br>  <span class="hljs-attr">hello2</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;   <span class="hljs-comment">// 指向window(彩蛋1里有提到)</span><br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`你好，我是<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>`</span>)<br>    &#125;)<br>  &#125;<br>&#125;<br><br>me.hello1();   <span class="hljs-comment">// 你好，我是帅得歪瓜裂枣</span><br>me.hello2();   <span class="hljs-comment">// 你好，我是帅得乱七八糟</span><br><br></code></pre></td></tr></table></figure>

<h5 id="彩蛋-3"><a href="#彩蛋-3" class="headerlink" title="彩蛋 3"></a>彩蛋 3</h5><p>关于回调函数的参数问题</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">let func = <span class="hljs-function"><span class="hljs-params">(fn)</span> =&gt;</span> &#123;<br>    fn();<br>&#125;<br>let callback = <span class="hljs-function"><span class="hljs-params">(param)</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(param)<br>&#125;<br>let fn = function() &#123;<br>    let param = <span class="hljs-number">123</span>;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(param);   <span class="hljs-regexp">//</span> <span class="hljs-number">1</span>s后打印： <span class="hljs-number">123</span><br>    &#125;, <span class="hljs-number">1000</span>)<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">(param)</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(param);   <span class="hljs-regexp">//</span> <span class="hljs-number">1</span>s后打印： <span class="hljs-literal">undefined</span><br>    &#125;, <span class="hljs-number">3000</span>)<br><br>    func(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> callback(param))      <span class="hljs-regexp">//</span> <span class="hljs-number">123</span><br>    func(<span class="hljs-function"><span class="hljs-params">(param)</span> =&gt;</span> callback(param)) <span class="hljs-regexp">//</span> <span class="hljs-literal">undefined</span><br>&#125;<br>fn();<br></code></pre></td></tr></table></figure>

<p>为何我给回调的参数加上<code>param</code>，则打印变为<code>undefined</code>？ 这其实是函数作用域在作怪！如果在回调的参数上加<code>param</code>，则该回调内的所有<code>param</code>(包括回调的参数<code>param</code>)都是属于该回调函数的作用域内。而很明显，回调里的<code>param</code>没有赋上任何值，所以是<code>undefined</code>。如果参数没有 param，则回调内的<code>param</code>就会向上一层作用域内寻找<code>param</code>，恰好 fn 里有定义<code>param</code> 且值为 123。</p>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>高级</tag>
      </tags>
  </entry>
  <entry>
    <title>全栈之路</title>
    <url>/2021/10/27/%E5%85%A8%E6%A0%88%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<h4 id="url"><a href="#url" class="headerlink" title="url"></a>url</h4><blockquote>
<p><a href="http://example.com/path?query=value">http://example.com/path?query=value</a></p>
</blockquote>
<blockquote>
<p>http:// Protocol</p>
</blockquote>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">HTTP: Non-<span class="hljs-keyword">Encrypted</span><br>HTTPS: <span class="hljs-keyword">Encrypted</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>example.com</p>
</blockquote>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">Host</span><br>(每个服务器都有它独特的host)<br>例如： <span class="hljs-selector-tag">youtube</span><span class="hljs-selector-class">.com</span> (一个服务器)   <span class="hljs-selector-tag">netflix</span><span class="hljs-selector-class">.com</span>(也是一个服务器)<br></code></pre></td></tr></table></figure>

<blockquote>
<p>path</p>
</blockquote>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli">不同页面：<br><span class="hljs-string">/users</span><br><span class="hljs-string">/cats</span><br><span class="hljs-string">/dogs</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>Query String</p>
</blockquote>
<p>让服务器有不同的响应内容</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Key</span>      <span class="hljs-built_in">Value</span><br><span class="hljs-variable">query</span>    <span class="hljs-variable">value</span><br><span class="hljs-variable">search</span>   <span class="hljs-variable">dogs</span><br></code></pre></td></tr></table></figure>

<p>但是 url 仅仅只有 Query String 服务器是不知道要干什么的…所以需要 GET、POST 等操作来让服务器知道是对指定内容进行增删改查…</p>
<h4 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">GET</span>] http:<span class="hljs-comment">//example.com/users</span><br>  * Gets a list of the resource<br>  * Acts <span class="hljs-keyword">on</span> the entire resource<br>[<span class="hljs-meta">POST</span>]http:<span class="hljs-comment">//example.com/users</span><br>  * Used to create a <span class="hljs-keyword">new</span> resource<br>  * Acts <span class="hljs-keyword">on</span> the entire resource<br>[<span class="hljs-meta">GET</span>]http:<span class="hljs-comment">//example.com/users/1</span><br>  * Gets the resource <span class="hljs-keyword">with</span> the given ID<br>  * Acts <span class="hljs-keyword">on</span> a single resource<br>[<span class="hljs-meta">PUT</span>]http:<span class="hljs-comment">//example.com/users/1</span><br>  * Updates the resource <span class="hljs-keyword">with</span> the given ID<br>  * Acts <span class="hljs-keyword">on</span> a single resource<br>[<span class="hljs-meta">DELETE</span>]http:<span class="hljs-comment">//example.com/users/1</span><br>  * Deletes the resource <span class="hljs-keyword">with</span> the given ID<br>  * Acts <span class="hljs-keyword">on</span> a single resource<br></code></pre></td></tr></table></figure>

<h4 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h4><p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-27-at-7.37.30-PM.71e45fs02ns0.png" alt="mvc"><br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-27-at-7.39.29-PM.6a1a0q3s0lg0.png" alt="mvc本质流程"></p>
<h4 id="Node-js-—-Express-—-MogonDB"><a href="#Node-js-—-Express-—-MogonDB" class="headerlink" title="Node.js — Express — MogonDB"></a>Node.js — Express — MogonDB</h4><p>指令</p>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">npm</span> <span class="hljs-selector-tag">init</span> <span class="hljs-selector-tag">-y</span><br><span class="hljs-selector-tag">npm</span> <span class="hljs-selector-tag">i</span> <span class="hljs-selector-tag">express</span> <span class="hljs-selector-tag">ejs</span> <span class="hljs-selector-tag">express-ejs-layouts</span><br><span class="hljs-comment">// nodemon将监视启动目录中的文件，如果有任何文件更改，nodemon将自动重新启动node应用程序</span><br><span class="hljs-selector-tag">npm</span> <span class="hljs-selector-tag">i</span> <span class="hljs-selector-tag">--save-dev</span> <span class="hljs-selector-tag">nodemon</span><br><span class="hljs-selector-tag">npm</span> <span class="hljs-selector-tag">i</span> <span class="hljs-selector-tag">mongoose</span><br><span class="hljs-selector-tag">npm</span> <span class="hljs-selector-tag">i</span> <span class="hljs-selector-tag">--save-dev</span> <span class="hljs-selector-tag">dotenv</span>    <span class="hljs-comment">// 允许我们使用env变量...例如 process.env(自己要创建一个.env文件)</span><br></code></pre></td></tr></table></figure>

<p><strong>思考：为什么总会在项目中使用 npm init 来初始化项目呢？</strong><br>在 node 开发中使用 npm init 会生成一个 pakeage.json 文件，这个文件主要是用来记录这个项目的详细信息的，它会将我们在项目开发中所要用到的包，以及项目的详细信息等记录在这个项目中。方便在以后的版本迭代和项目移植的时候会更加的方便。也是防止在后期的项目维护中误删除了一个包导致的项目不能够正常运行。使用 npm init 初始化项目还有一个好处就是在进行项目传递的时候不需要将项目依赖包一起发送给对方，对方在接受到你的项目之后再执行 npm install 就可以将项目依赖全部下载到项目里。话不多说我们就直接开始进行操作。</p>
<p><strong>ejs</strong><br><a href="https://zhuanlan.zhihu.com/p/52722144">使用 EJS 模板引擎</a></p>
<p><strong>MogonDB</strong></p>
<blockquote>
<p>下载地址： <a href="https://www.mongodb.com/try/download/community">https://www.mongodb.com/try/download/community</a><br>安装方式： <a href="https://www.runoob.com/mongodb/mongodb-osx-install.html">https://www.runoob.com/mongodb/mongodb-osx-install.html</a></p>
</blockquote>
<p><strong>HeroKu</strong><br>让代码部署到网络上…</p>
]]></content>
      <categories>
        <category>全栈篇</category>
      </categories>
      <tags>
        <tag>全栈</tag>
      </tags>
  </entry>
  <entry>
    <title>前端技术-随笔</title>
    <url>/2021/10/21/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF-%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<h4 id="不要写较长的函数-写短小精悍的函数才是硬道理…"><a href="#不要写较长的函数-写短小精悍的函数才是硬道理…" class="headerlink" title="不要写较长的函数 写短小精悍的函数才是硬道理…"></a>不要写较长的函数 写短小精悍的函数才是硬道理…</h4><h4 id="性能优化与可读性和可维护性比较"><a href="#性能优化与可读性和可维护性比较" class="headerlink" title="性能优化与可读性和可维护性比较"></a>性能优化与可读性和可维护性比较</h4><p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-21-at-2.22.22-PM.35sbd0m61g00.png" alt="一个40年程序员如是说"></p>
<h4 id="codepen-中-html-标签的自动补全功能是要按-tab-键"><a href="#codepen-中-html-标签的自动补全功能是要按-tab-键" class="headerlink" title="codepen 中 html 标签的自动补全功能是要按 tab 键"></a>codepen 中 html 标签的自动补全功能是要按 tab 键</h4>]]></content>
      <categories>
        <category>程序员素养篇</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>各种第三方库和有用的网站</title>
    <url>/2021/10/26/%E5%90%84%E7%A7%8D%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/</url>
    <content><![CDATA[<ul>
<li><p>创建各种随机的 id: <a href="https://www.npmjs.com/package/uuid">uuid</a></p>
</li>
<li><p>临时 email(temporary email): <a href="https://temp-mail.org/en?__cf_chl_captcha_tk__=pmd_3sqozgesOjiYQawAofglAq5i.BE_BIbQ82jvwb2nUWE-1635683915-0-gqNtZGzNAyWjcnBszQdR">temp-mail</a><br>(方便测试邮箱登录、修改密码等功能)</p>
</li>
<li><p>免费实现用户认证 firebase：<a href="https://console.firebase.google.com/">firebase</a></p>
</li>
<li><p>在 react 中使用方便的 icon：<a href="https://fontawesome.com/v5.15/how-to-use/on-the-web/using-with/react">fontawesome</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>使用的工具篇</category>
      </categories>
      <tags>
        <tag>奇淫技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>开发个人博客反思和总结</title>
    <url>/2021/10/09/%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%8F%8D%E6%80%9D%E5%92%8C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="开发过程"><a href="#开发过程" class="headerlink" title="开发过程"></a>开发过程</h4><ol>
<li>购买域名 Namecheap —&gt; 算了，最后还是去的阿里云买的…国外的 支付方式有点困难<br>.com 和 .net 有什么区别呢？</li>
</ol>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-title">.com （商业机构）；</span><br><span class="hljs-title">.net （从事互联网服务的机构）；</span><br></code></pre></td></tr></table></figure>

<p>买的域名对于所在区域有什么影响没？</p>
<ol start="2">
<li>设定 DNS 将域名停泊到 Cloudflare，因为它有免费的 SSL 以及全球 CND 加速等服务(采用免费方案)，然后设定 DNS， 加入两个 A 记录<br>(<a href="https://zhuanlan.zhihu.com/p/86961133">https://zhuanlan.zhihu.com/p/86961133</a>)</li>
</ol>
<h2 id="cloudflare-的优势是什么-cnd-是什么东东？"><a href="#cloudflare-的优势是什么-cnd-是什么东东？" class="headerlink" title="cloudflare 的优势是什么 cnd 是什么东东？"></a>cloudflare 的优势是什么 cnd 是什么东东？</h2><p><a href="https://cloud.tencent.com/developer/article/1137135">cloudflare 相关知识</a><br>SEO –&gt;<br>建站需要什么东西</p>
<ol>
<li>域名</li>
<li>空间(主机) —&gt; 存储网站的地方</li>
<li>程序(目前已经有开源程序了)</li>
</ol>
<p><strong>域名</strong>:heyang.xyz (域名是租的…) 具有唯一性<br>注意：<br>不要购买中文域名(如果有 seo)<br>买常用的后缀<br>容易记忆的</p>
<p><strong>什么是网站空间？</strong><br>服务器(专业电脑，更强大) —&gt; 目前干脆就用自己的电脑当一个服务器算了…(不行，电脑要一直开机才行…但事实上不可能一直开机)<br>空间(服务器里的文件夹)<br>上述的这个文件夹可以和域名链接在一起(所以访问网站，其实就是通过域名打开服务器里的文件夹)</p>
<p>空间所以我们采用租的方式…</p>
<p><strong>建站程序</strong><br>事实上大多数都是用的建站程序来写的…<br>WordPress<br>织梦</p>
<hr>
<p>HEXO<br>安装 nodejs –&gt; nodejs 让 js 成为了与 php、py、perl、ruby 等服务端你语言平起平坐的脚本语言</p>
<blockquote>
<p>hexo 安装：npm intall hexo-cli -g</p>
</blockquote>
<p>利用 github 的仓库作为 hexo 的服务器来搭建个人网站</p>
<p>个人博客的话，用 hexo 完全不需要去另外购买空间，可以托管到个 ithub、coding 等托管平台，免费提供的空间完全足够了，毕竟一篇文章顶天不过十几 kb</p>
<hr>
<p><a href="https://pages.github.com/">https://pages.github.com</a></p>
<p>采用 github page + hexo</p>
<p><a href="https://hexo.io/">hexo 网站</a><br><a href="https://hexo.io/plugins/">hexo 插件</a></p>
<p>.github.io 是一个二级域名… 二级域名有什么不同之处吗？</p>
<p><a href="https://hexo.io/themes/">hexo 主题</a></p>
<p>我喜欢的主题：<a href="https://github.com/blleng/hexo-theme-lx">hexo-theme-lx</a><br><a href="https://github.com/zhaoo/hexo-theme-zhaoo">推荐 hexo 主题</a></p>
<p><a href="https://github.com/fluid-dev/hexo-theme-fluid">最牛逼最适合我的 hexo 主题</a><br>fluid 这个主题文档相当的详尽不错！</p>
<blockquote>
<p>hexo 清理缓存，重新部署:<br>hexo clean &amp;&amp; hexo g -d<br>—&gt; 当我使用了这个命令后，我所更新的东西就会自动放在<a href="https://bruce-shuai.github.io/%E9%87%8C%E4%BA%86%E3%80%82%E8%80%8C%E4%B8%8D%E6%98%AF%E7%94%A8git">https://bruce-shuai.github.io/里了。而不是用git</a> add . git commit -m …这些操作…</p>
</blockquote>
<h4 id="为博客绑定自己的域名…"><a href="#为博客绑定自己的域名…" class="headerlink" title="为博客绑定自己的域名…"></a>为博客绑定自己的域名…</h4><p>资料<br><a href="https://cloud.tencent.com/developer/article/1435908">dns 解析</a></p>
<p><a href="https://www.bilibili.com/video/BV1rb411n79N?from=search&seid=2760737936132922743&spm_id_from=333.337.0.0">该域名的教程</a></p>
<hr>
<p><a href="https://blog.justlovesmile.top/">看这位大佬的 hexo 笔记能学到很多</a><br><a href="http://blog.itchenliang.club/posts/22350780-f32d-11ea-bb4a-d3e1cbe3d59d/">魔改 hexo</a><br><a href="https://pxxyyz.com/categories/">fluid 大佬博客</a><br><a href="https://i.vince.pub/p/fluid-doc-pr/#%E4%B8%80%E8%A8%80">fluid 又一个大佬博客</a><br><a href="https://papiboy.gitee.io/2021/03/25/hexo%E7%BE%8E%E5%8C%96%E9%A1%B5%E9%9D%A2/">再一位 fluid 大佬</a><br><a href="https://www.itrhx.com/2018/08/27/A04-Hexo-blog-topic-personalization/">再来一篇 fluid 美化的博客</a><br><a href="https://blog.jalenchuh.cn/posts/hexo-fluid/">这位大佬的 fluid 的美化教程很不错</a><br><a href="https://emoryhuang.cn/blog/1729600336.html">再一位大佬</a><br><a href="https://blog.justlovesmile.top/posts/c8972b63.html">hexo 的使用</a></p>
<p><a href="https://segmentfault.com/a/1190000012805627">更换 hexo 主题</a></p>
<p><a href="https://waline.js.org/guide/get-started.html#leancloud-%E8%AE%BE%E7%BD%AE-%E6%95%B0%E6%8D%AE%E5%BA%93">hexo 评论区 Waline 插件</a></p>
<p><a href="https://www.pexels.com/zh-cn/">免费图片网站</a><br><a href="https://undraw.co/search">免费 svg 图片网站</a></p>
<hr>
<p><strong>博客性能优化：</strong></p>
<hr>
<p><strong>cdn</strong><br>GitHub+jsDelivr+PicGo 搭建免费图床<br>相关博客：<br><a href="https://blog.justlovesmile.top/posts/c8972b63.html">https://blog.justlovesmile.top/posts/c8972b63.html</a><br><a href="https://segmentfault.com/a/1190000020240864">https://segmentfault.com/a/1190000020240864</a></p>
<p><strong>–&gt; 无需下载软件的方法：<a href="picx.xpoet.cn">PicX</a></strong><br>用 cdn 外链的好处是什么？</p>
<hr>
<h2 id="Artitalk"><a href="#Artitalk" class="headerlink" title="Artitalk"></a><strong>Artitalk</strong></h2><p>发布说说<br>官网：<a href="https://artitalk.js.org/">https://artitalk.js.org/</a></p>
<hr>
<p>SEO</p>
<hr>
<p>留言板</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><code class="hljs llvm">一言： https://developer.hitokoto.cn/sentence/#<span class="hljs-variable">%E6</span><span class="hljs-variable">%8</span>E<span class="hljs-variable">%A5</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%8</span>F<span class="hljs-variable">%A3</span><span class="hljs-variable">%E8</span><span class="hljs-variable">%AF</span><span class="hljs-variable">%B4</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%98</span><span class="hljs-variable">%8</span>E  // 这个网站的api有点骚~<br></code></pre></td></tr></table></figure>

<hr>
<p>loading 动画：<br><a href="https://www.zyoushuo.cn/post/69e.html">1</a></p>
<hr>
<p>更改的内容效果先在 hexo server –debug 上观看(一般来说有大的改动，需重启 hexo server –debug)<br>如果感觉更改的不错(依次输入下面三个语句 上传到 heyang.xyz 里)：<br>hexo generate<br>hexo deploy<br>hexo clean</p>
<hr>
<h4 id="性能检测："><a href="#性能检测：" class="headerlink" title="性能检测："></a>性能检测：</h4><p>不多赘述，这篇文章讲得非常好！<a href="https://juejin.cn/book/6844733750048210957/section/6844733750123692046">修言-Performance、LightHouse 与性能 API</a></p>
<p>解决国内 github+hexo 打开页面慢的方法：<br>由于国内访问 github 的速度较慢，因此可以通过双部署同时部署到 Coding<a href="https://coding.net/">https://coding.net/</a><br><a href="https://zhuanlan.zhihu.com/p/100926319">一篇不错的文章</a><br>更多 Coading 绑定部署操作需要进一步看</p>
]]></content>
      <categories>
        <category>IT随笔</category>
      </categories>
      <tags>
        <tag>互联网</tag>
      </tags>
  </entry>
  <entry>
    <title>开始我的个人博客之旅啦</title>
    <url>/2021/10/07/%E5%BC%80%E5%A7%8B%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85%E5%95%A6/</url>
    <content><![CDATA[<p>这篇博客只是用来测试一下网站 哈哈哈<br>祝福看见这篇博客的你 永远快乐哦!</p>
<head>
  ..
  <script src="//cdn.jsdelivr.net/npm/@waline/client"></script>
  ...
</head>
<body>
  ...
  <div id="waline"></div>
  <script>
    Waline({
      el: '#waline',
      serverURL: 'https://blog-api-9sizcti78-bruce-shuai.vercel.app/',
    });
  </script>
</body>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>有效括号问题</title>
    <url>/2021/10/07/%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">/**<br> * 题目描述：给定一个只包括<span class="hljs-string">&#x27;(&#x27;</span>, <span class="hljs-string">&#x27;)&#x27;</span>, <span class="hljs-string">&#x27;&#123;&#x27;</span>, <span class="hljs-string">&#x27;&#125;&#x27;</span>, <span class="hljs-string">&#x27;[&#x27;</span>, <span class="hljs-string">&#x27;]&#x27;</span>的字符串,判断字符串是否有效<br> * <br> * 记住一个规律： 括号成立 意味着 对称性<br> */<br><br><span class="hljs-regexp">//</span> 括号问题，我们一般首选栈来做    ----&gt;   对称性<br><br><span class="hljs-regexp">//</span> 用一个map来维护左括号和右括号的对应关系<br><span class="hljs-regexp">//</span> map 关系真的非常的好用<br><span class="hljs-regexp">//</span> const leftToRight = &#123;<br><span class="hljs-regexp">//</span>   <span class="hljs-string">&quot;(&quot;</span>:<span class="hljs-string">&quot;)&quot;</span>,<br><span class="hljs-regexp">//</span>   <span class="hljs-string">&quot;&#123;&quot;</span>:<span class="hljs-string">&quot;&#125;&quot;</span>,<br><span class="hljs-regexp">//</span>   <span class="hljs-string">&quot;[&quot;</span>:<span class="hljs-string">&quot;]&quot;</span><br><span class="hljs-regexp">//</span> &#125;<br><br><span class="hljs-regexp">//</span> /**<br><span class="hljs-regexp">//</span>  * @param &#123;string&#125; s<br><span class="hljs-regexp">//</span>  * @return &#123;boolean&#125;<br><span class="hljs-regexp">//</span>  */<br><br><span class="hljs-regexp">//</span> <span class="hljs-regexp">//</span> 有些细节 我<br><span class="hljs-regexp">//</span> const isValid = <span class="hljs-keyword">function</span>(s) &#123;<br><span class="hljs-regexp">//</span>   <span class="hljs-regexp">//</span> 结合题意，空字符串无条件判断为 true<br><span class="hljs-regexp">//</span>   <span class="hljs-keyword">if</span> (!s) &#123;<br><span class="hljs-regexp">//</span>     return true;<br><span class="hljs-regexp">//</span>   &#125;<br><span class="hljs-regexp">//</span>   <span class="hljs-regexp">//</span> 初始化 stack 数组<br><span class="hljs-regexp">//</span>   const stack = [];<br><span class="hljs-regexp">//</span>   <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;<br><span class="hljs-regexp">//</span>     <span class="hljs-keyword">if</span> (s[i] === <span class="hljs-string">&#x27;(&#x27;</span> || s[i] === <span class="hljs-string">&#x27;&#123;&#x27;</span> || s[i] === <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br><span class="hljs-regexp">//</span>       stack.push(leftToRight[s[i]])<br><span class="hljs-regexp">//</span>     &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-regexp">//</span>       <span class="hljs-regexp">//</span> 但是人家写的是!stack.length || stack.pop() !== ch  好奇怪...<br><span class="hljs-regexp">//</span>       <span class="hljs-keyword">if</span> (stack.pop() !== s[i]) &#123;<br><span class="hljs-regexp">//</span>         return false;<br><span class="hljs-regexp">//</span>       &#125;<br><span class="hljs-regexp">//</span>     &#125;<br><span class="hljs-regexp">//</span>   &#125;<br><span class="hljs-regexp">//</span>   <span class="hljs-regexp">//</span> 若所有的括号都能配对成功，那么最后栈应该是空的<br><span class="hljs-regexp">//</span>   <span class="hljs-regexp">//</span> return !stack.length;<br><br><span class="hljs-regexp">//</span>   return true;<br><span class="hljs-regexp">//</span> &#125;<br><br><br><br><span class="hljs-regexp">//</span> 注意： ))))(((( 这种是错误的。左括号必须以正确的顺序闭合<br><br><span class="hljs-regexp">//</span> 对象映射大法 ----&gt;  注意！变量名千万搞错不能出错, 有时要好好检查检查自己的变量名...<br>const leftToRight = &#123;<br>  <span class="hljs-string">&quot;&#123;&quot;</span>:<span class="hljs-string">&quot;&#125;&quot;</span>,<br>  <span class="hljs-string">&quot;(&quot;</span>:<span class="hljs-string">&quot;)&quot;</span>,<br>  <span class="hljs-string">&quot;[&quot;</span>:<span class="hljs-string">&quot;]&quot;</span><br>&#125;<br><br><br><span class="hljs-regexp">//</span> 我自己想到一个方法。设置两个栈。一个栈放入左侧符号的映射。  一个栈放入右侧符号。 两个栈进行一一对比<br>const isValid = (str) =&gt; &#123;<br>  const stack = [];<br>  <span class="hljs-regexp">//</span> 数组缓存<br>  let len = str.length;<br><br>  <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>    <span class="hljs-keyword">if</span> (str[i] === <span class="hljs-string">&#x27;&#123;&#x27;</span> || str[i] === <span class="hljs-string">&#x27;[&#x27;</span> || str[i] === <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>      stack.push(leftToRight[str[i]]);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stack.length !== <span class="hljs-number">0</span> &amp;&amp; str[i] === stack[stack.length - <span class="hljs-number">1</span>]) &#123;<br>      stack.pop();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stack.length === <span class="hljs-number">0</span>) &#123;<br>      return false;<br>    &#125;<br>  &#125;<br>  return stack.length === <span class="hljs-number">0</span>;<br>&#125;<br><br>console.log(<span class="hljs-string">&#x27;test&#x27;</span>, isValid(<span class="hljs-string">&#x27;()[]&#123;&#125;&#x27;</span>));<br></code></pre></td></tr></table></figure>

<head>
  ..
  <script src="//cdn.jsdelivr.net/npm/@waline/client"></script>
  ...
</head>
<body>
  ...
  <div id="waline"></div>
  <script>
    Waline({
      el: '#waline',
       avatar: 'monsterid',
      serverURL: 'https://blog-api-9sizcti78-bruce-shuai.vercel.app/',
    });
  </script>
</body>]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>栈类相关问题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>浅拷贝和深拷贝</title>
    <url>/2021/10/08/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<blockquote>
<p>前置知识：值赋值和引用赋值就不再赘述了, 相对而言挺基础的…</p>
</blockquote>
<p>我已知的能够在<code>js</code>里实现<code>拷贝</code>的 3 种现成方法 🧐</p>
<h4 id="3-种现成的实现拷贝的方法"><a href="#3-种现成的实现拷贝的方法" class="headerlink" title="3 种现成的实现拷贝的方法"></a>3 种现成的实现拷贝的方法</h4><h5 id="1-JSON-大法"><a href="#1-JSON-大法" class="headerlink" title="1. JSON 大法"></a>1. JSON 大法</h5><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> json大法<br>/**<br> * 优点：最简单的实现深拷贝的方式<br> * 缺点：<br> * 支持的数据类型：String<span class="hljs-regexp">/Number/</span>Boolean<span class="hljs-regexp">/Object/</span>Array/null<br> * 不支持的类型： undefined<span class="hljs-regexp">/Symbol/</span>循环引用<span class="hljs-regexp">/函数/</span>Date/RegExp<br> */<br><br> const obj1 = &#123;a: <span class="hljs-number">100</span>, b: &#123;key: <span class="hljs-string">&#x27;123&#x27;</span>&#125;&#125;<br> const obj2 = JSON.parse(JSON.stringify(obj1))<br>console.log(obj1 === obj2) <span class="hljs-regexp">//</span> false<br> 个人评价：事实上，<span class="hljs-number">90</span>%的情况下，上述方法已经够用了，一般不支持的类型这种用得少...<br></code></pre></td></tr></table></figure>

<h5 id="2-Object-assign-–-gt-浅拷贝"><a href="#2-Object-assign-–-gt-浅拷贝" class="headerlink" title="2.Object.assign() –&gt; 浅拷贝"></a>2.Object.assign() –&gt; 浅拷贝</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj3 = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-attr">sorce</span>: [<span class="hljs-number">88</span>, <span class="hljs-number">100</span>]&#125;<br><span class="hljs-keyword">var</span> obj4 = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, obj3)  <span class="hljs-comment">// obj1 与 &#123;&#125; 合并， 内部的引用还是一样的</span><br><span class="hljs-built_in">console</span>.log(obj3 === obj4) <span class="hljs-comment">// false</span><br><br>个人评价： 用法方便简单，但是注意是浅拷贝，在做一些项目的时候，需要有清晰的脑袋知道自己是在做深拷贝还是浅拷贝<br></code></pre></td></tr></table></figure>

<h5 id="3-Lodash-库"><a href="#3-Lodash-库" class="headerlink" title="3.Lodash 库"></a>3.Lodash 库</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// _.clone     浅拷贝</span><br><span class="hljs-comment">// _.deepclone 深拷贝</span><br><span class="hljs-keyword">var</span> obj5 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-attr">sorce</span>: [<span class="hljs-number">88</span>, <span class="hljs-number">100</span>]&#125;<br><span class="hljs-keyword">var</span> obj6 = _.cloneDeep(obj5);<br><span class="hljs-built_in">console</span>.log(obj5 === obj6)<br><br>个人评价： 不用说，牛逼！<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="深拷贝实现"><a href="#深拷贝实现" class="headerlink" title="深拷贝实现"></a>深拷贝实现</h4><h5 id="本套深拷贝实现方法前置知识"><a href="#本套深拷贝实现方法前置知识" class="headerlink" title="本套深拷贝实现方法前置知识"></a>本套深拷贝实现方法前置知识</h5><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> obj1 为一个普通对象<br>let obj1 = &#123;<br> name: <span class="hljs-string">&#x27;张三&#x27;</span>,<br> sex: <span class="hljs-string">&#x27;男&#x27;</span>,<br> age: <span class="hljs-number">18</span>,<br> friends: [<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-string">&#x27;小玉&#x27;</span>, <span class="hljs-string">&#x27;小萌&#x27;</span>]<br>&#125;<br><br><span class="hljs-regexp">//</span> 创建一个空对象 obj2<br>let obj2 = &#123;&#125;<br><span class="hljs-regexp">//</span> 依次将obj1对象里的属性赋值到obj2里(注意，要判断obj1里的属性是普通类型(值类型)还是引用类型)<br><span class="hljs-regexp">//</span> 值类型 直接复制。如果是引用类型还需要再深层进入引用类型中找到人家的值类型(递归大法)<br>obj2.name = obj1.name   <span class="hljs-regexp">//</span> 是否为普通类型<br>obj2.sex = obj1.sex     <span class="hljs-regexp">//</span> 是否为普通类型<br>obj2.age = obj1.age     <span class="hljs-regexp">//</span> 是否为普通类型<br>obj2.friends = obj1friends <span class="hljs-regexp">//</span> 遍历循环obj1friends。返回新的friends<br><br></code></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">/**<br> * 数据类型<br> *<br> * typeof <span class="hljs-number">1</span>      <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;number&quot;</span><br> * typeof <span class="hljs-string">&quot;a&quot;</span>    <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;string&quot;</span><br> * typeof true   <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;boolean&quot;</span><br> * typeof &#123;&#125;     <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;object&quot;</span><br> * typeof []     <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;object&quot;</span><br> * typeof null   <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;object&quot;</span>   &lt;---  这里容易产生误会<br> * typeof undefined      <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;undefined&quot;</span><br> * typeof <span class="hljs-keyword">function</span>()&#123;&#125;   <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;function&quot;</span><br> * typeof Symbol()       <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;symbol&quot;</span><br> *<br> *<br> * Object.prototype.toString.call(<span class="hljs-number">1</span>)         <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;[object Number]&#x27;</span><br> * Object.prototype.toString.call(<span class="hljs-string">&#x27;a&#x27;</span>)       <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;[object String]&#x27;</span><br> * Object.prototype.toString.call(true)      <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;[object Boolean]&#x27;</span><br> * Object.prototype.toString.call(&#123;&#125;)        <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;[object Object]&#x27;</span><br> * Object.prototype.toString.call([])        <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;[object Array]&#x27;</span><br> * Object.prototype.toString.call(null)      <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;[object Null]&#x27;</span><br> * Object.prototype.toString.call(<span class="hljs-regexp">/a/</span>)       <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;[object RegExp]&#x27;</span><br> * Object.prototype.toString.call(undefined) <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;[object Undefined]&#x27;</span><br> * Object.prototype.toString.call(<span class="hljs-keyword">function</span>()&#123;&#125;)  <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;[object Function]&#x27;</span><br> * Object.prototype.toString.call(new Date())    <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;[object Date]&#x27;</span><br> */<br></code></pre></td></tr></table></figure>

<h5 id="开始实现深拷贝"><a href="#开始实现深拷贝" class="headerlink" title="开始实现深拷贝"></a>开始实现深拷贝</h5><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> deepClone = <span class="hljs-function">(<span class="hljs-params">src</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">type</span> = <span class="hljs-built_in">Object</span>.prototype.toString.call(src).slice(<span class="hljs-number">8</span>, -<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">let</span> dist = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;Number&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> src;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;String&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> src;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;Boolean&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> src;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;Object&#x27;</span>) &#123;<br>    dist = &#123;&#125;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;Array&#x27;</span>) &#123;<br>    dist = []<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;Function&#x27;</span>) &#123;<br>    <span class="hljs-comment">// ... 这个挺有困惑的</span><br>    dist = src.bind(<span class="hljs-built_in">this</span>);   <span class="hljs-comment">// 生成了一个新的函数，this指向的是什么</span><br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> src) &#123;<br>    dist[key] = deepClone(src[key]);<br>  &#125;<br>  <span class="hljs-keyword">return</span> dist;<br>&#125;<br><br><span class="hljs-keyword">let</span> obj1 = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;100&#x27;</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-string">&#x27;200&#x27;</span>,<br>  <span class="hljs-attr">c</span>: &#123;<span class="hljs-attr">d</span>: <span class="hljs-string">&#x27;300&#x27;</span>, <span class="hljs-attr">e</span>: &#123;<span class="hljs-attr">f</span>: <span class="hljs-string">&#x27;500&#x27;</span>&#125;&#125;,<br>  <span class="hljs-attr">fn</span>: <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;this is a function&#x27;</span>)&#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> obj2 = deepClone(obj1);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;obj1 === obj2 ?&#x27;</span>, obj1 === obj2);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;obj2&#x27;</span>, obj2);<br><br></code></pre></td></tr></table></figure>

<head>
  ..
  <script src="//cdn.jsdelivr.net/npm/@waline/client"></script>
  ...
</head>
<body>
  ...
  <div id="waline"></div>
  <script>
    Waline({
      el: '#waline',
       avatar: 'monsterid',
      serverURL: 'https://blog-api-9sizcti78-bruce-shuai.vercel.app/',
    });
  </script>
</body>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理</title>
    <url>/2021/10/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h3><p>人的语言(自然语言) —&gt; 是上下文有关的<br>机器的语言 —&gt; 不会考虑上下文的…</p>
<p><strong>计算机语言</strong>还能提供给人类新的思考方式<br>例如： 面向对象思维、函数式思维…</p>
<h4 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h4><p>源程序 —&gt; 编译器 —&gt; 目标程序<br><code>编译器</code> 将 <code>源程序</code> 编译成 <code>目标程序</code></p>
<h4 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h4><figure class="highlight brainfuck"><table><tr><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">源程序</span> --&gt;<br>         <span class="hljs-comment">|</span> --&gt; <span class="hljs-comment">解释器</span> --&gt; <span class="hljs-comment">输出</span><br>  <span class="hljs-comment">输入</span> --&gt;<br></code></pre></td></tr></table></figure>

<p><code>解释器</code><strong>同时</strong>接受源程序 和 输入，立即执行并返回输出<br>早期 js 是解释型语言的</p>
<h4 id="混合编译器"><a href="#混合编译器" class="headerlink" title="混合编译器"></a>混合编译器</h4><figure class="highlight brainfuck"><table><tr><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">源程序</span> --&gt; <span class="hljs-comment">第一次编译</span> --&gt; <span class="hljs-comment">中间代码</span> --&gt; <span class="hljs-comment">第二次编译</span> --&gt;<br>                                              <span class="hljs-comment">|</span>--&gt; <span class="hljs-comment">虚拟机</span>--&gt; <span class="hljs-comment">输出</span><br>                                         <span class="hljs-comment">输入</span>--&gt;<br></code></pre></td></tr></table></figure>

<p><strong>中间代码的作用</strong></p>
<ul>
<li>中间代码更容易被翻译成目标程序、优化空间更大</li>
<li>中间语言的存在更利于编译器的实现</li>
<li>让虚拟机处理复杂的执行环境(跨平台)</li>
</ul>
<h4 id="即时编译器-JIT"><a href="#即时编译器-JIT" class="headerlink" title="即时编译器(JIT)"></a>即时编译器(JIT)</h4><ul>
<li>一种提高效率的方法，中间代码不是直接执行，而是先被编译成机器码再执行</li>
</ul>
<p>—&gt; 现代 java、nodejs 就是这样编译方式<br>优点：提高执行效率(50%以上)</p>
<h4 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h4><p>在一个平台编译产生多个平台的可执行代码</p>
<hr>
<p><strong>不同方式优劣势</strong></p>
<ul>
<li>解释执行有性能问题，但也异常灵活，例如支持 eval 函数(基本上解释型语言都可以支持 eval 函数，意味着程序可以动态修改…)</li>
<li>直接交叉编译 技术难度是其次的，跨平台问题会多；一次编译很多包也会有分发问题 — 产品问题</li>
<li>虚拟化技术提供了更好的体验，却没有提供更好的性能(JIT 完美解决这一点 &lt;—&gt; 时间平摊技术)</li>
</ul>
<h4 id="编译的流程-关注度分离"><a href="#编译的流程-关注度分离" class="headerlink" title="编译的流程(关注度分离)"></a>编译的流程(关注度分离)</h4><p>编译器的第一步： 词法分析(一个分词断句+判断词性的过程)<br>编译器的第二步： 语法分析(把词法分析形成的结果转化为一颗抽象语法树(AST)) 语法分析器常常被称作 Parser<br>编译器的第三步： 语义分析<br>编译器的第四步： 生成机器码(二进制)</p>
<blockquote>
<p>机器不懂高级语言<br>机器像[卡片机]一样, 不断读取下一条指令并执行<br>这种简单的设计就是今天的复杂的计算机…</p>
</blockquote>
<p>关注度分离思考<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-25-at-9.12.53-PM.65obrf4b2qc0.png" alt="编译器处理的两大过程"><br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-25-at-9.14.21-PM.3h54z1grvus0.png" alt="编译器分层设计"></p>
<p><strong>分层设计(最常见的软件架构)<strong>：关注度分离–&gt;每层都有意义，每一层都足够强大，都有</strong>优质的算法数据结构、架构技巧来解决大量共性问题</strong>(架构师做到这一点就牛逼，做不到就不行…)</p>
<h4 id="词法分析器简介"><a href="#词法分析器简介" class="headerlink" title="词法分析器简介"></a>词法分析器简介</h4><h5 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h5><ul>
<li>将字符流转成符号流 输入：源代码(字符流) 输出：符号流</li>
<li>词法分析过程类似中学语文学习的<strong>词性标注</strong>。每个符号是一个元组，应该至少包括一个字符串和词性描述<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-01-at-1.52.33-PM.52htvhvktog0.png" alt="词法分析"></li>
</ul>
<h6 id="符号-词法单元"><a href="#符号-词法单元" class="headerlink" title="符号(词法单元)"></a>符号(词法单元)</h6><ul>
<li>词法分析器的结果是一个个的符号，英文 Token，也叫<strong>词法单元</strong></li>
<li>在数学上符号表示一个元组。例如整数 123 表示 (123, Integer)</li>
</ul>
<p>实现词法分析器的基本接口</p>
<ul>
<li>实现符号类型枚举</li>
<li>实现关键词字典</li>
<li>定义词法分析器的程序接口</li>
</ul>
<h6 id="流-Stream-是什么？"><a href="#流-Stream-是什么？" class="headerlink" title="流(Stream)是什么？"></a>流(Stream)是什么？</h6><p>流：随着<strong>时间推移</strong>逐渐产生的<strong>可用数据序列</strong></p>
<blockquote>
<p>流的使用者永远不知道流里的数据有多少。流中的数据是通过时间来产生的…</p>
</blockquote>
<p>抽象出像工厂流水线一样的处理数据的标准过程</p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2021/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/30573146">对称加密和非对称加密</a></p>
<p><a href="liaoxuefeng.com/wiki/1252599548343744/1304227729113121">摘要</a><br><a href="https://www.bilibili.com/video/BV1w4411m7GL?from=search&seid=18369141538307426732&spm_id_from=333.337.0.0">https vs http</a></p>
<p><a href="https://juejin.cn/post/7002781373014474759#comment">CDN</a></p>
<p><strong>以太网、局域网二者关系</strong><br><code>以太网</code>只是组成互联网的一个子集，<code>以太网</code>是现在主流的<code>局域网标准</code>，而互联网是指将大量的局域网连接起来，进行资源的分享。</p>
<p><a href="https://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">阮一峰 互联网协议</a></p>
<p>每一层都是为了完成一种功能。为了实现这些功能，就需要大家都<code>遵守共同的规则</code>。大家都遵守的规则，就叫做<code>&quot;协议&quot;</code>（protocol）</p>
<p><code>IP协议</code>的作用主要有两个，一个是为每一台计算机<code>分配IP地址</code>，另一个是确定哪些地址在<code>同一个子网络</code></p>
<p><strong>“端口”是 0 到 65535 之间的一个整数</strong>，正好 16 个二进制位。<strong>0 到 1023 的端口被系统占用，用户只能选用大于 1023 的端口</strong>。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系</p>
<p><a href="https://www.youtube.com/watch?v=HGetnD4ISrw&list=PLgJ_1RCsjcSmUw-DoTfD8kVJGqxz7MjNd&index=70">教程</a></p>
<p>注意： 计算机网络 不仅仅是软件概念，还包含了硬件设备并且计算机网络不仅仅是信息通信，还可以支持广泛的应用</p>
<h5 id="计算机网络的分类："><a href="#计算机网络的分类：" class="headerlink" title="计算机网络的分类："></a>计算机网络的分类：</h5><p><strong>按网络的作用范围分类</strong>：广域网(WAN)、城域网(MAN)、局域网(LAN)</p>
<p>广域网：范围：几十到几千公里 区域：跨省、跨国<br>城域网：范围：5KM-50KM 区域：城市间<br>局域网：范围：1KM 以内(有点小啊)区域：地区内</p>
<p><strong>按网络的使用者分类</strong>：公用网络、专用网络(军方、公司、银行)</p>
<h5 id="互联网的发展历史"><a href="#互联网的发展历史" class="headerlink" title="互联网的发展历史"></a>互联网的发展历史</h5><ul>
<li><p>第一个阶段： 单个网络 ARPANET —&gt; 计算机利用<strong>交换机</strong>来完成信息的交互(计算机数量是非常少的)</p>
</li>
<li><p>第二个阶段： 三层结构的互联网 —&gt;</p>
</li>
</ul>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><code class="hljs gherkin">        主干网<br>          |<span class="hljs-string"></span><br><span class="hljs-string">    主干网----主干网</span><br><span class="hljs-string">      </span>|<span class="hljs-string">        </span>|<br>  +-------+   ...<br>地区网   地区网<br>  |<span class="hljs-string">       </span>|<br>校园网   校园网<br></code></pre></td></tr></table></figure>

<p>全国(美国)的学校政府公司这些网连在一起的</p>
<ul>
<li>第三个阶段： 多层次 ISP 互联网<br>ISP(Internet Service Provider): 网络服务提供商 —&gt; 例如：中国电信、中国移动、中国联通</li>
</ul>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli">            主干ISP     <span class="hljs-string">//</span> 跨国操作<span class="hljs-string">...</span><br>              |<br>       主干ISP<span class="hljs-params">----</span>主干ISP<br>         |        |<br>     +<span class="hljs-params">-------</span>+   <span class="hljs-string">...</span><br>   地区ISP  地区ISP<br>     |<br>  +<span class="hljs-params">------</span>+<br>公司     校园<br></code></pre></td></tr></table></figure>

<p>主干 ISP: 例如 中国移动<br>地区 ISP: 例如 四川移动</p>
<h5 id="中国互联网的发展简史"><a href="#中国互联网的发展简史" class="headerlink" title="中国互联网的发展简史"></a>中国互联网的发展简史</h5><figure class="highlight brainfuck"><table><tr><td class="code"><pre><code class="hljs brainfuck">  <span class="hljs-comment">1980年开始</span>    <span class="hljs-comment">1989年第一个</span>        <span class="hljs-comment">1994接入</span><br>  <span class="hljs-comment">互联网实验</span>     <span class="hljs-comment">公共网络建立运行</span>    <span class="hljs-comment">国际互联网</span><br>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span>&gt; --<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span>&gt; --<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span>&gt;<br></code></pre></td></tr></table></figure>

<p>5 个中国最大的计算机公用网络</p>
<ol>
<li>中国电信互联网</li>
<li>中国联通互联网</li>
<li>中国移动互联网</li>
<li>中国教育与科研计算机网</li>
<li>中国科学技术网</li>
</ol>
<h5 id="计算机网络的层次结构"><a href="#计算机网络的层次结构" class="headerlink" title="计算机网络的层次结构"></a>计算机网络的层次结构</h5><p>首先先考虑一个问题</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">计算机<span class="hljs-selector-tag">A</span> 和 计算机<span class="hljs-selector-tag">B</span>如何进行通信？<br><br>我们需要考虑一些问题：<br> 例如：如何保证数据通路顺畅？<br>      如何识别目的计算机？<br>      当前目的计算机状态是怎样的？<br>      计算机传递的数据是否是错误的？<br>...可见，计算机通信要考虑的问题是繁多而复杂的。为了解决这些问题。我们采用分层来实现不同的功能<br></code></pre></td></tr></table></figure>

<p>分层要考虑的东西：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">顶层：  网络应用数据  <span class="hljs-comment">---&gt;  视频、文件、游戏</span><br>下一层：数据可靠通信  <span class="hljs-comment">---&gt;  数据错误、重复</span><br>下一层：物理网络接入  <span class="hljs-comment">---&gt;  光电等物理特性</span><br></code></pre></td></tr></table></figure>

<h5 id="层次结构设计的基本原则-这些设计思想是值得学习的…"><a href="#层次结构设计的基本原则-这些设计思想是值得学习的…" class="headerlink" title="层次结构设计的基本原则(这些设计思想是值得学习的…)"></a>层次结构设计的基本原则(这些设计思想是值得学习的…)</h5><ul>
<li>各层之间是相互独立的(某一层是不需要知道下一层的原理或实现是怎么样的…层与层之间的耦合度是非常低的…)</li>
<li>每一层要有足够的灵活性，以方便应对未来的变化</li>
<li>各层之间完全解耦(上一层的变化是不影响下一层的…)</li>
</ul>
<h5 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h5><figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">应用层  <span class="hljs-comment">----&gt;  为计算机用户提供接口和服务</span><br>表示层  <span class="hljs-comment">----&gt;  数据处理(编码解码、加密解密等)</span><br>会话层  <span class="hljs-comment">----&gt;  管理(建立、维护、重连)通信会话</span><br>传输层  <span class="hljs-comment">----&gt;  管理端到端的通信连接</span><br>网络层  <span class="hljs-comment">----&gt;  数据路由(决定数据在网络的路径)</span><br>数据链路层 <span class="hljs-comment">--&gt;  管理相邻节点之间的数据通信</span><br>物理层  <span class="hljs-comment">----&gt;  数据通信的光电物理特性</span><br></code></pre></td></tr></table></figure>

<ul>
<li>OSI 本来想要成为全球计算机都遵循的标准</li>
<li>OSI 在市场化过程中困难重重，TCP/IP 在全球范围成功运行</li>
<li>OSI 最终并没有成为广为使用的标准模型<ul>
<li>原因如下：</li>
</ul>
<ol>
<li>OSI 的专家缺乏实际操作经验…</li>
<li>OSI 标准制定周期过长，按 OSI 标准生产的设备无法及时进入市场</li>
<li>OSI 模型设计的并不合理，一些功能在多层中重复出现</li>
</ol>
</li>
</ul>
<h5 id="TCP-IP-四层模型"><a href="#TCP-IP-四层模型" class="headerlink" title="TCP/IP 四层模型"></a>TCP/IP 四层模型</h5><ul>
<li>应用层 (包含了 OSI 的 应用层、表示层、会话层) —&gt; 一些协议：HTTP/FTP</li>
<li>传输层 —&gt; 一些协议：TCP/UDP</li>
<li>网络层 —&gt; 一些协议：IP/ICMP</li>
<li>网络接口层 (包含了 物理层、数据链路层) –&gt; 一些协议：Ethernet/ARP/RARP</li>
</ul>
<p>通信过程</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">计算机A</span>                         <span class="hljs-comment">计算机B</span><br> <span class="hljs-comment">应用层</span>                          <span class="hljs-comment">应用层</span><br> <span class="hljs-comment">传输层</span>      --<span class="hljs-literal">-</span>&gt; <span class="hljs-comment">路由器</span> --<span class="hljs-literal">-</span>&gt;     <span class="hljs-comment">传输层</span><br> <span class="hljs-comment">网络层</span>           <span class="hljs-comment">网络层</span>          <span class="hljs-comment">网络层</span><br> <span class="hljs-comment">网络接口层</span>        <span class="hljs-comment">网络接口层</span>      <span class="hljs-comment">网络接口层</span><br></code></pre></td></tr></table></figure>

<h5 id="现代互联网的网络拓扑"><a href="#现代互联网的网络拓扑" class="headerlink" title="现代互联网的网络拓扑"></a>现代互联网的网络拓扑</h5><ul>
<li><p>边缘部分(用户可以直接接触的部分)<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/%E8%BE%B9%E7%BC%98%E9%83%A8%E5%88%86-%E5%AE%B6%E5%BA%AD.qb1jknhbm8w.png" alt="边缘部分"><br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/%E8%BE%B9%E7%BC%98%E9%83%A8%E5%88%86-%E4%BC%81%E4%B8%9A.2zlos9ma7bo0.png" alt="边缘部分"><br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91.5g08pnr99c80.png" alt="网络拓扑"><br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-11-at-6.58.37-PM.38vof6hxygc0.png" alt="核心部分"></p>
<p>海底电缆相互连接…???</p>
<p>客户-服务器(C/S)模式<br>对等连接(P2P)模式 (下载速度更快…)</p>
</li>
<li><p>核心部分</p>
</li>
</ul>
<h5 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h5><p>速率单位：bps = bit/s<br>为什么电信拉的 100M 光纤，测试峰值速度只有 12M 每秒?</p>
<p>网络常用单位(Mbps)<br>100M/s = 100Mbps = 100Mbit/s<br>100Mbit/s = (100 / 8)MB/s = 12.5MB/s</p>
<h6 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h6><ul>
<li>发送时延</li>
<li>传播时延</li>
<li>排队时延</li>
<li>处理时延</li>
</ul>
<p>总时延 = 发送时延 + 传播时延 + 排队时延 + 处理时延</p>
<h6 id="往返时间-RTT"><a href="#往返时间-RTT" class="headerlink" title="往返时间 RTT"></a>往返时间 RTT</h6><p>RTT 是评估网络质量的一项重要指标<br>RTT 表示的是数据报文在端到端通信中的来回一次的时间<br>通常使用 ping 命令来查看 RTT<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/ping.3ede6r5ghy00.png" alt="ping"></p>
<h4 id="物理层概述"><a href="#物理层概述" class="headerlink" title="物理层概述"></a>物理层概述</h4><h5 id="物理层的作用"><a href="#物理层的作用" class="headerlink" title="物理层的作用"></a>物理层的作用</h5><ul>
<li>连接不同的物理设备(跨国 isp –&gt; 通过海底电缆进行连接…)</li>
<li>传输比特流</li>
</ul>
<p>连接不同物理设备的介质：双绞线、同轴电缆、光纤、红外线、无线(电磁波)、激光</p>
<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/%E6%AF%94%E7%89%B9%E6%B5%81.bzz72eiwus0.png" alt="比特流"></p>
<h5 id="信道的基本概念"><a href="#信道的基本概念" class="headerlink" title="信道的基本概念"></a>信道的基本概念</h5><ul>
<li>信道是往一个方向发送信息的媒体</li>
<li>一条通信电路包含一个接收信道和一个发送信道(即两条信道)</li>
</ul>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">          发送信道<br>设备A  &lt;-----------&gt;  设备B<br>          接收信道<br></code></pre></td></tr></table></figure>

<ul>
<li>单工通信信道<ul>
<li>只能一个方向通信，没有反方向反馈的信道</li>
<li>有线电视、无线电收音机(只能接收，不能发送)等</li>
</ul>
</li>
<li>半双工通信信道<ul>
<li>双方都可以发送和接收信息</li>
<li>不能双方同时发送，也不能同时接收</li>
</ul>
</li>
<li>全双工通信信道<ul>
<li>双方都可以同时发送和接收信息</li>
</ul>
</li>
</ul>
<h5 id="分用-复用技术"><a href="#分用-复用技术" class="headerlink" title="分用-复用技术"></a>分用-复用技术</h5><figure class="highlight brainfuck"><table><tr><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">设备1</span> --<span class="hljs-literal">+</span>                            <span class="hljs-literal">+</span>-- <span class="hljs-comment">设备4</span><br><span class="hljs-comment">设备2</span> --<span class="hljs-comment">|</span>--<span class="hljs-literal">-</span> <span class="hljs-comment">复用</span> --<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span> <span class="hljs-comment">分用</span> --<span class="hljs-literal">-</span><span class="hljs-comment">|</span>-- <span class="hljs-comment">设备5</span><br><span class="hljs-comment">设备3</span> --<span class="hljs-literal">+</span>                            <span class="hljs-literal">+</span>-- <span class="hljs-comment">设备6</span><br><br></code></pre></td></tr></table></figure>

<h5 id="数据链路层概述"><a href="#数据链路层概述" class="headerlink" title="数据链路层概述"></a>数据链路层概述</h5><ul>
<li><p>封装成帧</p>
<ul>
<li>“帧”是数据链路层数据的基本单位</li>
<li>发送端在网络层的一段数据前后添加特定标记形成“帧”</li>
<li>接收端根据前后特定标记识别出“帧”</li>
<li>(物理层不会管你“帧”不“帧”，物理层只管比特流的传输。这里也说明了层与层之间是相互独立，完全解耦的)<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-14-at-10.24.26-AM.zvv3inrxkz4.png" alt="封装成帧"></li>
</ul>
</li>
<li><p>透明传输</p>
<ul>
<li>“透明”在计算机领域是非常重要的一个术语</li>
<li>一种实际存在的事物却又看起来不存在一样</li>
<li>即是控制字符在帧数据中，但是要当作不存在的去处理<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-14-at-10.29.06-AM.3o19ml6y9tq0.png" alt="没有透明传输会出现的问题"><br>ESC 是转义字符<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-14-at-10.30.58-AM.2j99msq02ea0.png" alt="透明传输"><ul>
<li>这个转义字符和编程语言中的”&quot;功能是非常相似的</li>
</ul>
</li>
</ul>
</li>
<li><p>差错监测</p>
<ul>
<li><p>物理层只管传输比特流，无法控制是否出错</p>
</li>
<li><p>数据链路层负责起“差错检测”的工作</p>
</li>
<li><p>奇偶校验码<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-14-at-10.40.05-AM.3yco91z14js0.png" alt="奇偶校验码"></p>
<p>&lt;—奇偶校验码的局限性—&gt;<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-14-at-10.42.35-AM.493mxsqda8y0.png" alt="奇偶校验码的局限性"></p>
</li>
<li><p>循环冗余校验码 CRC<br>–&gt; 更成熟的差错监测</p>
<ul>
<li>一种根据传输或保存的数据而<strong>产生固定位数校验码</strong>的方法</li>
<li><strong>检测</strong>数据传输或者保存后可能出现的错误</li>
<li>生成的数字计算出来并且<strong>附加到数据后面</strong></li>
<li>模“2”除法<ul>
<li>模“2”除法是二进制下的除法</li>
<li>与算术除法类似，但除法不错位，实际是“异或”操作<ul>
<li>异或操作</li>
<li>0 xor 0 = 0</li>
<li>0 xor 1 = 1</li>
<li>1 xor 0 = 1</li>
<li>1 xor 1 = 0</li>
<li><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-14-at-10.51.48-AM.622jua94k8g0.png" alt="模“2”除法"></li>
</ul>
</li>
</ul>
</li>
<li>具体操作<ul>
<li>选定一个用于校验的多项式 G(x), 并在数据尾部添加 r 个 0</li>
<li>将添加 r 个 0 后的数据，使用模“2”除法除以多项式的位串</li>
<li>得到的余数填充在原数据 r 个 0 的位置得到可校验的位串<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-14-at-11.10.46-AM.7avoq98rzp80.png" alt="循环冗余校验码CRC-1"><br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-14-at-11.13.26-AM.39suzj8cu7w0.png" alt="循环冗余校验码CRC-2"><br>101001000 =&gt; 101001<strong>001</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="最大传输单元-MTU"><a href="#最大传输单元-MTU" class="headerlink" title="最大传输单元 MTU"></a>最大传输单元 MTU</h4><ul>
<li>MTU –&gt; 最大传输单元<ul>
<li>数据链路层的数据帧也不是无限大的(数据帧长度受 MTU 限制)</li>
<li>数据帧过长或过小都会影响传输的效率 (以太网 MTU 一般为 1500 字节)</li>
</ul>
</li>
<li>路径 MTU<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-28-at-10.26.13-AM.dw0l58n12nk.png" alt="路径MTU"></li>
</ul>
<h4 id="以太网协议讲解"><a href="#以太网协议讲解" class="headerlink" title="以太网协议讲解"></a>以太网协议讲解</h4><figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">                   |---&gt;设备C<br>设备A -----&gt;路由器-&gt;|<br>                   |---&gt;设备B<br>路由器怎么知道A要发给谁？<br></code></pre></td></tr></table></figure>

<ul>
<li><p>MAC 地址</p>
<ul>
<li>MAC 地址(物理地址、硬件地址)</li>
<li>每一个设备都拥有唯一的 MAC 地址(如何查看 MAC 地址呢？) -</li>
<li><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-28-at-10.40.03-AM.26rz5cnw8uow.png" alt="MAC"></li>
<li>MAC 地址共<code>48位</code>,使用十六进制表示</li>
<li>```<br>我的MAC地址：14:7d:da:a5:20:c8 –&gt; 4(16进制-&gt;4位) * 2 * 6(总共6组，每组2个)<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span> 以太网协议<br><span class="hljs-bullet">  -</span> 以太网是一种使用广泛的<span class="hljs-strong">**局域网**</span>技术<br><span class="hljs-bullet">  -</span> 以太网是一种应用于<span class="hljs-strong">**数据链路层**</span>的协议<br><span class="hljs-bullet">  -</span> 使用以太网可以完成相邻设备的<span class="hljs-strong">**数据帧**</span>传输<br><br></code></pre></td></tr></table></figure>
<pre><code>        以太网协议
</code></pre>
目的地址     源地址     类型     帧数据      CRC(校验码)<br>6(MAC地址)  6        2       45~1500      4<br>6表示6个字节       类型表示帧数据<br>1个字节8位       是什么类型的帧数据<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><br>MAC 地址表(是一个映射表)<br>![MAC地址表](https:<span class="hljs-regexp">//</span>cdn.jsdelivr.net<span class="hljs-regexp">/gh/</span>Bruce-shuai<span class="hljs-regexp">/picBed@master/</span>Screen-Shot-<span class="hljs-number">2021</span>-<span class="hljs-number">10</span>-<span class="hljs-number">28</span>-at-<span class="hljs-number">10.55</span>.<span class="hljs-number">11</span>-AM.<span class="hljs-number">3</span>bhpm4ldhac0.png)<br><br>MAC 地址表实质是路由器所拥有的!<br>![路由器实现原理](https:<span class="hljs-regexp">//</span>cdn.jsdelivr.net<span class="hljs-regexp">/gh/</span>Bruce-shuai<span class="hljs-regexp">/picBed@master/</span>Screen-Shot-<span class="hljs-number">2021</span>-<span class="hljs-number">10</span>-<span class="hljs-number">28</span>-at-<span class="hljs-number">11.00</span>.<span class="hljs-number">19</span>-AM.<span class="hljs-number">1</span>y9ghg39ruzk.png)<br><br>![路由器没找到MAC地址](https:<span class="hljs-regexp">//</span>cdn.jsdelivr.net<span class="hljs-regexp">/gh/</span>Bruce-shuai<span class="hljs-regexp">/picBed@master/</span>Screen-Shot-<span class="hljs-number">2021</span>-<span class="hljs-number">10</span>-<span class="hljs-number">28</span>-at-<span class="hljs-number">11.03</span>.<span class="hljs-number">21</span>-AM.<span class="hljs-number">64</span>kg5mwnjw80.png)<br><br>![路由器跨设备传输数据](https:<span class="hljs-regexp">//</span>cdn.jsdelivr.net<span class="hljs-regexp">/gh/</span>Bruce-shuai<span class="hljs-regexp">/picBed@master/</span>Screen-Shot-<span class="hljs-number">2021</span>-<span class="hljs-number">10</span>-<span class="hljs-number">28</span>-at-<span class="hljs-number">11.15</span>.<span class="hljs-number">44</span>-AM.<span class="hljs-number">5</span>x0sbfvsnow0.png)<br>--&gt; 需要学习网络层的内容才能解决跨设备传输数据问题<br><br><span class="hljs-comment">#### 网络层</span><br><br>注意：网络层是路由器最顶层的协议了...<br><br>&gt; 网络层 ---&gt; 数据路由(决定数据在网络的路径)<br><br>**数据链路层**只能解决相邻物理结点传输(比如：相邻的路由器与电脑)<br><br>**网络层**是可以解决大结点之间的数据传递的<br><br>路由器可以分为**家庭路由器**和**企业路由器**<br><br></code></pre></td></tr></table></figure>
网络层IP协议相关 –&gt;  IP协议  子网划分 简单路由过程<br> |<br>网络层其他协议   –&gt;  ARP协议与RARP协议 ICMP协议<br> |<br>IP的路由算法  –&gt;  路由的概述  内部网关路由协议   外部网关路由协议</li>
</ul>
</li>
</ul>
<pre><code>
#### IP 协议讲解

- 虚拟互连网络
  - 实际的计算机网络是错综复杂的
  - 物理设备通过使用 IP 协议，屏蔽了物理网络之间的差异
  - 当网络中的主机使用 IP 协议连接时，则无需关注网络细节
- IP 协议
</code></pre>
]]></content>
      <categories>
        <category>计算机网络篇</category>
      </categories>
  </entry>
  <entry>
    <title>项目中的小技巧</title>
    <url>/2021/10/31/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h4 id="amp-amp-的使用"><a href="#amp-amp-的使用" class="headerlink" title="&amp;&amp;的使用"></a>&amp;&amp;的使用</h4><p>先看用法</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 如果&amp;&amp;左右两边都有效则返回的是&amp;&amp;右边的内容<br>true &amp;&amp; <span class="hljs-number">123</span>   <span class="hljs-regexp">//</span> <span class="hljs-number">123</span><br><br>false &amp;&amp; <span class="hljs-number">123</span>  <span class="hljs-regexp">//</span> false<br><br><span class="hljs-number">123</span> &amp;&amp; <span class="hljs-number">456</span>    <span class="hljs-regexp">//</span> <span class="hljs-number">456</span><br></code></pre></td></tr></table></figure>

<p>更多知识有待扩充…</p>
<h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 常见情况：</span><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">number</span> = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> result;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">number</span> &gt;= <span class="hljs-number">50</span>) &#123;<br>  result = <span class="hljs-string">&#x27;Not to fifty!&#x27;</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  result = <span class="hljs-string">&#x27;It could be worse&#x27;</span><br>&#125;<br><br><span class="hljs-built_in">console</span>.log(result);  <span class="hljs-comment">// It could be worse</span><br></code></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 用三元运算符</span><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">number</span> = <span class="hljs-number">5</span>;<br><span class="hljs-comment">// 完美的浓缩着代码....</span><br><span class="hljs-keyword">const</span> result = <span class="hljs-built_in">number</span> &gt;= <span class="hljs-number">50</span> ? <span class="hljs-string">&#x27;Not to fifty!&#x27;</span> : <span class="hljs-string">&#x27;It could be worse&#x27;</span><br><span class="hljs-built_in">console</span>.log(result);  <span class="hljs-comment">// It could be worse</span><br></code></pre></td></tr></table></figure>

<p>注意：对于<strong>三元运算符</strong> 仅限于做简单的返回值的事。不要做其他例如对象属性修改这种麻烦的操作…不然可能有意想不到的操作</p>
<figure class="highlight nim"><table><tr><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">const</span> user = <span class="hljs-meta">&#123;...&#125;</span><br>// 下述操作其实就会懵逼。不要这样做<br>user.valid ? user.save() : user.printErrors()<br><br>老老实实用<span class="hljs-keyword">if</span>……<span class="hljs-keyword">else</span>……<br><span class="hljs-keyword">if</span> (user.valid) &#123;<br>  user.save()<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  user.printErrors()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>嵌套事也不要做…</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">const <span class="hljs-built_in">number</span> = <span class="hljs-number">12</span>;<br>let <span class="hljs-literal">result</span>;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">number</span> === <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-literal">result</span> = &#x27;You have nothing&#x27;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">number</span> &lt; <span class="hljs-number">10</span>) &#123;<br>  <span class="hljs-literal">result</span> = &#x27;You have very little&#x27;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-literal">result</span> = &#x27;You have a lot&#x27;<br>&#125;<br><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-literal">result</span>)<br></code></pre></td></tr></table></figure>

<p>下面这种嵌套不要做…难以理解，难以解析</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">result = number === <span class="hljs-number">0</span> ? <span class="hljs-string">&#x27;You have nothing : (</span><br><span class="hljs-string">  number &lt; 10 ? &#x27;</span>You have very littl<span class="hljs-string">e&#x27; : &#x27;</span>You have a lot<span class="hljs-string">&#x27;</span><br><span class="hljs-string">)</span><br><span class="hljs-string"></span><br><span class="hljs-string">console.log(result)</span><br></code></pre></td></tr></table></figure>

<p>写代码不是为了追求短…而是为了让代码的可读性更好。就算有段代码写 10 行其实可以压缩成 1 行，但是如果写 10 行可读性大于写 1 行。那也应该选择写 10 行的代码…</p>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>奇淫技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机通识-随笔</title>
    <url>/2021/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86-%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<h4 id="Terminal-Commands"><a href="#Terminal-Commands" class="headerlink" title="Terminal Commands"></a>Terminal Commands</h4><ol>
<li><code>pwd</code> 用于告诉你当前所在目录</li>
<li><code>ls</code> 用于告诉你当前目录层级的所有文件</li>
<li><code>ls -al</code></li>
<li><code>ls -a</code></li>
<li><code>clear</code> 清理当前终端内容</li>
<li><code>cd</code> 进入某个文件 <code>cd ..</code> 往上一个文件走</li>
<li><code>mkdir</code> 创建一个文件夹</li>
<li><code>touch</code> 创建一个文件</li>
<li><code>cp</code> 旧文件 新文件</li>
<li><code>mv</code> 旧文件 新文件</li>
<li>键盘上下键可以看前面自己写的命令</li>
<li><code>rm</code> 删除一个文件</li>
<li><code>rm -f</code> 删除一个文件夹</li>
<li><code>rm -r</code></li>
<li><code>vim</code> 修改文件 —&gt; <code>nano</code> 更好 vim 学习成本太高</li>
<li><code>cat</code> 查看文件的具体内容</li>
<li><code>echo</code></li>
<li><code>control + c</code> 终止当前终端</li>
</ol>
]]></content>
      <categories>
        <category>程序员素养篇</category>
      </categories>
  </entry>
  <entry>
    <title>一篇文章解决Promise...then，async/await执行顺序类型题</title>
    <url>/2021/10/08/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E8%A7%A3%E5%86%B3Promise-then%EF%BC%8Casync-await%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E7%B1%BB%E5%9E%8B%E9%A2%98/</url>
    <content><![CDATA[<p>最近我在沸点里摸鱼的时候，发现了一些掘友在不约而同的讨论一种类型的题，即 Promise…then, async/await 执行顺序类型的题。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61f40af93cec47d281efaa67db337670~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-06-10 下午10.18.25.png"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdb16e753c6742ae94f531022a41d789~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-06-10 下午10.16.31.png"><br>恰好，在前一段时间我对此种类型的题有所研究 📃。因此，我也想趁这个机会看看是否能把这种类型的题讲述清楚。</p>
<p>废话就不多说了，先出几道题，大伙试试看，能不能把这几道题做出来！<br>（注：以下题目都是从网上以及掘友发的沸点里获取的）</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">题目一：<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">100</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">200</span>);<br>&#125;)<br><span class="hljs-built_in">Promise</span>.resolve().<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">300</span>);<br>&#125;)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">400</span>);<br>求打印结果：<br></code></pre></td></tr></table></figure>

<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">题目二：<br><span class="hljs-built_in">Promise</span>.resolve().<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;error1&#x27;</span>)<br>&#125;).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);<br>&#125;)<br>求打印结果：<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">题目三：<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async1 start&#x27;</span>);<br>  <span class="hljs-keyword">await</span> async2();<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async1 end&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async2&#x27;</span>);<br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script start&#x27;</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>)<br>async1()<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span> (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>  resolve()<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise2&#x27;</span>)<br>&#125;)<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script end&#x27;</span>)<br>求打印结果：<br></code></pre></td></tr></table></figure>

<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">题目四：<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>);<br>  resolve();<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2&#x27;</span>);<br>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3&#x27;</span>);<br>    resolve();<br>  &#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;4&#x27;</span>);<br>  &#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;5&#x27;</span>);<br>  &#125;)<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;6&#x27;</span>);<br>&#125;)<br><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;7&#x27;</span>);<br>  resolve()<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;8&#x27;</span>);<br>&#125;)<br>求打印结果：<br></code></pre></td></tr></table></figure>

<p>不知道大家对于上面四道题是否感觉有点恶心？哈哈，如果感到恶心，就对了！跟着这篇文章走，相信大家在文章看完之后能轻松解决上面的几道题！</p>
<p>废话不多说，如果有兴趣就接着往下看吧！</p>
<hr>
<p>首先我们需要知道这类题型实质是在考察以下几个内容</p>
<ul>
<li>异步</li>
<li>event loop 执行机制</li>
<li>Promise 语法</li>
<li>async/await 语法</li>
<li>宏任务、微任务</li>
</ul>
<p>其实，掌握了上述的五个内容，无论这类题型怎么变，你都能将题玩于股掌之间(他强任他强，清风拂山岗)。</p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>由于能开始思考这道题的兄弟，想必还是有一定的 JS 基础。所以我也不再细讲啥是异步、以及 event loop 执行机制了(这类博文网上一抓一大把~)。我只简单分享一下我对于异步的一些感悟：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-number">1</span>、异步是用来解决JS单线程等待这种问题的<br><span class="hljs-number">2</span>、异步是基于回调函数的形式来实现的<br><span class="hljs-number">3</span>、常见的异步有：<span class="hljs-built_in">setTimeout</span>、ajax、<span class="hljs-built_in">Promise</span>……<span class="hljs-keyword">then</span>、<span class="hljs-keyword">async</span>/<span class="hljs-keyword">await</span>、图片加载、网络请求资源<br><span class="hljs-number">4</span>、牢记<span class="hljs-number">5</span>个版块  Call Stack、 Web APIs、 Browser <span class="hljs-built_in">console</span>、 Callback Queue<br>、 micro task queue 这五个版块透露出异步的执行过程<br><span class="hljs-number">5</span>、宏任务是在DOM渲染后触发，微任务是在DOM渲染前触发<br></code></pre></td></tr></table></figure>

<h3 id="Promise、-Async-await"><a href="#Promise、-Async-await" class="headerlink" title="Promise、 Async/await"></a>Promise、 Async/await</h3><p>很多讲<code>Promise</code>的文章都说过，<code>Promise</code>的出现是为了解决臭名昭著的<code>callback hell</code>。由于异步是基于回调函数的形式来实现的，那么异步就离不开回调函数。但在上古时期，反人类的嵌套回调让老一辈的程序员们苦不堪言…而 Promise 搭配 then 展现的管道式回调函数，让异步更直观、更优雅的展现出来，广受大家好评！</p>
<p>而<code>async/await</code> 是 ECMAScript 2017 提出的内容。但事实上它们只是<code>Promise</code>的语法糖，但这颗 🍬 贼甜！</p>
<p>针对<code>Promise</code>以及<code>async/await</code>的骚用法，我想尝试用千层饼的套路来讲讲~</p>
<h5 id="第一层："><a href="#第一层：" class="headerlink" title="第一层："></a>第一层：</h5><p>Promise 是一个类（函数），接受一个回调函数作为参数，并且这个回调函数的参数也有两个，这两个参数约定俗成被命名为 <code>resolve</code>, <code>reject</code></p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    ...<br>&#125;)<br></code></pre></td></tr></table></figure>

<h5 id="第二层："><a href="#第二层：" class="headerlink" title="第二层："></a>第二层：</h5><p><code>resolve</code>, <code>reject</code>这两个参数其实也都是函数</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode">Promise<span class="hljs-comment">((resolve, reject)</span> =&gt; &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-comment">(...)</span> &#123;<br>        resolve<span class="hljs-comment">(...)</span>;     <span class="hljs-comment">// 执行resolve函数</span><br>    &#125; else &#123;<br>        reject<span class="hljs-comment">(...)</span>;      <span class="hljs-comment">// 执行reject函数</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<h5 id="第三层："><a href="#第三层：" class="headerlink" title="第三层："></a>第三层：</h5><p>对于紧跟 Promise 实例的<code>then</code>，其参数等于<code>resolve</code>接受的参数；紧跟 Promise 实例的<code>catch</code>，其参数等于<code>reject</code>接受的参数。</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">const p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve)</span> =&gt;</span> &#123;    <span class="hljs-regexp">//</span> p为<span class="hljs-built_in">Promise</span>实例<br>    const a = <span class="hljs-number">100</span>;<br>    resolve(a);<br>&#125;)<br><br>p1.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(param)</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;param:&#x27;</span>, param);      <span class="hljs-regexp">//</span> param: <span class="hljs-number">100</span><br>&#125;)<br><br>const p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    const a = <span class="hljs-number">100</span>;<br>    reject(a);<br>&#125;)<br><br>p2.<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">(param)</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;param&#x27;</span>, param);<br>&#125;)<br><br></code></pre></td></tr></table></figure>

<h5 id="第四层："><a href="#第四层：" class="headerlink" title="第四层："></a>第四层：</h5><p>Promise 的实例有三种状态： <code>pending(加载中)</code>、<code>fulfilled(执行成功)</code>、<code>rejected(执行错误)</code>。其实我们很好理解这三种状态，因为它们恰好对应了<code>异步正在执行</code>和<code>异步执行完的结果</code>(无非成功或失败两种状态)这三种状态</p>
<p>三种状态的表现：</p>
<ul>
<li>pending: Promise 实例处于<code>pending</code>状态时，不会触发 then 和 catch。</li>
<li>fufilled: Promise 实例处于<code>fulfilled</code>状态时，只会触发 then(不会触发 catch)</li>
<li>rejected： Promise 实例处于<code>rejected</code>状态时，只会触发 catch(不会触发 then)</li>
</ul>
<p>(无论是 then 还是 catch，它们里面都是回调函数)</p>
<p>那么问题来了，如何判断 Promise 实例对象是处于那种状态呢？</p>
<p>很简单，看下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 啥也没有做~</span><br>&#125;)<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;p&#x27;</span>, p);<br></code></pre></td></tr></table></figure>

<p>Chrome 控制台显示结果如下图：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a40d9c5af8794683b9660bd378bd0316~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-06-12 下午9.00.33.png"></p>
<p>截图说明了此时的 Promise 实例是处于<code>pending</code>状态的。其实，当 Promise 内部的回调不执行<code>resolve</code>或<code>reject</code>的时候，Promise 实例就处于<code>pending</code>状态！</p>
<p>再看下面的代码 👇🏻</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"> <span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;    <span class="hljs-comment">// p1为Promise实例</span><br>     <span class="hljs-keyword">const</span> a = <span class="hljs-number">100</span>;<br>     resolve(a);<br> &#125;)<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;p1&#x27;</span>, p1)    <span class="hljs-comment">// fulfilled</span><br><br> <span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>     <span class="hljs-keyword">const</span> a = <span class="hljs-number">100</span>;<br>     reject(a);<br> &#125;)<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;p2&#x27;</span>, p2)    <span class="hljs-comment">// rejected</span><br></code></pre></td></tr></table></figure>

<p>Chrome 控制台显示结果如下图：<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/508e710a9a0847d69cc13e1f79e03ef7~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-06-12 下午9.03.58.png"></p>
<p>这里的代码是借用的第三层的代码，其实看到这儿就解释了第三层的套路。对于第一个 Promise 实例执行参数<code>resolve</code>就代表了，当前 Promise 实例对象的状态为<code>fulfilled</code>，因此接下来可以触发 then，以及对应的回调。如果 Promise 实例对象执行了<code>reject</code>，则实例对象的状态变为了 <code>rejected</code>，可以触发 catch~ 有兴趣的小伙伴可以试试，在<code>fulfilled</code>状态执行下 catch 或者在<code>rejected</code>状态下执行下 then，试试能否执行代码成功。</p>
<h5 id="第五层："><a href="#第五层：" class="headerlink" title="第五层："></a>第五层：</h5><p>在第五层有 3 句至理名言需要知道(不需要去死记硬背，下面我会用例子帮助你理解)</p>
<blockquote>
<p>无论是 then 还是 catch 里的回调内容只要代码正常执行或者正常返回，则当前新的 Promise 实例为 fulfilled 状态。如果有报错或返回 Promise.reject()则新的 Promise 实例为 rejected 状态。</p>
</blockquote>
<blockquote>
<p>fulfilled 状态能够触发 then 回调</p>
</blockquote>
<blockquote>
<p>rejected 状态能够触发 catch 回调</p>
</blockquote>
<p>举例之前我先补充一个小知识！</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Promise</span>.resolve()  表示一个fulfilled状态的<span class="hljs-built_in">Promise</span>实例<br><span class="hljs-built_in">Promise</span>.reject()   表示一个rejected状态的<span class="hljs-built_in">Promise</span>实例<br></code></pre></td></tr></table></figure>

<p>好，我将放码过来！</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">题目一：<br><span class="hljs-built_in">Promise</span>.resolve().<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>&#125;).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>初看此题，感觉似乎此题有点难度~ 不过，结合我的三句至理名言，我们一起来分析一下此题！！</p>
<p><code>Promise.resolve()</code> 是一个状态为<code>fulfilled</code>状态的 Promise 实例。<code>fulfilled</code>状态能够触发 then 回调。因此，第一个 then 会被执行，并且能够顺利打印结果而不报错！故 Promise.resolve().then(() =&gt; {console.log(1)}) 这个新的 Promise 实例为<code>fulfilled</code>状态，所以可以触发下一个 then，但是无法触发 catch，故 catch 的内容忽略，从而执行第二个 then 的内容。 所以，此题的打印结果为： 1 3</p>
<p>好了，下面再来看看第二题(此题也是文章开头出的第二题)：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Promise</span>.resolve().<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;error1&#x27;</span>);<br>&#125;).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>有了上一题的经验，做这一道题就轻松很多了~ Promise.resolve()是一个<code>fulfilled</code>状态的实例，所以可以触发 then，而第一个 then 之中有 throw new Error(‘error1’) 这种报错操作，则 Promise.resolve.then(() =&gt; {<br>console.log(1);<br>throw new Error(‘error1’)<br>})就是一个<code>rejected</code>状态的 Promise 实例，所以可以触发 catch，catch 的内容是可以正常执行的，没有报错误，则 Promise.resolve().then(…).catch(…)是一个<code>fulfilled</code>状态的 Promise 实例，可以触发 then，故 then 的内容能够被执行。</p>
<p>故代码结果为： 1 2 3</p>
<h5 id="第六层："><a href="#第六层：" class="headerlink" title="第六层："></a>第六层：</h5><p>做了前面两道题，不知道大家有没有一点困惑。感觉我似乎有意回避了 then、catch 的返回值即(return …),而且也没有在 then、catch 里写具体的参数。导致我在第五层的第一句至理名言“无论是 then 或者 catch 里的内容只要正常执行或者正常返回…”也没有完全体现出来。 大家别慌，其实这正是我要讲的第六层套路~</p>
<p>then、catch 参数的来头其实就是我在第三层套路里就讲过<code>“紧跟Promise实例的then的参数等于resolve接受的参数；紧跟Promise实例的catch的参数等于reject接受的参数。”</code>。如果 then、catch 里的回调，没有写返回内容，则 then 或 catch 后面即将被触发的 then 或 catch 是无法接受到参数的；而如果有返回内容，即 return… 那么无论返回的是普通值还是是 Promise 实例，其实都会对应被转化为 Promise 的实例(Promise.resolve(…)或者 Promise.reject(…))</p>
<p>结合代码再来理解一下~</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">&#x27;我想出错&#x27;</span>).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">(err)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(err);<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;我不想出错&#x27;</span>;  <span class="hljs-regexp">//</span> 会被自动封装成<span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">&#x27;我不想出错&#x27;</span>)<br>&#125;).<span class="hljs-keyword">then</span>(data =&gt; &#123;<br>  <span class="hljs-built_in">console</span>.log(data);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">&#x27;我不想出错&#x27;</span>)<br>&#125;).<span class="hljs-keyword">then</span>(data =&gt; &#123;<br>  <span class="hljs-built_in">console</span>.log(data);<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>代码打印结果：<br>我想出错<br>我不想出错<br>我不想出错</p>
<h5 id="第七层："><a href="#第七层：" class="headerlink" title="第七层："></a>第七层：</h5><p>第七层套路，我来谈谈 async/await。 因为 Promise 的出现主要是为了解决异步的回调地狱问题。将噩梦般的嵌套回调变为了优雅的管道式回调。但这始终是逃不掉“回调”二字。而 async/await 虽说只是 Promise 的语法糖，但让你“脱离”了回调，拥抱了同步代码~</p>
<p>下面我再分享大家五句经典语录~</p>
<blockquote>
<p>执行 async 函数，返回的是 Promise 对象</p>
</blockquote>
<blockquote>
<p>await 必须在 async 包裹之下执行</p>
</blockquote>
<blockquote>
<p>await 相当于 Promise 的 then 并且同一作用域下 await 下面的内容全部作为 then 中回调的内容</p>
</blockquote>
<blockquote>
<p>try……catch 可捕获异常，代替了 Promise 的 catch</p>
</blockquote>
<blockquote>
<p>异步中先执行微任务，再执行宏任务</p>
</blockquote>
<p>且看下面的代码分析：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;我是async函数&#x27;</span>;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async:&#x27;</span>, fn());<br></code></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d97ad91369b344ee8e168444253fa1b0~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-06-13 下午10.23.56.png"></p>
<p>这里的 fn() 相当于 Promise.resolve(‘我是 async 函数’)，验证了第一条语录！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">&#x27;帅得乱七八糟&#x27;</span>);<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> p; <span class="hljs-comment">// await就相当于Promise.then, 故data就是then的参数</span><br>  <span class="hljs-built_in">console</span>.log(data);    <span class="hljs-comment">// 这里的代码为then中回调的内容</span><br>&#125;)()<br></code></pre></td></tr></table></figure>

<p>上面的这段代码，大家可以试着把<code>async</code>删掉，结果一定会报错！这就验证了第二条语录！上面代码的注释结合第三条语录，大家应该能够体会到<code>await</code>的作用！</p>
<p>再看下面一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">&#x27;err&#x27;</span>);<br>  <span class="hljs-comment">// await + try...catch 相当于 Promise.catch</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> p;<br>    <span class="hljs-built_in">console</span>.log(res);<br>  &#125; <span class="hljs-keyword">catch</span>(ex) &#123;  <span class="hljs-comment">// ex 来源于reject()里面的数</span><br>    <span class="hljs-built_in">console</span>.error(ex);<br>  &#125;<br>&#125;)()<br></code></pre></td></tr></table></figure>

<p>打印结果为 err，验证了第四条语录。</p>
<p>在此补充一点内容：</p>
<ul>
<li>常见的微任务： Promise……then、 async/await</li>
<li>常见的宏任务： setTimeout、setInterval<blockquote>
<p>考虑过在文章里谈谈宏任务和微任务的执行机制，但限于篇幅以及本篇文章的侧重点在于解题于是就不过多赘述其他内容了，有兴趣的朋友可以在评论区讨论一下。</p>
</blockquote>
</li>
</ul>
<p>其实看到这儿，文章开始出的所有题目都能够解决了。不信就试试 💪🏻</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">题目三:<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async1 start&#x27;</span>);<br>  <span class="hljs-keyword">await</span> async2();<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async1 end&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async2&#x27;</span>);<br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script start&#x27;</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>)<br>async1()<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span> (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>  resolve()<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise2&#x27;</span>)<br>&#125;)<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script end&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>此题需要注意两个点</p>
<ol>
<li>new Promise()内部的回调函数是当成同步函数执行</li>
<li>执行到 await code 时，会先执行 code，再执行 await</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">代码分析：<br><span class="hljs-number">1.</span> 先执行同步代码。<br><span class="hljs-number">2.</span> 所以首先执行 console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>);<br><span class="hljs-number">3.</span> setTimeout为宏任务，先不执行<br><span class="hljs-number">4.</span> 执行async1函数 console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async1 start&#x27;</span>); 以及 async2(); await由于是Promise.then的语法糖是异步代码，先不执行<br><span class="hljs-number">5.</span> <span class="hljs-keyword">new</span> Promise() 内部代码要执行，后面的<span class="hljs-keyword">then</span>的内容为微任务先不执行<br><span class="hljs-number">6.</span>执行console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>)<br><span class="hljs-number">7.</span>同步代码执行结束<br><span class="hljs-number">8.</span>开始按代码顺序执行微任务<br><span class="hljs-number">9.</span>先执行 console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async1 end&#x27;</span>); 前面说过，await下面的代码相当于<span class="hljs-keyword">then</span>里回调的内容<br><span class="hljs-number">10.</span><span class="hljs-keyword">new</span> Promise.then里面的内容 console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;promise2&#x27;</span>)<br><span class="hljs-number">11.</span> 最后执行 宏任务代码，即setTimeout里的内容<br><br>执行结果：<br>script <span class="hljs-keyword">start</span><br>async1 <span class="hljs-keyword">start</span><br>async2<br>promise1<br>script <span class="hljs-keyword">end</span><br>async1 <span class="hljs-keyword">end</span><br>promise2<br>setTimeout<br></code></pre></td></tr></table></figure>

<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">题目四：<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>);<br>  resolve();<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2&#x27;</span>);<br>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3&#x27;</span>);<br>    resolve();<br>  &#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;     <span class="hljs-regexp">//</span> 📌<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;4&#x27;</span>);<br>  &#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;5&#x27;</span>);<br>  &#125;)<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;6&#x27;</span>);   <span class="hljs-regexp">//</span> 📌<br>&#125;)<br><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;7&#x27;</span>);<br>  resolve()<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;8&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">代码分析：<br><span class="hljs-number">1.</span>先执行同步代码<br><span class="hljs-number">2.</span>setTimeout 为宏任务，先不执行<br><span class="hljs-number">3.</span><span class="hljs-keyword">new</span> Promise里的代码作为同步代码，要执行 console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;1&#x27;</span>); 而<span class="hljs-keyword">then</span>作为微任务，先不执行<br><span class="hljs-number">4.</span>又是一个<span class="hljs-keyword">new</span> Promise,所以和第三步同理。只执行 console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;7&#x27;</span>);<br><span class="hljs-number">5.</span>开始执行异步代码<br><span class="hljs-number">6.</span>执行第一个<span class="hljs-keyword">new</span> Promise里的<span class="hljs-keyword">then</span> 即console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;2&#x27;</span>);以及<span class="hljs-keyword">new</span> Promise的同步代码 console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;3&#x27;</span>);<br><span class="hljs-number">7.</span>这步有点意思，这里不是执行console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;4&#x27;</span>); 而是执行console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;8&#x27;</span>);<br><span class="hljs-number">8.</span>注释为📌的两个<span class="hljs-keyword">then</span>是同层级的，所以按照执行顺序来打印<br><span class="hljs-number">9.</span>执行第三个层级的<span class="hljs-keyword">then</span>，所有微任务代码完成<br><span class="hljs-number">10.</span>执行宏任务代码，即console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;0&#x27;</span>);<br><br>代码结果：<br><span class="hljs-number">1</span><br><span class="hljs-number">7</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">8</span><br><span class="hljs-number">4</span><br><span class="hljs-number">6</span><br><span class="hljs-number">5</span><br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<p>说有千层饼套路，其实只有 7 层套路，但这每一层套路都是我对于 Promise、async/await 的感悟，有些内容并未细讲，比如微任务、宏任务与 DOM 之间的执行顺序这种相对底层的内容本文并未谈及，毕竟这篇文章的侧重点是在解决 Promise、async/await 执行顺序类型题。本文也可能有内容错误或逻辑错误，也请大家多多包涵，多多指出，谢谢！！</p>
<p>好了，大功已告成！想必通过这些题，大家已经领悟到了解决此类题型的奥义！</p>
<head>
  ..
  <script src="//cdn.jsdelivr.net/npm/@waline/client"></script>
  ...
</head>
<body>
  ...
  <div id="waline"></div>
  <script>
    Waline({
      el: '#waline',
       avatar: 'monsterid',
      serverURL: 'https://blog-api-9sizcti78-bruce-shuai.vercel.app/',
    });
  </script>
</body>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS Animation 性能篇</title>
    <url>/2021/11/07/CSS-Animation-%E6%80%A7%E8%83%BD%E7%AF%87/</url>
    <content><![CDATA[<blockquote>
<p>这篇博客将告诉你如何良好的提高<code>animation动画性能</code>以及如何使用 <code>Chrome</code>的 <code>dev tools</code>进行性能检测</p>
</blockquote>
]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS Animation</title>
    <url>/2021/11/07/CSS-Animation/</url>
    <content><![CDATA[<p>先放代码</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">/* html文件 */</span><br>&lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;parent&quot;</span>&gt;<br>  &lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;child&quot;</span>&gt;&lt;/div&gt;<br>&lt;/div&gt;<br><br><span class="hljs-comment">/* css文件 */</span><br><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: hsl(<span class="hljs-number">200</span>, <span class="hljs-number">100%</span>, <span class="hljs-number">20%</span>);<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;<br>&#125;<br><br><span class="hljs-selector-class">.parent</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">transform</span>: translateX(<span class="hljs-number">100%</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>
]]></content>
  </entry>
</search>
