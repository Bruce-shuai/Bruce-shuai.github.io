<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS Animation 性能篇</title>
    <url>/2021/11/07/CSS-Animation-%E6%80%A7%E8%83%BD%E7%AF%87/</url>
    <content><![CDATA[<blockquote>
<p>这篇博客将告诉你如何良好的提高<code>animation动画性能</code>以及如何使用 <code>Chrome</code>的 <code>dev tools</code>进行性能检测</p>
</blockquote>
]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS Animation</title>
    <url>/2021/11/07/CSS-Animation/</url>
    <content><![CDATA[<p>注意： 似乎一个元素的 transform 只能使用一次?! 好像这句话不对…</p>
<blockquote>
<p>这篇文章 能让你的 <code>css</code>技术更上一层楼</p>
</blockquote>
<p><strong>注意：下面的代码中我在 css 文件中使用了 <code>//</code> 注释符，这在 css 文件中需删掉(css 文件不支持这种注释方式)</strong></p>
<p>先看代码：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/* html文件 */</span><br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* css文件 */</span><br><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">hsl</span>(<span class="hljs-number">200</span>, <span class="hljs-number">100%</span>, <span class="hljs-number">20%</span>);<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;<br>&#125;<br><br><span class="hljs-selector-class">.parent</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">100%</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>代码效果如下：<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-07-at-7.28.54-PM.gif" alt="Animation效果"></p>
<p>上面的代码非常简单，没有任何动态效果，只有硬生生的红块跳动！ 因此，我要引出<code>CSS Animation</code>让生硬的跳动变得有趣！</p>
<p>事实上，css 有两种制作动画(Animate)的方式</p>
<table>
<thead>
<tr>
<th><strong>动画制作方式</strong></th>
<th><strong>动画效果</strong></th>
</tr>
</thead>
<tbody><tr>
<td>transition</td>
<td>用于制作简单的动画</td>
</tr>
<tr>
<td>animation</td>
<td>用于制作复杂的动画</td>
</tr>
</tbody></table>
<h4 id="简单动画：transition"><a href="#简单动画：transition" class="headerlink" title="简单动画：transition"></a>简单动画：transition</h4><h5 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h5><p><strong>针对上面的例子，我有一点说明：</strong><br>很多朋友会犯一个错误，会把 <code>transition</code> 放在 <code>hover</code> 伪类里使用或者把<code>transition</code>放在物块产生动画的环境里。但事实上，如果放在<code>hover</code>里面,我触控<code>parent</code>才会运动，而放弃触摸则动画会<strong>立刻消失</strong>，这会让动画效果非常不连贯！所以应该把<code>transition</code>放在 <code>child</code> 里面(即把<code>transition</code>放在本身需要运动的元素里)</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* css 文件 */</span><br><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">hsl</span>(<span class="hljs-number">200</span>, <span class="hljs-number">100%</span>, <span class="hljs-number">20%</span>);<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;<br>&#125;<br><br><span class="hljs-selector-class">.parent</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">100%</span>);<br>  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span> ease-in-out<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-28-at-11.08.05-AM.gif" alt="不连贯动画"></p>
<h5 id="transition-基础属性"><a href="#transition-基础属性" class="headerlink" title="transition 基础属性"></a>transition 基础属性</h5><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">transition: 由下列四个属性组成<br>transition-delay           <span class="hljs-regexp">//</span> 动画延迟时间(多少时间后才开始动画) (默认是 <span class="hljs-number">0</span>s)<br>transition-duration        <span class="hljs-regexp">//</span> 动画使用时间  (默认是 <span class="hljs-number">0</span>s)<br>transition-property        <span class="hljs-regexp">//</span> 哪些属性会受到动画影响  (默认是 all)<br>transition-timing-<span class="hljs-keyword">function</span> <span class="hljs-regexp">//</span> 决定你的动画是以怎样的节奏进行 (默认是 ease)<br></code></pre></td></tr></table></figure>

<h5 id="transition-duration-amp-transition-property"><a href="#transition-duration-amp-transition-property" class="headerlink" title="transition-duration &amp; transition-property"></a>transition-duration &amp; transition-property</h5><p>示例 1：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">hsl</span>(<span class="hljs-number">200</span>, <span class="hljs-number">100%</span>, <span class="hljs-number">20%</span>);<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;<br>  // <span class="hljs-attribute">transition</span>: all;           // 注意这里！ all 是默认值(<span class="hljs-attribute">transition-property</span>: all)，即会监视child所有属性的变化<br>  transition: transform <span class="hljs-number">2s</span>;     // 会监视child中 <span class="hljs-attribute">transform</span> 属性的变化；这里的 <span class="hljs-number">2s</span> 即 <span class="hljs-attribute">transition-duration</span><br>&#125;<br><br><span class="hljs-selector-class">.parent</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">100%</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-28-at-11.20.13-AM.gif" alt="transition 1"></p>
<p>示例 2：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">hsl</span>(<span class="hljs-number">200</span>, <span class="hljs-number">100%</span>, <span class="hljs-number">20%</span>);<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">transition</span>: <span class="hljs-number">2s</span>;            // 我没有指定<span class="hljs-attribute">transition-property</span>内容，则<span class="hljs-attribute">transition-property</span>默认为all<br>&#125;<br><br><span class="hljs-selector-class">.parent</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: green;   // 因为指定的是所有属性，所以也包括了这里的绿色<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">100%</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-28-at-11.24.17-AM.gif" alt="transition 2"></p>
<h5 id="transition-timing-function"><a href="#transition-timing-function" class="headerlink" title="transition-timing-function"></a>transition-timing-function</h5><p>示例 3：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">hsl</span>(<span class="hljs-number">200</span>, <span class="hljs-number">100%</span>, <span class="hljs-number">20%</span>);<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">transition</span>: transform <span class="hljs-number">2s</span> ease-in-out;    // 注意这里！ 为了方便记忆<span class="hljs-attribute">transition-timing-function</span>各大属性的效果，下面我做了一个列表<br>&#125;<br><br><span class="hljs-selector-class">.parent</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">100%</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>transition-timing-function</strong></th>
<th><strong>属性效果</strong></th>
</tr>
</thead>
<tbody><tr>
<td>ease</td>
<td>开始慢，然后快，然后慢结束</td>
</tr>
<tr>
<td>linear</td>
<td>从开始到结束具有相同速度</td>
</tr>
<tr>
<td>ease-in</td>
<td>缓慢启动</td>
</tr>
<tr>
<td>ease-out</td>
<td>指定一个缓慢结束的过渡效果</td>
</tr>
<tr>
<td>ease-in-out</td>
<td>指定一个缓慢开始和结束的过渡效果</td>
</tr>
<tr>
<td>cubic-bezier(n,n,n,n)</td>
<td>允许您在三次贝塞尔函数中定义自己的值</td>
</tr>
</tbody></table>
<p><code>cubic-bezier(n,n,n,n)</code> 这个属性是可以利用 <code>chrome</code> 的控制台，自己进行任意调节的</p>
<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-28-at-11.39.51-AM.png" alt="自己调节cubic-bezier" width="300px"/>

<h5 id="transition-delay"><a href="#transition-delay" class="headerlink" title="transition-delay"></a>transition-delay</h5><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">hsl</span>(<span class="hljs-number">200</span>, <span class="hljs-number">100%</span>, <span class="hljs-number">20%</span>);<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">transition</span>: transform <span class="hljs-number">2s</span> ease-in-out <span class="hljs-number">2.5s</span>;    // 注意这里！ 我推迟了<span class="hljs-number">2.5s</span>运行动画<br>&#125;<br><br><span class="hljs-selector-class">.parent</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">100%</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-28-at-11.45.17-AM.gif" alt="transition-delay"></p>
<p><strong>以上就是 <code>transition</code> 所能做的所有事，为了更复杂的动画实现，必须使用 <code>animation</code></strong></p>
<h4 id="复杂动画：animation-属性"><a href="#复杂动画：animation-属性" class="headerlink" title="复杂动画：animation 属性"></a>复杂动画：animation 属性</h4><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">animation 的属性：<br>animation-name       <span class="hljs-regexp">//</span> 给要实现的整体动画流程取个名字<br>@keyframes           <span class="hljs-regexp">//</span> 用这个动画名字 来进一步开展 动画行动逻辑<br>animation-duration   <span class="hljs-regexp">//</span> 动画使用时间<br>animation-delay      <span class="hljs-regexp">//</span> 动画延迟时间<br>animation-play-state <span class="hljs-regexp">//</span> 指定动画是正在运行还是暂停<br>animation-iteration-count  <span class="hljs-regexp">//</span> 设置动画播放次数<br>animation-direction        <span class="hljs-regexp">//</span> 设置动画的播放顺序<br>animation-timing-<span class="hljs-keyword">function</span>  <span class="hljs-regexp">//</span> 决定你的动画是以怎样的节奏进行<br>animation-fill-mode <span class="hljs-regexp">//</span> 指定了动画不播放时元素的样式<br>animation           <span class="hljs-regexp">//</span> 这是所有animation属性的集合<br></code></pre></td></tr></table></figure>

<p><code>animation</code> 可以用在你想使用的地方(尽管放在 hover 上仍然会出现前面我讲的鼠标一撤退立即停止动画的效果)</p>
<h5 id="animation-name-amp-keyframes"><a href="#animation-name-amp-keyframes" class="headerlink" title="animation-name &amp; @keyframes"></a>animation-name &amp; @keyframes</h5><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">hsl</span>(<span class="hljs-number">200</span>, <span class="hljs-number">100%</span>, <span class="hljs-number">20%</span>);<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;<br>&#125;<br><br><span class="hljs-selector-class">.parent</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">animation</span>: left-to-right <span class="hljs-number">1s</span> ease-in <span class="hljs-number">0.5s</span>; <span class="hljs-comment">/* 可以取任意名字, 1s是动画时间, ease-in是缓慢启动, .5s是延迟时间 */</span><br>&#125;<br><br><span class="hljs-keyword">@keyframes</span> left-to-right &#123;<br>  <span class="hljs-comment">/* 动画全流程 0%~100% */</span><br>  <span class="hljs-comment">/* 0% 默认是.child 的所有内容 */</span><br>  <span class="hljs-comment">/* 当 100%的内容执行完后，@keyframes 会立刻销毁所有添加的内容,回归最初的.child的内容 */</span><br>  <span class="hljs-number">100%</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">100%</span>);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-28-at-12.06.59-PM.gif" alt="animation-name &amp; @keyframes"></p>
<h5 id="animation-fill-mode"><a href="#animation-fill-mode" class="headerlink" title="animation-fill-mode"></a>animation-fill-mode</h5><table>
<thead>
<tr>
<th><strong>animation-fill-mode 属性</strong></th>
<th><strong>效果</strong></th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>动画在执行之前或之后不会对元素应用任何样式</td>
</tr>
<tr>
<td>forwards</td>
<td>元素将保留最后一个关键帧设置的样式值</td>
</tr>
<tr>
<td>backwards</td>
<td>元素将获得由第一个关键帧设置的样式值(取决于动画方向)，并在动画延迟期间保留它</td>
</tr>
<tr>
<td>both</td>
<td>The animation will follow the rules for both forwards and backwards, extending the animation properties in both directions</td>
</tr>
</tbody></table>
<p>还有两个属性：<code>initial</code> 和 <code>inherit</code> 就暂时不写了(自己查)</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">hsl</span>(<span class="hljs-number">200</span>, <span class="hljs-number">100%</span>, <span class="hljs-number">20%</span>);<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;<br>&#125;<br><br><span class="hljs-selector-class">.parent</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">animation</span>: left-to-right <span class="hljs-number">1s</span> ease-in <span class="hljs-number">0.5s</span> forwards; <span class="hljs-comment">/* forwards元素将保留最后一个关键帧设置的样式, 不会像前面代码一样，执行完100%后理解回退到最初位置 */</span><br>&#125;<br><br><span class="hljs-keyword">@keyframes</span> left-to-right &#123;<br>  <span class="hljs-number">100%</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">100%</span>);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-28-at-12.20.42-PM.gif" alt="animation-fill-mode"></p>
<h4 id="中间过渡动画"><a href="#中间过渡动画" class="headerlink" title="中间过渡动画"></a>中间过渡动画</h4><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">hsl</span>(<span class="hljs-number">200</span>, <span class="hljs-number">100%</span>, <span class="hljs-number">20%</span>);<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;<br>&#125;<br><br><span class="hljs-selector-class">.parent</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">animation</span>: left-to-right <span class="hljs-number">1s</span> ease-in <span class="hljs-number">0.5s</span> forwards;<br>&#125;<br><br><span class="hljs-keyword">@keyframes</span> left-to-right &#123;<br>  <span class="hljs-number">0%</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-number">33%</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">0%</span>, <span class="hljs-number">100%</span>);<br>  &#125;<br>  <span class="hljs-number">66%</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">100%</span>, <span class="hljs-number">100%</span>);<br>  &#125;<br>  <span class="hljs-number">100%</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">100%</span>, <span class="hljs-number">0%</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-28-at-12.27.35-PM.gif" alt="中间过渡动画"></p>
<h5 id="animation-iteration-count-amp-animation-direction"><a href="#animation-iteration-count-amp-animation-direction" class="headerlink" title="animation-iteration-count &amp; animation-direction"></a>animation-iteration-count &amp; animation-direction</h5><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">hsl</span>(<span class="hljs-number">200</span>, <span class="hljs-number">100%</span>, <span class="hljs-number">20%</span>);<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;<br>&#125;<br><br><span class="hljs-selector-class">.parent</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">animation</span>: left-to-right <span class="hljs-number">1s</span> ease-in <span class="hljs-number">0.1s</span> forwards <span class="hljs-number">4</span> alternate; <span class="hljs-comment">/* 设置动画播放次数 并且是交替顺序播放(alternate) */</span><br>&#125;<br><br><span class="hljs-keyword">@keyframes</span> left-to-right &#123;<br>  <span class="hljs-number">0%</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-number">33%</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">0%</span>, <span class="hljs-number">100%</span>);<br>  &#125;<br>  <span class="hljs-number">66%</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">100%</span>, <span class="hljs-number">100%</span>);<br>  &#125;<br>  <span class="hljs-number">100%</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">100%</span>, <span class="hljs-number">0%</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-28-at-12.33.41-PM.gif" alt="神奇动画"></p>
<h5 id="animation-的神奇效果展示"><a href="#animation-的神奇效果展示" class="headerlink" title="animation 的神奇效果展示"></a>animation 的神奇效果展示</h5><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">hsl</span>(<span class="hljs-number">200</span>, <span class="hljs-number">100%</span>, <span class="hljs-number">20%</span>);<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">animation</span>: left-to-right <span class="hljs-number">1s</span> ease-in <span class="hljs-number">5s</span> forwards infinite alternate; <span class="hljs-comment">/* 没有放在 hover位置，而是直接放在.child位置，并且我设置了 无限次的执行 infinite*/</span><br>&#125;<br><br><span class="hljs-selector-class">.parent</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">animation-play-state</span>: paused; <span class="hljs-comment">/* 我触碰parent时，child会暂停运动*/</span><br>&#125;<br><br><span class="hljs-keyword">@keyframes</span> left-to-right &#123;<br>  <span class="hljs-number">0%</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-number">33%</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">0%</span>, <span class="hljs-number">100%</span>);<br>  &#125;<br>  <span class="hljs-number">66%</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">100%</span>, <span class="hljs-number">100%</span>);<br>  &#125;<br>  <span class="hljs-number">100%</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">100%</span>, <span class="hljs-number">0%</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-28-at-12.40.28-PM.gif" alt="神奇动画2"></p>
<p>内容已讲完，属性的很多值我没在博客里追溯！自己去查！哈哈~</p>
]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS-Background</title>
    <url>/2021/12/05/CSS-Background/</url>
    <content><![CDATA[<p>这个可以同时控制多张图片</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">background-repeat</span>: no-repeat;<br>  <span class="hljs-attribute">background-attachment</span>: fixed;<br>  <span class="hljs-attribute">background-position</span>: left bottom, right bottom;<br>  <span class="hljs-attribute">background-size</span>: <span class="hljs-built_in">calc</span>(((<span class="hljs-number">100vw</span> - <span class="hljs-number">40rem</span>) / <span class="hljs-number">2</span>) - <span class="hljs-number">3.2rem</span>), <span class="hljs-built_in">calc</span>(((<span class="hljs-number">100vw</span> - <span class="hljs-number">40rem</span>) / <span class="hljs-number">2</span>) - <span class="hljs-number">3.2rem</span>), cover;   // 注意这里<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">...</span>), <span class="hljs-built_in">url</span>(<span class="hljs-string">...</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS Media Query</title>
    <url>/2021/11/28/CSS-Media-Query/</url>
    <content><![CDATA[<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* style.css */</span><br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-selector-class">.title</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">6rem</span>;<br>&#125;<br><span class="hljs-selector-class">.subtitle</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">4rem</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">/* index.js */</span><br>&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">title</span>&quot;&gt;<span class="hljs-symbol">Title</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">subtitle</span>&quot;&gt;<span class="hljs-symbol">Sub</span> <span class="hljs-symbol">Title</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-28-at-9.20.00-PM.png" alt="示例"></p>
<p>为了实现移动端响应效果 需在后面添加 <code>@media</code> + <code>适应的设备</code><br>适应的设备类型如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">all   (默认值) 适配各种设备<br><span class="hljs-builtin-name">print</span>  设配打印机<span class="hljs-built_in"></span><br><span class="hljs-built_in">screen </span>适用于电脑屏幕、平板电脑、智能手机等<br>speech 用于屏幕阅读器<br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* style.css */</span><br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-selector-class">.title</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">6rem</span>;<br>&#125;<br><span class="hljs-selector-class">.subtitle</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">4rem</span>;<br>&#125;<br><br><span class="hljs-comment">/* 当前我想适配各种设备 */</span><br><span class="hljs-keyword">@media</span> all <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">500px</span>) &#123;  <span class="hljs-comment">/* 一般使用 max-width 来作为媒体的选择器 */</span><br>  <span class="hljs-comment">/* 这里面我可以写任何css代码 */</span><br>  <span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">color</span>: green<br>  &#125;<br>  <span class="hljs-selector-class">.title</span> &#123;<br>    <span class="hljs-attribute">color</span>: purple<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里表示如果在 <code>500px</code> 的宽度以内，遵循 <code>@media</code> 的内容，如果超过 <code>500px</code> 则遵循 <code>@media</code> 之外的设定<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-28-at-9.29.10-PM.gif" alt="@media max-width"></p>
<p>注意： 你有下面这样的写法，效果同上面一样，因为 <code>all</code> 是默认属性</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">500px</span>) &#123;<br>  <span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">color</span>: green<br>  &#125;<br>  <span class="hljs-selector-class">.title</span> &#123;<br>    <span class="hljs-attribute">color</span>: purple<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>注意：<code>@media query</code> 这选择器同其他任何选择器一样 遵循从上到下的执行顺序</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.title</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">6rem</span>;<br>&#125;<br><span class="hljs-selector-class">.subtitle</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">4rem</span>;<br>&#125;<br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">500px</span>) &#123;<br>  <span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">color</span>: green<br>  &#125;<br>  <span class="hljs-selector-class">.title</span> &#123;<br>    <span class="hljs-attribute">color</span>: yellow<br>  &#125;<br>&#125;<br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可见，由于 <code>body</code> 在<code>@media</code> 之下，所以 <code>@media</code> 内部控制的 <code>body</code> 就被下面的 <code>body</code> 覆盖了<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-28-at-9.38.04-PM.gif" alt="选择器效果覆盖"></p>
<h4 id="orientation"><a href="#orientation" class="headerlink" title="orientation"></a>orientation</h4><p><code>@media </code>也常搭配 <code>orientation</code> 来实现响应式布局</p>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">orientation</span>: landscape) <span class="hljs-comment">// 横向(width &gt; height)</span><br><span class="hljs-variable">@media</span> (<span class="hljs-attribute">orientation</span>: portrait)  <span class="hljs-comment">// 纵向(height &gt; width)</span><br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-selector-class">.title</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">6rem</span>;<br>&#125;<br><span class="hljs-selector-class">.subtitle</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">4rem</span>;<br>&#125;<br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">500px</span>) &#123;<br>  <span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">color</span>: green<br>  &#125;<br>&#125;<br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">orientation</span>:landscape) &#123;<br>  <span class="hljs-selector-class">.title</span> &#123;<br>    <span class="hljs-attribute">color</span>: purple<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-28-at-9.45.23-PM.gif" alt="orientation"></p>
<p>当宽度大于高度的时候，<code>title</code> 显紫色。当宽度小于 <code>500px</code> 的时候整体是绿色的(<code>title</code> 的显色情况优先级更高,因为选择器位置顺序问题)</p>
<h4 id="and-结合"><a href="#and-结合" class="headerlink" title="and 结合"></a>and 结合</h4><p>上面的两个<code>@media</code> 我其实可以用 <code>and</code> 结合起来。则表示 必须满足 我结合的这些 <code>@media</code> 的所有条件，才会执行 <code>@media</code> 里面的内容</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-selector-class">.title</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">6rem</span>;<br>&#125;<br><span class="hljs-selector-class">.subtitle</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">4rem</span>;<br>&#125;<br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">orientation</span>:landscape) <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">500px</span>)&#123;<br>  <span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">color</span>: green<br>  &#125;<br>  <span class="hljs-selector-class">.title</span> &#123;<br>    <span class="hljs-attribute">color</span>: purple<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-28-at-9.52.55-PM.gif" alt="and"></p>
<h4 id="表示或者"><a href="#表示或者" class="headerlink" title=", 表示或者"></a>, 表示或者</h4><p><code>and</code>是要求所有@media 联系的条件都要满足才行，而 <code>,</code> 是或者的意思，即只要满足其中一个@media 的条件就可以执行</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-selector-class">.title</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">6rem</span>;<br>&#125;<br><span class="hljs-selector-class">.subtitle</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">4rem</span>;<br>&#125;<br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">orientation</span>:landscape), (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">500px</span>)&#123;<br>  <span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">color</span>: green<br>  &#125;<br>  <span class="hljs-selector-class">.title</span> &#123;<br>    <span class="hljs-attribute">color</span>: purple<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-28-at-9.57.07-PM.gif" alt=","></p>
<blockquote>
<p>事实上，我们常用的就 <code>min-width</code> <code>max-width</code> <code>orientation</code> 这几种属性</p>
</blockquote>
]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS Units</title>
    <url>/2021/11/08/CSS-Units/</url>
    <content><![CDATA[<p>一篇文章解决 <code>px</code>、<code>%</code>、<code>vh</code>、<code>vw</code>、<code>em</code>、<code>rem</code> 这些 css 常用单位</p>
<h4 id="最简单的单位：px-VS"><a href="#最简单的单位：px-VS" class="headerlink" title="最简单的单位：px VS %"></a>最简单的单位：<code>px</code> VS <code>%</code></h4><p>px 是一个绝对单位，无论在什么情况下，1px 的大小一定是固定的<br>% 是一个相对单位，1%的大小是相对它的父元素的</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/* html文件 */</span><br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box fifty-percent&quot;</span>&gt;<span class="hljs-number">50</span>%&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box one-hundred-pixels&quot;</span>&gt;<span class="hljs-number">100</span>px&lt;/<span class="hljs-keyword">div</span>&gt;<br><br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box fifty-percent&quot;</span>&gt;<span class="hljs-number">50</span>%&lt;<span class="hljs-regexp">/div&gt;   /</span>* 这里的百分比是相对于父元素的大小 */<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box one-hundred-pixels&quot;</span>&gt;<span class="hljs-number">100</span>px&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* css文件 */</span><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">hsl</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100%</span>, <span class="hljs-number">50%</span>);<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid;<br>&#125;<br><br><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid;<br>&#125;<br><br><span class="hljs-selector-class">.fifty-percent</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;<br>&#125;<br><br><span class="hljs-selector-class">.one-hundred-pixels</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-08-at-11.15.20-PM.png" alt="px和%"></p>
<h4 id="vw-和-vh"><a href="#vw-和-vh" class="headerlink" title="vw 和 vh"></a><code>vw</code> 和 <code>vh</code></h4><p><code>1vw</code>等于当前所在的屏幕宽度的 <strong>1/100</strong><br><code>1vh</code>等于当前所在的屏幕高度的 <strong>1/100</strong></p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/* html文件 */</span><br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box fifty-percent&quot;</span>&gt;<span class="hljs-number">50</span>%&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box fifty-vw&quot;</span>&gt;<span class="hljs-number">50</span>vw&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box twenty-five-vh&quot;</span>&gt;<span class="hljs-number">25</span>vh&lt;/<span class="hljs-keyword">div</span>&gt;<br><br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box fifty-percent&quot;</span>&gt;<span class="hljs-number">50</span>%&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box fifty-vw&quot;</span>&gt;<span class="hljs-number">50</span>vw&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box twenty-five-vh&quot;</span>&gt;<span class="hljs-number">25</span>vh&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* css文件 */</span><br><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid;<br>&#125;<br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">hsl</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100%</span>, <span class="hljs-number">50%</span>);<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid;<br>&#125;<br><br><span class="hljs-selector-class">.fifty-percent</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;<br>&#125;<br><br><span class="hljs-selector-class">.fifty-vw</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">50vw</span>;<br>&#125;<br><br><span class="hljs-selector-class">.twenty-five-vh</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">25vh</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-08-at-11.25.56-PM.gif" alt="vh&amp;vw"></p>
<p>可见，无论当前页面如何放大或缩小。50vw 就一定是当前页面的 50%的宽度。25vh 就一定是当前页面的 25%的高度<br>这两者都不受<strong>父元素</strong>的影响</p>
<h4 id="有点难度的单位：rem-和-em"><a href="#有点难度的单位：rem-和-em" class="headerlink" title="有点难度的单位：rem 和 em"></a>有点难度的单位：rem 和 em</h4><p>首先，rem 和 em 都是<strong>相对单位</strong></p>
<p><strong>注意：</strong><br><code>rem</code>是相对 root 的<code>font-size</code>的大小<br><code>em</code>是相对自身元素的<code>font-size</code>的大小</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/* html文件 */</span><br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;one-rem&quot;</span>&gt;<span class="hljs-number">1</span>rem&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;one-em&quot;</span>&gt;<span class="hljs-number">1</span>em&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;two-rem&quot;</span>&gt;<span class="hljs-number">2</span>rem&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;two-em&quot;</span>&gt;<span class="hljs-number">2</span>em&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;hr&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;one-rem&quot;</span>&gt;<span class="hljs-number">1</span>rem&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;one-em&quot;</span>&gt;<span class="hljs-number">1</span>em&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;two-rem&quot;</span>&gt;<span class="hljs-number">2</span>rem&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;two-em&quot;</span>&gt;<span class="hljs-number">2</span>em&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* css文件 */</span><br><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">30px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid;<br>&#125;<br><br><span class="hljs-selector-class">.one-em</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1em</span>;<br>&#125;<br><br><span class="hljs-selector-class">.one-rem</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1rem</span>;<br>&#125;<br><br><span class="hljs-selector-class">.two-em</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2em</span>;<br>&#125;<br><br><span class="hljs-selector-class">.two-rem</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2rem</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-08-at-11.44.58-PM.png" alt="em&amp;rem"></p>
<p>事实上，root 元素的默认<code>font-size</code>是<code>16px</code>。对于分界线上面的字体大小，都是根据 root 来安排的大小。但是，分界线后面的字体大小。<code>rem</code>是根据<code>root</code>的 <code>font-size</code>，<code>em</code>是根据父元素的 <code>font-size</code><br>(上面说的有误：em是根据自身元素来判定的)<br>如果 root 中<code>font-size</code>是<code>16px</code>, 则在任何位置：<code>font-size: 1rem === font-size: 16px</code><br>如果 root 中<code>font-size</code>是<code>16px</code>, 某一个父元素的<code>font-size: 20px</code>,则子元素的：<code>font-size: 1em === font-size: 20px</code></p>
<p>所以，建议主要使用<code>rem</code>。因为<code>em</code>在嵌套的 font-size 中是非常难以把控的…</p>
<p>有时候为了方便控制字体大小和使用 rem，会这样做</p>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">62.5%</span>;    <span class="hljs-comment">// 16 * 62.5% = 10px  这样 1rem === 10px</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<p>当然，<code>rem</code>、<code>em</code>虽说是根据<code>font-size</code>的大小来定义的。但同样能作为盒子的长和宽的单位</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/* html文件 */</span><br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;icon-container&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;icon em-icon&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;span&gt;<span class="hljs-number">1</span>em icon&lt;/span&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;icon-container&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;icon rem-icon&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;span&gt;<span class="hljs-number">1</span>rem icon&lt;/span&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;icon-container large&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;icon em-icon&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;span&gt;<span class="hljs-number">1</span>em icon&lt;/span&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;icon-container large&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;icon rem-icon&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;span&gt;<span class="hljs-number">1</span>rem icon&lt;/span&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br><br><span class="hljs-comment">/* css文件 */</span><br><br>.icon-container.large &#123;<br>  font-<span class="hljs-keyword">size</span>: <span class="hljs-number">30</span>px;<br>&#125;<br><br>.em-icon &#123;<br>  width: <span class="hljs-number">1</span>em;<br>  height: <span class="hljs-number">1</span>em;<br>&#125;<br><br>.rem-icon &#123;<br>  width: <span class="hljs-number">1</span>rem;<br>  height: <span class="hljs-number">1</span>rem;<br>&#125;<br><br>.icon &#123;<br>  background-color: red;<br>&#125;<br><br>.parent &#123;<br>  font-<span class="hljs-keyword">size</span>: <span class="hljs-number">30</span>px;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-09-at-11.43.51-AM.png" alt="em和rem在盒子上的效果"></p>
<p>可见，<code>1rem</code>的 icon 效果无论在哪都一样，但是<code>em</code>的 icon 会根据父元素的<code>font-size</code>的大小而做出相应的改变…</p>
<p>有上述代码其实我们可以知道：<br><code>em</code> 最好用于规定盒子的大小，而不是用来控制字体的大小<br><code>rem</code>确恰恰适合规定字体的大小…</p>
<h4 id="font-size-的-单位"><a href="#font-size-的-单位" class="headerlink" title="font-size 的%单位"></a>font-size 的%单位</h4><p>在文章的上面我已讲述了，<code>%</code>是根据父元素来进行比较大小的。而<code>em</code>同样如此。事实上，<code>font-size</code>中使用<code>%</code>单位和使用<code>em</code>单位效果是一样的</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/* html文件 */</span><br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;two-rem&quot;</span>&gt;<span class="hljs-number">2</span>rem&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;two-em&quot;</span>&gt;<span class="hljs-number">2</span>em&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;two-hundred&quot;</span>&gt;<span class="hljs-number">200</span>%&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;hr&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;two-rem&quot;</span>&gt;<span class="hljs-number">2</span>rem&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;two-em&quot;</span>&gt;<span class="hljs-number">2</span>em&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;two-hundred&quot;</span>&gt;<span class="hljs-number">200</span>%&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br><br><span class="hljs-comment">/* css文件 */</span><br>.parent &#123;<br>  font-<span class="hljs-keyword">size</span>: <span class="hljs-number">30</span>px;<br>&#125;<br><br>.two-em &#123;<br>  font-<span class="hljs-keyword">size</span>: <span class="hljs-number">2</span>em;<br>&#125;<br><br>.two-rem &#123;<br>  font-<span class="hljs-keyword">size</span>: <span class="hljs-number">2</span>rem;<br>&#125;<br><br>.two-hundred &#123;<br>  font-<span class="hljs-keyword">size</span>: <span class="hljs-number">200</span>%;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-09-at-11.52.38-AM.png" alt="em VS %"></p>
<p>可见，<code>1em === 100%</code></p>
<h4 id="更多关于-css-units-内容细节"><a href="#更多关于-css-units-内容细节" class="headerlink" title="更多关于 css units 内容细节"></a>更多关于 css units 内容细节</h4><p><code>imooc网</code> 西门老舅 第六章有相关具体解析…</p>
]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS Position</title>
    <url>/2021/11/07/CSS-Position/</url>
    <content><![CDATA[<p><code>position</code> 是 <code>css</code> 中一个非常重要的属性。它的作用是将元素在网页中定位。而设定值总共有 5 个。分别是 <code>static</code>、<code>absolute</code>、<code>relative</code>、<code>fixed</code> 以及 <code>sticky</code></p>
<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p><code>HTML</code> 里面所有元素的 <code>position</code> 默认值都是 <code>static</code></p>
<p><code>static</code> 会跟随 HTML 排版的流程(flow)移动(最常见的 HTML 排版格式)(元素从上到下，非重叠的排列)<br><code>static</code>的元素对于 top、left、right、bottom 设定值不会生效</p>
<p>例子代码：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">/* html文件 */</span><br>&lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;parent&quot;</span>&gt;<br>  Parent<br>  &lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;child-one child&quot;</span>&gt;<br>    One<br>  &lt;/div&gt;<br>  &lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;child-two child&quot;</span>&gt;<br>    Two<br>  &lt;/div&gt;<br>  &lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;child-three child&quot;</span>&gt;<br>    Three<br>  &lt;/div&gt;<br>&lt;/div&gt;<br><br><span class="hljs-comment">/* css文件 */</span><br><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span>;<br>  <span class="hljs-attribute">background-color</span>: hsl(<span class="hljs-number">200</span>, <span class="hljs-number">80%</span>, <span class="hljs-number">50%</span>);<br>&#125;<br><br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.child-one</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: hsl(<span class="hljs-number">0</span>, <span class="hljs-number">80%</span>, <span class="hljs-number">50%</span>);<br>&#125;<br><br><span class="hljs-selector-class">.child-two</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: hsl(<span class="hljs-number">50</span>, <span class="hljs-number">80%</span>, <span class="hljs-number">50%</span>);<br>&#125;<br><br><span class="hljs-selector-class">.child-three</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: hsl(<span class="hljs-number">100</span>, <span class="hljs-number">80%</span>, <span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>效果显示：<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-07-at-1.06.35-PM.72mf9nnxe9k0.png" alt="static效果"></p>
<h5 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h5><p><code>relative</code> 也会跟随 HTML 排版的流程(flow)移动。<strong>但是它比<code>static</code>多了 top、left、right、bottom 的设定。</strong><br>并且使用 relative 的模块的位置移动不影响其他模块(如果是使用了位置移动，则该模块脱离了文档流，似乎不太纯粹…)</p>
<blockquote>
<p>注意点：<code>relative</code> 事实上<strong>最好不要使用</strong>位置的移动，不然容易造成显示的混乱</p>
</blockquote>
<p>除此之外，**<code>relative</code>最重要的一个功能是在它里面的<code>absolute</code>元素会根据<code>relative</code>的位置去定位**</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* css文件 */</span><br>// 其余代码部分和上述一样<br><br><span class="hljs-selector-class">.child-one</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">hsl</span>(<span class="hljs-number">0</span>, <span class="hljs-number">80%</span>, <span class="hljs-number">50%</span>);<br>  <span class="hljs-comment">/*  进行relative操作  */</span><br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">5px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-07-at-1.11.21-PM.1bun6g5kxrwg.png" alt="relative效果"></p>
<h5 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h5><p>现在来看一下代码：<br>(其余代码和 static 那节没有变化)</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.child-one</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">hsl</span>(<span class="hljs-number">0</span>, <span class="hljs-number">80%</span>, <span class="hljs-number">50%</span>);<br>  <span class="hljs-attribute">position</span>: absolute;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-07-at-1.24.10-PM.3bbsxkssqvi0.png" alt="absolute效果1"></p>
<p>可见，<code>One</code> 这个<code>div元素</code>失去了宽度。原因是，<code>absolute</code>属性完完全全的让当前元素脱离了文档流, 对于其他没有设置为<code>absolute</code>的元素来说，<code>One</code>这个元素好似不存在！</p>
<blockquote>
<p><strong>注意点</strong>：事实上,我上面已说，<code>relative</code>不适合用位置移动。而<code>absolute</code>却是<strong>非常适合</strong>使用位置移动的！！</p>
</blockquote>
<p><code>absolute</code>这种方式会非常方便在你想在某个位置固定住一个元素，而其他元素不会影响这个被固定住的元素 (完全脱离文档流 + 位置的移动)</p>
<blockquote>
<p>还有一个<strong>注意点</strong>：absolute 的位置移动是相对于父元素的(非 static、absolute)。如果父元素是(static、absolute)的，则会进行找父元素的父元素进行看是否符合条件(非 static、absolute)。如果都不符合条件，则根据最顶层元素来进行位置的移动…</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.child-one</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">hsl</span>(<span class="hljs-number">0</span>, <span class="hljs-number">80%</span>, <span class="hljs-number">50%</span>);<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-07-at-1.39.17-PM.4d2dsj8a49w.png" alt="absolute效果2"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">hsl</span>(<span class="hljs-number">200</span>, <span class="hljs-number">80%</span>, <span class="hljs-number">50%</span>);<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.child-one</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">hsl</span>(<span class="hljs-number">0</span>, <span class="hljs-number">80%</span>, <span class="hljs-number">50%</span>);<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-07-at-1.41.30-PM.5stck9to3m00.png" alt="absolute效果3"></p>
<p><strong>(absolute + relative 是绝配)</strong></p>
<h5 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h5><p><code>fixed</code> 与 <code>absolute</code> 很相似。不同的地方有以下两个</p>
<ol>
<li><code>fixed</code> 会定位到荧幕中的固定位置。所以即使卷动页面，也会一直保持在那个位置</li>
<li>即使放在<code>relative</code>页面，<code>fixed</code>元素也会根据页面，即 body 去定位，不会根据 relative 去定位(这是要在 fiex 设定了 top、left、right、bottom 等属性时才会出现的效果)</li>
</ol>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/* HTML文件 */</span><br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;<br>  Parent<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;child-one child&quot;</span>&gt;<br>    One<br>  &lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;child-two child&quot;</span>&gt;<br>    Two<br>  &lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;child-three child&quot;</span>&gt;<br>    Three<br>  &lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt; * <span class="hljs-number">100</span><br>&lt;/<span class="hljs-keyword">div</span>&gt;<br><br><span class="hljs-comment">/* css文件 */</span><br>.child-one &#123;<br>  background-color: hsl(<span class="hljs-number">0</span>, <span class="hljs-number">80</span>%, <span class="hljs-number">50</span>%);<br>  position: fixed;<br>  bottom: <span class="hljs-number">10</span>px;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-07-at-1.59.31-PM.5f6b4g3m13w0.gif" alt="fixed效果显示"></p>
<p>如果是 <code>absolute</code>。<code>absolute</code> 元素所在的容器(父元素)有卷轴的话，它就会随着卷动而移动<br><strong>(这是 fixed 和 absolute 二者最大的不同)</strong></p>
<h4 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a>sticky</h4><p>sticky 是完美结合了 <code>relative</code> 和 <code>fixed</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* css文件 */</span><br><span class="hljs-selector-class">.child-one</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">hsl</span>(<span class="hljs-number">0</span>, <span class="hljs-number">80%</span>, <span class="hljs-number">50%</span>);<br>  <span class="hljs-attribute">position</span>: sticky;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>外表看似和 relative 效果差不多。可真正滚动滑条的时候就大大的不同了<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-07-at-2.11.58-PM.4gp9o7g2tf60.gif" alt="sticky效果"></p>
<h5 id="sticky-效果图"><a href="#sticky-效果图" class="headerlink" title="sticky 效果图"></a>sticky 效果图</h5><p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-07-at-4.45.31-PM.3ysiy6q3te40.gif" alt="sticky效果图1"><br><a href="https://codepen.io/bruce-shuai/pen/yLoKqqR?editors=1100">对应代码</a></p>
]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS-in-JS</title>
    <url>/2021/10/10/CSS-in-JS/</url>
    <content><![CDATA[<blockquote>
<p>注意：css 模块与 webpack 的相关内容有待补充！</p>
</blockquote>
<p><code>CSS-in-JS</code> 不是指某一个具体的库，是指<strong>组织 CSS 代码的一种方式</strong>，代表库有 <a href="https://styled-components.com/">styled-component</a> 和 <a href="https://emotion.sh/docs/introduction">emotion</a>。</p>
<h4 id="传统-CSS-的缺陷"><a href="#传统-CSS-的缺陷" class="headerlink" title="传统 CSS 的缺陷"></a>传统 CSS 的缺陷</h4><ol>
<li><p>缺乏模块组织<br>在传统的 JS 和 CSS 中其实都没有<strong>模块</strong>的概念，后来在 JS 界陆续有了 CommonJS 和 ECMAScript Module, 以及<code>webpack</code>为主的模块打包工具渐渐的成熟。而<code>CSS-in-JS</code>就可以用<strong>模块化的方式</strong>组织 CSS，<strong>依托与 JS 的模块化方案</strong>。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> styled <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@emotion/styled&#x27;</span>;<br><br><span class="hljs-comment">// styled 其实就是一个模块</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Button = styled.button<span class="hljs-string">`</span><br><span class="hljs-string"> color: turquoise;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure></li>
<li><p>缺乏作用域<br>传统的 <code>CSS</code> 只有一个<code>全局作用域</code>，比如说一个 class 可以匹配全局的任意元素。随着项目成长，CSS 会变得越来越难以组织，最终导致失控。<code>CSS-in-JS</code> 可以通过生成独特的选择符，来实现作用域的效果。</p>
</li>
</ol>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.css-1c4ktv6</span> &gt;* &#123;   <span class="hljs-comment">// 1c4ktv6是哈希</span><br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">0</span> <span class="hljs-meta">!important</span>;<br>  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">0</span> <span class="hljs-meta">!important</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> css = <span class="hljs-function"><span class="hljs-params">styleBlock</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> className = someHash(styleBlock);<br>  <span class="hljs-keyword">const</span> styleEl = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;style&#x27;</span>);<br>  styleEl.textContent = <span class="hljs-string">`</span><br><span class="hljs-string">    .<span class="hljs-subst">$&#123;className&#125;</span> &#123;</span><br><span class="hljs-string">      <span class="hljs-subst">$&#123;styleBlock&#125;</span></span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">  `</span>;<br>  <span class="hljs-built_in">document</span>.head.appendChild(styleEl);<br>  <span class="hljs-keyword">return</span> className;<br>&#125;<br><span class="hljs-keyword">const</span> className = css(<span class="hljs-string">`</span><br><span class="hljs-string">  color: red;</span><br><span class="hljs-string">  padding: 20px;</span><br><span class="hljs-string">`</span>);<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>隐式依赖，让样式难以追踪</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-class">.target</span> <span class="hljs-selector-class">.name</span> <span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><br><span class="hljs-selector-tag">body</span> <span class="hljs-selector-id">#container</span> <span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">color</span>: green<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!doctype <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;container&#x27;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;target&#x27;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;name&#x27;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是啥颜色？<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    // 这会让人懵逼的...<br>     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>那么这个 h1 元素最终显式为什么颜色？加入你想要追踪这个影响这个 h1 的样式，怎么追踪？</p>
<p>而 CSS-in-JS 的方案就简单直接、易于追踪：</p>
<figure class="highlight hsp"><table><tr><td class="code"><pre><code class="hljs hsp">export const <span class="hljs-keyword">Title</span> = styled.h1`<br>  <span class="hljs-keyword">color</span>: green<span class="hljs-comment">;</span><br>`<br>&lt;<span class="hljs-keyword">Title</span>&gt;<br>  我是啥颜色？<br>&lt;/<span class="hljs-keyword">Title</span>&gt;<br></code></pre></td></tr></table></figure>

<ol start="4">
<li><p>没有变量<br>传统的 CSS 规则里没有变量…(其实有–var 变量)，但是在 CSS-in-JS 中可以方便地控制变量：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">const</span> Container = styled.<span class="hljs-keyword">div</span>(props =&gt; (&#123;<br> <span class="hljs-keyword">display</span>: <span class="hljs-string">&#x27;flex&#x27;</span>,<br> flexDirection: props.column &amp;&amp; <span class="hljs-string">&#x27;column&#x27;</span><br>&#125;))<br></code></pre></td></tr></table></figure></li>
<li><p>CSS 选择器与 HTML 元素高度耦合</p>
</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-class">.target</span> <span class="hljs-selector-class">.name</span> <span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-selector-tag">body</span> <span class="hljs-selector-id">#container</span> <span class="hljs-selector-tag">h1</span> &#123;<br>    <span class="hljs-attribute">color</span>: green<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!doctype <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;container&#x27;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;target&#x27;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;name&#x27;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是啥颜色？<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>如果你想把 h1 改成 h2，必须要同时改动 CSS 和 HTML。而在 CSS-in-JS 中，HTML 和 CSS 是结合在一起的，易于修改。(这其实是在程序层次上需要极力去避免的…)</p>
<hr>
<h4 id="Emotion-介绍"><a href="#Emotion-介绍" class="headerlink" title="Emotion 介绍"></a>Emotion 介绍</h4><p>Emotion 是目前最受欢迎的 CSS-in-JS 库之一，它还对 React 作了很好的适应，可以方便地创建 styled component，也支持写行内样式：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/** @jsx jsx */</span><br><span class="hljs-keyword">import</span> &#123; jsx &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@emotion/react&#x27;</span>;<br><br>render(<br>  &lt;<span class="hljs-keyword">div</span><br>    css=&#123;&#123;<br>      backgroundColor: <span class="hljs-string">&#x27;hotpink&#x27;</span>,<br>      <span class="hljs-string">&#x27;&amp;:hover&#x27;</span>: &#123;<br>        color: <span class="hljs-string">&#x27;lightgreen&#x27;</span><br>      &#125;<br>    &#125;&#125;<br>  &gt;<br>    <span class="hljs-keyword">This</span> has a hotpink background.<br>  &lt;/<span class="hljs-keyword">div</span>&gt;<br><br>)<br></code></pre></td></tr></table></figure>

<p>这种写法比起 React 自带的 style 的写法功能更强大，比如可以处理级联、伪类等 style 处理的不了的情况：</p>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">color:</span> <span class="hljs-string">&quot;red&quot;</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&gt;</span>&#123;keyword&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<p><strong>我感觉，好像 tailwindcss 没有 emotion 这样更接近组件化编程的思想</strong></p>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 神奇属性</title>
    <url>/2021/11/28/CSS-%E7%A5%9E%E5%A5%87%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h4 id="text-overflow"><a href="#text-overflow" class="headerlink" title="text-overflow"></a>text-overflow</h4><h4 id="white-space"><a href="#white-space" class="headerlink" title="white-space"></a>white-space</h4><h4 id="text-shadow"><a href="#text-shadow" class="headerlink" title="text-shadow"></a>text-shadow</h4><h4 id="inset"><a href="#inset" class="headerlink" title="inset"></a>inset</h4><figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-attribute">position</span>: absolute;<br>inset: <span class="hljs-number">0</span>; <span class="hljs-comment">/* 等同于：top、right、bottom、left 全部为0 */</span><br></code></pre></td></tr></table></figure>

<h4 id="object-fit"><a href="#object-fit" class="headerlink" title="object-fit"></a>object-fit</h4><h4 id="object-position"><a href="#object-position" class="headerlink" title="object-position"></a>object-position</h4><h4 id="list-style"><a href="#list-style" class="headerlink" title="list-style"></a>list-style</h4><h4 id="focus-vs-active"><a href="#focus-vs-active" class="headerlink" title=":focus vs :active"></a>:focus vs :active</h4><p><code>:focus</code> 表示 你点击了该元素，元素一直保持某一种状态。除非你点击其他部分。保持的状态才会消退</p>
<p><code>:active</code> 表示 你点击某元素的时候，你要你不松开鼠标，则元素一直会维持着一种状态</p>
<h4 id="letter-spacing"><a href="#letter-spacing" class="headerlink" title="letter-spacing"></a>letter-spacing</h4><p>控制文本中字符与字符之间的距离</p>
]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS-继承</title>
    <url>/2021/12/10/CSS-%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h3 id="initial"><a href="#initial" class="headerlink" title="initial"></a>initial</h3><h3 id="inherit"><a href="#inherit" class="headerlink" title="inherit"></a>inherit</h3><h3 id="unset"><a href="#unset" class="headerlink" title="unset"></a>unset</h3><h3 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h3>]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 选择器</title>
    <url>/2021/11/29/CSS-%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<h4 id="最基本的选择器"><a href="#最基本的选择器" class="headerlink" title="最基本的选择器"></a>最基本的选择器</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">* 通配符选择器<br>标签选择器<br><span class="hljs-keyword">class</span>选择器<br><span class="hljs-symbol">id</span>选择器<br></code></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">/* html */</span><br>&lt;div&gt;This <span class="hljs-keyword">is</span> a div&lt;/div&gt;<br>&lt;span id=<span class="hljs-string">&quot;green&quot;</span>&gt;This <span class="hljs-keyword">is</span> a span&lt;/span&gt;<br>&lt;ul&gt;<br>  &lt;li <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">purple</span>&quot;&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">1</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">2</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">purple</span>&quot;&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">3</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">4</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>&lt;/<span class="hljs-symbol">ul</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">/* css */</span><br><span class="hljs-comment">/* 此选择器影响所有元素: 通配符选择器 */</span><br>* &#123;<br>  <span class="hljs-built_in">background</span>-<span class="hljs-built_in">color</span>: <span class="hljs-built_in">red</span>;<br>&#125;<br><br><span class="hljs-comment">/* 选择独立的元素: 标签选择器 */</span><br><span class="hljs-comment">/* 影响div标签 */</span><br>div &#123;<br>  <span class="hljs-built_in">background</span>-<span class="hljs-built_in">color</span>: yellow;<br>&#125;<br><br><span class="hljs-comment">/* 影响li标签 */</span><br>li &#123;<br>  <span class="hljs-built_in">background</span>-<span class="hljs-built_in">color</span>: <span class="hljs-built_in">blue</span>;<br>&#125;<br><br><span class="hljs-comment">/* class选择器 非常常用，因为威力大 */</span><br>.purple &#123;<br>  <span class="hljs-built_in">background</span>-<span class="hljs-built_in">color</span>: purple;<br>&#125;<br><br><span class="hljs-comment">/* id选择器(因为一个id选择器只能作用在一个地方“威力太小”，所以不太常用) */</span><br>#<span class="hljs-built_in">green</span> &#123;<br>  <span class="hljs-built_in">background</span>-<span class="hljs-built_in">color</span>: <span class="hljs-built_in">green</span>;<br>&#125;<br><br><span class="hljs-comment">/* 注意！选择器受位置影响，放置在下面的选择器会覆盖上面的选择器(在选择器所支配的属性是一样的情况下) */</span><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-29-at-9.02.25-AM.png" alt="基本选择器"></p>
<h4 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h4><h5 id="限制-class-的使用范围"><a href="#限制-class-的使用范围" class="headerlink" title="限制 class 的使用范围"></a>限制 class 的使用范围</h5><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">/* html */<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;red blue-text&quot;</span>&gt;</span>This is a div<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span>This is a div<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>This is a div too<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>This is a span<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span>Item 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">/* css */</span><br><span class="hljs-comment">/* 只想div标签中带red这个class名的受影响(注意，结合的时候没有空格,且div在class名前面) */</span><br>div.<span class="hljs-built_in">red</span>.<span class="hljs-built_in">blue</span>-<span class="hljs-built_in">text</span> &#123;<br>  <span class="hljs-built_in">background</span>-<span class="hljs-built_in">color</span>: <span class="hljs-built_in">red</span>;<br>  <span class="hljs-built_in">color</span>: <span class="hljs-built_in">blue</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-29-at-9.11.22-AM.png" alt="限制class"></p>
<h5 id="多个选择器一起使用"><a href="#多个选择器一起使用" class="headerlink" title="多个选择器一起使用"></a>多个选择器一起使用</h5><p>(一起使用只需要一个 <code>,</code> 就可以了)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">/* html */<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;red blue-text&quot;</span>&gt;</span>This is a div<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span>This is a div<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>This is a div too<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>This is a span<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span>Item 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* css */</span><br><span class="hljs-selector-tag">span</span>,<br><span class="hljs-selector-tag">li</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br><br><span class="hljs-comment">/* 下面的选择器会覆盖上面选择器的部分内容 */</span><br><span class="hljs-selector-tag">span</span>,<br><span class="hljs-selector-tag">li</span><span class="hljs-selector-class">.red</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: yellow;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-29-at-9.19.13-AM.png" alt="多个选择器一起使用"></p>
<p><strong>(说明：下面说的父选择器和子选择器只是为了方便理解嵌套关系，而非真的有父选择器、子选择器、子子孙孙选择器)</strong></p>
<h5 id="使用嵌套选择器"><a href="#使用嵌套选择器" class="headerlink" title="使用嵌套选择器"></a>使用嵌套选择器</h5><p>(父选择器 子子孙孙选择器) –&gt; 选择器类型是不限的 只要是选择器之间嵌套即可</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">/* html */</span><br>&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">red</span>&quot;&gt;<span class="hljs-symbol">This</span> <span class="hljs-symbol">is</span> <span class="hljs-symbol">a</span> <span class="hljs-symbol">div</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;<span class="hljs-symbol">div</span>&gt;<br>  &lt;<span class="hljs-symbol">span</span>&gt;<br>    &lt;<span class="hljs-symbol">b</span>&gt;<span class="hljs-symbol">nexted</span> <span class="hljs-symbol">text</span>&lt;/<span class="hljs-symbol">b</span>&gt;<br>  &lt;/<span class="hljs-symbol">span</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;<span class="hljs-symbol">ul</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">red</span>&quot;&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">1</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">2</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">3</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">4</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>&lt;/<span class="hljs-symbol">ul</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* css */</span><br><span class="hljs-comment">/* 有空格，这里表示获取ul的子元素 li */</span><br><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><br><span class="hljs-comment">/* b是div的子子孙孙*/</span><br><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">b</span> &#123;<br>  <span class="hljs-attribute">color</span>: green;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-29-at-9.25.59-AM.png" alt="嵌套选择器"></p>
<h5 id="直接后代选择器"><a href="#直接后代选择器" class="headerlink" title="直接后代选择器"></a>直接后代选择器</h5><p>(父选择器 &gt; 子选择器) –&gt; 父选择器是子选择器(不是子子孙孙选择器)</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">/* html */</span><br>&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">red</span>&quot;&gt;<span class="hljs-symbol">This</span> <span class="hljs-symbol">is</span> <span class="hljs-symbol">a</span> <span class="hljs-symbol">div</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;<span class="hljs-symbol">div</span>&gt;<br>  &lt;<span class="hljs-symbol">span</span>&gt;<br>    &lt;<span class="hljs-symbol">b</span>&gt;<span class="hljs-symbol">nexted</span> <span class="hljs-symbol">text</span>&lt;/<span class="hljs-symbol">b</span>&gt;<br>  &lt;/<span class="hljs-symbol">span</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;<span class="hljs-symbol">ul</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">red</span>&quot;&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">1</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">2</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">3</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">4</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>&lt;/<span class="hljs-symbol">ul</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* css */</span><br><span class="hljs-comment">/* b标签选择器是span标签选择器的子选择器 */</span><br><span class="hljs-selector-tag">span</span> &gt; <span class="hljs-selector-tag">b</span> &#123;<br>  <span class="hljs-attribute">color</span>: purple;<br>&#125;<br><br><span class="hljs-comment">/* b标签不会显绿色字体，只会显紫色 因为b标签选择器不是div选择器的子选择器 */</span><br><span class="hljs-selector-tag">div</span> &gt; <span class="hljs-selector-tag">b</span> &#123;<br>  <span class="hljs-attribute">color</span>: green;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-29-at-9.35.29-AM.png" alt="效果图"></p>
<h5 id="兄弟姐妹选择器"><a href="#兄弟姐妹选择器" class="headerlink" title="兄弟姐妹选择器"></a>兄弟姐妹选择器</h5><p><strong>~ 选择器</strong> A ~ B (A 和 B 是同层级的选择器, A 后面的 B 类型选择器会受到影响)</p>
<p>示例一：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">/* html */</span><br>&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">red</span>&quot;&gt;<span class="hljs-symbol">This</span> <span class="hljs-symbol">is</span> <span class="hljs-symbol">a</span> <span class="hljs-symbol">div</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;<span class="hljs-symbol">div</span>&gt;<br>  &lt;<span class="hljs-symbol">span</span>&gt;<br>    &lt;<span class="hljs-symbol">b</span>&gt;<span class="hljs-symbol">nexted</span> <span class="hljs-symbol">text</span>&lt;/<span class="hljs-symbol">b</span>&gt;<br>  &lt;/<span class="hljs-symbol">span</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;<span class="hljs-symbol">ul</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">red</span>&quot;&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">1</span>&lt;/<span class="hljs-symbol">li</span>&gt;  // 注意观察位置<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">2</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">3</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">4</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>&lt;/<span class="hljs-symbol">ul</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* css */</span><br><span class="hljs-comment">/* li.red 后面的兄弟姐妹会受到影响 */</span><br><span class="hljs-selector-tag">li</span><span class="hljs-selector-class">.red</span> ~ <span class="hljs-selector-tag">li</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-29-at-9.40.47-AM.png" alt="~选择器1"></p>
<p>示例 2：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">/* html */</span><br>&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">red</span>&quot;&gt;<span class="hljs-symbol">This</span> <span class="hljs-symbol">is</span> <span class="hljs-symbol">a</span> <span class="hljs-symbol">div</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;<span class="hljs-symbol">div</span>&gt;<br>  &lt;<span class="hljs-symbol">span</span>&gt;<br>    &lt;<span class="hljs-symbol">b</span>&gt;<span class="hljs-symbol">nexted</span> <span class="hljs-symbol">text</span>&lt;/<span class="hljs-symbol">b</span>&gt;<br>  &lt;/<span class="hljs-symbol">span</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;<span class="hljs-symbol">ul</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">1</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">red</span>&quot;&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">2</span>&lt;/<span class="hljs-symbol">li</span>&gt;  // 注意观察位置<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">3</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">4</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>&lt;/<span class="hljs-symbol">ul</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* css */</span><br><span class="hljs-comment">/* li.red 后面的兄弟姐妹会受到影响 */</span><br><span class="hljs-selector-tag">li</span><span class="hljs-selector-class">.red</span> ~ <span class="hljs-selector-tag">li</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-29-at-9.44.37-AM.png" alt="~选择器2"></p>
<h5 id="直接兄弟姐妹选择器"><a href="#直接兄弟姐妹选择器" class="headerlink" title="直接兄弟姐妹选择器"></a>直接兄弟姐妹选择器</h5><p><strong>+选择器</strong>： 所谓<strong>直接兄弟姐妹选择器</strong>即：在<strong>兄弟姐妹选择器</strong>的基础设定上再添一个设定：我只要我<strong>下一个</strong>兄弟姐妹</p>
<p>(注意：和上面的兄弟姐妹选择器比较一下)<br>示例 1：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">/* html */</span><br>&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">red</span>&quot;&gt;<span class="hljs-symbol">This</span> <span class="hljs-symbol">is</span> <span class="hljs-symbol">a</span> <span class="hljs-symbol">div</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;<span class="hljs-symbol">div</span>&gt;<br>  &lt;<span class="hljs-symbol">span</span>&gt;<br>    &lt;<span class="hljs-symbol">b</span>&gt;<span class="hljs-symbol">nexted</span> <span class="hljs-symbol">text</span>&lt;/<span class="hljs-symbol">b</span>&gt;<br>  &lt;/<span class="hljs-symbol">span</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;<span class="hljs-symbol">ul</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">red</span>&quot;&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">1</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">2</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">3</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">4</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>&lt;/<span class="hljs-symbol">ul</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* css */</span><br><span class="hljs-selector-tag">li</span><span class="hljs-selector-class">.red</span> + <span class="hljs-selector-tag">li</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-29-at-9.49.54-AM.png" alt="+选择器1"></p>
<p>示例 2：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">/* html */</span><br>&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">red</span>&quot;&gt;<span class="hljs-symbol">This</span> <span class="hljs-symbol">is</span> <span class="hljs-symbol">a</span> <span class="hljs-symbol">div</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;<span class="hljs-symbol">div</span>&gt;<br>  &lt;<span class="hljs-symbol">span</span>&gt;<br>    &lt;<span class="hljs-symbol">b</span>&gt;<span class="hljs-symbol">nexted</span> <span class="hljs-symbol">text</span>&lt;/<span class="hljs-symbol">b</span>&gt;<br>  &lt;/<span class="hljs-symbol">span</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;<span class="hljs-symbol">ul</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">1</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">red</span>&quot;&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">2</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">3</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">4</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>&lt;/<span class="hljs-symbol">ul</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* css */</span><br><span class="hljs-selector-tag">li</span><span class="hljs-selector-class">.red</span> + <span class="hljs-selector-tag">li</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-29-at-9.51.43-AM.png" alt="+选择器2"></p>
<p>示例 3：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">/* html */</span><br>&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">red</span>&quot;&gt;<span class="hljs-symbol">This</span> <span class="hljs-symbol">is</span> <span class="hljs-symbol">a</span> <span class="hljs-symbol">div</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;<span class="hljs-symbol">div</span>&gt;<br>  &lt;<span class="hljs-symbol">span</span>&gt;<br>    &lt;<span class="hljs-symbol">b</span>&gt;<span class="hljs-symbol">nexted</span> <span class="hljs-symbol">text</span>&lt;/<span class="hljs-symbol">b</span>&gt;<br>  &lt;/<span class="hljs-symbol">span</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;<span class="hljs-symbol">ul</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">1</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">red</span>&quot;&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">2</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">3</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">green</span>&quot;&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">4</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>&lt;/<span class="hljs-symbol">ul</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">/* css */</span><br><span class="hljs-comment">/* 没有效果，因为不是直接兄弟姐妹 */</span><br><span class="hljs-selector-tag">li</span><span class="hljs-selector-class">.red</span> + <span class="hljs-selector-tag">li</span><span class="hljs-selector-class">.green</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br><br><span class="hljs-comment">/* 没有效果，因为不是直接兄弟姐妹 */</span><br><span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.red</span> + <span class="hljs-selector-tag">ul</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-29-at-9.55.46-AM.png" alt="+选择器3"></p>
<h4 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h4><h5 id="hover"><a href="#hover" class="headerlink" title=":hover"></a>:hover</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">/* html */</span><br>&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">red</span>&quot;&gt;<span class="hljs-symbol">This</span> <span class="hljs-symbol">is</span> <span class="hljs-symbol">a</span> <span class="hljs-symbol">div</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;<span class="hljs-symbol">div</span>&gt;<br>  &lt;<span class="hljs-symbol">span</span>&gt;<br>    &lt;<span class="hljs-symbol">b</span>&gt;<span class="hljs-symbol">nexted</span> <span class="hljs-symbol">text</span>&lt;/<span class="hljs-symbol">b</span>&gt;<br>  &lt;/<span class="hljs-symbol">span</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;<span class="hljs-symbol">ul</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">1</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">red</span>&quot;&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">2</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">3</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">green</span>&quot;&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">4</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>&lt;/<span class="hljs-symbol">ul</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-29-at-10.09.26-AM.gif" alt=":hover"></p>
<h5 id="focus"><a href="#focus" class="headerlink" title=":focus"></a>:focus</h5><p>这个伪类一般用于 <code>input</code> 和 <code>button</code> 标签<br>效果：点击后会一直保持着某一种状态，除非点击其他地方才会取消状态</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">/* html文件 */</span><br>&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">red</span>&quot;&gt;<span class="hljs-symbol">This</span> <span class="hljs-symbol">is</span> <span class="hljs-symbol">a</span> <span class="hljs-symbol">div</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;<span class="hljs-symbol">div</span>&gt;<br>  &lt;<span class="hljs-symbol">span</span>&gt;<br>    &lt;<span class="hljs-symbol">b</span>&gt;<span class="hljs-symbol">nexted</span> <span class="hljs-symbol">text</span>&lt;/<span class="hljs-symbol">b</span>&gt;<br>  &lt;/<span class="hljs-symbol">span</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;<span class="hljs-symbol">ul</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">1</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">red</span>&quot;&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">2</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">3</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">green</span>&quot;&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">4</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>&lt;/<span class="hljs-symbol">ul</span>&gt;<br>&lt;<span class="hljs-symbol">input</span> <span class="hljs-symbol">type</span>=&quot;<span class="hljs-symbol">text</span>&quot;&gt;<br>&lt;<span class="hljs-symbol">button</span>&gt;按钮&lt;/<span class="hljs-symbol">button</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* css文件 */</span><br><span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">:focus</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br><br><span class="hljs-selector-tag">button</span><span class="hljs-selector-pseudo">:focus</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: green;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-29-at-10.14.35-AM.gif" alt=":focus"></p>
<h5 id="required"><a href="#required" class="headerlink" title=":required"></a>:required</h5><p>有种元素被选定的感觉 (似乎只能用在 <code>input</code> 标签)</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">/* html */</span><br>&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">red</span>&quot;&gt;<span class="hljs-symbol">This</span> <span class="hljs-symbol">is</span> <span class="hljs-symbol">a</span> <span class="hljs-symbol">div</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;<span class="hljs-symbol">div</span>&gt;<br>  &lt;<span class="hljs-symbol">span</span>&gt;<br>    &lt;<span class="hljs-symbol">b</span>&gt;<span class="hljs-symbol">nexted</span> <span class="hljs-symbol">text</span>&lt;/<span class="hljs-symbol">b</span>&gt;<br>  &lt;/<span class="hljs-symbol">span</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;<span class="hljs-symbol">ul</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">1</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">red</span>&quot;&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">2</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">3</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">green</span>&quot;&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">4</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>&lt;/<span class="hljs-symbol">ul</span>&gt;<br>&lt;<span class="hljs-symbol">input</span> <span class="hljs-symbol">type</span>=&quot;<span class="hljs-symbol">text</span>&quot; <span class="hljs-symbol">required</span>&gt;   // 注意这里！<br>&lt;<span class="hljs-symbol">button</span>&gt;按钮&lt;/<span class="hljs-symbol">button</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">:required</span> &#123;   // 只要有<span class="hljs-selector-tag">input</span>元素上绑定了 required 就会受到影响<br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-29-at-10.20.38-AM.png" alt=":required"></p>
<h5 id="checked"><a href="#checked" class="headerlink" title=":checked"></a>:checked</h5><p>这个选择器和<code>&lt;input type=&quot;checkbox&quot;&gt;</code>搭配</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">/* html */</span><br>&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">red</span>&quot;&gt;<span class="hljs-symbol">This</span> <span class="hljs-symbol">is</span> <span class="hljs-symbol">a</span> <span class="hljs-symbol">div</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;<span class="hljs-symbol">div</span>&gt;<br>  &lt;<span class="hljs-symbol">span</span>&gt;<br>    &lt;<span class="hljs-symbol">b</span>&gt;<span class="hljs-symbol">nexted</span> <span class="hljs-symbol">text</span>&lt;/<span class="hljs-symbol">b</span>&gt;<br>  &lt;/<span class="hljs-symbol">span</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;<span class="hljs-symbol">ul</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">1</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">red</span>&quot;&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">2</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">3</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">green</span>&quot;&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">4</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>&lt;/<span class="hljs-symbol">ul</span>&gt;<br>&lt;<span class="hljs-symbol">input</span> <span class="hljs-symbol">type</span>=&quot;<span class="hljs-symbol">checkbox</span>&quot;&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* css */</span><br><span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">:checked</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-29-at-10.23.41-AM.gif" alt=":checked"></p>
<h5 id="disabled"><a href="#disabled" class="headerlink" title=":disabled"></a>:disabled</h5><p>表示元素禁止使用</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">/* html */</span><br>&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">red</span>&quot;&gt;<span class="hljs-symbol">This</span> <span class="hljs-symbol">is</span> <span class="hljs-symbol">a</span> <span class="hljs-symbol">div</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;<span class="hljs-symbol">div</span>&gt;<br>  &lt;<span class="hljs-symbol">span</span>&gt;<br>    &lt;<span class="hljs-symbol">b</span>&gt;<span class="hljs-symbol">nexted</span> <span class="hljs-symbol">text</span>&lt;/<span class="hljs-symbol">b</span>&gt;<br>  &lt;/<span class="hljs-symbol">span</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;<span class="hljs-symbol">ul</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">1</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">red</span>&quot;&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">2</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">3</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">green</span>&quot;&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">4</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>&lt;/<span class="hljs-symbol">ul</span>&gt;<br>&lt;<span class="hljs-symbol">input</span> <span class="hljs-symbol">disabled</span> <span class="hljs-symbol">type</span>=&quot;<span class="hljs-symbol">checkbox</span>&quot;&gt;  // 注意这里<br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">:disabled</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">50px</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-29-at-8.08.48-PM.png" alt="禁止使用"></p>
<h5 id="first-child-amp-last-child-amp-nth-child"><a href="#first-child-amp-last-child-amp-nth-child" class="headerlink" title=":first-child &amp; :last-child &amp; nth-child"></a>:first-child &amp; :last-child &amp; nth-child</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">red</span>&quot;&gt;<span class="hljs-symbol">This</span> <span class="hljs-symbol">is</span> <span class="hljs-symbol">a</span> <span class="hljs-symbol">div</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;<span class="hljs-symbol">div</span>&gt;<br>  &lt;<span class="hljs-symbol">span</span>&gt;<br>    &lt;<span class="hljs-symbol">b</span>&gt;<span class="hljs-symbol">nexted</span> <span class="hljs-symbol">text</span>&lt;/<span class="hljs-symbol">b</span>&gt;<br>  &lt;/<span class="hljs-symbol">span</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;<span class="hljs-symbol">ul</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">1</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">red</span>&quot;&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">2</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">3</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">green</span>&quot;&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">4</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>&lt;/<span class="hljs-symbol">ul</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:first</span>-child &#123;<br>  <span class="hljs-attribute">background</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-29-at-8.19.59-PM.png" alt=":first-child"></p>
<p><strong>但是注意一个问题：这里的 first-child 一定是第一个子元素。如果是下面这样的操作就会出错</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">red</span>&quot;&gt;<span class="hljs-symbol">This</span> <span class="hljs-symbol">is</span> <span class="hljs-symbol">a</span> <span class="hljs-symbol">div</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;<span class="hljs-symbol">div</span>&gt;<br>  &lt;<span class="hljs-symbol">span</span>&gt;<br>    &lt;<span class="hljs-symbol">b</span>&gt;<span class="hljs-symbol">nexted</span> <span class="hljs-symbol">text</span>&lt;/<span class="hljs-symbol">b</span>&gt;<br>  &lt;/<span class="hljs-symbol">span</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;<span class="hljs-symbol">ul</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">1</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">red</span>&quot;&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">2</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">3</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">green</span>&quot;&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">4</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>&lt;/<span class="hljs-symbol">ul</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span><span class="hljs-selector-class">.red</span><span class="hljs-selector-pseudo">:first</span>-child &#123;<br>  <span class="hljs-attribute">background</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样不会有任何红色出现！因为 这里的 <code>li.red:first-child</code> 违背了第一个子元素的原则</p>
<p><strong>:last-child</strong> 道理和 <strong>:first-child</strong> 是一致的</p>
<p>如果你想选中中间的某个元素，使用 <code>:nth-child()</code>就好</p>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>n) &#123;   <span class="hljs-comment">// 选中的是偶数的li背景为红色</span><br>  <span class="hljs-attribute">background</span>: red;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-29-at-8.26.14-PM.png" alt="nth-child"></p>
<p>// TODO 还有些 nth-相关内容就暂且不想弄</p>
<h4 id="not"><a href="#not" class="headerlink" title=":not()"></a>:not()</h4><p><code>A:not(B)</code> 表示除 B 元素之外的这系列 A 元素都会受到影响</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">red</span>&quot;&gt;<span class="hljs-symbol">This</span> <span class="hljs-symbol">is</span> <span class="hljs-symbol">a</span> <span class="hljs-symbol">div</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;<span class="hljs-symbol">div</span>&gt;<br>  &lt;<span class="hljs-symbol">span</span>&gt;<br>    &lt;<span class="hljs-symbol">b</span>&gt;<span class="hljs-symbol">nexted</span> <span class="hljs-symbol">text</span>&lt;/<span class="hljs-symbol">b</span>&gt;<br>  &lt;/<span class="hljs-symbol">span</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;<span class="hljs-symbol">ul</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">1</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">red</span>&quot;&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">2</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span>&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">3</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>  &lt;<span class="hljs-symbol">li</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">green</span>&quot;&gt;<span class="hljs-symbol">Item</span> <span class="hljs-symbol">4</span>&lt;/<span class="hljs-symbol">li</span>&gt;<br>&lt;/<span class="hljs-symbol">ul</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:not</span>(.green) &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-29-at-8.31.15-PM.png" alt=":not"></p>
<h4 id="before-after"><a href="#before-after" class="headerlink" title="::before, ::after"></a>::before, ::after</h4><figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span>&gt;这是一个<span class="hljs-keyword">div</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">::before</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;Before&quot;</span>;<br>  <span class="hljs-attribute">background</span>: red;<br>&#125;<br><br><span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;After&quot;</span>;<br>  <span class="hljs-attribute">background</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-29-at-8.34.27-PM.png" alt="before&amp;after"></p>
<h4 id="data-attribute"><a href="#data-attribute" class="headerlink" title="data-attribute"></a>data-attribute</h4><p>示例一：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta">&lt;<span class="hljs-keyword">div</span> data-red&gt;这是一个<span class="hljs-keyword">div</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> data-red=<span class="hljs-string">&quot;true&quot;</span>&gt;这是一个<span class="hljs-keyword">div</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> data-red=<span class="hljs-string">&quot;false&quot;</span>&gt;这是一个<span class="hljs-keyword">div</span>&lt;/<span class="hljs-keyword">div</span>&gt;  <span class="hljs-comment">// 匹配不到下面的data-red=&quot;true&quot;，但能匹配data-red</span><br></code></pre></td></tr></table></figure>

<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-attr">[data-red]</span> &#123;   <span class="hljs-comment">// 只写属性名 不写属性值，则能匹配所有相同属性名</span><br>  <span class="hljs-attribute">color</span>: white;<br>  <span class="hljs-attribute">background</span>: green;<br>&#125;<br><br><span class="hljs-selector-attr">[data-red=<span class="hljs-string">&quot;true&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">color</span>: black;<br>  <span class="hljs-attribute">background</span>: yellowgreen;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-29-at-8.41.49-PM.png" alt="data-attribute1"></p>
<p>示例二：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> data-red&gt;这是一个<span class="hljs-keyword">div</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> data-red=<span class="hljs-string">&quot;123&quot;</span>&gt;这是一个<span class="hljs-keyword">div</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> data-red=<span class="hljs-string">&quot;124&quot;</span>&gt;这是一个<span class="hljs-keyword">div</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> data-red=<span class="hljs-string">&quot;2123&quot;</span>&gt;这是一个<span class="hljs-keyword">div</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-attr">[data-red]</span> &#123;<br>  <span class="hljs-attribute">color</span>: white;<br>  <span class="hljs-attribute">background</span>: green;<br>&#125;<br><br><span class="hljs-selector-attr">[data-red^=<span class="hljs-string">&quot;12&quot;</span>]</span> &#123;   <span class="hljs-comment">// 匹配12开头的属性值</span><br>  <span class="hljs-attribute">color</span>: black;<br>  <span class="hljs-attribute">background</span>: yellowgreen;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-29-at-8.45.05-PM.png" alt="data-attribute2"></p>
<p>示例三：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> data-red&gt;这是一个<span class="hljs-keyword">div</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> data-red=<span class="hljs-string">&quot;123&quot;</span>&gt;这是一个<span class="hljs-keyword">div</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> data-red=<span class="hljs-string">&quot;124&quot;</span>&gt;这是一个<span class="hljs-keyword">div</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> data-red=<span class="hljs-string">&quot;2123&quot;</span>&gt;这是一个<span class="hljs-keyword">div</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-attr">[data-red]</span> &#123;<br>  <span class="hljs-attribute">color</span>: white;<br>  <span class="hljs-attribute">background</span>: green;<br>&#125;<br><br><span class="hljs-selector-attr">[data-red$=<span class="hljs-string">&quot;24&quot;</span>]</span> &#123;   <span class="hljs-comment">// 匹配以24结尾的属性值</span><br>  <span class="hljs-attribute">color</span>: black;<br>  <span class="hljs-attribute">background</span>: yellowgreen;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-29-at-8.47.08-PM.png" alt="data-attribute3"></p>
<p>示例四：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> data-red&gt;这是一个<span class="hljs-keyword">div</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> data-red=<span class="hljs-string">&quot;123&quot;</span>&gt;这是一个<span class="hljs-keyword">div</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> data-red=<span class="hljs-string">&quot;124&quot;</span>&gt;这是一个<span class="hljs-keyword">div</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> data-red=<span class="hljs-string">&quot;2123&quot;</span>&gt;这是一个<span class="hljs-keyword">div</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-attr">[data-red]</span> &#123;<br>  <span class="hljs-attribute">color</span>: white;<br>  <span class="hljs-attribute">background</span>: green;<br>&#125;<br><br><span class="hljs-selector-attr">[data-red*=<span class="hljs-string">&quot;12&quot;</span>]</span> &#123;   <span class="hljs-comment">// 匹配只要属性值中有12的都可以</span><br>  <span class="hljs-attribute">color</span>: black;<br>  <span class="hljs-attribute">background</span>: yellowgreen;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-29-at-8.48.41-PM.png" alt="data-attribute3"></p>
]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS-随笔一</title>
    <url>/2021/10/18/CSS-%E9%9A%8F%E7%AC%94%E4%B8%80/</url>
    <content><![CDATA[<hr>
<h4 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h4><p>关于 <code>display:hidden</code> 这类能隐藏元素的方法区别:<br><a href="https://75.team/post/five-ways-to-hide-elements-in-css.html">用 CSS 隐藏页面元素的 5 种方法</a></p>
<h4 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h4><p>关于 button 和 flex 搭配的特殊情况<br><a href="https://www.cnblogs.com/zhuzhenwei918/p/6389567.html">这是一篇关于父子元素继承的博客</a></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// css</span><br>  <span class="hljs-selector-class">.BigBox</span> &#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">flex-direction</span>: column;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span>;<br>    <span class="hljs-attribute">background</span>: red;<br>  &#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">// html</span><br>  &lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">BigBox</span>&quot;&gt;<br>    &lt;<span class="hljs-symbol">button</span> <span class="hljs-symbol">type</span>=&quot;<span class="hljs-symbol">button</span>&quot;&gt;点击我&lt;/<span class="hljs-symbol">button</span>&gt;<br>  &lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure>

<p>效果如下：<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-18-at-10.07.07-AM.5g0xixkr2380.png" alt="flex+btn-1"></p>
<p>这个按钮的 width 和 BigBox 盒子的宽度一样</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">// html</span><br>  &lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">BigBox</span>&quot;&gt;<br>    &lt;<span class="hljs-symbol">div</span>&gt;<br>    &lt;<span class="hljs-symbol">button</span> <span class="hljs-symbol">type</span>=&quot;<span class="hljs-symbol">button</span>&quot;&gt;点击我&lt;/<span class="hljs-symbol">button</span>&gt;<br>    &lt;/<span class="hljs-symbol">div</span>&gt;<br>  &lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-18-at-10.09.32-AM.5ulg5xqki2s0.png" alt="flex+btn-2"><br>显然 button 的宽度变为内联的那种效果。根据内容来扩大自己的宽度</p>
<p>事实上， <code>flex</code> 对于 内联元素都有拉伸的效果(毕竟 <code>flex</code> 叫弹性盒子…)。那如何规避 <code>flex</code> 的弹性效果呢？</p>
<ol>
<li>就是上述的在内联元素的外层套一个 <code>div</code>(块级盒子)。</li>
<li>可以在 flex 的子元素(内联元素，在 flex 里内联元素特殊)设置<code>width</code> 和 <code>height</code>(例如此题就是给 button 设置长度和宽度)</li>
<li>通过 <code>margin:auto</code> 这种也可以消除拉伸状态</li>
</ol>
<figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts">  .<span class="hljs-class">BigBox </span>&#123;<br><span class="hljs-symbol">    display:</span> flex;<br>    flex-direction: column;<br><span class="hljs-symbol">    width:</span> <span class="hljs-number">200</span>px;<br><span class="hljs-symbol">    height:</span> <span class="hljs-number">150</span>px;<br><span class="hljs-symbol">    background:</span> red;<br>  &#125;<br>  <span class="hljs-class">button </span>&#123;<br><span class="hljs-symbol">    margin:</span> <span class="hljs-number">0</span> auto;<br>  &#125;<br>  <span class="hljs-params">&lt;/style&gt;</span><br><span class="hljs-params">&lt;/head&gt;</span><br><span class="hljs-params">&lt;body&gt;</span><br>  <span class="hljs-params">&lt;div class=&quot;BigBox&quot;&gt;</span><br>    <span class="hljs-params">&lt;button type=&quot;button&quot;&gt;</span>点击我<span class="hljs-params">&lt;/button&gt;</span><br>  <span class="hljs-params">&lt;/div&gt;</span><br><span class="hljs-params">&lt;/body&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-18-at-11.06.51-AM.5llejkgdkig0.png" alt="效果如下"></p>
<ol start="4">
<li>还有的办法就是消除 <code>flex</code> 的默认拉伸效果</li>
</ol>
<figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts">  .<span class="hljs-class">BigBox </span>&#123;<br><span class="hljs-symbol">    display:</span> flex;<br>    flex-direction: column;<br><span class="hljs-symbol">    width:</span> <span class="hljs-number">200</span>px;<br><span class="hljs-symbol">    height:</span> <span class="hljs-number">150</span>px;<br><span class="hljs-symbol">    background:</span> red;<br>  &#125;<br>  <span class="hljs-class">button </span>&#123;<br>    <span class="hljs-comment">/* align-items属性某个子元素在交叉轴上的对齐方式 */</span><br>    <span class="hljs-comment">/* align-items 默认属性 stretch */</span><br>    align-self: center;<br>  &#125;<br>  <span class="hljs-params">&lt;/style&gt;</span><br><span class="hljs-params">&lt;/head&gt;</span><br><span class="hljs-params">&lt;body&gt;</span><br>  <span class="hljs-params">&lt;div class=&quot;BigBox&quot;&gt;</span><br>    <span class="hljs-params">&lt;button type=&quot;button&quot;&gt;</span>点击我<span class="hljs-params">&lt;/button&gt;</span><br>  <span class="hljs-params">&lt;/div&gt;</span><br><span class="hljs-params">&lt;/body&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-18-at-11.06.51-AM.5llejkgdkig0.png" alt="效果如下"></p>
<h4 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h4><p>关于 radio + button 的玩法总结：<br><a href="https://play.tailwindcss.com/FLrfGpKId1">radio + button 内容 –&gt; 使用的 tailwindcss</a></p>
<p>关键点 1：<code>radio</code> 标签的使用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 单选按钮让用户只选择有限数量的选项之一 --&gt;</span><br><span class="hljs-comment">&lt;!-- 所以 name 要保持一致 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;tab&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iPhone-13-pro&quot;</span> <span class="hljs-attr">checked</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;tab&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iPhone-13&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;tab&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iPhone-se&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-10-18-at-12.06.02-PM.tmocxv39y3k.gif" alt="radio效果图"></p>
<p>关键点 2：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/General_sibling_combinator">通用兄弟选择器的使用(~)</a> 搭配 <code>:checked</code></p>
<figure class="highlight dust"><table><tr><td class="code"><pre><code class="hljs dust"><span class="xml">元素1~元素2 </span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable"></span><br><span class="hljs-template-variable">&#125;</span><span class="xml"></span><br><span class="xml">表示选择元素1 下面所有的元素2</span><br><span class="xml">但是~层级问题始终有点迷~</span><br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">    <span class="hljs-selector-id">#iPhone-13-pro</span><span class="hljs-selector-pseudo">:checked</span> ~ <span class="hljs-selector-class">.iphone</span> <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">1</span>) &#123;</span><br><span class="css">      <span class="hljs-attribute">color</span>: red;</span><br><span class="css">    &#125;</span><br><span class="css">    <span class="hljs-selector-id">#iPhone-13</span><span class="hljs-selector-pseudo">:checked</span> ~ <span class="hljs-selector-class">.iphone</span> <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>) &#123;</span><br><span class="css">      <span class="hljs-attribute">color</span>: red;</span><br><span class="css">    &#125;</span><br><span class="css">    <span class="hljs-selector-id">#iPhone-se</span><span class="hljs-selector-pseudo">:checked</span> ~ <span class="hljs-selector-class">.iphone</span> <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">3</span>) &#123;</span><br><span class="css">      <span class="hljs-attribute">color</span>: red;</span><br><span class="css">    &#125;</span><br><span class="css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 单选按钮让用户只选择有限数量的选项之一 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- 所以 name 要保持一致 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;tab&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iPhone-13-pro&quot;</span> <span class="hljs-attr">checked</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;tab&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iPhone-13&quot;</span>  /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;tab&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iPhone-se&quot;</span> /&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;iphone&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>iphone 13 pro<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>iphone 13<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>iphone se<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-10-18-at-12.22.39-PM.5x922m5shww0.gif" alt="radio 效果 2"></p>
<p>关键点三： <code>label标签</code>的使用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">    <span class="hljs-comment">/* label[属性] 很牛 */</span></span><br><span class="css">    // 注意 ~ 必须是左右两边是最后得同层级的才行</span><br><span class="css">    <span class="hljs-selector-id">#iPhone-13-pro</span><span class="hljs-selector-pseudo">:checked</span> ~ <span class="hljs-selector-class">.iphone</span> <span class="hljs-selector-tag">label</span><span class="hljs-selector-attr">[for=<span class="hljs-string">&quot;iPhone-13-pro&quot;</span>]</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">color</span>: red;</span><br><span class="css">    &#125;</span><br><span class="css">    <span class="hljs-selector-id">#iPhone-13</span><span class="hljs-selector-pseudo">:checked</span> ~ <span class="hljs-selector-class">.iphone</span> <span class="hljs-selector-tag">label</span><span class="hljs-selector-attr">[for=<span class="hljs-string">&quot;iPhone-13&quot;</span>]</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">color</span>: red;</span><br><span class="css">    &#125;</span><br><span class="css">    <span class="hljs-selector-id">#iPhone-se</span><span class="hljs-selector-pseudo">:checked</span> ~ <span class="hljs-selector-class">.iphone</span> <span class="hljs-selector-tag">label</span><span class="hljs-selector-attr">[for=<span class="hljs-string">&quot;iPhone-se&quot;</span>]</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">color</span>: red;</span><br><span class="css">    &#125;</span><br><span class="css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 单选按钮让用户只选择有限数量的选项之一 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- 所以 name 要保持一致 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;tab&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iPhone-13-pro&quot;</span> <span class="hljs-attr">checked</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;tab&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iPhone-13&quot;</span>  /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;tab&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iPhone-se&quot;</span> /&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;iphone&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;iPhone-13-pro&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>iphone 13 pro<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;iPhone-13&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>iphone 13<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;iPhone-se&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>iphone se<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-10-18-at-12.32.02-PM.27m3tsv2zp34.gif" alt="radio 效果3"></p>
<p>关键点四：<code>隐藏radio</code>利用 <code>display:none</code>属性。<br>(<a href="#%E9%97%AE%E9%A2%98%E4%B8%80">display:none</a>)</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;tab&quot;</span> <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;iPhone-13-pro&quot;</span> <span class="hljs-attribute">style</span>=<span class="hljs-string">&quot;display: none;&quot;</span> checked /&gt;<br>&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;tab&quot;</span> <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;iPhone-13&quot;</span>  <span class="hljs-attribute">style</span>=<span class="hljs-string">&quot;display: none;&quot;</span> /&gt;<br>&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;tab&quot;</span> <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;iPhone-se&quot;</span> <span class="hljs-attribute">style</span>=<span class="hljs-string">&quot;display: none;&quot;</span>/&gt;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-10-18-at-12.37.56-PM.4j6vcoxrlnu0.gif" alt="效果四"></p>
<h4 id="设置侧边滑动块"><a href="#设置侧边滑动块" class="headerlink" title="设置侧边滑动块"></a>设置侧边滑动块</h4><p><a href="https://www.youtube.com/watch?v=v_8CmC6cwUs&t=305s">视频</a></p>
<h4 id="神坑“margin-auto”"><a href="#神坑“margin-auto”" class="headerlink" title="神坑“margin:auto”"></a>神坑“margin:auto”</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">margin:</span> <span class="hljs-number">0</span> <span class="hljs-string">auto;</span> <span class="hljs-string">/*水平居中对齐*/</span><br><span class="hljs-attr">margin:</span> <span class="hljs-string">auto;</span> <span class="hljs-string">/*上下左右auto</span> <span class="hljs-string">但是上下左右不起作用</span> <span class="hljs-string">还是水平居中对齐*/</span><br><span class="hljs-meta">---</span><br><span class="hljs-string">但是在</span> <span class="hljs-string">flex(grid)</span> <span class="hljs-string">items</span> <span class="hljs-string">上的</span> <span class="hljs-attr">margin:</span> <span class="hljs-string">auto</span> <span class="hljs-string">不仅对水平方向有效，对垂直方向同样有效</span><br></code></pre></td></tr></table></figure>

<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> style=<span class="hljs-string">&quot;height: 200px; width: 200px; background: red;&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> style=<span class="hljs-string">&quot;height: 50px; width: 50px; background: yellow; margin: auto&quot;</span>&gt;块级&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<p>效果为：<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-23-at-12.08.50-AM.7kaaythbtjk0.png" alt="神坑margin:auto-1"></p>
<hr>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> style=<span class="hljs-string">&quot;display:grid; height: 200px; width: 200px; background: red;&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> style=<span class="hljs-string">&quot;height: 50px; width: 50px; background: yellow; margin: auto&quot;</span>&gt;块级&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-23-at-12.10.18-AM.1t4jj2z6k2gw.png" alt="神坑margin:auto-2"></p>
<h4 id="white-space-用法"><a href="#white-space-用法" class="headerlink" title="white-space 用法"></a>white-space 用法</h4><p><a href="https://www.w3schools.com/cssref/tryit.asp?filename=trycss_text_white-space">https://www.w3schools.com/cssref/tryit.asp?filename=trycss_text_white-space</a></p>
<h4 id="css-伪类的用法-last-child"><a href="#css-伪类的用法-last-child" class="headerlink" title="css 伪类的用法 :last-child"></a>css 伪类的用法 :last-child</h4><h4 id="outline-none-有什么用？"><a href="#outline-none-有什么用？" class="headerlink" title="outline:none 有什么用？"></a>outline:none 有什么用？</h4><p>用于取消选中框的最外层颜色…</p>
<h4 id="非常有用的针对字符换行的-css-属性："><a href="#非常有用的针对字符换行的-css-属性：" class="headerlink" title="非常有用的针对字符换行的 css 属性："></a>非常有用的针对字符换行的 css 属性：</h4><p><code>word-wrap: break-word;</code><br><code>word-break: break-all;</code></p>
]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>Calc css</title>
    <url>/2021/11/09/Calc-css/</url>
    <content><![CDATA[<p><code>calc</code> 的出现让 <code>纯css</code> 更加的强大</p>
<h4 id="calc-基础应用"><a href="#calc-基础应用" class="headerlink" title="calc 基础应用"></a>calc 基础应用</h4><figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">/* html文件 */</span><br>&lt;div class=<span class="hljs-string">&quot;container&quot;</span>&gt;&lt;/div&gt;<br><br><span class="hljs-comment">/* css文件 */</span><br>.container &#123;<br>  <span class="hljs-built_in">width</span>: <span class="hljs-number">100</span>%;<br>  <span class="hljs-built_in">height</span>: <span class="hljs-number">80</span>px;<br>  <span class="hljs-built_in">background</span>-<span class="hljs-built_in">color</span>: <span class="hljs-built_in">red</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-09-at-12.53.14-PM.png" alt="普通的一个模块"></p>
<p>事实上，如果我想上面的这个盒子长度变为 300px 我可以这样做</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">80px</span>;<br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但我如果使用<code>calc</code>。我可以这样做</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">100px</span> + <span class="hljs-number">200px</span>);<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">80px</span>;<br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>甚至，我可以让 <code>calc</code> 进行嵌套操作…</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">50px</span> + <span class="hljs-built_in">calc</span>(<span class="hljs-number">100px</span> + <span class="hljs-number">200px</span>));<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">80px</span>;<br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我还可以在 <code>calc</code> 中使用不同的单位</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">100%</span> - <span class="hljs-number">30px</span>);<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">80px</span>;<br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>注意：calc(a - b) 操作符两边一定要留有一个空格并且 calc()这二者中间不能留空格，不然 calc 不起效果。</strong></p>
<h4 id="calc-搭配-var-让-css-更加强大"><a href="#calc-搭配-var-让-css-更加强大" class="headerlink" title="calc 搭配 var() 让 css 更加强大"></a>calc 搭配 var() 让 css 更加强大</h4><p><code>calc</code>是可以结合<code>var()</code>的</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima"><span class="hljs-comment">/* html文件 */</span><br>&lt;div class=<span class="hljs-string">&quot;container&quot;</span>&gt;&lt;/div&gt;<br><br><span class="hljs-comment">/* css文件 */</span><br>.container &#123;<br>  --<span class="hljs-built_in">width</span>: 100px;<br>  <span class="hljs-built_in">width</span>: calc(<span class="hljs-built_in">var</span>(--<span class="hljs-built_in">width</span>) * <span class="hljs-number">2</span>);<br>  <span class="hljs-built_in">height</span>: 80px;<br>  margin: <span class="hljs-number">0</span> auto;<br>  <span class="hljs-built_in">background</span>-<span class="hljs-built_in">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-09-at-1.07.09-PM.png" alt="calc + var"></p>
<p>下面来进行一个有意思的(<code>calc</code> 结合 <code>var</code>)操作</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima"><span class="hljs-comment">/* html文件 */</span><br>&lt;button class=<span class="hljs-string">&quot;btn btn--primary&quot;</span>&gt;Primary&lt;/button&gt;<br>&lt;button class=<span class="hljs-string">&quot;btn btn--danger&quot;</span>&gt;Danger&lt;/button&gt;<br><span class="hljs-comment">/* css文件 */</span><br>:root &#123;<br>  --hue: <span class="hljs-number">200</span>;<br>&#125;<br><br>.btn &#123;<br>  <span class="hljs-built_in">width</span>: 100px;<br>  <span class="hljs-built_in">height</span>: 30px;<br>  <span class="hljs-built_in">color</span>: white;<br>  <span class="hljs-built_in">border</span>-<span class="hljs-built_in">radius</span>: 15px;<br>&#125;<br><br>.btn--primary &#123;<br>  <span class="hljs-built_in">background</span>-<span class="hljs-built_in">color</span>: hsl(<span class="hljs-built_in">var</span>(--hue), <span class="hljs-number">100</span><span class="hljs-symbol">%</span>, <span class="hljs-number">50</span><span class="hljs-symbol">%</span>);<br>&#125;<br>.btn--primary:hover &#123;<br>  <span class="hljs-built_in">background</span>-<span class="hljs-built_in">color</span>: hsl(<span class="hljs-built_in">var</span>(--hue), <span class="hljs-number">100</span><span class="hljs-symbol">%</span>, <span class="hljs-number">70</span><span class="hljs-symbol">%</span>);<br>&#125;<br><br>.btn--danger &#123;<br>  <span class="hljs-built_in">background</span>-<span class="hljs-built_in">color</span>: hsl(calc(<span class="hljs-number">200</span> - <span class="hljs-built_in">var</span>(--hue)), <span class="hljs-number">100</span><span class="hljs-symbol">%</span>, <span class="hljs-number">50</span><span class="hljs-symbol">%</span>);<br>&#125;<br><br>.btn--danger:hover &#123;<br>  <span class="hljs-built_in">background</span>-<span class="hljs-built_in">color</span>: hsl(calc(<span class="hljs-number">200</span> - <span class="hljs-built_in">var</span>(--hue)), <span class="hljs-number">100</span><span class="hljs-symbol">%</span>, <span class="hljs-number">30</span><span class="hljs-symbol">%</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-09-at-1.22.08-PM.gif" alt="calc的神奇妙用"></p>
]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>Dynamic Module</title>
    <url>/2021/11/06/Dynamic-Module/</url>
    <content><![CDATA[<h3 id="Dynamic-Module"><a href="#Dynamic-Module" class="headerlink" title="Dynamic Module"></a>Dynamic Module</h3><p>进入按需加载(需要的时候才加载代码)的时代…让页面加载的速度更快…</p>
<p>看看案例：<br>如下是普通的模块导入：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">/* html 代码片段 */<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./script.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">/* script.js 代码片段 */</span><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">User</span>, &#123;printUser&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./user.js&#x27;</span>;<br><br>const <span class="hljs-keyword">user</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">User</span>(<span class="hljs-string">&#x27;Bruce&#x27;</span>, <span class="hljs-string">&#x27;Cook&#x27;</span>)<br>printUser(<span class="hljs-keyword">user</span>);<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* user.js 代码片段 */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">first, last</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.first = first;<br>    <span class="hljs-built_in">this</span>.last = last;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printUser</span>(<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;user.first&#125;</span> <span class="hljs-subst">$&#123;user.last&#125;</span>`</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>打印结果为 Bruce Cook</p>
</blockquote>
<p>文件运行逻辑： 先下载 script.js 文件，然后立刻下载 user.js 文件 (如果是 webpack 打包，可能会有一点点的变化)<br>但无论如何。只要页面进行加载，这些文件就会被下载…</p>
<p>但是<code>Dynamic Module</code>就如同前面所说是按需加载(需要的时候才加载代码)的</p>
<p><strong>import 变成一个函数</strong></p>
<figure class="highlight elm"><table><tr><td class="code"><pre><code class="hljs elm"><span class="hljs-number">1.</span> <span class="hljs-keyword">import</span>(&#x27;文件相对路径&#x27;)<br>-&gt; <span class="hljs-keyword">import</span>(&#x27;./user.js&#x27;)<br><span class="hljs-number">2.</span> <span class="hljs-keyword">import</span>函数返回一个promise<br>-&gt; <span class="hljs-keyword">import</span>(&#x27;./user.js&#x27;).then(module =&gt; &#123;     // 这里会提供该文件的所有module信息<br>  console.log(module)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-06-at-11.25.17-AM.63cc4nodfyo0.png" alt="module信息"></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">3.</span> 解构 <span class="hljs-keyword">then</span> 中的参数module<br><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./user.js&#x27;</span>).<span class="hljs-keyword">then</span>((&#123;<span class="hljs-keyword">default</span>: <span class="hljs-keyword">User</span>, printUser&#125;) =&gt; &#123;<br>  console.log(<span class="hljs-string">&#x27;User&#x27;</span>, <span class="hljs-keyword">User</span>);<br>  console.log(<span class="hljs-string">&#x27;printUser&#x27;</span>, printUser);<br>&#125;)<br>注意上面的<span class="hljs-keyword">default</span>: <span class="hljs-keyword">User</span> 其实就和下述方式导出<span class="hljs-keyword">User</span> 很相似<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">User</span>, printUser &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./user.js&#x27;</span><br></code></pre></td></tr></table></figure>

<p>现在 我们的代码模块是动态导入的，而非静态导入<br>来看看整体代码</p>
<h4 id="Dynamic-Module-的优势之一：页面加载更快"><a href="#Dynamic-Module-的优势之一：页面加载更快" class="headerlink" title="Dynamic Module 的优势之一：页面加载更快"></a>Dynamic Module 的优势之一：页面加载更快</h4><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">/* html 代码片段 */<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./script.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* script.js 代码片段 */</span><br><span class="hljs-comment">// 5s 后才会加载这个模块...</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./user.js&#x27;</span>).then(<span class="hljs-function">(<span class="hljs-params">&#123;<span class="hljs-keyword">default</span>:User, printUser&#125;</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&#x27;Bruce&#x27;</span>, <span class="hljs-string">&#x27;Cook&#x27;</span>)<br>    printUser(user);<br>  &#125;)<br>&#125;, <span class="hljs-number">5000</span>)<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* user.js 代码片段 */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">first, last</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.first = first;<br>    <span class="hljs-built_in">this</span>.last = last;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printUser</span>(<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;user.first&#125;</span> <span class="hljs-subst">$&#123;user.last&#125;</span>`</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码让你的页面加载速度会更上一层楼！！</p>
<h4 id="Dynamic-Module-的优势之二：如果你有一系列的文件。但根据不同用户只需要其中一个文件的时候"><a href="#Dynamic-Module-的优势之二：如果你有一系列的文件。但根据不同用户只需要其中一个文件的时候" class="headerlink" title="Dynamic Module 的优势之二：如果你有一系列的文件。但根据不同用户只需要其中一个文件的时候"></a>Dynamic Module 的优势之二：如果你有一系列的文件。但根据不同用户只需要其中一个文件的时候</h4><p>这里最能显示出<code>Dynamic Module</code>这个优势的是，不同国家语言文件！</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">文件目录：<br>  |- index.html<br>  |- script.js<br>  |- en-translations.js   <span class="hljs-regexp">//</span> 英语文件<br>  |- sp-translations.js   <span class="hljs-regexp">//</span> 西班牙语文件<br>  |- fr-translations.js   <span class="hljs-regexp">//</span> 法语文件<br></code></pre></td></tr></table></figure>

<p>如果使用静态导入方式：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/* html 代码片段 */</span><br>&lt;script <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;module&quot;</span> defer src=<span class="hljs-string">&quot;./script.js&quot;</span>&gt;&lt;/script&gt;<br><br><span class="hljs-comment">/* script.js文件 */</span><br><span class="hljs-keyword">import</span> englishTranslations <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./en-translations.js&#x27;</span><br><span class="hljs-keyword">import</span> spanishTranslations <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./sp-translations.js&#x27;</span><br><span class="hljs-keyword">import</span> frenchTranslations <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./fr-translations.js&#x27;</span><br><br><span class="hljs-keyword">const</span> user = &#123; <span class="hljs-attr">locale</span>: <span class="hljs-string">&#x27;en&#x27;</span> &#125;<br><span class="hljs-keyword">let</span> translations;<br><span class="hljs-keyword">switch</span> (user.locale) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;sp&#x27;</span>:<br>    translations = spanishTranslations<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;fr&#x27;</span>:<br>    translations = frenchTranslations<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">default</span>:<br>    translations = englishTranslations<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(translations.HI)<br><br><span class="hljs-comment">/* en-translations.js */</span><br><span class="hljs-keyword">const</span> translations = &#123;<br>  <span class="hljs-attr">HI</span>: <span class="hljs-string">&#x27;hi&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> translations;<br><br><span class="hljs-comment">/* sp-translations.js */</span><br><span class="hljs-keyword">const</span> translations = &#123;<br>  <span class="hljs-attr">HI</span>: <span class="hljs-string">&#x27;hola&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> translations;<br><br><span class="hljs-comment">/* fr-translations.js */</span><br><span class="hljs-keyword">const</span> translations = &#123;<br>  <span class="hljs-attr">HI</span>: <span class="hljs-string">&#x27;salut&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> translations;<br></code></pre></td></tr></table></figure>

<p>试想，如果我要弄 20 个国家的语言…我还用静态导入的方式，页面加载有多慢，代码文件上传体积有多大</p>
<p>现在我使用 <code>dynamic module</code> 来实现一下代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* script.js文件 */</span><br><span class="hljs-keyword">import</span> englishTranslations <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./en-translations.js&#x27;</span><br><span class="hljs-keyword">import</span> spanishTranslations <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./sp-translations.js&#x27;</span><br><span class="hljs-keyword">import</span> frenchTranslations <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./fr-translations.js&#x27;</span><br><br><br><br><span class="hljs-keyword">const</span> user = &#123; <span class="hljs-attr">locale</span>: <span class="hljs-string">&#x27;en&#x27;</span> &#125;<br><span class="hljs-comment">// 牛逼，还可以使用模板字符串</span><br><span class="hljs-keyword">import</span>(<span class="hljs-string">`./<span class="hljs-subst">$&#123;user.locale&#125;</span>-translations.js`</span>)<br>.catch(<span class="hljs-function">() =&gt;</span> &#123;   <span class="hljs-comment">// 这里是用来解决默认选项问题的(当不存在想要的user.locale时会触发)</span><br>  <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./en-translations.js&#x27;</span>)<br>&#125;)<br>.then(<span class="hljs-function">(<span class="hljs-params">&#123;<span class="hljs-keyword">default</span>:translations&#125;</span>) =&gt;</span> &#123;  <span class="hljs-comment">// 这里使用重命名的方式</span><br>  <span class="hljs-built_in">console</span>.log(translations.HI)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>显然，上述的<code>dynamic module</code> 让代码更加的简洁了…并且性能会更高</p>
<p><strong>再来一个例子</strong></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">文件目录：<br>  <span class="hljs-string">|- index.html</span><br>  <span class="hljs-string">|- script.js</span><br>  <span class="hljs-string">|- rectangle.js</span><br>  <span class="hljs-string">|- triangle.js</span><br></code></pre></td></tr></table></figure>

<figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">/* script.js文件 */</span><br><span class="hljs-keyword">import</span> renderRectangle from <span class="hljs-string">&#x27;./rectangle.js&#x27;</span>;<br><span class="hljs-keyword">import</span> renderTriangle from <span class="hljs-string">&#x27;./triangle.js&#x27;</span>;<br><br><span class="hljs-keyword">const</span> shapes = [<br>  &#123; type: <span class="hljs-string">&#x27;rectangle&#x27;</span> &#125;,<br>  &#123; type: <span class="hljs-string">&#x27;triangle&#x27;</span> &#125;,<br>  &#123; type: <span class="hljs-string">&#x27;rectangle&#x27;</span> &#125;<br>]<br><br><span class="hljs-built_in">shape</span>.forEach(<span class="hljs-built_in">shape</span> =&gt; &#123;<br>  <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">shape</span>.type) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;rectangle&#x27;</span>:<br>      renderRectangle(<span class="hljs-built_in">shape</span>)<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;triangle&#x27;</span>:<br>      renderTriangle(<span class="hljs-built_in">shape</span>)<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* triangle.js */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderShape</span>(<span class="hljs-params">shape</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Render Triangle&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">/* rectangle.js */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderShape</span>(<span class="hljs-params">shape</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Render Rectangle&#x27;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>用 <code>dynamic module</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> shapes = [<br>  &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;rectangle&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;triangle&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;rectangle&#x27;</span> &#125;<br>]<br><br>shape.forEach(<span class="hljs-function"><span class="hljs-params">shape</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">import</span>(<span class="hljs-string">`./<span class="hljs-subst">$&#123;shape.<span class="hljs-keyword">type</span>&#125;</span>.js`</span>).then(<span class="hljs-function">(<span class="hljs-params">&#123;<span class="hljs-keyword">default</span>:render&#125;</span>) =&gt;</span> &#123;<br>      render(shape)<br>    &#125;)<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>我们可以使用 <code>await/async</code> 来更进一步来解决问题</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> shapes = [<br>  &#123; <span class="hljs-keyword">type</span>: <span class="hljs-string">&#x27;rectangle&#x27;</span> &#125;,<br>  &#123; <span class="hljs-keyword">type</span>: <span class="hljs-string">&#x27;triangle&#x27;</span> &#125;,<br>  &#123; <span class="hljs-keyword">type</span>: <span class="hljs-string">&#x27;rectangle&#x27;</span> &#125;<br>]<br><br>shape.forEach(async shape =&gt; &#123;<br>    <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">default</span>: render&#125; = await <span class="hljs-keyword">import</span>(<span class="hljs-string">`./$&#123;shape.type&#125;.js`</span>);<br>    render(shape)<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>高级</tag>
      </tags>
  </entry>
  <entry>
    <title>Emotion的安装和基本使用</title>
    <url>/2021/10/10/Emotion%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>更细节的操作应该看官网指导：<br><a href="https://emotion.sh/docs/introduction">Emotion 官网</a></p>
<h5 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h5><p>针对 react 框架</p>
<blockquote>
<p>npm i @emotion/react<br>npm i @emotion/styled @emotion/react</p>
</blockquote>
]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>高级</tag>
      </tags>
  </entry>
  <entry>
    <title>Form表格</title>
    <url>/2021/11/21/Form%E8%A1%A8%E6%A0%BC/</url>
    <content><![CDATA[<p><a href="https://codepen.io/bruce-shuai/pen/VwzNeLP?editors=0100">在 codepen 中写了一个 form 表格</a></p>
<blockquote>
<p>本来说，<code>form</code> 表格是一个比较基础的内容！但我在做 <code>react</code> 项目的时候，使用 <code>antd</code> 里的 <code>form</code> 表格，感觉太繁琐且不灵活(应该是我菜的缘故)，所以我想自己手写一个 <code>form</code>，但无奈太久没自己手写 <code>form</code> 了，所以已经生疏，为此，我专门写一篇博客方便记忆学习</p>
</blockquote>
<h3 id="form-表格基础知识"><a href="#form-表格基础知识" class="headerlink" title="form 表格基础知识"></a>form 表格基础知识</h3><p>文件夹：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">|-form.html</span><br><span class="hljs-string">|-result.html</span><br></code></pre></td></tr></table></figure>

<h4 id="form-表格的重要属性："><a href="#form-表格的重要属性：" class="headerlink" title="form 表格的重要属性："></a>form 表格的重要属性：</h4><p><code>action</code>：用于表示你的表格提交到哪里<br><code>method</code>：<br>get 提交的内容会显示到 url 上面<br>post 一般是有服务器的才会使用</p>
<h5 id="form-表格示例"><a href="#form-表格示例" class="headerlink" title="form 表格示例"></a>form 表格示例</h5><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">/* form.html */<br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;result.html&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>用户名：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;key1&quot;</span>&gt;</span>  // name 会作为 url 的 key 值<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>密码：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;key2&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">/* result.html */<br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;results&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/form.html&quot;</span>&gt;</span>Back to Form<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">const</span> resultsList = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;results&#x27;</span>);</span><br><span class="javascript">  <span class="hljs-comment">// URLSearchParams 接口定义了一些实用的方法来处理 URL 的查询字符串</span></span><br><span class="javascript">  <span class="hljs-comment">// window.location.search 用于获取页面URL中从?开始的部分</span></span><br><span class="javascript">  <span class="hljs-keyword">new</span> URLSearchParams(<span class="hljs-built_in">window</span>.location.search).forEach(<span class="hljs-function">(<span class="hljs-params">value, name</span>) =&gt;</span> &#123;</span><br><span class="javascript">    resultsList.append(<span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span>: <span class="hljs-subst">$&#123;value&#125;</span>`</span>)</span><br><span class="javascript">    resultsList.append(<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;br&#x27;</span>))</span><br><span class="javascript">  &#125;)</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>(可以看看 url 的变化)<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-21-at-1.42.47-PM.gif" alt="基本操作"></p>
<h4 id="label-标签的使用"><a href="#label-标签的使用" class="headerlink" title="label 标签的使用"></a>label 标签的使用</h4><p>有两种写法：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">// 写法一：带 for\id 属性</span><br>  &lt;<span class="hljs-keyword">label</span> <span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;用户名：&lt;/<span class="hljs-keyword">label</span>&gt;<br>  &lt;<span class="hljs-keyword">input</span> id=<span class="hljs-string">&quot;username&quot;</span> name=<span class="hljs-string">&quot;key1&quot;</span>&gt;<br></code></pre></td></tr></table></figure>

<p><label for="username">用户名：</label><br><input id="username" name="key1"></p>
<figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">// 写法二：不带 for\id 属性</span><br>  &lt;<span class="hljs-keyword">label</span>&gt;<br>    用户名：<br>    &lt;<span class="hljs-keyword">input</span> name=<span class="hljs-string">&quot;key1&quot;</span>&gt;<br>  &lt;/<span class="hljs-keyword">label</span>&gt;<br></code></pre></td></tr></table></figure>

<label>
  用户名：<input id="username" name="key1">
</label>

<p>上述两种其实达到的效果是一致的</p>
<h4 id="input-和-button-标签的-type-类型"><a href="#input-和-button-标签的-type-类型" class="headerlink" title="input 和 button 标签的 type 类型"></a>input 和 button 标签的 type 类型</h4><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">/* form.html */<br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;result.html&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>用户名：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;key1&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span> (text 是默认属性)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>密码：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;key2&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span>&gt;</span>重置<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>   // 让输入框的内容重置<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-21-at-2.11.46-PM.gif" alt="type类型"></p>
<h5 id="value-属性-placeholder-属性-required-属性"><a href="#value-属性-placeholder-属性-required-属性" class="headerlink" title="value 属性, placeholder 属性, required 属性"></a>value 属性, placeholder 属性, required 属性</h5><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">/* form.html */<br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;result.html&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>用户名：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;key1&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;default&quot;</span>&gt;</span>  // 仅增添了value<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>密码：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;key2&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span>&gt;</span>重置<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-21-at-2.15.06-PM.gif" alt="默认值"></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">&lt;input <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;key1&quot;</span> <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attribute">placeholder</span>=<span class="hljs-string">&quot;哈哈哈&quot;</span>&gt;<br></code></pre></td></tr></table></figure>

 <input name="key1" type="text" placeholder="哈哈哈">

<p><code>required</code>会给出一些出错的提示</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">input</span> <span class="hljs-type">name</span>=&quot;key1&quot; <span class="hljs-keyword">type</span>=&quot;text&quot; placeholder=&quot;哈哈哈&quot; required&gt;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-21-at-2.20.51-PM.gif" alt="required1"></p>
<h5 id="type-”email”"><a href="#type-”email”" class="headerlink" title="type=”email”"></a>type=”email”</h5><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;result.html&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>用户名：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;key1&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>  <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;哈哈哈&quot;</span> <span class="hljs-attr">required</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>密码：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;key2&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">required</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>邮箱：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;key3&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">required</span>&gt;</span>   // 这里的类型变成email了<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span>&gt;</span>重置<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>(注意：要达到 email 格式提示效果，需要 required + type=”email” 才行哦！)</p>
<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-21-at-2.25.04-PM.gif" alt="requied2"></p>
<h5 id="type-”number”"><a href="#type-”number”" class="headerlink" title="type=”number”"></a>type=”number”</h5><figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim"><span class="hljs-symbol">&lt;div&gt;</span><br>  <span class="hljs-symbol">&lt;label&gt;</span>年龄：&lt;/label&gt;<br>  &lt;<span class="hljs-built_in">input</span> name=<span class="hljs-string">&quot;key3&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-built_in">min</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-built_in">max</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;  // 可以设置最小值和最大值<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-21-at-2.31.49-PM.gif" alt="number"></p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><code class="hljs sqf">&lt;div&gt;<br>  &lt;label&gt;年龄：&lt;/label&gt;<br>  &lt;input <span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;key3&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-built_in">min</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-built_in">max</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-built_in">step</span>=<span class="hljs-string">&quot;10&quot;</span>&gt;  <span class="hljs-comment">// 每次增加10</span><br>&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<p>下面自己来试一下</p>
<div>
  <label>年龄：</label>
  <input name="key3" type="number" min="0" max="100" step="10">
</div>

<h5 id="type-”date”"><a href="#type-”date”" class="headerlink" title="type=”date”"></a>type=”date”</h5><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>生日：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;date&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<div>
  <label>生日：</label>
  <input type="date">
</div>

<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim"><span class="hljs-symbol">&lt;div&gt;</span><br>  <span class="hljs-symbol">&lt;label&gt;</span>生日：&lt;/label&gt;<br>  &lt;<span class="hljs-built_in">input</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;date&quot;</span> <span class="hljs-built_in">min</span>=<span class="hljs-string">&quot;2021-11-21&quot;</span>&gt;  // 可以设置<span class="hljs-built_in">min</span> 和 <span class="hljs-built_in">max</span><br>&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<div>
  <label>生日：</label>
  <input type="date" min="2021-11-21">
</div>

<h5 id="type-”checkbox”-“radio”"><a href="#type-”checkbox”-“radio”" class="headerlink" title="type=”checkbox”/“radio”"></a>type=”checkbox”/“radio”</h5><figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata">最爱水果(可多选)<br>&lt;div&gt;<br>  &lt;<span class="hljs-keyword">label</span>&gt;<br>    香蕉<br>    &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;<br>  &lt;/<span class="hljs-keyword">label</span>&gt;<br>  &lt;<span class="hljs-keyword">label</span>&gt;<br>    苹果<br>    &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;<br>  &lt;/<span class="hljs-keyword">label</span>&gt;<br>  &lt;<span class="hljs-keyword">label</span>&gt;<br>    葡萄<br>    &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;<br>  &lt;/<span class="hljs-keyword">label</span>&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<div>
  <label>
    香蕉
    <input type="checkbox">
  </label>
  <label>
    苹果
    <input type="checkbox">
  </label>
  <label>
    葡萄
    <input type="checkbox">
  </label>
</div>

<figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata">最爱水果(只能选一样)<br>&lt;div&gt;<br>  &lt;<span class="hljs-keyword">label</span>&gt;<br>    香蕉<br>    &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;radio&quot;</span> name=&quot;fruit&gt;   <span class="hljs-comment">// name 要一致才行</span><br>  &lt;/<span class="hljs-keyword">label</span>&gt;<br>  &lt;<span class="hljs-keyword">label</span>&gt;<br>    苹果<br>    &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;radio&quot;</span> name=&quot;fruit&gt;<br>  &lt;/<span class="hljs-keyword">label</span>&gt;<br>  &lt;<span class="hljs-keyword">label</span>&gt;<br>    葡萄<br>    &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;radio&quot;</span> name=&quot;fruit&gt;<br>  &lt;/<span class="hljs-keyword">label</span>&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<div>
  <label>
    香蕉
    <input type="radio" name="fruit">
  </label>
  <label>
    苹果
    <input type="radio" name="fruit">
  </label>
  <label>
    葡萄
    <input type="radio" name="fruit">
  </label>
</div>

<h5 id="select-标签"><a href="#select-标签" class="headerlink" title="select 标签"></a>select 标签</h5><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;result.html&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>用户名：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;key1&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>  <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;哈哈哈&quot;</span> <span class="hljs-attr">required</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>密码：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;key2&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">required</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;eyeColor&quot;</span>&gt;</span>眼睛颜色<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;eyeColor&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;eyeColor&quot;</span> <span class="hljs-attr">multiple</span>&gt;</span>   <span class="hljs-comment">&lt;!-- multiple 可以达到多选的效果--&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Green&quot;</span>&gt;</span>绿色<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Black&quot;</span>&gt;</span>黑色<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Blue&quot;</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;蓝色&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>  <span class="hljs-comment">&lt;!-- label 在这里代替了option标签中间写的内容--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span>&gt;</span>重置<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-21-at-3.26.59-PM.gif" alt="select标签"></p>
<h5 id="type-”hidden”"><a href="#type-”hidden”" class="headerlink" title="type=”hidden”"></a>type=”hidden”</h5><p>这个标签在表格中不会显示出来，但伴随表格提交是会有内容出现</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;result.html&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>用户名：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;key1&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>  <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;哈哈哈&quot;</span> <span class="hljs-attr">required</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>密码：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;key2&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">required</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;我要隐藏&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span>&gt;</span>重置<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-21-at-3.35.54-PM.gif" alt="hidden"></p>
<h4 id="type-”file”"><a href="#type-”file”" class="headerlink" title="type=”file”"></a>type=”file”</h4><p>注意：因为文件是很大的，所以无法一次性上传到后端(所以这个应该用 post 的请求方法才会奏效)。我们需要给 <code>form</code> 增加新的属性：<code>enctype=&quot;multipart/form-data&quot;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;result.html&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span>&gt;</span>重置<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-21-at-3.45.25-PM.gif" alt="file"></p>
<p>事实上 type 还有 tel、url、color 这几种属性。效果其实挺简单，在网上一查便知就不过多赘述了…</p>
<h3 id="form-进阶知识"><a href="#form-进阶知识" class="headerlink" title="form 进阶知识"></a>form 进阶知识</h3><p>利用 js 操作 form 表格</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">/* index.html */<br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./script.js&quot;</span> <span class="hljs-attr">defer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;error&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;GET&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;form&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>Name<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span>Password<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Password&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* script.js */</span><br><br><span class="hljs-keyword">const</span> username = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;name&#x27;</span>)<br><span class="hljs-keyword">const</span> password = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;password&#x27;</span>)<br><span class="hljs-keyword">const</span> form = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;form&#x27;</span>)<br><span class="hljs-keyword">const</span> errorElement = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;error&#x27;</span>)<br><br>form.addEventListener(<span class="hljs-string">&#x27;submit&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> messages = [];<br><br>  <span class="hljs-keyword">if</span> (username.value === <span class="hljs-string">&#x27;&#x27;</span> || username.value == <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 这里的 == 是为了兼容 undefined 和 null</span><br>    messages.push(<span class="hljs-string">&#x27;Name is required&#x27;</span>)<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (password.value.length &lt;= <span class="hljs-number">6</span>) &#123;<br>    messages.push(<span class="hljs-string">&#x27;Password must be longer than 6 characters&#x27;</span>)<br>  &#125;<br>  errorElement.innerText = messages.join(<span class="hljs-string">&#x27;,&#x27;</span>)<br>  <span class="hljs-keyword">if</span> (messages.length &gt; <span class="hljs-number">0</span>) &#123;<br>    e.preventDefault();  <span class="hljs-comment">// 用于取消事件的默认动作，防止submit提交后跳转页面(无其他路径就会刷新自己当前的页面)</span><br>    errorElement.innerText = messages.join(<span class="hljs-string">&#x27;,&#x27;</span>)<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p><strong>注意：</strong> <code>e.preventDefault()</code> 在 <code>form</code> 表格中非常常用 效果如下：<br>用于取消事件的默认动作，防止 <code>submit</code> 提交后跳转页面(无其他路径就会刷新自己当前的页面)。所以可以防止页面刷新</p>
]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>Git基本用法</title>
    <url>/2021/10/20/Git%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>尽量写得精简~<br><code>Git</code> 是一个分布式版本控制系统</p>
<p><strong>版本控制</strong> <strong>主动提交</strong> <strong>中央仓库</strong> 这三个要素，共同构成了<strong>版本控制系统的核心</strong><br>开发团队中的每个人向中央仓库主动提交自己的改动和同步别人的改动，并在需要的时候查看和操作历史版本，这就是版本控制系统。</p>
<p>版本控制系统 有 <strong>中央式版本控制系统</strong> 和 <strong>分布式版本控制系统</strong></p>
<p>为了精简，这篇博客只讲<strong>分布式版本控制系统</strong>，即 <code>git</code> 这种操作</p>
<h4 id="分布式版本控制"><a href="#分布式版本控制" class="headerlink" title="分布式版本控制"></a>分布式版本控制</h4><p>具备 <code>中央仓库</code> 和 <code>本地仓库</code></p>
<p>一个团队的每个成员都有一个本地仓库。这个仓库里有所有的版本历史。成员在自己的本地仓库进行代码提交，然后在适当的时机把本地仓库的代码记录上传到中央仓库进行整合</p>
<p>来一个假设项目团队</p>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less">程序员<span class="hljs-selector-tag">A</span>(老大)<br>程序员<span class="hljs-selector-tag">B</span><br>程序员<span class="hljs-selector-tag">C</span><br><br>三人一起做一个项目<br><br><span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">A</span> 搭建项目架构，然后把这些代码提交到本地仓库。<br><span class="hljs-selector-tag">-</span> 然后 <span class="hljs-selector-tag">A</span> 在服务器(这里就假设为github)上创建了一个中央仓库，并把提交到本地仓库的代码又推送到<span class="hljs-selector-tag">github</span>上<br><span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">B</span>、<span class="hljs-selector-tag">C</span> 把<span class="hljs-selector-tag">github</span>上<span class="hljs-selector-tag">A</span>提交的所有内容克隆到本地，拥有了各自的本地仓库 (这下 A B C可以并行开发)<br><span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">A</span> <span class="hljs-selector-tag">B</span> <span class="hljs-selector-tag">C</span> 都可以把自己写的每一次改动提交到各自的本地仓库。<br><span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">A</span> <span class="hljs-selector-tag">B</span> <span class="hljs-selector-tag">C</span> 把各自的功能完成后，就可以把这个功能相关的所有提交从本地仓库推送到中央仓库<br><span class="hljs-selector-tag">-</span> 每次当有人把新的提交推送到中央仓库的时候，另外两个人就<br>可以选择把这些提交同步到自己的机器上，并把它们和自己的本地代码合并<br></code></pre></td></tr></table></figure>

<h4 id="git-最基本操作"><a href="#git-最基本操作" class="headerlink" title="git 最基本操作"></a>git 最基本操作</h4><h5 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h5><p><a href="https://git-scm.com/">git 下载</a></p>
<h5 id="github-中央仓库-项目拉取到本地"><a href="#github-中央仓库-项目拉取到本地" class="headerlink" title="github(中央仓库)项目拉取到本地"></a>github(中央仓库)项目拉取到本地</h5><p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-24-at-8.07.12-PM.png" alt="github项目"></p>
<p>上面是我在 github 的一个项目，现在复制上面 <code>SSH</code> 里的一串字符</p>
<p>然后在终端：git clone + 刚复制的地址</p>
<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-24-at-8.13.54-PM.png" alt="git clone" width="400px">

<p>Git 就会把你的远程仓库 clone 到本地。在这个过程中，你可能会需要输入你的 GitHub 用户名和密码</p>
<p>下面是我刚从 <code>github</code> 上拉取的项目 <code>calculate</code> 里的文件内容<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-24-at-8.17.27-PM.png" alt="文件夹1"></p>
<p>在该文件夹里 快捷键：<code>command + shift + .</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-24-at-8.19.35-PM.png" alt="文件夹2"></p>
<p>现在<code>calculate</code>文件夹里隐藏的文件夹 <code>.git</code> 和 <code>.gitignore</code> 全都浮现出来了</p>
<p>这个 <code>.git</code> 目录，就是你的<code>本地仓库(Local Repository)</code>，你的 所有版本信息都会存在这里。而 <code>.git</code> 所在的这个根目录，称为 Git 的<code>工作目录(Working Directory)</code>，它保存了你当前从仓库中签出(checkout)的内容</p>
<h5 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h5><p><strong>作用：查看提交记录(从远程仓库拉取过来的项目也能看它曾经的提交记录)</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-24-at-8.23.33-PM.png" alt="git log"></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">具体来分析一下输入 git log 之后，打印的内容<br><br>commit xxxxxx    <span class="hljs-regexp">//</span> 提交的id<br>Author: 帅得乱七八糟 &lt;<span class="hljs-number">284970670</span>@qq.com&gt;  <span class="hljs-regexp">//</span> 提交作者<br>Date:   Tue Nov <span class="hljs-number">23</span> <span class="hljs-number">14</span>:<span class="hljs-number">15</span>:<span class="hljs-number">31</span> <span class="hljs-number">2021</span> +<span class="hljs-number">0800</span> <span class="hljs-regexp">//</span> 提交时期<br></code></pre></td></tr></table></figure>

<blockquote>
<p>好了，为了后面更详细的操作，我现在 github 上创建一个空的项目(git-review),然后从远程拉取，操作和上面是一样的</p>
</blockquote>
<h5 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h5><p><strong>作用：status 是用来查看工作目录当前状态的指令</strong><br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-24-at-8.34.28-PM.png" alt="git status"></p>
<p>从上图我可以获得以下内容:</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><code class="hljs taggerscript">1. 我当前处于 master branch 这个分支上<br>2. 我当前没有任何内容 commit<br>3. 我有 untracked files (未追踪的文件)，文件名是<br>&quot;<span class="hljs-symbol">\3</span>47<span class="hljs-symbol">\2</span>73<span class="hljs-symbol">\2</span>03<span class="hljs-symbol">\3</span>44<span class="hljs-symbol">\2</span>71<span class="hljs-symbol">\2</span>40<span class="hljs-symbol">\3</span>46<span class="hljs-symbol">\2</span>26<span class="hljs-symbol">\2</span>07<span class="hljs-symbol">\3</span>46<span class="hljs-symbol">\2</span>34<span class="hljs-symbol">\2</span>54.md&quot; // 所以最后用英文命名哈哈，不然弄些这种数字命名就很怪！！<br>4. 我可以使用gitadd来开始追踪文件。<br></code></pre></td></tr></table></figure>

<h5 id="git-add-文件名"><a href="#git-add-文件名" class="headerlink" title="git add + 文件名"></a>git add + 文件名</h5><p><strong>进一步解析</strong><br>所谓<code>untracked</code>状态，它的意思是 <strong>Git 仓库</strong> 对它没有进行任何记录，你在提交的时候不会把它提交上去，查看提交历史也不会看到它。总之，对于 Git 仓库来说，它是不存在的。</p>
<p>如果我想提交这个文件，首先用 add 指令让 git 开始追踪它：<code>git add 练习文本.md</code></p>
<p>但是注意一个问题：当我输入这行代码后，终端不会给我任何反馈…<br>但是再次输入 <code>git status</code> 效果如下：<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-24-at-8.43.53-PM.png" alt="git add"></p>
<p>从上图我可以获得以下内容</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><code class="hljs taggerscript">- <span class="hljs-symbol">\3</span>47<span class="hljs-symbol">\2</span>73<span class="hljs-symbol">\2</span>03<span class="hljs-symbol">\3</span>44<span class="hljs-symbol">\2</span>71<span class="hljs-symbol">\2</span>40<span class="hljs-symbol">\3</span>46<span class="hljs-symbol">\2</span>26<span class="hljs-symbol">\2</span>07<span class="hljs-symbol">\3</span>46<span class="hljs-symbol">\2</span>34<span class="hljs-symbol">\2</span>54.md 文件变成了绿色。<br>- 而它的描述也从 &quot;Untracked files&quot; 变成了 &quot;Changes to be commited&quot;<br><br>这里说明了一点：练习文本.md 这个文件的状态 从 &quot;untracked&quot;(未跟踪)变成了 &quot;staged&quot;(已暂存) 。意思是这个文件的改动已经被记录在了staging area(暂存区)<br></code></pre></td></tr></table></figure>

<h5 id="git-commit-m-“提交描述”"><a href="#git-commit-m-“提交描述”" class="headerlink" title="git commit -m “提交描述”"></a>git commit -m “提交描述”</h5><p><strong>作用：把暂存区里的代码提交到本地仓库</strong></p>
<blockquote>
<p>这里 其实可以使用<code>git commit</code>。 不过需要你掌握 nano 或者 vim… 这里不多赘述</p>
</blockquote>
<p>输入之后，来看看提交记录: <code>git log</code><br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-24-at-8.51.45-PM.png" alt="git commit -m"></p>
<p><strong>内容已经成功提交到本地仓库啦！</strong><br>(这次提交已经保存在了 .git 这个目录里的某个地方了)</p>
<p>现在修改一下内容，然后用<code>git status</code>查看状态<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-24-at-8.56.06-PM.png" alt="二次输入"><br>可见，这个文件又变红了，不过这次它左边的文字不是 <code>&quot;New file:&quot;</code> 而是 <code>&quot;modified:&quot;</code>，而且上方显示它的状态也不是 <code>&quot;Untracked&quot;</code> 而是 “not staged for commit”，意思很明确:Git 已经认识这个文件了，它不是个新文件，但它有了一些改动。<br>后面的处理方式一样：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">add</span> xxx<br>git <span class="hljs-keyword">commit</span> -m &quot;xxx&quot;<br></code></pre></td></tr></table></figure>

<p>然后使用<code>git log</code>, 就会看见，当前已经有两次提交了</p>
<h5 id="把提交内容推送到中央仓库"><a href="#把提交内容推送到中央仓库" class="headerlink" title="把提交内容推送到中央仓库"></a>把提交内容推送到中央仓库</h5><h4 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h4><p><strong>注意：此操作需要联网！</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-24-at-9.02.29-PM.png" alt="git push"></p>
]]></content>
      <categories>
        <category>程序员素养篇</category>
      </categories>
      <tags>
        <tag>互联网</tag>
      </tags>
  </entry>
  <entry>
    <title>GraphQL</title>
    <url>/2021/12/17/GraphQL/</url>
    <content><![CDATA[<!-- 后端的GraphQL 先不学...先把我当前重点东西弄了来... -->

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2021-12-17-%E4%B8%8A%E5%8D%8810.56.16.png" alt="RESTful 的弊端1"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2021-12-17-%E4%B8%8A%E5%8D%8810.58.17.png" alt="RESTful 的弊端2"></p>
<p>后端返回的数据过多，前端只用到其中一部分。或者后端返回的数据过少，前端需要发送多个请求来组合数据，api 分散，不容易统一管理工具。<br>GraphQL 是一种新的 api 查询语言，前端可以自己决定需要那些数据，只需要发送一次请求就能获得所有的数据。访问集中提供的 api:<code>http://xxx/graphql</code>。前后端独立，后端的改动基本不影响前端的接口</p>
<p>GraphQL 的结构和 js 的对象结构很像。数据是按照类型组织的,类型中的数据都是强类型，可以是：String、Int、Float、Boolean、ID、数组、自定义类型</p>
<h3 id="前端使用-GraphQL"><a href="#前端使用-GraphQL" class="headerlink" title="前端使用 GraphQL"></a>前端使用 GraphQL</h3><p>一个免费的 graphql 的 api 的网站：<a href="https://countries.trevorblades.com/">https://countries.trevorblades.com/</a></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">|-index.html</span><br><span class="hljs-string">|-script.js</span><br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;script.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br>/* index.html */<br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;continent-select&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">selected</span> <span class="hljs-attr">hidden</span>&gt;</span>Select a Continent<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>  // 这里的hidden写法是挺讲究的。可以去掉看看效果<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;countries-list&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">/* script.js */</span><br><br>fetch(<span class="hljs-string">&#x27;https://countries.trevorblades.com/&#x27;</span>, &#123;<br>  method: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>  headers: &#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>&#125;,<br>  <span class="hljs-selector-tag">body</span>: JSON<span class="hljs-selector-class">.stringify</span>(&#123;<br>    query: `<br>      query &#123;<br>        continents &#123;<br>          name<br>          <span class="hljs-selector-tag">code</span><br>        &#125;<br>      &#125;<br>    `<br>  &#125;)<br>&#125;)<br><span class="hljs-selector-class">.then</span>(res =&gt; res<span class="hljs-selector-class">.json</span>())<br><span class="hljs-selector-class">.then</span>(data =&gt; &#123;<br>  console<span class="hljs-selector-class">.log</span>(data<span class="hljs-selector-class">.data</span>.continent)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2021-12-17-%E4%B8%8B%E5%8D%883.12.10.png" alt="打印结果1"></p>
<p>如果去掉 <code>code</code></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">/* script.js */</span><br><br>fetch(<span class="hljs-string">&#x27;https://countries.trevorblades.com/&#x27;</span>, &#123;<br>  method: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>  headers: &#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>&#125;,<br>  <span class="hljs-selector-tag">body</span>: JSON<span class="hljs-selector-class">.stringify</span>(&#123;<br>    query: `<br>      query &#123;<br>        continents &#123;<br>          name<br>        &#125;<br>      &#125;<br>    `<br>  &#125;)<br>&#125;)<br><span class="hljs-selector-class">.then</span>(res =&gt; res<span class="hljs-selector-class">.json</span>())<br><span class="hljs-selector-class">.then</span>(data =&gt; &#123;<br>  console<span class="hljs-selector-class">.log</span>(data<span class="hljs-selector-class">.data</span>.continent)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>结果如下：<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2021-12-17-%E4%B8%8B%E5%8D%883.13.23.png" alt="打印结果2"></p>
<p>现在结合 <code>select</code> 标签</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">/* script.js */</span><br>const continentSelect = document.querySelector(<span class="hljs-string">&#x27;#continent-select&#x27;</span>);<br><br><span class="hljs-keyword">fetch</span>(<span class="hljs-string">&#x27;https://countries.trevorblades.com/&#x27;</span>, &#123;<br>  <span class="hljs-keyword">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>  headers: &#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>&#125;,<br>  body: <span class="hljs-type">JSON</span>.stringify(&#123;<br>    query: `<br>      query &#123;<br>        continents &#123;<br>          <span class="hljs-type">name</span><br>          code<br>        &#125;<br>      &#125;<br>    `<br>  &#125;)<br>&#125;)<br>.<span class="hljs-keyword">then</span>(res =&gt; res.json())<br>.<span class="hljs-keyword">then</span>(data =&gt; &#123;<br>  data.data.continents.<span class="hljs-keyword">forEach</span>(continent =&gt; &#123;<br>    const <span class="hljs-keyword">option</span> = document.createElement(<span class="hljs-string">&#x27;option&#x27;</span>);<br>    <span class="hljs-keyword">option</span>.<span class="hljs-keyword">value</span> = continent.code;<br>    <span class="hljs-keyword">option</span>.innerText = continent.name;<br>    continentSelect.append(<span class="hljs-keyword">option</span>);<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2021-12-17-%E4%B8%8B%E5%8D%883.21.10.png" alt="select"></p>
<h4 id="传递变量"><a href="#传递变量" class="headerlink" title="传递变量"></a>传递变量</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* script.js */</span><br><span class="hljs-keyword">const</span> continentSelect = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#continent-select&#x27;</span>);<br><span class="hljs-keyword">const</span> continentList = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#countries-list&#x27;</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">queryFetch</span>(<span class="hljs-params">query, variables</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> fetch(<span class="hljs-string">&#x27;https://countries.trevorblades.com/&#x27;</span>, &#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>  <span class="hljs-attr">headers</span>: &#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>&#125;,<br>  <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify(&#123;<br>    <span class="hljs-attr">query</span>: query,<br>    <span class="hljs-attr">variables</span>: variables<br>  &#125;)<br>&#125;)<br>.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.json())<br>&#125;<br><br><br>continentSelect.addEventListener(<span class="hljs-string">&#x27;change&#x27;</span>,<span class="hljs-keyword">async</span> (e) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> continentCode = e.target.value;<br>  <span class="hljs-keyword">const</span> continentCountries = <span class="hljs-keyword">await</span> getContinentCountries(continentCode);<br>  continentList.innerText = <span class="hljs-string">&#x27;&#x27;</span>;  <span class="hljs-comment">// 每次使用先清零</span><br>  continentCountries.forEach(<span class="hljs-function"><span class="hljs-params">country</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> element = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);<br>    element.innerText = country.name;<br>    continentList.appendChild(element);<br>  &#125;)<br>&#125;)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getContinentCountries</span>(<span class="hljs-params">continentCode</span>) </span>&#123;<br>  <span class="hljs-comment">// 这里是带有变量的query查询</span><br>  <span class="hljs-keyword">return</span> queryFetch(<span class="hljs-string">`</span><br><span class="hljs-string">  query getCountries($code: ID!)&#123;</span><br><span class="hljs-string">    continent(code: $code) &#123;</span><br><span class="hljs-string">      countries &#123;</span><br><span class="hljs-string">        name</span><br><span class="hljs-string">      &#125;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">`</span>, &#123; <span class="hljs-attr">code</span>: continentCode &#125;).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> data.data.continent.countries)<br>&#125;<br><br><br>queryFetch(<span class="hljs-string">`</span><br><span class="hljs-string">  query &#123;</span><br><span class="hljs-string">    continents &#123;</span><br><span class="hljs-string">      name</span><br><span class="hljs-string">      code</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">`</span>)<br>.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>  data.data.continents.forEach(<span class="hljs-function"><span class="hljs-params">continent</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> option = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;option&#x27;</span>);<br>    option.value = continent.code;<br>    option.innerText = continent.name;<br>    continentSelect.append(option);<br>  &#125;)<br>&#125;)<br><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E5%B1%8F%E5%B9%95%E5%BD%95%E5%88%B62021-12-17-%E4%B8%8B%E5%8D%884.15.35.gif" alt="效果图"></p>
]]></content>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML之语义化标签</title>
    <url>/2021/12/10/HTML%E4%B9%8B%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<p>目前常用的语义化标签：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">&lt;Header&gt;    <span class="hljs-regexp">//</span> 表示标题的系列内容<br>&lt;h1&gt;        <span class="hljs-regexp">//</span> 一般用来表示最大的题目<br>&lt;h2&gt;        <span class="hljs-regexp">//</span> 表示次要一些的题目<br><br><br>&lt;form&gt;      <span class="hljs-regexp">//</span> 表示要输入的一些内容  一般input、button标签外部就要嵌套个form标签<br><br><br>&lt;main&gt;     <span class="hljs-regexp">//</span> 表示核心部分的内容<br>&lt;section&gt;   <span class="hljs-regexp">//</span> 表示某一部分的内容，一般嵌套在&lt;main&gt;里<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>HTML篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP状态码</title>
    <url>/2021/10/22/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    <content><![CDATA[<p><a href="https://www.restapitutorial.com/httpstatuscodes.html">HTTP Status Codes</a></p>
]]></content>
      <categories>
        <category>程序员素养篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>JS DOM操作</title>
    <url>/2021/11/24/JS-DOM%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p><strong>// TODO 还有些细节问题有待补充</strong></p>
<p>基础代码目录：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">|-index.html</span><br><span class="hljs-string">|-script.js</span><br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">/* index.html */<br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;script.js&quot;</span> <span class="hljs-attr">defer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">    <span class="hljs-selector-tag">body</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">display</span>: flex;</span><br><span class="css">      <span class="hljs-attribute">justify-content</span>: center;</span><br><span class="css">      <span class="hljs-attribute">align-items</span>: center;</span><br><span class="css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span>;</span><br><span class="css">    &#125;</span><br><span class="css">    <span class="hljs-selector-class">.grandparent</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;</span><br><span class="css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;</span><br><span class="css">      <span class="hljs-attribute">background-color</span>: red;</span><br><span class="css">      <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid black;</span><br><span class="css">      <span class="hljs-attribute">display</span>: flex;</span><br><span class="css">      <span class="hljs-attribute">flex-direction</span>: column;</span><br><span class="css">      <span class="hljs-attribute">justify-content</span>: center;</span><br><span class="css">      <span class="hljs-attribute">align-items</span>: center;</span><br><span class="css">    &#125;</span><br><span class="css">    <span class="hljs-selector-class">.parent</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">360px</span>;</span><br><span class="css">      <span class="hljs-attribute">height</span>:<span class="hljs-number">160px</span>;</span><br><span class="css">      <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;</span><br><span class="css">      <span class="hljs-attribute">background-color</span>: green;</span><br><span class="css">      <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid black;</span><br><span class="css">      <span class="hljs-attribute">display</span>: flex;</span><br><span class="css">      <span class="hljs-attribute">justify-content</span>: space-around;</span><br><span class="css">      <span class="hljs-attribute">align-items</span>: center;</span><br><span class="css">    &#125;</span><br><span class="css">    <span class="hljs-selector-class">.child</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">140px</span>;</span><br><span class="css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">      <span class="hljs-attribute">background-color</span>: yellow;</span><br><span class="css">      <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid black;</span><br><span class="css">    &#125;</span><br><span class="css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;grandparent&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;grandparent-id&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;child-one&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-24-at-12.13.37-PM.png" width="400px" alt="基础样式1">

<h4 id="getElementById"><a href="#getElementById" class="headerlink" title="getElementById"></a>getElementById</h4><p>现在我利用 <code>js</code> 来获取 <code>dom</code> 中带有 <code>id</code> 的元素</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;grandparent&quot;</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;grandparent-id&quot;</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/* script.js */</span><br><span class="hljs-keyword">const</span> grandparent = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;grandparent-id&#x27;</span>);<br>grandparent.style.backgroundColor = <span class="hljs-string">&quot;blue&quot;</span><br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-24-at-1.32.23-PM.png" width="350px" alt="基础样式2">

<h4 id="getElementsByClassName"><a href="#getElementsByClassName" class="headerlink" title="getElementsByClassName"></a>getElementsByClassName</h4><p>注意：使用这种方法后，返回的是一个伪数组</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/* script.js */</span><br>const grandparent = document.get<span class="hljs-constructor">ElementById(&#x27;<span class="hljs-params">grandparent</span>-<span class="hljs-params">id</span>&#x27;)</span>;<br><br><span class="hljs-comment">// Array.from() 方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例</span><br><span class="hljs-comment">// const parents = document.getElementsByClassName(&#x27;parent&#x27;);  // 这是一个伪数组</span><br>const parents = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>from(document.get<span class="hljs-constructor">ElementsByClassName(&#x27;<span class="hljs-params">parent</span>&#x27;)</span>);<br>parents.<span class="hljs-keyword">for</span><span class="hljs-constructor">Each(<span class="hljs-params">changeColor</span>)</span>;<br><br><span class="hljs-keyword">function</span> change<span class="hljs-constructor">Color(<span class="hljs-params">element</span>)</span> &#123;<br>  element.style.backgroundColor = <span class="hljs-string">&quot;purple&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-24-at-1.41.11-PM.png" width="400px" alt="基础样式3" />

<h4 id="querySelector-amp-querySelectorAll"><a href="#querySelector-amp-querySelectorAll" class="headerlink" title="querySelector &amp; querySelectorAll"></a>querySelector &amp; querySelectorAll</h4><p>上述两种方法很智能，可以代替 <code>getElementById</code> 和 <code>getElementsByClassName</code></p>
<p>不过注意：<code>querySelector</code> 只能捕捉一个元素。如果用 <code>querySelector</code> 来捕捉一系列的同类名元素。只会捕捉同类名的第一个元素(从上到下的排列)</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> grandparent = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;#grandparent-id&#x27;</span>)   <span class="hljs-comment">// id方法获取</span><br><span class="hljs-comment">// const grandparent = document.querySelector(&#x27;.grandparent&#x27;);  // class方法获取(不是伪数组)</span><br><br><span class="hljs-keyword">const</span> parent = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;.parent&#x27;</span>);<br>parent.style.backgroundColor = <span class="hljs-string">&quot;purple&quot;</span><br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-24-at-1.53.30-PM.png" width="400px"  alt="基础样式4"/>

<p><code>querySelectorAll</code> 解决了 <code>querySelector</code> 只能捕捉一个元素的问题</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">const grandparent = document.query<span class="hljs-constructor">Selector(&#x27;#<span class="hljs-params">grandparent</span>-<span class="hljs-params">id</span>&#x27;)</span>   <span class="hljs-comment">// id方法获取</span><br><span class="hljs-comment">// const grandparent = document.querySelector(&#x27;.grandparent&#x27;);  // class方法获取(不是伪数组)</span><br><br><br>const parents = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>from(document.query<span class="hljs-constructor">SelectorAll(&#x27;.<span class="hljs-params">parent</span>&#x27;)</span>);<br>parents.<span class="hljs-keyword">for</span><span class="hljs-constructor">Each(<span class="hljs-params">changeColor</span>)</span>;<br><br><span class="hljs-keyword">function</span> change<span class="hljs-constructor">Color(<span class="hljs-params">element</span>)</span> &#123;<br>  element.style.backgroundColor = <span class="hljs-string">&quot;purple&quot;</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-24-at-1.56.54-PM.png" width="400px" alt="基础样式5">

<hr>
<p><strong>注意：</strong><br>有一个问题：我前文有说，<code>getElementsByClassName</code> 获取的是一个类数组(伪数组)，<code>querySelectorAll</code>也获取的是一个类数组(伪数组)。但是它们的伪数组是不一样的。<strong>getElementsByClassName 获取的是 HTMLCollection</strong> 而 <strong>querySelectorAll 获取全部对象集合，是一个 NodeList 类数组</strong> <code>querySelectorAll</code> 获取的元素即使不转化为 数组，也能够使用<code>forEach</code>，但是<code>getElementsByClassName</code>不可以</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-25-at-11.46.03-AM.png" width="450px" alt="伪数组问题"></h2><h4 id="通过-children-来获取子类"><a href="#通过-children-来获取子类" class="headerlink" title="通过 children 来获取子类"></a>通过 children 来获取子类</h4><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">const</span> grandparent = document.querySelector(<span class="hljs-string">&#x27;.grandparent&#x27;</span>)<br><span class="hljs-keyword">const</span> parents = <span class="hljs-keyword">Array</span>.<span class="hljs-keyword">from</span>(grandparent.children);    <span class="hljs-comment">// 通过 children 来获取子类</span><br><br>parents.<span class="hljs-keyword">forEach</span>(changeColor)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeColor</span>(<span class="hljs-params">element</span>) </span>&#123;<br>  element.style.backgroundColor = <span class="hljs-string">&#x27;black&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-24-at-2.06.10-PM.png" width="400px" alt="基础样式6">

<p>利用 <code>children</code> 属性来灵活控制元素</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">const</span> grandparent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.grandparent&#x27;</span>);<br><span class="hljs-keyword">const</span> parents = <span class="hljs-built_in">Array</span>.<span class="hljs-keyword">from</span>(grandparent.children);<br><span class="hljs-keyword">const</span> parentOne = parents[<span class="hljs-number">0</span>];<br><br><span class="hljs-keyword">const</span> children = <span class="hljs-built_in">Array</span>.<span class="hljs-keyword">from</span>(parentOne.children)<br>changeColor(children[<span class="hljs-number">0</span>])<br><br><span class="hljs-keyword">function</span> changeColor(element) &#123;<br>  element.style.backgroundColor = <span class="hljs-string">&#x27;black&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-24-at-2.10.36-PM.png" width="400px" alt="基础样式7">

<p><code>querySelector</code> 和 <code>querySelectorAll</code> 还能在子元素的基础上继续使用。这样的操作对于<code>getElementById</code> 和 <code>getElementsByClassName</code> 是无法实现的</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">const</span> grandparent = document.querySelector(<span class="hljs-string">&#x27;.grandparent&#x27;</span>);<br><span class="hljs-keyword">const</span> parents = <span class="hljs-keyword">Array</span>.<span class="hljs-keyword">from</span>(grandparent.children);<br><br><span class="hljs-keyword">const</span> children = <span class="hljs-keyword">Array</span>.<span class="hljs-keyword">from</span>(parents[<span class="hljs-number">0</span>].querySelectorAll(<span class="hljs-string">&#x27;.child&#x27;</span>))<br>children.<span class="hljs-keyword">forEach</span>(changeColor)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeColor</span>(<span class="hljs-params">element</span>) </span>&#123;<br>  element.style.backgroundColor = <span class="hljs-string">&#x27;black&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-24-at-2.17.24-PM.png" width="400px" alt="基础样式8">

<h4 id="parent"><a href="#parent" class="headerlink" title="parent"></a>parent</h4><p><code>parentElement</code> <code>parentNode</code> 这二者还是有一点点小的区别的 // 有待查找</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">const childOne = document.query<span class="hljs-constructor">Selector(<span class="hljs-string">&quot;#child-one&quot;</span>)</span><br>const parent = childOne.parentElement;<br>const grandparent = parent.parentElement;<br><br>change<span class="hljs-constructor">Color(<span class="hljs-params">grandparent</span>)</span><br>change<span class="hljs-constructor">Color(<span class="hljs-params">parent</span>)</span><br><br><br><span class="hljs-keyword">function</span> change<span class="hljs-constructor">Color(<span class="hljs-params">element</span>)</span> &#123;<br>  element.style.backgroundColor = &#x27;black&#x27;<br>&#125;<br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-24-at-2.45.38-PM.png" width="400px" alt=”parent1“>

<h4 id="closest"><a href="#closest" class="headerlink" title="closest"></a>closest</h4><p>// 有待进一步学习…</p>
<h4 id="nextElementSibling"><a href="#nextElementSibling" class="headerlink" title="nextElementSibling"></a>nextElementSibling</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> childOne = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#child-one&quot;</span>)<br><span class="hljs-keyword">const</span> childTwo = childOne.nextElementSibling;<br><br>changeColor(childTwo)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeColor</span>(<span class="hljs-params">element</span>) </span>&#123;<br>  element.style.backgroundColor = <span class="hljs-string">&#x27;black&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-24-at-2.50.26-PM.png" width="400px" alt=”nextElementSibling“>

<h4 id="previousElementSibling"><a href="#previousElementSibling" class="headerlink" title="previousElementSibling"></a>previousElementSibling</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">const childOne = document.query<span class="hljs-constructor">Selector(<span class="hljs-string">&quot;#child-one&quot;</span>)</span><br>const childTwo = childOne.nextElementSibling;<br><br>change<span class="hljs-constructor">Color(<span class="hljs-params">childTwo</span>.<span class="hljs-params">previousElementSibling</span>)</span><br><br><span class="hljs-keyword">function</span> change<span class="hljs-constructor">Color(<span class="hljs-params">element</span>)</span> &#123;<br>  element.style.backgroundColor = &#x27;black&#x27;<br>&#125;<br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-24-at-2.50.26-PM.png" width="400px" alt="previousElementSibling">
]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>JS-DOM操作2</title>
    <url>/2021/11/25/JS-DOM%E6%93%8D%E4%BD%9C2/</url>
    <content><![CDATA[<p>文件夹目录：<br>(下列全为空文件)</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">|-index.html</span><br><span class="hljs-string">|-script.js</span><br></code></pre></td></tr></table></figure>

<h4 id="添加元素到页面"><a href="#添加元素到页面" class="headerlink" title="添加元素到页面"></a>添加元素到页面</h4><h5 id="append"><a href="#append" class="headerlink" title="append"></a>append</h5><figure class="highlight d"><table><tr><td class="code"><pre><code class="hljs d"><span class="hljs-comment">/* script.js */</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">body</span> = document.<span class="hljs-keyword">body</span>;<br><span class="hljs-keyword">body</span>.append(<span class="hljs-string">&quot;Hello World&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>此时页面会显示 <strong><code>Hello World</code></strong></p>
<h5 id="appendChild"><a href="#appendChild" class="headerlink" title="appendChild"></a>appendChild</h5><p>但是如果是这样</p>
<figure class="highlight d"><table><tr><td class="code"><pre><code class="hljs d"><span class="hljs-comment">/* script.js */</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">body</span> = document.<span class="hljs-keyword">body</span>;<br><span class="hljs-keyword">body</span>.appendChild(<span class="hljs-string">&quot;Hello World&quot;</span>)<br></code></pre></td></tr></table></figure>

<blockquote>
<p>页面控制台报错：script.js:2 Uncaught TypeError: Failed to execute ‘appendChild’ on ‘Node’: parameter 1 is not of type ‘Node’.</p>
</blockquote>
<p>告诉我们页面需要 <code>node</code>，而不是 <code>string</code></p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>事实上，对于<code>appendChild</code>你只能添加 <code>div</code>、<code>span</code>这种<code>node</code>结点; 但是<code>append</code> 去可以添加任何元素…甚至字符串…</p>
<h4 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h4><p><code>document.createElement(&#39;&#39;)</code> 这种方式可以创建各种元素<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-25-at-3.48.20-PM.png" alt="创建元素"></p>
<p>例如创建一个<code>div</code>标签: <code>const div = document.createElement(&#39;div&#39;)</code></p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">/* script.js */</span><br><span class="hljs-keyword">const</span> body = document.body;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">div</span> = document.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);<br>body.append(<span class="hljs-keyword">div</span>);    <span class="hljs-comment">// 此时，div标签已经放在了页面上</span><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-25-at-3.53.04-PM.png" alt="创建元素"></p>
<h4 id="给创建的元素增添内容"><a href="#给创建的元素增添内容" class="headerlink" title="给创建的元素增添内容"></a>给创建的元素增添内容</h4><h5 id="innerText"><a href="#innerText" class="headerlink" title="innerText"></a>innerText</h5><figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">const</span> body = document.body;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">div</span> = document.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);<br><br><span class="hljs-keyword">div</span>.innerText = <span class="hljs-string">&#x27;Hello World&#x27;</span><br>body.append(<span class="hljs-keyword">div</span>);<br></code></pre></td></tr></table></figure>

<p>此时，页面会打印出<code>Hello World</code></p>
<h5 id="textContent"><a href="#textContent" class="headerlink" title="textContent"></a>textContent</h5><figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">const</span> body = document.body;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">div</span> = document.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);<br><br><span class="hljs-keyword">div</span>.textContent = <span class="hljs-string">&#x27;Hello World&#x27;</span><br>body.append(<span class="hljs-keyword">div</span>);<br></code></pre></td></tr></table></figure>

<p>此时，页面也会打印出<code>Hello World</code></p>
<h5 id="innerText-VS-textContent"><a href="#innerText-VS-textContent" class="headerlink" title="innerText VS textContent"></a>innerText VS textContent</h5><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">/* index.html */<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display:none;&quot;</span>&gt;</span>Bye<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">/* <span class="hljs-keyword">script</span>.js */<br>const <span class="hljs-keyword">div</span> = document.querySelector(&#x27;<span class="hljs-keyword">div</span>&#x27;);<br><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">div</span>.textContent);<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">div</span>.innerText);<br></code></pre></td></tr></table></figure>

<p>打印结果：<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-25-at-4.03.20-PM.png" alt="innerText VS textContent"></p>
<p>它们的区别如下：<br><strong>textContent</strong> 不仅会获得 html 中实实在在出现的内容(不受 css 影响)，甚至连标签空了多少格也会知晓<br><strong>innerText</strong> 只会获得应该显示的内容(受 css 影响)</p>
<h5 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a>innerHTML</h5><p><strong>作用：往页面注射 html 标签</strong></p>
<p>当前 <code>index.html</code> 页面 <code>body</code> 部分内容为空</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">/* script.js */</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">div</span> = document.body;<br><span class="hljs-keyword">div</span>.innerText = <span class="hljs-string">&#x27;&lt;strong&gt;你好&lt;/strong&gt;&#x27;</span> <span class="hljs-comment">// div.textContent效果一样</span><br></code></pre></td></tr></table></figure>

<p>页面打印内容为：<code>&lt;strong&gt;你好&lt;/strong&gt;</code></p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">/* script.js */</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">div</span> = document.body;<br><span class="hljs-keyword">div</span>.innerHTML = <span class="hljs-string">&#x27;&lt;strong&gt;你好&lt;/strong&gt;&#x27;</span><br></code></pre></td></tr></table></figure>

<p>页面打印内容为：<strong>你好</strong> (加粗版)</p>
<p><strong>注意：这种方式看似非常方便，但会有极大的安全问题！！</strong> 因此我也有了一篇相关博客</p>
<p>在 <code>js</code> 中，我目前知道的也只有这样的方式能注射 <code>html</code> 内容。不过，以上面例子为例，我可以用另外的方式达到同样的效果</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">/* script.js */</span><br><span class="hljs-keyword">const</span> body = document.body;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">strong</span> = document.createElement(<span class="hljs-string">&#x27;strong&#x27;</span>);<br><span class="hljs-keyword">strong</span>.innerText=<span class="hljs-string">&#x27;你好&#x27;</span>;<br>body.append(<span class="hljs-keyword">strong</span>);<br></code></pre></td></tr></table></figure>

<h4 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h4><h5 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">/* index.html */</span><br>&lt;div&gt;<br>  &lt;span <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">var1</span>&quot;&gt;好吗？&lt;/<span class="hljs-symbol">span</span>&gt;<br>  &lt;<span class="hljs-symbol">span</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">var2</span>&quot;&gt;好的！&lt;/<span class="hljs-symbol">span</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/* script.js */</span><br><span class="hljs-keyword">const</span> div = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;div&quot;</span>);<br><span class="hljs-keyword">const</span> var1 = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;var1&quot;</span>);<br><span class="hljs-keyword">const</span> var2 = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;var2&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>页面显示： <strong>好吗？好的！</strong></p>
<p>现在使用<code>remove()</code>方法<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-25-at-5.27.02-PM.png" alt="remove"></p>
<p>可见，使用了 <code>remove</code> 后，整个 <code>html页面</code> 该元素已经被彻底销毁了</p>
<h5 id="removeChild"><a href="#removeChild" class="headerlink" title="removeChild()"></a>removeChild()</h5><p>可以移除自己的子元素</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/* script.js */</span><br><span class="hljs-keyword">const</span> div = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;div&quot;</span>);<br><span class="hljs-keyword">const</span> var1 = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;.var1&quot;</span>);<br><span class="hljs-keyword">const</span> var2 = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;.var2&quot;</span>);<br><br>div.removeChild(var1);<br></code></pre></td></tr></table></figure>

<p>同样可以达到整个 <code>html页面</code> 中把该元素彻底销毁</p>
<p>但使用 <code>remove()</code> 更加的简单明了</p>
<h4 id="元素的属性"><a href="#元素的属性" class="headerlink" title="元素的属性"></a>元素的属性</h4><h5 id="getAttribute-获取元素的属性值"><a href="#getAttribute-获取元素的属性值" class="headerlink" title="getAttribute 获取元素的属性值"></a>getAttribute 获取元素的属性值</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">/* index.html */</span><br>&lt;div&gt;<br>  &lt;span title=<span class="hljs-string">&quot;hi&quot;</span> <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">var1</span>&quot;&gt;好吗？&lt;/<span class="hljs-symbol">span</span>&gt;<br>  &lt;<span class="hljs-symbol">span</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">var2</span>&quot;&gt;好的！&lt;/<span class="hljs-symbol">span</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* script.js */</span><br><span class="hljs-keyword">const</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;div&quot;</span>);<br><span class="hljs-keyword">const</span> var1 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.var1&quot;</span>);<br><span class="hljs-keyword">const</span> var2 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.var2&quot;</span>);<br><br><span class="hljs-built_in">console</span>.log(var1.getAttribute(<span class="hljs-string">&#x27;class&#x27;</span>));    <span class="hljs-comment">// var1 (获取了元素的类名)</span><br><span class="hljs-built_in">console</span>.log(var1.getAttribute(<span class="hljs-string">&#x27;title&#x27;</span>));    <span class="hljs-comment">// hi (获取了元素的title属性的内容)</span><br><br>当然，你直接这样写也可以获取属性<br><span class="hljs-built_in">console</span>.log(var1.className);    <span class="hljs-comment">// var1 (获取了元素的类名)  注意，这里是className</span><br><span class="hljs-built_in">console</span>.log(var1.title);        <span class="hljs-comment">// hi (获取了元素的title属性的内容)</span><br></code></pre></td></tr></table></figure>

<h5 id="setAttribute-修改元素的属性值"><a href="#setAttribute-修改元素的属性值" class="headerlink" title="setAttribute 修改元素的属性值"></a>setAttribute 修改元素的属性值</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">/* index.html */</span><br>&lt;div&gt;<br>  &lt;span title=<span class="hljs-string">&quot;hi&quot;</span> <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">var1</span>&quot;&gt;好吗？&lt;/<span class="hljs-symbol">span</span>&gt;<br>  &lt;<span class="hljs-symbol">span</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">var2</span>&quot;&gt;好的！&lt;/<span class="hljs-symbol">span</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/* script.js */</span><br><span class="hljs-keyword">const</span> div = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;div&quot;</span>);<br><span class="hljs-keyword">const</span> var1 = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;.var1&quot;</span>);<br><span class="hljs-keyword">const</span> var2 = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;.var2&quot;</span>);<br><br>console.log(var1.setAttribute(<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;self&#x27;</span>));<br></code></pre></td></tr></table></figure>

<p>这里还甚至自动给 <code>var1</code> 添加了 <code>id</code> 属性<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-25-at-5.42.41-PM.png" alt="setAttribute"></p>
<figure class="highlight gml"><table><tr><td class="code"><pre><code class="hljs gml">当然，你直接这样写也可以修改属性<br>var1.<span class="hljs-symbol">id</span> = <span class="hljs-string">&#x27;123&#x27;</span><br></code></pre></td></tr></table></figure>

<h5 id="removeAttribute-移除元素属性值"><a href="#removeAttribute-移除元素属性值" class="headerlink" title="removeAttribute 移除元素属性值"></a>removeAttribute 移除元素属性值</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">/* index.html */</span><br>&lt;div&gt;<br>  &lt;span title=<span class="hljs-string">&quot;hi&quot;</span> <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">var1</span>&quot;&gt;好吗？&lt;/<span class="hljs-symbol">span</span>&gt;<br>  &lt;<span class="hljs-symbol">span</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">var2</span>&quot;&gt;好的！&lt;/<span class="hljs-symbol">span</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/* script.js */</span><br><span class="hljs-keyword">const</span> div = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;div&quot;</span>);<br><span class="hljs-keyword">const</span> var1 = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;.var1&quot;</span>);<br><span class="hljs-keyword">const</span> var2 = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;.var2&quot;</span>);<br><br>var1.removeAttribute(<span class="hljs-string">&#x27;title&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-25-at-5.48.16-PM.png" alt="removeAttribute"></p>
<h4 id="data-attribute"><a href="#data-attribute" class="headerlink" title="data-attribute"></a>data-attribute</h4><h5 id="获取-Data-属性名"><a href="#获取-Data-属性名" class="headerlink" title="获取 Data 属性名"></a>获取 Data 属性名</h5><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">/* index.html */<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;var1&quot;</span> <span class="hljs-attr">data-test</span>=<span class="hljs-string">&quot;this is a test&quot;</span> <span class="hljs-attr">data-another-test</span>=<span class="hljs-string">&quot;this is another test&quot;</span>&gt;</span>好吗？<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;var2&quot;</span>&gt;</span>好的！<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/* script.js */</span><br><span class="hljs-keyword">const</span> div = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;div&quot;</span>);<br><span class="hljs-keyword">const</span> var1 = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;.var1&quot;</span>);<br><span class="hljs-keyword">const</span> var2 = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;.var2&quot;</span>);<br><br>console.log(var1.dataset);<br>console.log(var1.dataset.test);<br>console.log(var1.dataset.anotherTest);  <span class="hljs-comment">// 这里是驼峰写法(用 驼峰 代替 -)</span><br></code></pre></td></tr></table></figure>

<p>打印结果：<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-25-at-5.59.41-PM.png" alt="data-attribute"></p>
<h5 id="修改-Data-属性内容"><a href="#修改-Data-属性内容" class="headerlink" title="修改 Data 属性内容"></a>修改 Data 属性内容</h5><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">/* index.html */<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;var1&quot;</span> <span class="hljs-attr">data-test</span>=<span class="hljs-string">&quot;this is a test&quot;</span> <span class="hljs-attr">data-another-test</span>=<span class="hljs-string">&quot;this is another test&quot;</span>&gt;</span>好吗？<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;var2&quot;</span>&gt;</span>好的！<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/* script.js */</span><br><span class="hljs-keyword">const</span> div = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;div&quot;</span>);<br><span class="hljs-keyword">const</span> var1 = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;.var1&quot;</span>);<br><span class="hljs-keyword">const</span> var2 = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;.var2&quot;</span>);<br><br>console.log(var1.dataset);<br>console.log(var1.dataset.test);<br>console.log(var1.dataset.anotherTest);  <span class="hljs-comment">// 这里是驼峰写法(用 驼峰 代替 -)</span><br><br>var1.dataset.newTest = <span class="hljs-string">&#x27;new test&#x27;</span><br></code></pre></td></tr></table></figure>

<p>打印结果：<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-25-at-6.03.01-PM.png" alt="chang-attribute"></p>
<h4 id="对于-class-的控制"><a href="#对于-class-的控制" class="headerlink" title="对于 class 的控制"></a>对于 class 的控制</h4><h5 id="add"><a href="#add" class="headerlink" title="add"></a>add</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">/* index.html */</span><br>&lt;div&gt;<br>  &lt;span <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">var1</span>&quot;&gt;好吗？&lt;/<span class="hljs-symbol">span</span>&gt;<br>  &lt;<span class="hljs-symbol">span</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">var2</span>&quot;&gt;好的！&lt;/<span class="hljs-symbol">span</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/* script.js */</span><br><span class="hljs-keyword">const</span> div = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;div&quot;</span>);<br><span class="hljs-keyword">const</span> var1 = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;.var1&quot;</span>);<br><span class="hljs-keyword">const</span> var2 = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;.var2&quot;</span>);<br><br>var1.classList.add(<span class="hljs-string">&#x27;new-class&#x27;</span>);   <span class="hljs-comment">// 给var1 又添加了一个类名</span><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-25-at-6.06.30-PM.png" alt="classList"></p>
<h5 id="remove-1"><a href="#remove-1" class="headerlink" title="remove"></a>remove</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">/* index.html */</span><br>&lt;div&gt;<br>  &lt;span <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">var1</span>&quot;&gt;好吗？&lt;/<span class="hljs-symbol">span</span>&gt;<br>  &lt;<span class="hljs-symbol">span</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">var2</span>&quot;&gt;好的！&lt;/<span class="hljs-symbol">span</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/* script.js */</span><br><span class="hljs-keyword">const</span> div = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;div&quot;</span>);<br><span class="hljs-keyword">const</span> var1 = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;.var1&quot;</span>);<br><span class="hljs-keyword">const</span> var2 = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;.var2&quot;</span>);<br><br>var1.classList.add(<span class="hljs-string">&#x27;new-class&#x27;</span>)    <span class="hljs-comment">// 添加</span><br>var1.classList.remove(<span class="hljs-string">&#x27;new-class&#x27;</span>) <span class="hljs-comment">// 又移除</span><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-25-at-6.08.32-PM.png" alt="add&amp;remove"></p>
<h5 id="toggle"><a href="#toggle" class="headerlink" title="toggle"></a>toggle</h5><p>(第二参数为 true 的时候，添加该类名 为 false 的时候删除该类名)</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/* script.js */</span><br><span class="hljs-keyword">const</span> div = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;div&quot;</span>);<br><span class="hljs-keyword">const</span> var1 = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;.var1&quot;</span>);<br><span class="hljs-keyword">const</span> var2 = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;.var2&quot;</span>);<br><br>var1.classList.toggle(<span class="hljs-string">&#x27;toggle-name&#x27;</span>, <span class="hljs-keyword">false</span>);<br></code></pre></td></tr></table></figure>

<h4 id="修改元素的-style-样式"><a href="#修改元素的-style-样式" class="headerlink" title="修改元素的 style 样式"></a>修改元素的 style 样式</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">/* index.html */</span><br>&lt;div&gt;<br>  &lt;span <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">var1</span>&quot;&gt;好吗？&lt;/<span class="hljs-symbol">span</span>&gt;<br>  &lt;<span class="hljs-symbol">span</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">var2</span>&quot;&gt;好的！&lt;/<span class="hljs-symbol">span</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/* script.js */</span><br><span class="hljs-keyword">const</span> div = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;div&quot;</span>);<br><span class="hljs-keyword">const</span> var1 = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;.var1&quot;</span>);<br><span class="hljs-keyword">const</span> var2 = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;.var2&quot;</span>);<br><br>var1.style.color = <span class="hljs-string">&#x27;white&#x27;</span>;<br>var1.style.backgroundColor = <span class="hljs-string">&#x27;green&#x27;</span>;   <span class="hljs-comment">// 驼峰命名</span><br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-25-at-6.17.39-PM.png" width="250px" alt="style"/>
]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>JS-DOM操作3 事件</title>
    <url>/2021/11/25/JS-DOM%E6%93%8D%E4%BD%9C3-%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">/* index.html */<br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./script.js&quot;</span> <span class="hljs-attr">defer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">    <span class="hljs-selector-class">.grandparent</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">250px</span>;</span><br><span class="css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">250px</span>;</span><br><span class="css">      <span class="hljs-attribute">background-color</span>: red;</span><br><span class="css">      <span class="hljs-attribute">display</span>: flex;</span><br><span class="css">      <span class="hljs-attribute">justify-content</span>: center;</span><br><span class="css">      <span class="hljs-attribute">align-items</span>: center;</span><br><span class="css">    &#125;</span><br><span class="css">    <span class="hljs-selector-class">.parent</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">180px</span>;</span><br><span class="css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">180px</span>;</span><br><span class="css">      <span class="hljs-attribute">background-color</span>: blue;</span><br><span class="css">      <span class="hljs-attribute">display</span>: flex;</span><br><span class="css">      <span class="hljs-attribute">justify-content</span>: center;</span><br><span class="css">      <span class="hljs-attribute">align-items</span>: center;</span><br><span class="css">    &#125;</span><br><span class="css">    <span class="hljs-selector-class">.child</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">80px</span>;</span><br><span class="css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">80px</span>;</span><br><span class="css">      <span class="hljs-attribute">background-color</span>: green;</span><br><span class="css">    &#125;</span><br><span class="css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;grandparent&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/* srcipt.js */</span><br><span class="hljs-keyword">const</span> grandparent = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;.grandparent&quot;</span>);<br><span class="hljs-keyword">const</span> parent = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;.parent&quot;</span>);<br><span class="hljs-keyword">const</span> child = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;.child&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>效果图如下：<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-25-at-6.41.40-PM.png" alt="效果图" width="300px"/></p>
<h4 id="点击事件"><a href="#点击事件" class="headerlink" title="点击事件"></a>点击事件</h4><p><code>click</code></p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span> addEventListener 可以接受<span class="hljs-number">2</span>个或<span class="hljs-number">3</span>个参数 不过，绝大多数情况下是使用两个参数<br>grandparent.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(e)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(e);<br>&#125;)<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-25-at-8.30.38-PM.png" alt="点击事件1"></p>
<p>上图可得 事件 <code>e</code>有非常多的属性。但是我们重点来关注一下 <code>target</code><br>重点是 <code>e.target</code></p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span> addEventListener 可以接受<span class="hljs-number">2</span>个或<span class="hljs-number">3</span>个参数 不过，绝大多数情况下是使用两个参数<br>grandparent.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(e)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(e.target);<br>&#125;)<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-25-at-8.32.01-PM.png" alt="点击事件2"></p>
<p><strong>注意：事件执行是按照从上到下的顺序来写的</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> grandparent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.grandparent&quot;</span>);<br><span class="hljs-keyword">const</span> parent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.parent&quot;</span>);<br><span class="hljs-keyword">const</span> child = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.child&quot;</span>)<br><br><span class="hljs-comment">// addEventListener 可以接受2个或3个参数 不过，绝大多数情况下是使用两个参数</span><br>grandparent.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;grandparent 1&#x27;</span>);<br>&#125;)<br><br>grandparent.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;grandparent 2&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>控制台打印：(事实上我只点击了一次 grandparent)</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">grandparent</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">grandparent</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<h4 id="事件的额外知识"><a href="#事件的额外知识" class="headerlink" title="事件的额外知识"></a>事件的额外知识</h4><h5 id="事件冒泡和事件捕捉"><a href="#事件冒泡和事件捕捉" class="headerlink" title="事件冒泡和事件捕捉"></a>事件冒泡和事件捕捉</h5><p><strong>注意：默认是执行事件冒泡</strong></p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> grandparent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.grandparent&quot;</span>);<br><span class="hljs-keyword">const</span> parent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.parent&quot;</span>);<br><span class="hljs-keyword">const</span> child = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.child&quot;</span>)<br><br><span class="hljs-comment">// addEventListener 可以接受2个或3个参数 不过，绝大多数情况下是使用两个参数</span><br>grandparent.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;grandparent 1&#x27;</span>);<br>&#125;)<br><br>grandparent.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;grandparent 2&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>我这次点击 <code>parent</code> 或者 <code>child</code> 都会打印</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">grandparent</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">grandparent</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p>好！现在继续观察下面代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 代码是在上面的基础上进行更改</span><br><span class="hljs-keyword">const</span> grandparent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.grandparent&quot;</span>);<br><span class="hljs-keyword">const</span> parent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.parent&quot;</span>);<br><span class="hljs-keyword">const</span> child = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.child&quot;</span>)<br><br><span class="hljs-comment">// addEventListener 可以接受2个或3个参数 不过，绝大多数情况下是使用两个参数</span><br>grandparent.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;grandparent 1&#x27;</span>);<br>&#125;)<br><br>parent.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;parent 1&#x27;</span>);<br>&#125;)<br><br>child.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child 1&#x27;</span>);<br>&#125;)<br><br><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;document 1&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-25-at-8.44.02-PM.gif" alt="观察"></p>
<p>上面这种现象叫做 <strong>事件冒泡</strong> (想象泡泡向上游动)</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">document<br>   <span class="hljs-string">| 向上</span><br>grandparent<br>   <span class="hljs-string">| 向上</span><br> parent<br>   <span class="hljs-string">| 向上</span><br> child   &lt;--当点击child的时候<br></code></pre></td></tr></table></figure>

<p><strong>事件捕捉</strong><br><strong>注意：事件捕捉</strong>先发生，然后再进行的<strong>事件冒泡</strong></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">document<br>   <span class="hljs-string">| 向下</span><br>grandparent<br>   <span class="hljs-string">| 向下</span><br> parent<br>   <span class="hljs-string">| 向下</span><br> child<br></code></pre></td></tr></table></figure>

<p>现在来控制事件为事件捕捉！<br><code>addEventListener</code>的第三个参数是一个对象。 我给 <code>capture</code> 变为 <code>true</code><br>具体操作如下：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">grandparent.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(e)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;grandparent 1&#x27;</span>);<br>&#125;, &#123;capture: <span class="hljs-literal">true</span>&#125;)<br></code></pre></td></tr></table></figure>

<p>现在会发生一些列的变化：<br>先看整体代码：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">const grandparent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.grandparent&quot;</span>);<br>const parent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.parent&quot;</span>);<br>const child = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.child&quot;</span>)<br><br>grandparent.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(e)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;grandparent 1&#x27;</span>);<br>&#125;, &#123;capture: <span class="hljs-literal">true</span>&#125;)<br><br>parent.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(e)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;parent 1&#x27;</span>);<br>&#125;)<br><br>child.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(e)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child 1&#x27;</span>);<br>&#125;)<br><br><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(e)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;document 1&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>我点击了<code> child</code>(即绿色方块) 打印效果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-25-at-8.58.13-PM.png" alt="事件冒泡"></p>
<p>我们可见，打印依次顺序是 <code>grandparent --&gt; child --&gt; parent --&gt; document</code></p>
<p>原因是在事件捕捉状态的时候打印了 <code>grandparent</code> ,然后在事件冒泡的时候，逐个打印 <code>child --&gt; parent --&gt; document</code></p>
<p>现在来直观看看：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">const grandparent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.grandparent&quot;</span>);<br>const parent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.parent&quot;</span>);<br>const child = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.child&quot;</span>)<br><br>grandparent.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(e)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;grandparent capture&#x27;</span>);<br>&#125;, &#123;capture: <span class="hljs-literal">true</span>&#125;)<br>grandparent.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(e)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;grandparent bubble&#x27;</span>);<br>&#125;)<br><br>parent.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(e)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;parent bubble&#x27;</span>);<br>&#125;)<br>parent.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(e)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;parent capture&#x27;</span>);<br>&#125;, &#123;capture: <span class="hljs-literal">true</span>&#125;)<br><br>child.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(e)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child bubble&#x27;</span>);<br>&#125;)<br><br>child.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(e)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child capture&#x27;</span>);<br>&#125;, &#123;capture: <span class="hljs-literal">true</span>&#125;)<br><br><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(e)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;document bubble&#x27;</span>);<br>&#125;)<br><br><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(e)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;document capture&#x27;</span>);<br>&#125;, &#123;capture: <span class="hljs-literal">true</span>&#125;)<br></code></pre></td></tr></table></figure>

<p>现在我来点击一下 <code>绿色块(child)</code> 打印结果如下：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata">document <span class="hljs-keyword">capture</span><br>grandparent <span class="hljs-keyword">capture</span><br>parent <span class="hljs-keyword">capture</span><br>child <span class="hljs-keyword">capture</span><br>child <span class="hljs-keyword">bubble</span><br>parent <span class="hljs-keyword">bubble</span><br>grandparent <span class="hljs-keyword">bubble</span><br>document <span class="hljs-keyword">bubble</span><br></code></pre></td></tr></table></figure>

<h5 id="阻止事件捕捉和事件冒泡的继续执行"><a href="#阻止事件捕捉和事件冒泡的继续执行" class="headerlink" title="阻止事件捕捉和事件冒泡的继续执行"></a>阻止事件捕捉和事件冒泡的继续执行</h5><p><strong>stopPropagation</strong></p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">const grandparent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.grandparent&quot;</span>);<br>const parent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.parent&quot;</span>);<br>const child = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.child&quot;</span>)<br><br>grandparent.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(e)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;grandparent capture&#x27;</span>);<br>&#125;, &#123;capture: <span class="hljs-literal">true</span>&#125;)<br>grandparent.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(e)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;grandparent bubble&#x27;</span>);<br>&#125;)<br><br>parent.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(e)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;parent bubble&#x27;</span>);<br>&#125;)<br>parent.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(e)</span> =&gt;</span> &#123;<br>  e.stopPropagation()      <span class="hljs-regexp">//</span> 注意这里！！<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;parent capture&#x27;</span>);<br>&#125;, &#123;capture: <span class="hljs-literal">true</span>&#125;)<br><br>child.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(e)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child bubble&#x27;</span>);<br>&#125;)<br><br>child.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(e)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child capture&#x27;</span>);<br>&#125;, &#123;capture: <span class="hljs-literal">true</span>&#125;)<br><br><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(e)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;document bubble&#x27;</span>);<br>&#125;)<br><br><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(e)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;document capture&#x27;</span>);<br>&#125;, &#123;capture: <span class="hljs-literal">true</span>&#125;)<br></code></pre></td></tr></table></figure>

<p>我点击<code>绿色方块(child)</code>打印结果如下：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata">document <span class="hljs-keyword">capture</span><br>grandparent <span class="hljs-keyword">capture</span><br>parent <span class="hljs-keyword">capture</span>   <span class="hljs-comment">// 我就是在这里使用了 e.stopPropagation()</span><br></code></pre></td></tr></table></figure>

<p>从 <code>parent capture</code> 之后，无论是事件冒泡，还是事件捕捉都已经取消了(这里的意思应该是，让事件捕获和冒泡从根本上就都停止)</p>
<h5 id="事件只执行一次"><a href="#事件只执行一次" class="headerlink" title="事件只执行一次"></a>事件只执行一次</h5><p>利用第三个参数 <code>&#123;once: true&#125;</code></p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">const grandparent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.grandparent&quot;</span>);<br>const parent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.parent&quot;</span>);<br>const child = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.child&quot;</span>)<br><br>grandparent.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(e)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;grandparent bubble&#x27;</span>);<br>&#125;)<br><br>parent.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(e)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;parent bubble&#x27;</span>);<br>&#125;)<br><br>child.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(e)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child bubble&#x27;</span>);<br>&#125;, &#123;once: <span class="hljs-literal">true</span>&#125;)<br><br><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-25-at-9.18.18-PM.gif" alt="once:true"></p>
<p>可见，<code>child</code>事件只执行了一次。<br>由于 <code>once</code> 和 <code>capture</code> 都是第三个参数对象的属性。所以可以叠在一起使用…</p>
<h4 id="e-removeEventListener"><a href="#e-removeEventListener" class="headerlink" title="e.removeEventListener"></a>e.removeEventListener</h4><p><strong>作用：取消某一事件</strong></p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> grandparent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.grandparent&quot;</span>);<br><span class="hljs-keyword">const</span> parent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.parent&quot;</span>);<br><span class="hljs-keyword">const</span> child = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.child&quot;</span>)<br><br>grandparent.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;grandparent bubble&#x27;</span>);<br>&#125;)<br><br>parent.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, sayHi)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  parent.removeEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, sayHi)<br>&#125;, <span class="hljs-number">2000</span>)<br><br>child.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child bubble&#x27;</span>);<br>&#125;)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hi&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-25-at-9.27.43-PM.gif" alt="效果"></p>
<p>2s 后就 <code>parent</code> 的事件打印效果就失效了</p>
<p><strong>注意：这是一个非常重要的点即 我这里是重新设置了一个新的函数作为参数，而不是直接写回调函数</strong></p>
<p>看看下面这种错误示范：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">const grandparent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.grandparent&quot;</span>);<br>const parent = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.parent&quot;</span>);<br>const child = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.child&quot;</span>)<br><br>grandparent.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(e)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;grandparent bubble&#x27;</span>);<br>&#125;)<br><br>parent.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hi&#x27;</span>)&#125;)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  parent.removeEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hi&#x27;</span>)&#125;)<br>&#125;, <span class="hljs-number">2000</span>)<br><br>child.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(e)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child bubble&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-25-at-9.33.32-PM.gif" alt="注意观察"></p>
<p>这样你无论点击多少次，打印都不会变化。原因是 <code>removeEventListener</code> 中删减的函数 和 <code>addEventListener</code> 中使用的回调函数不是同一个函数。 而单独设一个函数来使用的话，它们就是同一个函数 (这里面涉及知识点：<strong>引用</strong>)</p>
<h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe">const divs = document.querySelectorAll(<span class="hljs-string">&#x27;div&#x27;</span>)<br><br>divs.forEach(div =&gt; &#123;<br>  div.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, () =&gt; &#123;<br>    console.log(<span class="hljs-string">&#x27;hi&#x27;</span>);<br>  &#125;)<br>&#125;)<br><br>const <span class="hljs-keyword">new</span><span class="hljs-type">Div</span> = document.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);<br><span class="hljs-keyword">new</span><span class="hljs-type">Div</span>.style.width = <span class="hljs-string">&quot;200px&quot;</span>;<br><span class="hljs-keyword">new</span><span class="hljs-type">Div</span>.style.height = <span class="hljs-string">&quot;200px&quot;</span>;<br><span class="hljs-keyword">new</span><span class="hljs-type">Div</span>.style.backgroundColor = <span class="hljs-string">&quot;purple&quot;</span>;<br>document.body.append(<span class="hljs-keyword">new</span><span class="hljs-type">Div</span>)<br></code></pre></td></tr></table></figure>

<p>效果如下：<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-25-at-9.53.49-PM.gif" alt="事件委托"></p>
<p>我点击 <code>child</code> 会打印 3 次<code>hi</code>, 点击 <code>parent</code> 会打印 2 次<code>hi</code>, 点击 <code>grandparent</code> 会打印 1 次<code>hi</code>。我点击紫色方块，什么都不会打印、</p>
<p><strong>紫色方块没有打印，是因为建立这个 div 元素是在建立 addEventListener 之后</strong>所以没有效果。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe">const divs = document.querySelectorAll(<span class="hljs-string">&#x27;div&#x27;</span>)<br><br>divs.forEach(div =&gt; &#123;<br>  div.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, () =&gt; &#123;<br>    console.log(<span class="hljs-string">&#x27;hi&#x27;</span>);<br>  &#125;)<br>&#125;)<br><br>const <span class="hljs-keyword">new</span><span class="hljs-type">Div</span> = document.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);<br><span class="hljs-keyword">new</span><span class="hljs-type">Div</span>.style.width = <span class="hljs-string">&quot;200px&quot;</span>;<br><span class="hljs-keyword">new</span><span class="hljs-type">Div</span>.style.height = <span class="hljs-string">&quot;200px&quot;</span>;<br><span class="hljs-keyword">new</span><span class="hljs-type">Div</span>.style.backgroundColor = <span class="hljs-string">&quot;purple&quot;</span>;<br><span class="hljs-keyword">new</span><span class="hljs-type">Div</span>.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, () =&gt; &#123;<br>  console.log(<span class="hljs-string">&#x27;hi&#x27;</span>);<br>&#125;)<br>document.body.append(<span class="hljs-keyword">new</span><span class="hljs-type">Div</span>)<br></code></pre></td></tr></table></figure>

<p>现在点击<strong>紫色方块</strong>就有效果啦！</p>
<p>现在我有一种新方法来实现同样的功能：<br><strong>比较流行也很方便！！</strong></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe">const divs = document.querySelectorAll(<span class="hljs-string">&#x27;div&#x27;</span>)<br><br>document.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, e =&gt; &#123;  <span class="hljs-comment">// 注意：这里是最顶层的document，所以，无论在任何地方有新的元素生成，想影响该新元素，就能非常方便的影响这个新元素</span><br>  <span class="hljs-keyword">if</span> (e.target.matches(<span class="hljs-string">&#x27;div&#x27;</span>)) &#123;    <span class="hljs-comment">// matches 是e.target的一个特别的属性</span><br>    console.log(<span class="hljs-string">&#x27;hi&#x27;</span>);<br>  &#125;<br>&#125;)<br><br>const <span class="hljs-keyword">new</span><span class="hljs-type">Div</span> = document.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);<br><span class="hljs-keyword">new</span><span class="hljs-type">Div</span>.style.width = <span class="hljs-string">&quot;200px&quot;</span>;<br><span class="hljs-keyword">new</span><span class="hljs-type">Div</span>.style.height = <span class="hljs-string">&quot;200px&quot;</span>;<br><span class="hljs-keyword">new</span><span class="hljs-type">Div</span>.style.backgroundColor = <span class="hljs-string">&quot;purple&quot;</span>;<br>document.body.append(<span class="hljs-keyword">new</span><span class="hljs-type">Div</span>)<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-25-at-9.33.32-PM.gif" alt="事件委托2"></p>
]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>JS Dom data-attributes</title>
    <url>/2021/11/26/JS-Dom-data-attributes/</url>
    <content><![CDATA[<p><code>data-attributes</code>让<code>HTML</code>和<code>JS</code>完美的搭配</p>
<p>如果要使用<code>data-attributes</code>，则必须以<code>data-</code>来开头命名</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">/* index.html */<br>&lt;<span class="hljs-keyword">div</span><br>  <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;test-div&quot;</span><br>  data-user-<span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;帅得乱七八糟&quot;</span><br>  data-age<br>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<h4 id="读取data-attributes值"><a href="#读取data-attributes值" class="headerlink" title="读取data-attributes值"></a>读取<code>data-attributes</code>值</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">/* script.js */</span><br>const <span class="hljs-selector-tag">div</span> = document<span class="hljs-selector-class">.getElementById</span>(<span class="hljs-string">&quot;test-div&quot;</span>)<br>console<span class="hljs-selector-class">.log</span>(<span class="hljs-selector-tag">div</span>.dataset)<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-26-at-2.23.02-PM.png" alt="获取data-attributes"></p>
<p>注意：这个<code>DOMStringMap</code>是个对象，包含了所有该元素的<code>data-</code>属性。 并且打印的例如：<code>userName</code>是驼峰命名方式，这里是为了对应 <code>-</code> 运算符。并且如果定义了<code>data-attribute</code>但却没赋值，最后是以<code>&quot;&quot;</code>这个空字符串来作为值</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">const <span class="hljs-selector-tag">div</span> = document<span class="hljs-selector-class">.getElementById</span>(<span class="hljs-string">&quot;test-div&quot;</span>)<br>console<span class="hljs-selector-class">.log</span>(<span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.dataset</span>.age)  <span class="hljs-comment">// &quot;&quot;</span><br>console<span class="hljs-selector-class">.log</span>(<span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.dataset</span>.userName) <span class="hljs-comment">// &quot;帅得乱七八糟&quot;</span><br></code></pre></td></tr></table></figure>

<h4 id="修改和增加data-attributes值"><a href="#修改和增加data-attributes值" class="headerlink" title="修改和增加data-attributes值"></a>修改和增加<code>data-attributes</code>值</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">const <span class="hljs-selector-tag">div</span> = document<span class="hljs-selector-class">.getElementById</span>(<span class="hljs-string">&quot;test-div&quot;</span>)<br><br><span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.dataset</span><span class="hljs-selector-class">.newAttr</span> = <span class="hljs-string">&#x27;haha&#x27;</span>          <span class="hljs-comment">// 创建一个新的属性</span><br><span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.dataset</span><span class="hljs-selector-class">.userName</span> = <span class="hljs-string">&#x27;帅得歪瓜裂枣&#x27;</span>  <span class="hljs-comment">// 修改原来的属性</span><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-26-at-2.29.15-PM.png" alt="change-attributes"></p>
<h4 id="删除data-attributes值"><a href="#删除data-attributes值" class="headerlink" title="删除data-attributes值"></a>删除<code>data-attributes</code>值</h4><figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">const</span> <span class="hljs-keyword">div</span> = document.getElementById(<span class="hljs-string">&quot;test-div&quot;</span>)<br><br><span class="hljs-keyword">div</span>.dataset.newAttr = <span class="hljs-string">&#x27;haha&#x27;</span>;         <span class="hljs-comment">// 创建一个新的属性</span><br><span class="hljs-keyword">div</span>.dataset.userName = <span class="hljs-string">&#x27;帅得歪瓜裂枣&#x27;</span>;  <span class="hljs-comment">// 修改原来的属性</span><br>delete <span class="hljs-keyword">div</span>.dataset.newAttr;           <span class="hljs-comment">// 删除原来的属性</span><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-26-at-2.33.28-PM.png" alt="delet"></p>
<h4 id="JS-操作data-attributes值"><a href="#JS-操作data-attributes值" class="headerlink" title="JS 操作data-attributes值"></a>JS 操作<code>data-attributes</code>值</h4><figure class="highlight hsp"><table><tr><td class="code"><pre><code class="hljs hsp"><span class="hljs-comment">/* html */</span><br>&lt;<span class="hljs-keyword">button</span> data-modal-id=<span class="hljs-string">&quot;modal-1&quot;</span>&gt;Open Modal <span class="hljs-number">1</span>&lt;/<span class="hljs-keyword">button</span>&gt;<br>&lt;<span class="hljs-keyword">button</span> data-modal-id=<span class="hljs-string">&quot;modal-2&quot;</span>&gt;Open Modal <span class="hljs-number">2</span>&lt;/<span class="hljs-keyword">button</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/* js */</span><br><span class="hljs-keyword">const</span> buttons = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelectorAll</span>(<span class="hljs-string">&quot;[data-modal-id]&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>然后，可以有其他任何操作…</p>
]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>高级</tag>
      </tags>
  </entry>
  <entry>
    <title>JS ES6 obj</title>
    <url>/2021/11/10/JS-ES6-obj/</url>
    <content><![CDATA[<p><code>ES6</code>中对于对象(<code>Object</code>)的升级</p>
<h4 id="key-value"><a href="#key-value" class="headerlink" title="key:value"></a>key:value</h4><figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">const name</span> = <span class="hljs-string">&#x27;Bruce&#x27;</span>;<br><span class="hljs-attribute">const age</span> = 25;<br><br><span class="hljs-attribute">const person</span> = &#123;<br>  name: name,<br>  age: age<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于<strong>对象键值对</strong>的键名和值名一致，可以用下面这种更加简便的方法来表示</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">const</span> <span class="hljs-keyword">name</span> = <span class="hljs-string">&#x27;Kyle&#x27;</span><br><span class="hljs-keyword">const</span> age = <span class="hljs-number">25</span><br><br><span class="hljs-keyword">const</span> person = <span class="hljs-comment">&#123;</span><br><span class="hljs-comment">  name,</span><br><span class="hljs-comment">  age</span><br><span class="hljs-comment">&#125;</span><br></code></pre></td></tr></table></figure>

<h4 id="funcName-func"><a href="#funcName-func" class="headerlink" title="funcName:func"></a>funcName:func</h4><p>在 es6 中对于对象内，函数作为属性也有了新的简写方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* 原来的写法 */</span><br><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">sayHi</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hi&#x27;</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/* 现在的写法 */</span><br><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hi&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="obj-property"><a href="#obj-property" class="headerlink" title="[obj-property]"></a><code>[obj-property]</code></h4><p>我们可以在创建对象的时候，使用<strong>变量</strong>来定义对象的键</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">const</span> dynamicKey = <span class="hljs-string">&#x27;name&#x27;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">index</span> = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">const</span> person = &#123;<br>  [dynamicKey]: <span class="hljs-string">&#x27;Bruce&#x27;</span>,<br>  [<span class="hljs-string">&#x27;age&#x27;</span> + <span class="hljs-keyword">index</span>]: <span class="hljs-number">21</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>事实上方括号中的属性名最后会转化为字符串，作为属性名</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;Bruce&quot;</span>,<br>  <span class="hljs-attr">&quot;age&quot;</span>: <span class="hljs-number">21</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>灵活的使用动态属性：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">const</span> dynamicKey = <span class="hljs-string">&#x27;name&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">index</span> = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">const</span> person = &#123;&#125;<br>person[dynamicKey] = <span class="hljs-string">&#x27;Bruce&#x27;</span><br>person[<span class="hljs-string">&#x27;age&#x27;</span> + <span class="hljs-keyword">index</span>] = <span class="hljs-number">21</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>JS Module</title>
    <url>/2021/11/04/JS-Module/</url>
    <content><![CDATA[<p><code>ES Module</code> 让 js 代码逻辑更清晰，灵活性更强，更方便代码的管理</p>
<p>为了方便理解 Module。创建一个文件夹即目录</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">/* module文件夹 */<br>    <span class="hljs-string">|-index.html</span><br>    <span class="hljs-string">|-main.js</span><br>    <span class="hljs-string">|-user.js</span><br></code></pre></td></tr></table></figure>

<p>首先来看看<code>user.js</code>文件的内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, age</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printName</span>(<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`User’s name is <span class="hljs-subst">$&#123;user.age&#125;</span>`</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printAge</span>(<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`User is <span class="hljs-subst">$&#123;user.age&#125;</span> years old`</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当前<code>main.js</code>为一个空文件</p>
<p><code>index.html</code> 仅用 srcipt 标签导入<code>main.js</code>文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>当前想把<code>user.js</code>文件的内容以模块的方式导出给<code>main.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用export default  ---&gt; 这个只能在一个文件里最多使用一次(当然 这也可以不用写，后面导入的时候全为 import &#123;...&#125; from &#x27;...&#x27;)</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, age</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 其余使用 export 导出 (无default)</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printName</span>(<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`User’s name is <span class="hljs-subst">$&#123;user.age&#125;</span>`</span>);<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printAge</span>(<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`User is <span class="hljs-subst">$&#123;user.age&#125;</span> years old`</span>);<br>&#125;<br><br><span class="hljs-comment">// 当然，前面也可以不用写 export default、export 。直接在文件结尾部分如下方式写</span><br><span class="hljs-comment">// export default User</span><br><span class="hljs-comment">// export &#123;printAge, printName&#125;</span><br></code></pre></td></tr></table></figure>

<p><code>main.js</code>文件导入模块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 针对以export default方式导出的代码</span><br><span class="hljs-comment">// import User from &#x27;user.js&#x27;;   // 这叫绝对路径</span><br><span class="hljs-comment">// import User from &#x27;./user.js&#x27;; // 这叫相对路径</span><br><br><span class="hljs-comment">// 针对以export方式导出的代码</span><br><span class="hljs-keyword">import</span> &#123;printName, printAge&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./user.js&#x27;</span>;<br><br><span class="hljs-comment">// 注意：可以给导入的模块重命名</span><br><span class="hljs-comment">// 对于 export default 导出的模块，命名方式如下</span><br><span class="hljs-comment">// import U from &#x27;./user.js&#x27;   // U 是新名称 但代表的还是user.js文件的User模块</span><br><br><span class="hljs-comment">// 对于 export 导出的模块，命名方式如下</span><br><span class="hljs-comment">// import &#123;printName as printUserName, printAge&#125; from &#x27;./user.js&#x27; // printName名字改为了printUserName</span><br></code></pre></td></tr></table></figure>

<p><strong>重点：</strong>对于<code>index.html</code> 利用<code>script</code>标签导入<code>main.js</code>文件。并且有<code>ES Module</code>能力, 是有讲究的<br><strong>并且这个不是 react 代码，没有 webpack 配置。所以导入文件的时候后缀名一定要加。例如 ./user 这是错误的。应该改为 ./user.js</strong></p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">注意：如果要导入一个文件的所有内容，可以这样使用：`<span class="hljs-keyword">import</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;xxx&#x27;</span>`<br>当然，也可以给 * 重命名：`<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> M <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;xxx&#x27;</span>`<br>这样你要使用xxx文件的某个模块，你只需这样来用： `M.someModule`<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&lt;script type=<span class="hljs-string">&quot;module&quot;</span> defer src=<span class="hljs-string">&quot;./main.js&quot;</span>&gt;&lt;<span class="hljs-regexp">/script&gt;    /</span><span class="hljs-regexp">/ type=&quot;module&quot; 是必写的。defer是...???</span><br></code></pre></td></tr></table></figure>

<p>并且启动代码时不能以本地文件的方式启动：不然报错如下</p>
<blockquote>
<p>Origin null is not allowed by Access-Control-Allow-Origin.</p>
</blockquote>
<p>所以最好以 vscode 插件 Live Server 的(开启服务器的)方式打开</p>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>JS sort 玩法</title>
    <url>/2021/10/23/JS-sort-%E7%8E%A9%E6%B3%95/</url>
    <content><![CDATA[<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">let vals = [<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>];<br>vals.sort();         <span class="hljs-regexp">//</span> 不会返回新的数组，而是对自己本身进行修改...<br>console.log(vals);   <span class="hljs-regexp">//</span>  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure>

<p>似乎默认是按照字母顺序进行排序</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><code class="hljs sqf">let vals = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>];<br>vals.<span class="hljs-built_in">sort</span>();<br>console.<span class="hljs-built_in">log</span>(vals)   <span class="hljs-comment">// [10, 2, &#x27;A&#x27;, &#x27;a&#x27;]</span><br></code></pre></td></tr></table></figure>

<p>并且 sort 只会默认排序 <code>number</code>、<code>string</code> 这两种类型。 比如<code>对象类型</code>就不会有任何的变化…</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">let</span> vals = [&#123;x: <span class="hljs-number">10</span>, y:<span class="hljs-number">20</span>&#125;, &#123;x: <span class="hljs-number">20</span>, y:<span class="hljs-number">40</span>&#125;]<br>vals.sort();<br>console.log(<span class="hljs-built_in">vals</span>)   <span class="hljs-comment">// y 的值从大到小排列过</span><br></code></pre></td></tr></table></figure>

<p><strong>如果想让 sort 具备灵活的比较功能就需要自己去设置比较函数</strong></p>
<p>比较函数需要两个参数…</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compare</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> b.y - a.y;<br>&#125;<br><span class="hljs-keyword">let</span> vals = [&#123;<span class="hljs-attr">x</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">y</span>:<span class="hljs-number">20</span>&#125;, &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">y</span>:<span class="hljs-number">40</span>&#125;]<br>vals.sort(compare);  <span class="hljs-comment">// 放置的是回调函数 不能选择执行...</span><br><span class="hljs-built_in">console</span>.log(vals)    <span class="hljs-comment">// 没有丝毫变化...</span><br></code></pre></td></tr></table></figure>

<p><a href="https://www.w3schools.com/js/js_array_sort.asp">简洁的文档</a></p>
<h4 id="利用-sort-来写随机数组"><a href="#利用-sort-来写随机数组" class="headerlink" title="利用 sort 来写随机数组"></a>利用 sort 来写随机数组</h4><p>arr.sort((a, b) =&gt; Math.random() - 0.5); // 这是在原来数组中做变化</p>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>高级</tag>
      </tags>
  </entry>
  <entry>
    <title>JS-随笔一</title>
    <url>/2021/10/18/JS-%E9%9A%8F%E7%AC%94%E4%B8%80/</url>
    <content><![CDATA[<h4 id="问题一：Promise-中-catch-消化异常"><a href="#问题一：Promise-中-catch-消化异常" class="headerlink" title="问题一：Promise 中.catch 消化异常"></a>问题一：Promise 中.catch 消化异常</h4><p>看代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">let</span> data = <span class="hljs-number">100</span>;</span><br><span class="javascript">    resolve(data);</span><br><span class="javascript">  &#125;).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;data&#x27;</span>, data);</span><br><span class="javascript">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(data)</span><br><span class="javascript">    <span class="hljs-comment">// catch 用来消化异常</span></span><br><span class="javascript">  &#125;).catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;error&#x27;</span>, error);</span><br><span class="javascript">    <span class="hljs-comment">// 抛出错误，打断程序运行</span></span><br><span class="javascript">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error)</span><br><span class="javascript">  &#125;)</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-18-at-4.52.26-PM.1xab0wcem3ls.png" alt="promise-reject"></p>
<h4 id="问题二：Object-fromEntries-的使用方式"><a href="#问题二：Object-fromEntries-的使用方式" class="headerlink" title="问题二：Object.fromEntries() 的使用方式"></a>问题二：Object.fromEntries() 的使用方式</h4><p>Object.fromEntries()是用来创建对象的… 用二维数组或者一个 map 作为参数…<br>用代码来体验一下(注意：要提供键值对才行…)</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// Map</span><br><span class="hljs-keyword">const</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br><br>myMap.<span class="hljs-keyword">set</span>(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;dom&#x27;</span>);<br>myMap.<span class="hljs-keyword">set</span>(<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">60</span>);<br><br><span class="hljs-keyword">const</span> myObj = <span class="hljs-built_in">Object</span>.fromEntries(myMap)<br><span class="hljs-comment">// 生成了一个对象...</span><br>console.log(myObj)   <span class="hljs-comment">// &#123;name: &#x27;dom&#x27;, age: 60&#125;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 二维数组<br>const myArr = [<br>  [<span class="hljs-string">&#x27;search&#x27;</span>, <span class="hljs-string">&#x27;dogs&#x27;</span>],<br>  [<span class="hljs-string">&#x27;page&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>]<br>];<br>const myObj = Object.fromEntries(myArr);<br>console.log(myObj);   <span class="hljs-regexp">//</span> &#123;search: <span class="hljs-string">&#x27;dogs&#x27;</span>, page: <span class="hljs-string">&#x27;2&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Generators-的使用方法"><a href="#Generators-的使用方法" class="headerlink" title="Generators 的使用方法"></a>Generators 的使用方法</h4><p><a href="https://www.youtube.com/watch?v=IJ6EgdiI_wU">相关类型中比较好的视频</a></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua">// * 表示这是个generator函数...<br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">simpleGenerator</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-built_in">yield</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">yield</span> <span class="hljs-number">2</span>;<br>  <span class="hljs-built_in">yield</span> <span class="hljs-number">3</span>;<br>&#125;<br><br>const generatorObject = simpleGenerator();<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;generatorObject&#x27;</span>, generatorObject);  // 会打印一个复杂的对象(我们只需要关注这个对象里的<span class="hljs-built_in">next</span>属性)<br>const obj = generatorObject.<span class="hljs-built_in">next</span>()<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;obj&#x27;</span>, obj)              // &#123;value: <span class="hljs-number">1</span>, done: <span class="hljs-literal">false</span>&#125;<br>console.<span class="hljs-built_in">log</span>(generatorObject.<span class="hljs-built_in">next</span>())  // &#123;value: <span class="hljs-number">2</span>, done: <span class="hljs-literal">false</span>&#125;<br>console.<span class="hljs-built_in">log</span>(generatorObject.<span class="hljs-built_in">next</span>())  // &#123;value: <span class="hljs-number">3</span>, done: <span class="hljs-literal">false</span>&#125;<br>console.<span class="hljs-built_in">log</span>(generatorObject.<span class="hljs-built_in">next</span>())  // &#123;value: undefined, done: <span class="hljs-literal">true</span>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">simpleGenerator</span><span class="hljs-params">()</span></span> &#123;<br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;before 1&#x27;</span>)<br>  <span class="hljs-built_in">yield</span> <span class="hljs-number">1</span>;<br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;after 1&#x27;</span>)<br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;before 2&#x27;</span>)<br>  <span class="hljs-built_in">yield</span> <span class="hljs-number">2</span>;<br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;after 2&#x27;</span>)<br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;before 3&#x27;</span>)<br>  <span class="hljs-built_in">yield</span> <span class="hljs-number">3</span>;<br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;after 3&#x27;</span>)<br>&#125;<br><br>const generatorObject = simpleGenerator();<br>// 自己逐条去打印下面的东西就会有所感悟...<br>console.<span class="hljs-built_in">log</span>(generatorObject.<span class="hljs-built_in">next</span>())<br>console.<span class="hljs-built_in">log</span>(generatorObject.<span class="hljs-built_in">next</span>())<br>console.<span class="hljs-built_in">log</span>(generatorObject.<span class="hljs-built_in">next</span>())<br>console.<span class="hljs-built_in">log</span>(generatorObject.<span class="hljs-built_in">next</span>())<br></code></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">simpleGenerator</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-built_in">yield</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">yield</span> <span class="hljs-number">2</span>;<br>  <span class="hljs-built_in">yield</span> <span class="hljs-number">3</span>;<br>&#125;<br><br>const generatorObject = simpleGenerator();<br>console.<span class="hljs-built_in">log</span>(generatorObject.<span class="hljs-built_in">next</span>())<br>console.<span class="hljs-built_in">log</span>(generatorObject.<span class="hljs-built_in">next</span>())<br>const generatorObject2 = simpleGenerator();<br>console.<span class="hljs-built_in">log</span>(generatorObject2.<span class="hljs-built_in">next</span>())<br>console.<span class="hljs-built_in">log</span>(generatorObject2.<span class="hljs-built_in">next</span>())<br></code></pre></td></tr></table></figure>

<p>// generator 的常用例子</p>
<ol>
<li>有控制的无限循环</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">generateId</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> id = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;id&#x27;</span>, id)<br>    <span class="hljs-keyword">yield</span> id;<br>    id++;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> generatorObject = generateId();<br><span class="hljs-built_in">console</span>.log(generatorObject.next())<br><span class="hljs-built_in">console</span>.log(generatorObject.next())<br><span class="hljs-comment">// ... 可以无限写下去 所以写id的话，你想弄多少个就弄多少个...</span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li>iterator…</li>
</ol>
<figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">generator</span><span class="hljs-params">(array)</span></span> &#123;<br>  <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>    <span class="hljs-built_in">yield</span> array[i];<br>  &#125;<br>&#125;<br><br>const generatorObject = generator([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]);<br>console.<span class="hljs-built_in">log</span>(generatorObject.<span class="hljs-built_in">next</span>())<br>console.<span class="hljs-built_in">log</span>(generatorObject.<span class="hljs-built_in">next</span>())<br>console.<span class="hljs-built_in">log</span>(generatorObject.<span class="hljs-built_in">next</span>())<br>console.<span class="hljs-built_in">log</span>(generatorObject.<span class="hljs-built_in">next</span>())<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>return &amp; throw</li>
</ol>
<figure class="highlight livescript"><table><tr><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">function</span>* generateId() &#123;<br>  <span class="hljs-keyword">let</span> id = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;id&#x27;</span>, id)<br>    <span class="hljs-keyword">yield</span> id;<br>    id++;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> generatorObject = generateId();<br><span class="hljs-built_in">console</span>.log(generatorObject.next())<br><span class="hljs-built_in">console</span>.log(generatorObject.<span class="hljs-keyword">return</span>(<span class="hljs-number">10</span>))<br><span class="hljs-built_in">console</span>.log(generatorObject.<span class="hljs-keyword">throw</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;hi&#x27;</span>)))<br></code></pre></td></tr></table></figure>

<h4 id="iterator-的理解和学习…"><a href="#iterator-的理解和学习…" class="headerlink" title="iterator 的理解和学习…"></a>iterator 的理解和学习…</h4><p>在 js 中<code>array</code>、<code>Map</code>是默认可以<code>iterable</code>的<br>部署了<code>iterator</code>的具备一个特点 就是能够通过 for……of 进行遍历…</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">var a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">for</span>(v of a) &#123;console.log(v)&#125;<br><span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br><span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br><span class="hljs-regexp">//</span> <span class="hljs-number">3</span><br><br>a[Symbol.iterator]     <span class="hljs-regexp">//</span> 是一个函数(可以用来检测是否部署了iterator)<br>var i = a[Symbol.iterator]();<br>console.log(<span class="hljs-string">&#x27;i&#x27;</span>, i);   <span class="hljs-regexp">//</span> i 是一个Iterator (具备<span class="hljs-keyword">next</span>()方法)<br><br></code></pre></td></tr></table></figure>

<figure class="highlight autoit"><table><tr><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-comment">;</span><br><span class="hljs-keyword">const</span> numbersIterator = numbers[Symbol.iterator]()<span class="hljs-comment">;  // 变成generator了...</span><br><br>console.<span class="hljs-built_in">log</span>(numbersIterator.<span class="hljs-keyword">next</span>().value)<span class="hljs-comment">;</span><br>console.<span class="hljs-built_in">log</span>(numbersIterator.<span class="hljs-keyword">next</span>().value)<span class="hljs-comment">;</span><br>console.<span class="hljs-built_in">log</span>(numbersIterator.<span class="hljs-keyword">next</span>().value)<span class="hljs-comment">;</span><br>console.<span class="hljs-built_in">log</span>(numbersIterator.<span class="hljs-keyword">next</span>().value)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>来点例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 自己生成一个iterator</span><br><span class="hljs-comment">// 1, 4, 9, 16, 25</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">squared</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> n = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 闭包玩法...</span><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-function"><span class="hljs-title">next</span>(<span class="hljs-params"></span>)</span> &#123;   <span class="hljs-comment">// 这是对象的一个属性...</span><br>      n++;<br>      <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">5</span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>          <span class="hljs-attr">value</span>: n * n,<br>          <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span><br>        &#125;;<br>      &#125;<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span>,<br>        <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> squaredIterator = squared();<br><span class="hljs-built_in">console</span>.log(squaredIterator.next());<br><span class="hljs-built_in">console</span>.log(squaredIterator.next());<br><span class="hljs-built_in">console</span>.log(squaredIterator.next());<br><span class="hljs-built_in">console</span>.log(squaredIterator.next());<br></code></pre></td></tr></table></figure>

<h4 id="js-中关于函数相关的注意点"><a href="#js-中关于函数相关的注意点" class="headerlink" title="js 中关于函数相关的注意点"></a>js 中关于函数相关的注意点</h4><ol>
<li>console.dir 使用</li>
</ol>
<figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span><span class="hljs-params">(value)</span></span> &#123;<br>  console.<span class="hljs-built_in">log</span>(value)<br>&#125;<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">print</span>)  // 这样打印出的内容很范：ƒ <span class="hljs-built_in">print</span>(value) &#123;<br>  console.<span class="hljs-built_in">log</span>(value)<br>&#125;<br>console.dir(<span class="hljs-built_in">print</span>)  // ƒ <span class="hljs-built_in">print</span>(value)<br>arguments: null<br>caller: null<br>length: <span class="hljs-number">1</span><br>name: <span class="hljs-string">&quot;print&quot;</span><br>prototype: &#123;constructor: ƒ&#125;<br><span class="hljs-string">[[FunctionLocation]]</span>: VM193:<span class="hljs-number">1</span><br><span class="hljs-string">[[Prototype]]</span>: ƒ ()<br><span class="hljs-string">[[Scopes]]</span>: Scopes[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>函数其实就非常类似于普通的对象…(可以放在任何地方。可以为函数添加任何属性)唯一的不同就是函数要使用() 来调用，并且可以传参数 —&gt; 但是对象好像没有作用域、而函数是有作用域的…??</li>
</ol>
<figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span><span class="hljs-params">(value)</span></span> &#123;<br>  console.<span class="hljs-built_in">log</span>(value);<br>&#125;<br><br>// 我可以给函数增添属性<br><span class="hljs-built_in">print</span>.hi = <span class="hljs-string">&#x27;hi&#x27;</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;print.name&#x27;</span>, <span class="hljs-built_in">print</span>.name)<br><br>// 函数作为参数...<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useCallback</span><span class="hljs-params">(callback)</span></span> &#123;<br>  callback(<span class="hljs-string">&#x27;Hello&#x27;</span>)<br>&#125;<br><br>useCallback(<span class="hljs-built_in">print</span>)<br></code></pre></td></tr></table></figure>

<h4 id="强制转换一个对象中-某一属性的类型为-number"><a href="#强制转换一个对象中-某一属性的类型为-number" class="headerlink" title="强制转换一个对象中 某一属性的类型为 number"></a>强制转换一个对象中 某一属性的类型为 number</h4><p>有时候，我们得到的对象 其属性全部都为字符串类型。但是我们希望有些类型应该为 number 类型<br>例如：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-keyword">id</span>: <span class="hljs-string">&#x27;1&#x27;</span>,<br>  name: <span class="hljs-string">&#x27;帅得乱七八糟&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>解决办法：</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">const</span> newObj = &#123;<br>  ...obj,<br>  <span class="hljs-attribute">id:</span><span class="hljs-string"> Number</span>(obj.id) || <span class="hljs-literal">undefined</span> <span class="hljs-comment">// 不想id：0 这种情况...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="数组中查找指定元素的下标方法：indexOf"><a href="#数组中查找指定元素的下标方法：indexOf" class="headerlink" title="数组中查找指定元素的下标方法：indexOf"></a>数组中查找指定元素的下标方法：indexOf</h4><p>例如：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">let question = [<span class="hljs-string">&#x27;错误&#x27;</span>, <span class="hljs-string">&#x27;错误&#x27;</span>, <span class="hljs-string">&#x27;正确&#x27;</span>, <span class="hljs-string">&#x27;错误&#x27;</span>];<br><br>let findIndex = question.indexOf(<span class="hljs-string">&#x27;正确&#x27;</span>)  <span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br><br><span class="hljs-regexp">//</span> 如果找不到就会直接返回 -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<h4 id="自定义获取页面-url-的方法"><a href="#自定义获取页面-url-的方法" class="headerlink" title="自定义获取页面 url 的方法"></a>自定义获取页面 url 的方法</h4><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">function</span> getParameter(parameterName) &#123;<br>  <span class="hljs-regexp">//</span> window.location.search 获取当前url的参数(包括 ?)<br>  <span class="hljs-regexp">//</span> URLSearchParams 更多操作: https:<span class="hljs-regexp">//</span>developer.mozilla.org<span class="hljs-regexp">/zh-CN/</span>docs<span class="hljs-regexp">/Web/</span>API/URLSearchParams<br>  let parameters = new URLSearchParams(window.location.search)<br>  return parameters.get(parameterName);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="你不知道的-10-大-js-隐晦但有效的知识点"><a href="#你不知道的-10-大-js-隐晦但有效的知识点" class="headerlink" title="你不知道的 10 大 js 隐晦但有效的知识点"></a>你不知道的 10 大 js 隐晦但有效的知识点</h4><h5 id="的极限操作"><a href="#的极限操作" class="headerlink" title="?? 的极限操作"></a>?? 的极限操作</h5><h5 id="对控制台的神奇操作"><a href="#对控制台的神奇操作" class="headerlink" title="对控制台的神奇操作"></a>对控制台的神奇操作</h5><h5 id="的无敌操作"><a href="#的无敌操作" class="headerlink" title="?. 的无敌操作"></a>?. 的无敌操作</h5><h5 id="script-搭配-defer-的王者操作"><a href="#script-搭配-defer-的王者操作" class="headerlink" title="script 搭配 defer 的王者操作"></a>script 搭配 defer 的王者操作</h5><h5 id="自创块级作用域"><a href="#自创块级作用域" class="headerlink" title="自创块级作用域"></a>自创块级作用域</h5><figure class="highlight nim"><table><tr><td class="code"><pre><code class="hljs nim">switch (a) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">const</span> <span class="hljs-literal">result</span> = a * <span class="hljs-number">2</span>;<br>    console.log(<span class="hljs-literal">result</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>    <span class="hljs-keyword">const</span> <span class="hljs-literal">result</span> = a / <span class="hljs-number">2</span>;<br>    console.log(<span class="hljs-literal">result</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>    <span class="hljs-keyword">const</span> <span class="hljs-literal">result</span> = a + <span class="hljs-number">2</span>;<br>    console.log(<span class="hljs-literal">result</span>);<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述内容会报错…</p>
<p>下面用块级作用域解决问题</p>
<figure class="highlight nim"><table><tr><td class="code"><pre><code class="hljs nim">switch (a) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-literal">result</span> = a * <span class="hljs-number">2</span>;<br>    console.log(<span class="hljs-literal">result</span>);<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-literal">result</span> = a / <span class="hljs-number">2</span>;<br>    console.log(<span class="hljs-literal">result</span>);<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-literal">result</span> = a + <span class="hljs-number">2</span>;<br>    console.log(<span class="hljs-literal">result</span>);<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="不要误会-null-和-undefined-这两者的作用！"><a href="#不要误会-null-和-undefined-这两者的作用！" class="headerlink" title="不要误会 null 和 undefined 这两者的作用！"></a>不要误会 null 和 undefined 这两者的作用！</h4><blockquote>
<p>Everything is undefined until you define it</p>
</blockquote>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>)  <span class="hljs-regexp">//</span> <span class="hljs-literal">true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> === <span class="hljs-literal">undefined</span>) <span class="hljs-regexp">//</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>

<p><code>null</code> 表示这个东西没有值(no value)，不存在<br>(变量是不会自己变成 <code>null</code> 的。除非是程序员自己把它设置为 <code>null</code>)<br>所以，一个好习惯是当一个变量明确没有值的时候应该设置为 <code>null</code>。特别是前后端进行数据交互的时候<br>举个例子：在 <code>JSON</code> 化内容的时候需要注意</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">JSON</span>.stringify(&#123;foo:<span class="hljs-literal">undefined</span>&#125;)   <span class="hljs-regexp">//</span> &#123;&#125;<br><span class="hljs-built_in">JSON</span>.stringify(&#123;foo:<span class="hljs-literal">null</span>&#125;)        <span class="hljs-regexp">//</span> &#123;<span class="hljs-string">&quot;foo&quot;</span>:<span class="hljs-literal">null</span>&#125;<br></code></pre></td></tr></table></figure>

<p><code>undefined</code> 就相当于一个变量未被定义(没有赋任何值)…</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a;<br><span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure>

<p>下面这里举了把 <code>null</code> 或 <code>undefined</code> 赋值给变量的情况</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-literal">null</span>;<br><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// null</span><br><br>a = <span class="hljs-literal">undefined</span>;<br><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure>

<p>这样做的原因是为了重置一个变量。通过将变量设置为<code>undefined</code>，你传递了该变量不再包含任何有用信息的消息，而如果该值为<code>null</code>，则你明确表示某些操作的结果没有值。</p>
<blockquote>
<p>尽管 <code>null</code> 和 <code>undefined</code> 都表示 <strong>no value</strong> 但使用的目的是不一样的</p>
</blockquote>
<h4 id="最好不要使用-else"><a href="#最好不要使用-else" class="headerlink" title="最好不要使用 else"></a>最好不要使用 else</h4><h4 id="灵活的使用数组-对象解构"><a href="#灵活的使用数组-对象解构" class="headerlink" title="灵活的使用数组/对象解构"></a>灵活的使用数组/对象解构</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">const</span> alphabet = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>];<br><span class="hljs-keyword">const</span> nunmbers = [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>];<br><br><span class="hljs-keyword">const</span> [a, , c, ...rest] = alphabet;<br>console.<span class="hljs-built_in">log</span>(a);<br>console.<span class="hljs-built_in">log</span>(c);<br>console.<span class="hljs-built_in">log</span>(rest);<br><br><span class="hljs-keyword">const</span> newArray = [...alphabet, ...numbers]<br>console.<span class="hljs-built_in">log</span>(newArray)<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sumAndMultiply</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-comment">// return [a + b, a * b]</span><br>  <span class="hljs-keyword">return</span> [a + b, a * b, a / b]<br>&#125;<br><span class="hljs-keyword">const</span> [sum, multiply, division = <span class="hljs-string">&#x27;No division&#x27;</span>] = sumAndMultiply(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);   <span class="hljs-comment">// sum, multiply 是自己随意拟定的名字</span><br><span class="hljs-built_in">console</span>.log(sum);<br><span class="hljs-built_in">console</span>.log(multiply);<br><span class="hljs-built_in">console</span>.log(division)<br></code></pre></td></tr></table></figure>

<p>解构的真正威力是用在<strong>对象</strong>上~</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> personOne = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;帅得乱七八糟&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">21</span>,<br>  <span class="hljs-attr">address</span>: &#123;<br>    <span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;Somewhere&#x27;</span>,<br>    <span class="hljs-attr">state</span>: <span class="hljs-string">&#x27;One of them&#x27;</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> personTwo = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;帅得歪瓜裂枣&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">22</span>,<br>  <span class="hljs-attr">address</span>: &#123;<br>    <span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;Somewhere&#x27;</span>,<br>    <span class="hljs-attr">state</span>: <span class="hljs-string">&#x27;Another one of them&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">favoriteFood</span>: <span class="hljs-string">&#x27;Watermelon&#x27;</span><br>&#125;<br><br><span class="hljs-comment">// const &#123;name, age&#125; = personTwo;   // 这个和数组解构有点不一样... 这里取出来的名字要和对象原来的属性一一对应才行...</span><br><span class="hljs-comment">// 如果想改名字 方法如下</span><br><span class="hljs-keyword">const</span> &#123;<span class="hljs-attr">name</span>: SecondName, age, favoriteFood = <span class="hljs-string">&#x27;Rice&#x27;</span>&#125; = personTwo;<br><br><span class="hljs-built_in">console</span>.log(name);        <span class="hljs-comment">// &#x27;&#x27;</span><br><span class="hljs-built_in">console</span>.log(SecondName);  <span class="hljs-comment">// &#x27;帅得歪瓜裂枣&#x27;</span><br><span class="hljs-built_in">console</span>.log(age);<br><span class="hljs-built_in">console</span>.log(favoriteFood)<br><br><span class="hljs-keyword">const</span> &#123;name, ...rest&#125; = personOne;<br><span class="hljs-keyword">const</span> &#123;<span class="hljs-attr">address</span>:&#123;city&#125;&#125; = personOne;<br><span class="hljs-built_in">console</span>.log(name);<br><span class="hljs-built_in">console</span>.log(rest);<br><span class="hljs-built_in">console</span>.log(city);  <span class="hljs-comment">// Somewhere</span><br><br><span class="hljs-keyword">const</span> personThree = &#123;...personOne, ...personTwo&#125;;   <span class="hljs-comment">// 前者属性覆盖后者</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;personThree&#x27;</span>, personThree)<br><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printUser</span>(<span class="hljs-params">&#123;name, age&#125;</span>) </span>&#123;  <span class="hljs-comment">// 解构大法...而不会再用user.name  user.age</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Name is:<span class="hljs-subst">$&#123;name&#125;</span>. Age is <span class="hljs-subst">$&#123;age&#125;</span>`</span>)<br>&#125;<br><br>printUser<br></code></pre></td></tr></table></figure>

<h4 id="或者-一般可以用于一次性解决-undefined-和-null-问题"><a href="#或者-一般可以用于一次性解决-undefined-和-null-问题" class="headerlink" title="== 或者 != 一般可以用于一次性解决 undefined 和 null 问题"></a>== 或者 != 一般可以用于一次性解决 undefined 和 null 问题</h4><h4 id="n-是换行的意思"><a href="#n-是换行的意思" class="headerlink" title="\n 是换行的意思"></a>\n 是换行的意思</h4><h4 id="对于一个函数而言，传入的如果是一个引用类型，那么传的参数其实就是一个地址"><a href="#对于一个函数而言，传入的如果是一个引用类型，那么传的参数其实就是一个地址" class="headerlink" title="对于一个函数而言，传入的如果是一个引用类型，那么传的参数其实就是一个地址"></a>对于一个函数而言，传入的如果是一个引用类型，那么传的参数其实就是一个地址</h4><figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua">const a = [<span class="hljs-number">1</span> ,<span class="hljs-number">2</span> ,<span class="hljs-number">4</span> ,<span class="hljs-number">6</span>];<br>const b = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>]<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func1</span><span class="hljs-params">(a, b)</span></span> &#123;<br>  a[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;changeOne&#x27;</span>;<br>  b[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;changeTwo&#x27;</span>;<br>  console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;func1 a&#x27;</span>, a);<br>  console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;func1 b&#x27;</span>, b);<br>&#125;<br>func1(a, b);<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;a&#x27;</span>, a);<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;b&#x27;</span>, b);<br><br>// 打印结果<br>/*<br>  func1 a [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;changeOne&#x27;</span>, <span class="hljs-number">6</span>]<br>  func1 b [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;changeTwo&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>]<br>  a [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;changeOne&#x27;</span>, <span class="hljs-number">6</span>]<br>  b [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;changeTwo&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>]<br>*/<br></code></pre></td></tr></table></figure>

<h4 id="注意一件事情，在一个函数里，改变传入的对象本身，这种行为是不好的！-你至少应该复制一个副本！-不是复制地址值哦"><a href="#注意一件事情，在一个函数里，改变传入的对象本身，这种行为是不好的！-你至少应该复制一个副本！-不是复制地址值哦" class="headerlink" title="注意一件事情，在一个函数里，改变传入的对象本身，这种行为是不好的！ 你至少应该复制一个副本！(不是复制地址值哦)"></a>注意一件事情，在一个函数里，改变传入的对象本身，这种行为是不好的！ 你至少应该复制一个副本！(不是复制地址值哦)</h4><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"><span class="hljs-keyword">object</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> newObj = &#123; ...<span class="hljs-keyword">object</span> &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="js-对象属性通过“-”和“-”访问的区别"><a href="#js-对象属性通过“-”和“-”访问的区别" class="headerlink" title="js 对象属性通过“.”和“[ ]”访问的区别"></a>js 对象属性通过“.”和“[ ]”访问的区别</h4><p><a href="https://segmentfault.com/a/1190000021794888">参考文章</a></p>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON 基础知识 &amp; Ajax 基础知识</title>
    <url>/2021/10/08/JSON&amp;Ajax%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h4 id="为什么我们要把对象转化为字符串？"><a href="#为什么我们要把对象转化为字符串？" class="headerlink" title="为什么我们要把对象转化为字符串？"></a>为什么我们要把对象转化为字符串？</h4><ol>
<li><p>在网页开发的时候，我们需要把<code>对象信息</code>进行长期保存, 因此我们需要把这些信息传递给<code>服务器</code>。所以，需要通过把对象(变量)转化为字符串才能传递给<code>服务器</code>。</p>
</li>
<li><p>我们采用的是<code>http协议</code>即超文本传输协议(其本质就是由文本的形式进行传输)</p>
</li>
<li><p>JSON 字符串是绝大多数编程语言都支持的…</p>
</li>
</ol>
<h4 id="JSON-字符串的特征"><a href="#JSON-字符串的特征" class="headerlink" title="JSON 字符串的特征"></a>JSON 字符串的特征</h4><ol>
<li><strong>属性名称</strong>必须加<strong>双引号</strong> (因为人家默认规定的字符串外层是<code>单引号</code>，所以内层必须是<code>双引号</code>)</li>
<li><strong>属性值</strong>如果是字符串则必须加<strong>双引号</strong></li>
<li>对象当中的<code>方法(函数)</code>不会被转化为字符串</li>
</ol>
<p>(注意： JSON 本质就是字符串！！)</p>
<h4 id="JSON-和-对象的相互转换："><a href="#JSON-和-对象的相互转换：" class="headerlink" title="JSON 和 对象的相互转换："></a>JSON 和 对象的相互转换：</h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xiaoming&#x27;</span>,<br>  <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;boy&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>  <span class="hljs-function"><span class="hljs-title">say</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;想吃, 想喝, 想爱&#x27;</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 把对象转为JSON字符串</span><br><span class="hljs-keyword">let</span> str1 = <span class="hljs-built_in">JSON</span>.stringify(obj);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;obj&#x27;</span>, obj);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;str1&#x27;</span>, str1);   <span class="hljs-comment">// 纯粹的字符串且没有say方法</span><br><br><span class="hljs-comment">// 把数组转为JSON字符串</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">100</span>, &#123;<span class="hljs-attr">key</span>: <span class="hljs-number">100</span>, <span class="hljs-attr">obj</span>: &#123;&#125;, <span class="hljs-attr">str</span>: <span class="hljs-string">&#x27;测试&#x27;</span>&#125;]<br><span class="hljs-keyword">let</span> str2 = <span class="hljs-built_in">JSON</span>.stringify(arr);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;arr&#x27;</span>, arr);<br><span class="hljs-comment">// 内部的字符串元素全部被强制转化为双引号,数值不加引号，</span><br><span class="hljs-comment">// 对象元素进行深层改造(加双引号..),而且不再是对象，而是字符串了...</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;str2&#x27;</span>, str2);<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// JSON字符串转成对象</span><br><span class="hljs-comment">// JSON 字符串外层是单引号哦!!</span><br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;&#123;&quot;name&quot;: &quot;小明&quot;, &quot;sex&quot;: &quot;男&quot;, &quot;age&quot;:18&#125;&#x27;</span><br><span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">JSON</span>.parse(str);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;obj.name&#x27;</span>, obj.name);   <span class="hljs-comment">// 小明</span><br></code></pre></td></tr></table></figure>

<hr>
<h4 id="手写-ajax-核心方法"><a href="#手写-ajax-核心方法" class="headerlink" title="手写 ajax 核心方法"></a>手写 ajax 核心方法</h4><p>哈哈, 以不负责任的态度来说 🤪</p>
<blockquote>
<p><code>前端</code> 是用来显示数据的<br><code>后端</code> 是用来提供数据的</p>
</blockquote>
<p>所以，前端有一个非常重要的工作是向后端索要<code>数据</code>并将数据进行页面显示</p>
<p>如何向后端索要数据呢？</p>
<h5 id="书写-ajxa-4-个核心步骤"><a href="#书写-ajxa-4-个核心步骤" class="headerlink" title="书写 ajxa 4 个核心步骤"></a>书写 ajxa 4 个核心步骤</h5><blockquote>
<p>4 个步骤！但要注意执行顺序哦！</p>
</blockquote>
<ol>
<li>创建一个请求对象, js 提供的构造函数 XMLHttpRequest(分开记忆：XML Http Request)</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest()<br></code></pre></td></tr></table></figure>

<ol start="2">
<li><p>设置请求的数据得到返回时的处理函数</p>
<blockquote>
<p>xhr.onloadend(分开记忆：on load end) –&gt; 执行方式有点类似 onclick 这类函数</p>
</blockquote>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">xhr.onloadend = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 该数据全是服务器返回的json字符串</span><br>  <span class="hljs-comment">// 请求的数据放在哪了？请求的数据其实放在了请求对象上面</span><br>  xhr.responseText<br>  <span class="hljs-comment">// 进行转化</span><br>  <span class="hljs-keyword">let</span> stus = <span class="hljs-built_in">JSON</span>.parse(xhr.responseText)<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>设置请求信息</li>
</ol>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">向谁请求：<br>例如 http:<span class="hljs-regexp">//</span>www.jd.com、http:<span class="hljs-regexp">//</span>www.baidu.com<br>xhr.open(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/todos&#x27;</span>)<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>发送请求</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">xhr.send()<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 整体操作如下：</span><br><br><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>xhr.oploadend = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> stus = <span class="hljs-built_in">JSON</span>.parse(xhr.responseText)<br>  showTable(stus)<br>&#125;<br>xhr.open(<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/todos&#x27;</span>);<br>xhr.send();<br></code></pre></td></tr></table></figure>

<head>
  ..
  <script src="//cdn.jsdelivr.net/npm/@waline/client"></script>
  ...
</head>
<body>
  ...
  <div id="waline"></div>
  <script>
    Waline({
      el: '#waline',
       avatar: 'monsterid',
      serverURL: 'https://blog-api-9sizcti78-bruce-shuai.vercel.app/',
    });
  </script>
</body>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON细节知识</title>
    <url>/2021/11/27/JSON%E7%BB%86%E8%8A%82%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h4 id="什么是-JSON"><a href="#什么是-JSON" class="headerlink" title="什么是 JSON"></a>什么是 JSON</h4><p><strong>JSON(JavaScript Object Notation)</strong></p>
<ul>
<li>是一种数据的交换格式(和 xml 很相似)</li>
<li>通常被用于接口(APIs)和配置文件</li>
<li>相较于(xml) JSON 是轻量级且容易读和写的</li>
<li>兼容各种语言 (特别是针对 <code>js</code> 是兼容性最好的，<code>JSON</code> 实际上是 <code>JavaScript</code> 的一个子集)</li>
</ul>
<p>JSON 常常用与前后端的数据交互</p>
<h4 id="JSON-具备的类型"><a href="#JSON-具备的类型" class="headerlink" title="JSON 具备的类型"></a>JSON 具备的类型</h4><p><code>JSON</code> 的字符串规定必须用双引号<code>&quot;&quot;</code>，<code>Object</code> 的键也必须用双引号<code>&quot;&quot;</code></p>
<table>
<thead>
<tr>
<th>类型名</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>Strings</td>
<td>“Hello World” “Hi”(注意是双引号)</td>
</tr>
<tr>
<td>Numbers</td>
<td>10 1.5 -30 1.2e10(兼容各种进制和科学计数法)</td>
</tr>
<tr>
<td>Booleans</td>
<td>true false</td>
</tr>
<tr>
<td>null</td>
<td>null (注意，没有 undefined 类型)</td>
</tr>
<tr>
<td>Arrays</td>
<td>[1, 2, 3], [“Hello”, “World”]</td>
</tr>
<tr>
<td>Objects</td>
<td>{“key”: “value”} {“age”: 30} (注意，value 可以是 String、Number、Boolean、null、Array、Object 类型)</td>
</tr>
</tbody></table>
<h4 id="JSON-的使用方法"><a href="#JSON-的使用方法" class="headerlink" title="JSON 的使用方法"></a>JSON 的使用方法</h4><h5 id="创建-JSON-文件"><a href="#创建-JSON-文件" class="headerlink" title="创建 JSON 文件"></a>创建 JSON 文件</h5><p>文件后缀名：<code>.json</code><br>在 <code>json</code> 文件里，允许使用上述的几种类型。且一般将<code>[]</code>或者<code>&#123;&#125;</code>作为文件的顶层内容。</p>
<p><code>JSON</code>内容可以无限嵌套的，所以可以良好的用于深浅拷贝<br>例如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-comment">/* user.json */</span><br>&#123;<br>  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;帅得乱七八糟&quot;</span>,  <span class="hljs-comment">// 只能有, 不能用; 事实上连注释其实都是禁止写的</span><br>  <span class="hljs-attr">&quot;age&quot;</span>: <span class="hljs-number">21</span>,<br>  <span class="hljs-attr">&quot;isProgrammer&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">&quot;hobbies&quot;</span>: [<span class="hljs-string">&quot;看美女&quot;</span>, <span class="hljs-string">&quot;打乒乓球&quot;</span>],<br>  <span class="hljs-attr">&quot;friends&quot;</span>: [&#123;<br>    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;帅得歪瓜裂枣&quot;</span>,<br>    <span class="hljs-attr">&quot;age&quot;</span>: <span class="hljs-number">22</span>,<br>    <span class="hljs-attr">&quot;isProgrammer&quot;</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">&quot;friends&quot;</span>: [...]   <span class="hljs-comment">// 事实上，这里可以无限嵌套</span><br>  &#125;]<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="解析-JSON-字符串"><a href="#解析-JSON-字符串" class="headerlink" title="解析 JSON 字符串"></a>解析 JSON 字符串</h5><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-comment">/* users.json */</span><br>[<br>  &#123;<br>    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;帅得乱七八糟&quot;</span>,<br>    <span class="hljs-attr">&quot;age&quot;</span>: <span class="hljs-number">21</span>,<br>    <span class="hljs-attr">&quot;ability&quot;</span>: [<span class="hljs-string">&quot;打乒乓&quot;</span>, <span class="hljs-string">&quot;画画&quot;</span>],<br>    <span class="hljs-attr">&quot;friends&quot;</span>: [<br>      &#123;<br>        <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;帅得一塌糊涂&quot;</span>,<br>        <span class="hljs-attr">&quot;age&quot;</span>: <span class="hljs-number">20</span>,<br>        <span class="hljs-attr">&quot;ability&quot;</span>: [ <span class="hljs-string">&quot;画画&quot;</span>],<br>        <span class="hljs-attr">&quot;friends&quot;</span>: <span class="hljs-literal">null</span><br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;美得花里胡哨&quot;</span>,<br>        <span class="hljs-attr">&quot;age&quot;</span>: <span class="hljs-number">20</span>,<br>        <span class="hljs-attr">&quot;ability&quot;</span>: [ <span class="hljs-string">&quot;画画&quot;</span>, <span class="hljs-string">&quot;唱歌&quot;</span>],<br>        <span class="hljs-attr">&quot;friends&quot;</span>: <span class="hljs-literal">null</span><br>      &#125;<br>    ]<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;帅得歪瓜裂枣&quot;</span>,<br>    <span class="hljs-attr">&quot;age&quot;</span>: <span class="hljs-number">21</span>,<br>    <span class="hljs-attr">&quot;ability&quot;</span>: [<span class="hljs-string">&quot;写代码&quot;</span>],<br>    <span class="hljs-attr">&quot;friends&quot;</span>: <span class="hljs-literal">null</span><br>  &#125;<br>]<br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">/* index.html */<br><br>// 现在，我们把users.json文件里的所有内容全部放在js里面去，因为我前面就说过，json算js的一个子集。js完全兼容json<br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">const</span> users = [</span><br><span class="javascript">    &#123;</span><br><span class="javascript">      <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;帅得乱七八糟&quot;</span>,</span><br><span class="javascript">      <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">21</span>,</span><br><span class="javascript">      <span class="hljs-string">&quot;ability&quot;</span>: [<span class="hljs-string">&quot;打乒乓&quot;</span>, <span class="hljs-string">&quot;画画&quot;</span>],</span><br><span class="javascript">      <span class="hljs-string">&quot;friends&quot;</span>: [</span><br><span class="javascript">        &#123;</span><br><span class="javascript">          <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;帅得一塌糊涂&quot;</span>,</span><br><span class="javascript">          <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">20</span>,</span><br><span class="javascript">          <span class="hljs-string">&quot;ability&quot;</span>: [ <span class="hljs-string">&quot;画画&quot;</span>],</span><br><span class="javascript">          <span class="hljs-string">&quot;friends&quot;</span>: <span class="hljs-literal">null</span></span><br><span class="javascript">        &#125;,</span><br><span class="javascript">        &#123;</span><br><span class="javascript">          <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;美得花里胡哨&quot;</span>,</span><br><span class="javascript">          <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">20</span>,</span><br><span class="javascript">          <span class="hljs-string">&quot;ability&quot;</span>: [ <span class="hljs-string">&quot;画画&quot;</span>, <span class="hljs-string">&quot;唱歌&quot;</span>],</span><br><span class="javascript">          <span class="hljs-string">&quot;friends&quot;</span>: <span class="hljs-literal">null</span></span><br><span class="javascript">        &#125;</span><br><span class="javascript">      ]</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    &#123;</span><br><span class="javascript">      <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;帅得歪瓜裂枣&quot;</span>,</span><br><span class="javascript">      <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">21</span>,</span><br><span class="javascript">      <span class="hljs-string">&quot;ability&quot;</span>: [<span class="hljs-string">&quot;写代码&quot;</span>],</span><br><span class="javascript">      <span class="hljs-string">&quot;friends&quot;</span>: <span class="hljs-literal">null</span></span><br><span class="javascript">    &#125;</span><br><span class="javascript">  ]</span><br><span class="javascript"></span><br><span class="javascript">  <span class="hljs-built_in">console</span>.log(users)</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>打印结果如下：<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-27-at-11.10.17-AM.png" alt="users"></p>
<p>但事实上，当你处理 <code>json</code> 的时候，你应该把它用字符串来表示。在整个 <code>json</code> 内容外面加<strong>单引号</strong> (用双引号容易和<code>JSON</code>内部的双引号重叠)</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">&lt;script&gt;<br>  const users = `[<br>    &#123;<br>      &quot;name&quot;: &quot;帅得乱七八糟&quot;,<br>      &quot;age&quot;: <span class="hljs-number">21</span>,<br>      &quot;ability&quot;: [&quot;打乒乓&quot;, &quot;画画&quot;],<br>      &quot;friends&quot;: [<br>        &#123;<br>          &quot;name&quot;: &quot;帅得一塌糊涂&quot;,<br>          &quot;age&quot;: <span class="hljs-number">20</span>,<br>          &quot;ability&quot;: [ &quot;画画&quot;],<br>          &quot;friends&quot;: <span class="hljs-keyword">null</span><br>        &#125;,<br>        &#123;<br>          &quot;name&quot;: &quot;美得花里胡哨&quot;,<br>          &quot;age&quot;: <span class="hljs-number">20</span>,<br>          &quot;ability&quot;: [ &quot;画画&quot;, &quot;唱歌&quot;],<br>          &quot;friends&quot;: <span class="hljs-keyword">null</span><br>        &#125;<br>      ]<br>    &#125;,<br>    &#123;<br>      &quot;name&quot;: &quot;帅得歪瓜裂枣&quot;,<br>      &quot;age&quot;: <span class="hljs-number">21</span>,<br>      &quot;ability&quot;: [&quot;写代码&quot;],<br>      &quot;friends&quot;: <span class="hljs-keyword">null</span><br>    &#125;<br>  ]`<br><br>  // 然后用 <span class="hljs-type">JSON</span>.parse 来解析<span class="hljs-type">json</span>字符串<br>  console.log(<span class="hljs-type">JSON</span>.parse(users))<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p>所得结果和上图一样</p>
<h5 id="JSON-字符串化"><a href="#JSON-字符串化" class="headerlink" title="JSON 字符串化"></a>JSON 字符串化</h5><p><strong>使用方法为： JSON.stringify()</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">/* index.html */<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">const</span> users = &#123;          <span class="hljs-comment">// 这是一个简单的users对象。和上面的JSON 对象可不一样。没有 &quot;&quot; 符号</span></span><br><span class="javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xiaoming&#x27;</span>,</span><br><span class="javascript">    <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;boy&#x27;</span>,</span><br><span class="javascript">    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">say</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;想吃, 想喝, 想爱&#x27;</span>)</span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;</span><br><span class="javascript">  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.stringify(users));   <span class="hljs-comment">// 我把uses变为 JSON 字符串化(不仅变成JSON 还要是字符串版本的)</span></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>控制台打印结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;name&quot;</span>:<span class="hljs-string">&quot;xiaoming&quot;</span>,<span class="hljs-attr">&quot;sex&quot;</span>:<span class="hljs-string">&quot;boy&quot;</span>,<span class="hljs-attr">&quot;age&quot;</span>:<span class="hljs-number">18</span>&#125;  <span class="hljs-comment">// 可见，不仅字符串化了(最外层的&#x27;&#x27;在打印出来后看不见)， 并且原来的函数 say() 也被直接过滤了！！</span><br></code></pre></td></tr></table></figure>

<p><strong>JSON 是不支持函数的！</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">const</span> users = &#123;          <span class="hljs-comment">// 这是一个简单的users对象。和上面的JSON 对象可不一样。没有 &quot;&quot; 符号</span></span><br><span class="javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xiaoming&#x27;</span>,</span><br><span class="javascript">    <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;boy&#x27;</span>,</span><br><span class="javascript">    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">say</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;想吃, 想喝, 想爱&#x27;</span>)</span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;</span><br><span class="javascript">  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(users)));   <span class="hljs-comment">// 我把uses变为 JSON 字符串化(不仅变成JSON 还要是字符串版本的)</span></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-27-at-11.49.50-AM.png" alt="打印结果"></p>
<p><strong>Response.json()</strong><br>这行代码的意思是 返回一个被解析为 JSON 格式的 promise 对象</p>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>JS的编译原理</title>
    <url>/2021/12/08/JS%E7%9A%84%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="JS-是一遍编译一遍执行"><a href="#JS-是一遍编译一遍执行" class="headerlink" title="JS 是一遍编译一遍执行"></a>JS 是一遍编译一遍执行</h3><p>JS 代码片段在执行之前都会被编译，只是这个编译的时间会非常短暂(可能只有几微秒，甚至更短)，紧接着代码就会被执行</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">var</span> <span class="hljs-keyword">name</span> = <span class="hljs-string">&#x27;HeYang&#x27;</span><br></code></pre></td></tr></table></figure>

<p>上述这行代码在 JS 引擎中包含两个声明</p>
<ul>
<li>var name (编译时处理)</li>
<li>name = ‘HeYang’ (运行时处理)</li>
</ul>
<p><strong>编译阶段</strong><br>编译器 –&gt; 找当前作用域 –&gt; 将代码变为运行时所需要的代码<br><strong>执行阶段</strong><br>JS 引擎 –&gt; 作用域链</p>
<h3 id="LHS、RHS"><a href="#LHS、RHS" class="headerlink" title="LHS、RHS"></a>LHS、RHS</h3><p>LHS、RHS 是引擎在执行代码的时候，查询变量的两种方式。其中的 L R 分别意味着 Left、Right</p>
<p>LHS: 变量赋值或写入内存<br>RHS: 变量查找或从内存中读取，它强调的是这个读这个动作</p>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>作用域套作用域 就有了作用域链</p>
<h3 id="JS-的作用域"><a href="#JS-的作用域" class="headerlink" title="JS 的作用域"></a>JS 的作用域</h3><ul>
<li>全局作用域</li>
<li>函数作用域</li>
<li>块作用域</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>高级</tag>
      </tags>
  </entry>
  <entry>
    <title>JWT 知识</title>
    <url>/2021/12/04/JWT-%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p><a href="https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">阮一峰的这篇博客写得不错</a></p>
<h3 id="JWT-是什么？"><a href="#JWT-是什么？" class="headerlink" title="JWT 是什么？"></a>JWT 是什么？</h3><ul>
<li>JSON Web Token</li>
<li>JWT 的作用是<strong>用户授权(Authorization), 而不是用户的身份认证(Authentication)</strong></li>
</ul>
<h4 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h4><p>这是将你的用户名和密码在服务端进行验证 —&gt; 比如用户登录验证</p>
<h4 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h4><p>是确保用户发送了请求到指定的服务端, 然后服务端通过检查你的信息来判断你是否有权限使用某些东西，是确定经过身份验证的用户是否可以访问特定资源的过程</p>
<p><strong>简单来说，身份验证是验证您的身份的过程，而授权是验证您有权访问的过程</strong></p>
<p>传统的用户授权方式是利用 <code>Session ID</code>。客户端将 <code>Session ID</code> 放在 <code>cookies</code> 里面。然后每次的请求发送，客户端利用 <code>cookies</code> 将 <code>session id</code> 发送到服务器端。然后服务端检查该请求的 <code>Session id</code> 查找该用户，并判断该用户是否有权限做某些事<br>但是 <code>JWT</code> 代替了这样使用 <code>cookies</code>。而是利用 <code>JSON web token</code> 来进行用户授权认证</p>
<p>传统的用户登录方法 VS JWT 的用户登录方法<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-12-04-at-9.06.59-AM.png" alt="session VS JWT"></p>
<p>图表里可以看见是用户完成注册登录后 <code>Server</code> 端创建的 <code>JWT</code>，再返回给的客户端(把 <code>JWT</code> 全部传递给客户端, <code>JWT</code>里包含用户的全部信息)。而 <code>Server</code> 端创建的 <code>JWT</code> 是有 <code>Secret</code>(也只有 server 端会有 secret) 的。所以，如果你客户端或其他地方篡改 <code>JWT</code>。<code>Secret</code> 是会知道的(哈希算法)，下一次你把篡改的信息发送给服务端，服务端通过 <code>Secret</code> 就可以知道你是否篡改了信息，如果篡改了，这条 <code>JWT</code> 就无效了</p>
<p>传统的方法，用户信息存储在 <code>server</code> 端。 而 <code>jwt</code> 是将信息存储在 <code>token</code> 里, 这也意味着将用户信息存储在 <code>client</code> 端,而 <code>server</code> 端不会记得任何用户信息，这样也就意味着一个 <code>jwt</code> 能够放在各种 <code>server</code> 端上使用</p>
<p>注意：客户端收到服务器返回的 JWT –&gt; 放在 token 里面，token 可以储存在 Cookie 里面，也可以储存在 localStorage</p>
<h3 id="为什么要使用-JWT"><a href="#为什么要使用-JWT" class="headerlink" title="为什么要使用 JWT"></a>为什么要使用 JWT</h3><p><a href="https://jwt.io/">jwt 官网</a><br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-12-04-at-10.09.00-AM.png" alt="JWT"></p>
<p>上图的左边是加密后的 JWT(加密算法图中标出是:HS256) –&gt; 这将是从服务端发送到客户端以及从客户端发送给服务端的加密内容<br>上图的右边是解密后的 JWT：</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">HEADER</span>: 表示你用的是什么加密和解密算法,以及令牌：<span class="hljs-built_in">JWT</span>(jwt令牌统一写成JWT)<br>PAYLOAD:  表示你存储在<span class="hljs-built_in">token</span>里的所有用户信息  <span class="hljs-comment">/* 基础属性：sub: 类似用户id    name: 类似用户信息    iat: 签发时间*/</span><br>VERIFY SIGNATURE: 用于检验我们的<span class="hljs-built_in">token</span>信息是否在传回给server端之前就被修改 <span class="hljs-comment">/*这里使用了特别的加密算法 来加密HEADER和PAYLOAD, server也会通过secret来验证你的内容是否被篡改(secret只有服务器知道) */</span><br></code></pre></td></tr></table></figure>

<h3 id="JWT-是如何工作的-？-为什么我们要使用-JWT"><a href="#JWT-是如何工作的-？-为什么我们要使用-JWT" class="headerlink" title="JWT 是如何工作的 ？ 为什么我们要使用 JWT"></a>JWT 是如何工作的 ？ 为什么我们要使用 JWT</h3><p>这一部分其实主要是讲 JTW 更方便我们一个账户能够在多台服务器上使用</p>
<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-12-04-at-10.57.59-AM.png" alt="JWT WORK"></p>
<p>上图，我们有两个不同的 <code>server</code>： Bank、Retirement<br>Bank 这个服务器里具备银行的各种信息, Retirement 服务器拥有各种退休计划、保险信息</p>
<p>现在有一个要求，就是当你登录 Bank 后，你能够自动访问 Retirement。而是不是又要自己手动登录一次 Retirement。</p>
<p>好，如果你在 Bank 获得的 Session ID，你是无法通过此 Session ID，进入 Retirement 的！你需要登录 Retirement,获取从 Retirement 发送的 Session ID 才能进行系列授权操作</p>
<p>如果你使用的是 JWT。当你的 jwt 中的 secret 发送给了 Bank 和 Retirement，之后你把你的 jwt(jwt 包含了你全部的用户信息)发送给这两个服务器，因为他们有你的 secret。所以能够验证你是否是该服务端里的用户以及所对应的用户权限有哪些</p>
<p>无论有多少服务器，只要他们有你 jwt 的 secret(这是唯一的)，就能实现多服务器登录同一个用户</p>
<h3 id="token"><a href="#token" class="headerlink" title="token"></a>token</h3><p>token 的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。</p>
<p>当用户第一次登录后，服务器生成一个 token 并将此 token 返回给客户端，以后客户端只需带上这个 token 前来请求数据即可，无需再次带上用户名和密码。</p>
<p><strong>注意，在实战中，如果要使用 jwt,则我们登录注册后，服务端会返回一个 token</strong><br>这个 token 就是我们要保存的 jwt 的数据了<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-12-04-at-11.51.57-AM.png" alt="token"></p>
<p>发送请求携带 token 的方法：这里用的 fetch</p>
<figure class="highlight nim"><table><tr><td class="code"><pre><code class="hljs nim">fetch(&#x27;xxx&#x27;, &#123;<br>  <span class="hljs-keyword">method</span>: &#x27;xxx&#x27;,<br>  headers: &#123;<br>    <span class="hljs-type">Authorization</span>: token ? `<span class="hljs-type">Bearer</span> $&#123;token&#125;` : <span class="hljs-string">&quot;&quot;</span>, // 这里的token 是一个变量，值是server端获取来的<br>    ...<br>  &#125;,<br>  body: <span class="hljs-meta">&#123;...&#125;</span><br>&#125;).then(async (res) =&gt; &#123;<br>  ...<br>&#125;)<br></code></pre></td></tr></table></figure>

<h3 id="401-未授权"><a href="#401-未授权" class="headerlink" title="401 未授权"></a>401 未授权</h3><p>token 失效或未登录的时候，服务端就会返回 401</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">fetch(<span class="hljs-string">&#x27;xxx&#x27;</span>, &#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;xxx&#x27;</span>,<br>  <span class="hljs-attr">headers</span>: &#123;<br>    <span class="hljs-attr">Authorization</span>: token ? <span class="hljs-string">`Bearer <span class="hljs-subst">$&#123;token&#125;</span>`</span> : <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// 这里的token 是一个变量，值是server端获取来的</span><br>    ...<br>  &#125;,<br>  <span class="hljs-attr">body</span>: &#123;...&#125;<br>&#125;).then(<span class="hljs-keyword">async</span> (res) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (res.status === <span class="hljs-number">401</span>) &#123;<br>      <span class="hljs-comment">// 401 是未登录或token失效的意思</span><br>      <span class="hljs-comment">// 设置一个退出登录的操作(方法)</span><br>      <span class="hljs-built_in">window</span>.location.reload(); <span class="hljs-comment">// 页面重新刷新</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;请重新登录&quot;</span> &#125;);<br>    &#125;<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> res.json();<br>    <span class="hljs-keyword">if</span> (res.ok) &#123;<br>      <span class="hljs-keyword">return</span> data;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(data);<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>高级</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript Array 笔记</title>
    <url>/2021/10/20/JavaScript-Array-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>看代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> items = [<br>  &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bike&#x27;</span>,     <span class="hljs-attr">price</span>: <span class="hljs-number">100</span>&#125;,<br>  &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;TV&#x27;</span>,       <span class="hljs-attr">price</span>: <span class="hljs-number">200</span>&#125;,<br>  &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Album&#x27;</span>,    <span class="hljs-attr">price</span>: <span class="hljs-number">10</span>&#125;,<br>  &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Book&#x27;</span>,     <span class="hljs-attr">price</span>: <span class="hljs-number">5</span>&#125;,<br>  &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Phone&#x27;</span>,    <span class="hljs-attr">price</span>: <span class="hljs-number">500</span>&#125;,<br>  &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Computer&#x27;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">1000</span>&#125;,<br>  &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Keyboard&#x27;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">25</span>&#125;,<br>]<br></code></pre></td></tr></table></figure>

<h4 id="filter-–-gt-返回一个新的数组-对于排除原来数组的某些元素有奇效"><a href="#filter-–-gt-返回一个新的数组-对于排除原来数组的某些元素有奇效" class="headerlink" title="filter –&gt; 返回一个新的数组(对于排除原来数组的某些元素有奇效)"></a>filter –&gt; 返回一个新的数组(对于排除原来数组的某些元素有奇效)</h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> filteredItems = items.filter(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> item.price &lt;= <span class="hljs-number">100</span>;     <span class="hljs-comment">// boolean</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<h4 id="map-–-gt-返回一个新的数组-对于修改或展现原来数组的每一个元素部分内容而闻名"><a href="#map-–-gt-返回一个新的数组-对于修改或展现原来数组的每一个元素部分内容而闻名" class="headerlink" title="map –&gt; 返回一个新的数组(对于修改或展现原来数组的每一个元素部分内容而闻名)"></a>map –&gt; 返回一个新的数组(对于修改或展现原来数组的每一个元素部分内容而闻名)</h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> itemNames = items.map(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> item.name<br>&#125;)<br></code></pre></td></tr></table></figure>

<h4 id="find-–-gt-返回原来数组中的某个特定元素-对于查找原来数组特定元素有奇效。不过只要查找到一个元素后，就不会继续往后查找了"><a href="#find-–-gt-返回原来数组中的某个特定元素-对于查找原来数组特定元素有奇效。不过只要查找到一个元素后，就不会继续往后查找了" class="headerlink" title="find –&gt; 返回原来数组中的某个特定元素(对于查找原来数组特定元素有奇效。不过只要查找到一个元素后，就不会继续往后查找了)"></a>find –&gt; 返回原来数组中的某个特定元素(对于查找原来数组特定元素有奇效。不过只要查找到一个元素后，就不会继续往后查找了)</h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> foundItem = items.find(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> item.name === <span class="hljs-string">&#x27;Book&#x27;</span>    <span class="hljs-comment">// boolean</span><br>&#125;)<br><br>foundItem <span class="hljs-comment">// &#x27;Book&#x27;</span><br></code></pre></td></tr></table></figure>

<h4 id="indexOf-–-gt-数组中查找指定元素的下标方法"><a href="#indexOf-–-gt-数组中查找指定元素的下标方法" class="headerlink" title="indexOf –&gt; 数组中查找指定元素的下标方法"></a>indexOf –&gt; 数组中查找指定元素的下标方法</h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> question = [<span class="hljs-string">&#x27;错误&#x27;</span>, <span class="hljs-string">&#x27;错误&#x27;</span>, <span class="hljs-string">&#x27;正确&#x27;</span>, <span class="hljs-string">&#x27;错误&#x27;</span>]<br><span class="hljs-keyword">let</span> findIndex = question.indexOf(<span class="hljs-string">&#x27;正确&#x27;</span>);   <span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 如果找不到就会直接返回 -1</span><br></code></pre></td></tr></table></figure>

<!-- #### findIndex -->

<h4 id="forEach-–-gt-不返回新内容。会对原数组继续修改"><a href="#forEach-–-gt-不返回新内容。会对原数组继续修改" class="headerlink" title="forEach –&gt; 不返回新内容。会对原数组继续修改"></a>forEach –&gt; 不返回新内容。会对原数组继续修改</h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">items.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>  item.name = <span class="hljs-string">&#x27;jack&#x27;</span><br>  <span class="hljs-built_in">console</span>.log(item.name)<br>&#125;)<br></code></pre></td></tr></table></figure>

<h4 id="some-–-gt-返回一个布尔值-用于查看数组中是否有满足特定条件的元素"><a href="#some-–-gt-返回一个布尔值-用于查看数组中是否有满足特定条件的元素" class="headerlink" title="some –&gt; 返回一个布尔值(用于查看数组中是否有满足特定条件的元素)"></a>some –&gt; 返回一个布尔值(用于查看数组中是否有满足特定条件的元素)</h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> hasInexpensiveItems = items.some(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> item.price &lt;= <span class="hljs-number">100</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<h4 id="every-–-gt-返回一个布尔值-类似-some，但是是查看数组中是否每一个元素都满足特定条件"><a href="#every-–-gt-返回一个布尔值-类似-some，但是是查看数组中是否每一个元素都满足特定条件" class="headerlink" title="every –&gt; 返回一个布尔值(类似 some，但是是查看数组中是否每一个元素都满足特定条件)"></a>every –&gt; 返回一个布尔值(类似 some，但是是查看数组中是否每一个元素都满足特定条件)</h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> hasInexpensiveItems = items.every(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> item.price &lt;= <span class="hljs-number">100</span><br>&#125;)<br><br></code></pre></td></tr></table></figure>

<h4 id="reduce-–-gt-返回一个值-常用于计算数组元素中某个属性的和"><a href="#reduce-–-gt-返回一个值-常用于计算数组元素中某个属性的和" class="headerlink" title="reduce –&gt; 返回一个值(常用于计算数组元素中某个属性的和)"></a>reduce –&gt; 返回一个值(常用于计算数组元素中某个属性的和)</h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> total = items.reduce(<span class="hljs-function">(<span class="hljs-params">currentTotal, item</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> currentTotal + item.price<br>&#125;, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>

<p><strong>Reduce 具体讲解</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n <span class="hljs-keyword">of</span> numbers) &#123;<br>    sum += n;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(sum);   <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure>

<p>–&gt; 使用 reduce</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 两个参数</span><br><span class="hljs-comment"> * 参数一：回调函数 (此回调函数必须有返回值。且返回值赋值新一次迭代的accmulator)</span><br><span class="hljs-comment"> * 参数二：一个值, 作为accmulator的初始值 (如果参数二不写，则数组第一个元素作为accmulator的初始值)</span><br><span class="hljs-comment"> * 效果： 迭代调用reduce的数组的每一个元素 即 currentValue(从数组第一个元素开始)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">let</span> sum = numbers.reduce(<span class="hljs-function">(<span class="hljs-params">accmulator, currentValue</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 注意：这里是要有返回值才行的...</span><br>  <span class="hljs-comment">// 返回值赋值给accmulator</span><br>  <span class="hljs-keyword">return</span> accmulator + currentValue<br>&#125;, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment">// 上述执行过程</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *    accmulator: 0     currentValue: 1</span><br><span class="hljs-comment"> *    accmulator: 1     currentValue: -1</span><br><span class="hljs-comment"> *    accmulator: 0     currentValue: 2</span><br><span class="hljs-comment"> *    accmulator: 2     currentValue: 3</span><br><span class="hljs-comment"> *    accmulator: 5     打断施法...</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">console</span>.log(sum);   <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure>

<h4 id="includes-—-解决简单版的-find-问题。参数为简单数组。返回布尔值"><a href="#includes-—-解决简单版的-find-问题。参数为简单数组。返回布尔值" class="headerlink" title="includes — 解决简单版的 find 问题。参数为简单数组。返回布尔值"></a>includes — 解决简单版的 find 问题。参数为简单数组。返回布尔值</h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-keyword">const</span> total = items.includes(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure>

<h4 id="flat"><a href="#flat" class="headerlink" title="flat"></a>flat</h4><p>现在想象一件事：如果你有下面这样的嵌套数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>], <span class="hljs-number">8</span>];<br><span class="hljs-comment">// 我想将其转为未嵌套的数组</span><br><span class="hljs-built_in">console</span>.log(arr.flat()) <span class="hljs-comment">// [1, 2, 3, 4, 5, 6, 7, 8]</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> doubleNestedArr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>], <span class="hljs-number">5</span>], <span class="hljs-number">6</span>, [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>]]<br><span class="hljs-built_in">console</span>.log(doubleNestedArr.flat())<br><span class="hljs-comment">// [1, 2, [3, 4], 5, 6, 7, 8]</span><br></code></pre></td></tr></table></figure>

<p>如果我想展平多少个嵌套级别，我直接输入数字即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> doubleNestedArr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>], <span class="hljs-number">5</span>], <span class="hljs-number">6</span>, [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>]]<br><span class="hljs-built_in">console</span>.log(doubleNestedArr.flat(<span class="hljs-number">2</span>))<br><span class="hljs-comment">// [1, 2, 3, 4, 5, 6, 7, 8]</span><br></code></pre></td></tr></table></figure>

<p>使用<code>Infinity</code>后，无论有多少级的嵌套，我都可以展平</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> doubleNestedArr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>], <span class="hljs-number">5</span>], <span class="hljs-number">6</span>, [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>]]<br><span class="hljs-built_in">console</span>.log(doubleNestedArr.flat(<span class="hljs-literal">Infinity</span>))<br><span class="hljs-comment">// [1, 2, 3, 4, 5, 6, 7, 8]</span><br></code></pre></td></tr></table></figure>

<p><code>flat</code>还可以清除数组中的空格<br>例子如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, , <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, , <span class="hljs-number">9</span>]<br><span class="hljs-built_in">console</span>.log(arr)<br><span class="hljs-comment">// [1, 2, 3, 4, empty, 6, 7, empty, 9]</span><br><span class="hljs-built_in">console</span>.log(arr.flat())<br><span class="hljs-comment">// [1, 2, 3, 4, 6, 7, 9]</span><br></code></pre></td></tr></table></figure>

<h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h4><p><code>flatMap</code>实质等同于<code>map().flat()</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> people = [<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-attr">favNums</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>] &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Sally&#x27;</span>, <span class="hljs-attr">favNums</span>: [<span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>] &#125;,<br>]<br><span class="hljs-built_in">console</span>.log(people.map(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> p.favNums))<br><span class="hljs-comment">// [[1, 2, 4], [6, 8, 9]]</span><br><span class="hljs-built_in">console</span>.log(people.map(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> p.favNums).flat())<br><span class="hljs-comment">// [1, 2, 4, 6, 8, 9]</span><br><span class="hljs-built_in">console</span>.log(people.flatMap(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> p.favNums))<br><span class="hljs-comment">// [1, 2, 4, 6, 8, 9]</span><br></code></pre></td></tr></table></figure>

<h4 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h4><p>这个方法 其实可以实现数组的浅拷贝</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>b = a.slice();<br><span class="hljs-built_in">console</span>.log(b);       <span class="hljs-comment">// [1, 2, 3]</span><br><span class="hljs-built_in">console</span>.log(a === b)  <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>Pure Functions</title>
    <url>/2021/12/17/Pure-Functions/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>RESTful</title>
    <url>/2021/12/17/RESTful/</url>
    <content><![CDATA[<p>RESTFul</p>
<p>对于前端开发，我们不需要知道 RESTFul 的开发过程，但要知道该如何使用</p>
<ul>
<li>语义明确、轻量级、而且结构简单</li>
</ul>
<p><code>REST</code> \ <code>RESTFul</code> 这二者的区别就是一个是名词、一个是形容词</p>
<h4 id="RESTful-的基本特点"><a href="#RESTful-的基本特点" class="headerlink" title="RESTful 的基本特点"></a>RESTful 的基本特点</h4><ul>
<li>无状态：一次调用就能返回结果(WebSocket 这种持久化、有状态的连接就不属于 RESTful 的范畴)</li>
<li>面向”资源”, 所以，只会出现名词，而不会出现动词</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">api<span class="hljs-regexp">/v1/</span>touristRoutes       √<br>api<span class="hljs-regexp">/v1/</span>GetTouristRoutes    ×<br>api<span class="hljs-regexp">/v1/</span>createTouristRoutes ×<br></code></pre></td></tr></table></figure>

<ul>
<li>使用 HTTP 的动词<table>
<thead>
<tr>
<th>动词</th>
<th>意义</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>查看</td>
<td>HTTP GET api/v1/touristRoutes</td>
</tr>
<tr>
<td>POST</td>
<td>创建</td>
<td>HTTP POST api/v1/touristRoutes</td>
</tr>
<tr>
<td>PUT</td>
<td>更新</td>
<td>HTTP PUT api/v1/touristRoutes/{id}</td>
</tr>
<tr>
<td>PATCH</td>
<td>部分更新</td>
<td>HTTP PATCH api/v1/touristRoutes/{id}</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除</td>
<td>HTTP DELETE api/v1/touristRoutes/{id}</td>
</tr>
</tbody></table>
</li>
</ul>
<p>api 都长得一样，但根据 http 方法，来分类 api 所发挥的作用</p>
<ul>
<li>HATOAS 超媒体即应用状态引擎</li>
</ul>
<p><strong>RESTFul API 在某些情况好用，某些情况非常不好用</strong></p>
<ul>
<li>好用： 面向对象(资源), 如增删改查</li>
<li>不好用： 面对过程, 如登录</li>
</ul>
]]></content>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title>React Hooks的思考与总结</title>
    <url>/2022/01/13/React-Hooks%E7%9A%84%E6%80%9D%E8%80%83%E4%B8%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><a href="https://codesandbox.io/s/react-hooks-course-20vzg">代码地址</a></p>
<p>React 的中文含义即：“反应”或“创新”，它描述了 React 这样一个前端框架的核心原理：当数据发生变化时，UI 能够<strong>自动</strong>把变化反应出来</p>
<p>JSX 仅是语法糖，意味着。你不用 JSX 的写法，同样能够写出 React 来</p>
<p>JSX 不是一个新的概念，而只是原生 JS 的另一种写法，但是这种写法，将会大大降低你上手 React 的难度</p>
<p>在 React 组件中，任何一个 state 发生变化时，整个函数组件其实是被完全执行一遍的， 而且除了 state，多次的执行之间没有任何关系。所以在考虑这样一个场景的实现时，我们 的思考方式就是要首先考虑这个组件有哪些状态(state)，这些状态的变化是由什么触发 的，从而将整个功能串联起来。</p>
<blockquote>
<p>Hooks 的使用规则：1. 只能在函数组件的顶级作用域中使用，2. 只能在函数组件或者其他 Hooks 中使用</p>
</blockquote>
<h4 id="useState-让函数组件具备维持状态的能力"><a href="#useState-让函数组件具备维持状态的能力" class="headerlink" title="useState: 让函数组件具备维持状态的能力"></a>useState: 让函数组件具备维持状态的能力</h4><h5 id="比较-Class-组件的-state-和-hooks-组件的-state"><a href="#比较-Class-组件的-state-和-hooks-组件的-state" class="headerlink" title="比较 Class 组件的 state 和 hooks 组件的 state"></a>比较 Class 组件的 state 和 hooks 组件的 state</h5><p>二者最大的区别就是， 类组件的 state 只能有一个，然后再通过不同的属性来表示不同的状态。 而 useState 则可以很容易地创建多个 state，所以它更加的语义化</p>
<h4 id="useEffect-执行副作用"><a href="#useEffect-执行副作用" class="headerlink" title="useEffect: 执行副作用"></a>useEffect: 执行副作用</h4><p>副作用是指一段和当前执行结果无关的代码<br>useEffect 中代码的执行是不影响渲染出来的 UI 的。</p>
<p>其实不必刻意把 useEffect 对应到某几个生命周期方法中，虽然我以前也尝试这样做过，但是，有了这样的思维后，就有点应试教育的那种感觉，不能完全拥抱 hooks。我现在对于 useEffect 的理解是<strong>每次组件 render 完后判断依赖并执行就可以了</strong></p>
<p>注意一个小问题，useEffect 的 callback 要避免直接的 async 函数，需要封装一下：<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-01-14-%E4%B8%8A%E5%8D%889.2obivszc5g80.webp" alt="useEffect"></p>
<p><strong>useEffect 关于依赖项的一些规则</strong>：</p>
<ul>
<li>没有依赖项，则每次 render 完后都会重新执行</li>
<li>空数组作为依赖项，则只在首次执行 render 后触发</li>
<li>普通依赖项,第一次以及依赖项发生变化后执行</li>
<li>useEffect 还允许你返回一个函数，用于在<strong>组件销毁</strong>的时候做一些清理的操作</li>
</ul>
<p>在写 hooks 时候的注意点：</p>
<ol>
<li>在 useEffect 的回调函数中使用的变量，都必须在依赖项中声明 (这里的知识点有点重要)</li>
<li>Hooks 不能出现在条件语句或者循环中，也不能出现在 return 之后</li>
<li>Hooks 只能在函数组件或者自定义 Hooks 中使用</li>
</ol>
<p>(当然，React 官方给我们提供了一个 ESLint 的插件，专门用来检查 Hooks 是否正确被使用，它就是 eslint-plugin-react-hooks)</p>
<h4 id="useCallback-缓存回调函数"><a href="#useCallback-缓存回调函数" class="headerlink" title="useCallback: 缓存回调函数"></a>useCallback: 缓存回调函数</h4><p>当没必要的变量(一些函数)更新后导致组件重新渲染，有了 useCallback 就能让没必要的变量不引起组件的渲染</p>
<h4 id="useMemo-缓存计算的结果"><a href="#useMemo-缓存计算的结果" class="headerlink" title="useMemo: 缓存计算的结果"></a>useMemo: 缓存计算的结果</h4><p>可以避免重复的计算，对于性能的提升会有很大的帮助</p>
<h4 id="useRef-在多次渲染之间共享数据"><a href="#useRef-在多次渲染之间共享数据" class="headerlink" title="useRef: 在多次渲染之间共享数据"></a>useRef: 在多次渲染之间共享数据</h4><h4 id="useContext-定义全局状态"><a href="#useContext-定义全局状态" class="headerlink" title="useContext: 定义全局状态"></a>useContext: 定义全局状态</h4><h3 id="如何理解函数生命周期"><a href="#如何理解函数生命周期" class="headerlink" title="如何理解函数生命周期"></a>如何理解函数生命周期</h3><p>忘掉 Class 组件的生命周期…</p>
<p>在函数组件中你要思考的方式永远是：当某个状态发送变化时，我要做什么，而不是像在 Class 组件的某个生命周期方法中我要做什么</p>
<p>在函数组件中，是没有生命周期机制的</p>
]]></content>
  </entry>
  <entry>
    <title>Redux知识</title>
    <url>/2021/12/16/React-Redux/</url>
    <content><![CDATA[<p><a href="https://github.com/reduxjs/redux">redux github</a><br><a href="https://redux.js.org/">redux 官方文档</a><br><a href="https://www.redux.org.cn/">redux 中文文档</a><br>redux 是一个可预测的状态容器(可预测是因为无副作用，相同输入，一定会有相同的输出)</p>
<blockquote>
<p>注意：redux 和 context 二者是竞争关系。二者最好只选一个来使用</p>
</blockquote>
<h4 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h4><p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2021-12-16-%E4%B8%8B%E5%8D%8810.15.34.png" alt="redux"></p>
<p>redux 是统一保存数据的，在隔离了数据与 UI 的同时，负责处理数据的绑定</p>
<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2021-12-16-%E4%B8%8B%E5%8D%8810.18.39.png" alt="redux 数据流动"></p>
<p><code>store</code> 在 <code>redux</code> 中有且只有一个！可以把 <code>store</code> 看成一个带有推送功能的数据仓库</p>
<p><code>reducer</code> 是帮助 <code>store</code> 处理数据的<strong>方法</strong>。它是一个方法，一个过程，一个函数,它做到了为 <code>store</code> 进行初始化数据，和增删改查数据，最终将新的数据返回给 <code>store</code></p>
<p><code>action</code>是数据更新的指令</p>
<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2021-12-16-%E4%B8%8B%E5%8D%8810.24.30.png" alt="redux基本工作流"></p>
<h4 id="Redux-架构"><a href="#Redux-架构" class="headerlink" title="Redux 架构"></a>Redux 架构</h4><p>(这里的内容全部参考的是 <a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=510#/detail/pc?id=4865">修言的 react</a>)<br>Redux 背后的架构思想： Redux 的设计在很大程度上受益于 Flux 架构</p>
<h5 id="Flux-架构中，一个应用被拆分为-4-个部分"><a href="#Flux-架构中，一个应用被拆分为-4-个部分" class="headerlink" title="Flux 架构中，一个应用被拆分为 4 个部分"></a>Flux 架构中，一个应用被拆分为 4 个部分</h5><ul>
<li>View(视图层)：用户界面</li>
<li>Action：视图层发出的“消息”，它会触发应用状态的改变</li>
<li>Dispatcher: 负责对 action 进行分发</li>
<li>Store(数据层)： 它是存储应用状态的“仓库”，此外还会定义修改状态的逻辑。store 的变化最终会映射到 view 层上去</li>
</ul>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><code class="hljs gherkin">Action<br>  |<span class="hljs-string"></span><br><span class="hljs-string">  v</span><br><span class="hljs-string">Dispatcher &lt;--+</span><br><span class="hljs-string">  </span>|<span class="hljs-string">           </span>|<br>  v           |<span class="hljs-string"></span><br><span class="hljs-string">Store         Action</span><br><span class="hljs-string">  </span>|<span class="hljs-string">           </span>|<br>  v           |<span class="hljs-string"></span><br><span class="hljs-string"> View --------+</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure>

<p><strong>Flex 架构最核心的一个特点：</strong>严格的单向数据流</p>
<p><strong>单向数据流 vs 双向数据流</strong></p>
<p>双向数据流最为典型的代表就是前端场景下的 MVC 架构。前端应用/框架往往出于交互的需要，允许 View 和 Model 直接通信，造成混乱<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2021-12-17-%E4%B8%8B%E5%8D%889.39.30.png" alt="双向数据流"><br>双向数据绑定极难维护</p>
<p>在 Redux 的整个工作过程中，数据流是严格单向的。如果你想对数据进行修改，只有一种途径：派发 Action<br>在单向数据流下，状态的变化是<strong>可预测的</strong>。如果 store 中的数据发生了变化，那么有且仅有一个原因，那就是由 Dispatcher 派发 Action 来触发的。这样一来，就从根本上避免了混乱的数据关系，使整个流程变得清晰简单</p>
<p><strong>Redux 主要由 3 部分组成：Store、Reducer、Action</strong></p>
<ul>
<li>Store: 它是一个单一的数据源，而且是只读的(immutable)。</li>
<li>Action</li>
<li>Reducer</li>
</ul>
<p>在整个 Redux 的过程中，数据流是严格单向的。如果你想对数据进行修改，只有一种途径：派发 Action。Action 会被 Reducer 读取，Reducer 将根据 Action 内容的不同执行不同的计算逻辑，最终生成新的 state（状态），这个新的 state 会更新到 Store 对象里，进而驱动视图层面作出对应的改变。</p>
<p><strong>subscribe &amp; dispatch 分别代表了 redux 独有的发布-订阅模式</strong></p>
<h4 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布-订阅"></a>发布-订阅</h4><h4 id="进行代码实战"><a href="#进行代码实战" class="headerlink" title="进行代码实战"></a>进行代码实战</h4><figure class="highlight gherkin"><table><tr><td class="code"><pre><code class="hljs gherkin">src<br> |<span class="hljs-string">-redux</span><br><span class="hljs-string"> </span>|<span class="hljs-string">  </span>|<span class="hljs-string">-store.ts</span><br><span class="hljs-string"> </span>|<span class="hljs-string">  </span>|<span class="hljs-string">-xxxReducer.ts</span><br><span class="hljs-string"> </span>|<span class="hljs-string">-DemoComponent.ts</span><br></code></pre></td></tr></table></figure>

<figure class="highlight pf"><table><tr><td class="code"><pre><code class="hljs pf">/* xxxReducer.ts */<br><br>// 旧的<span class="hljs-keyword">state</span>在新的action的指令下，转变为新的<span class="hljs-keyword">state</span><br>export <span class="hljs-keyword">default</span> (<span class="hljs-keyword">state</span>:store存储的旧的数据, action) =&gt; &#123;<br>  // 注意：redux里面的store里存储的数据是immutable(数据不可更改)，所以不能直接修改<span class="hljs-keyword">state</span>，而是修改<span class="hljs-keyword">state</span>的副本，并返回修改的这个副本<br>  switch(action.type) &#123;<br>    case &#x27;XXX&#x27;: ... return newState<br>    case &#x27;YYY&#x27;: ... return newState<br>    ...<br>    <span class="hljs-keyword">default</span>: return <span class="hljs-keyword">state</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* store.ts */</span><br><span class="hljs-keyword">import</span> &#123;createStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;xxxReducer&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./xxxReducer&#x27;</span>;<br><br><span class="hljs-keyword">const</span> store = createStore(xxxReducer)<br><br></code></pre></td></tr></table></figure>

<figure class="highlight llvm"><table><tr><td class="code"><pre><code class="hljs llvm">/* DemoComponent */<br>数据订阅 <span class="hljs-keyword">store</span>.subscribe<br>数据获取 <span class="hljs-keyword">store</span>.getState()<br>数据推送 action 被 <span class="hljs-keyword">store</span>.dispatch 到 <span class="hljs-keyword">store</span><br><br>action 的标准官方格式:<br>&#123;<span class="hljs-keyword">type</span>: &#x27;字符串(用于简单标记这个action是干什么的)&#x27;<span class="hljs-punctuation">,</span> payload: 用于保存数据&#125;<br><br><span class="hljs-keyword">store</span>.dispatch(action)<br></code></pre></td></tr></table></figure>

<hr>
<p>一般要进行 action 的拆分和统一创建，避免项目代码的混乱，以及方便对于 action 的全局使用和管理</p>
<p>需要 Action Creator(工厂模式)，来进行 action 的管理</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><code class="hljs gherkin">src<br> |<span class="hljs-string">-redux</span><br><span class="hljs-string"> </span>|<span class="hljs-string">  </span>|<span class="hljs-string">-xxx</span><br><span class="hljs-string"> </span>|<span class="hljs-string">     </span>|<span class="hljs-string">-xxxReducer.ts</span><br><span class="hljs-string"> </span>|<span class="hljs-string">     </span>|<span class="hljs-string">-xxxActioins.ts   // 统一管理与xxx有关的action的创建和分发</span><br><span class="hljs-string"> </span>|<span class="hljs-string">  </span>|<span class="hljs-string">-store.ts</span><br><span class="hljs-string"> </span>|<br> |<span class="hljs-string">-DemoComponent.ts</span><br></code></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/* xxxActioins.ts */</span><br><span class="hljs-comment">// 因为字符串是固定的，所以完全可以用常量的方式来写字符串(全大写)，并且这些常量能够从外部访问</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> DEMO1_XXX = <span class="hljs-string">&#x27;demo1_xxx&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> DEMO2_XXX = <span class="hljs-string">&#x27;demo2_xxx&#x27;</span>;<br><br><span class="hljs-comment">// 统一处理action的机制，action creator(工厂模式)</span><br><br><span class="hljs-comment">// 利用ts辅助redux进行action的类型定义，避免书写错误</span><br><br><span class="hljs-keyword">interface</span> Demo1Action &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-keyword">typeof</span> DEMO1_XXX,   <span class="hljs-comment">// 这里typeof写得挺好</span><br>  <span class="hljs-attr">payload</span>: ...<br>&#125;<br><br><span class="hljs-keyword">interface</span> Demo2Action &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-keyword">typeof</span> DEMO2_XXX,   <span class="hljs-comment">// 这里typeof写得挺好</span><br>  <span class="hljs-attr">payload</span>: &#123;<span class="hljs-attr">param1</span>: ..., <span class="hljs-attr">param2</span>: ...&#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> xxxActioinTypes = Demo1Action | Demo2Action<br><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> demo1xxxActionCreator = (param: ...):<span class="hljs-function"><span class="hljs-params">Demo1Action</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">type</span>: DEMO1_XXX,<br>    <span class="hljs-attr">payload</span>: param<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> demo2xxxActionCreator = (param1:..., <span class="hljs-attr">param2</span>:...):<span class="hljs-function"><span class="hljs-params">Demo2Action</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">type</span>: DEMO2_XXX,<br>    <span class="hljs-attr">payload</span>: &#123;param1, param2&#125;<br>  &#125;<br>&#125;<br>...<br></code></pre></td></tr></table></figure>

<figure class="highlight pf"><table><tr><td class="code"><pre><code class="hljs pf">/* xxxReducer.ts */<br>import &#123;DEMO1_XXX, DEMO2_XXX, xxxActioinTypes&#125; <span class="hljs-keyword">from</span> &#x27;./xxxActioins&#x27;<br>// 旧的<span class="hljs-keyword">state</span>在新的action的指令下，转变为新的<span class="hljs-keyword">state</span><br>export <span class="hljs-keyword">default</span> (<span class="hljs-keyword">state</span>:store存储的旧的数据, action:xxxActioinTypes) =&gt; &#123; // 这里直接进行action的类型约束，避免自己手写action发生错误<br>  // 注意：避免在switch...case中直接使用字符串，而应该使用变量，不然，字符串写错了，你不好纠错<br>  switch(action.type) &#123;<br>    case DEMO1_XXX: ... return newState<br>    case DEMO2_XXX: ... return newState<br>    ...<br>    <span class="hljs-keyword">default</span>: return <span class="hljs-keyword">state</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h4><p><a href="https://react-redux.js.org/">react-redux</a><br>react-redux 是牛逼轰轰的插件，让组件对 store 的订阅与推送更加的简洁方便</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><code class="hljs gherkin">src<br>|<span class="hljs-string">-index.tsx</span><br><span class="hljs-string"></span>|<span class="hljs-string">-redux</span><br><span class="hljs-string"></span>|<span class="hljs-string">  </span>|<span class="hljs-string">-xxx</span><br><span class="hljs-string"></span>|<span class="hljs-string">     </span>|<span class="hljs-string">-xxxReducer.ts</span><br><span class="hljs-string"></span>|<span class="hljs-string">     </span>|<span class="hljs-string">-xxxActioins.ts   // 统一管理与xxx有关的action的创建和分发</span><br><span class="hljs-string"></span>|<span class="hljs-string">  </span>|<span class="hljs-string">-store.ts</span><br><span class="hljs-string"></span>|<br>|<span class="hljs-string">-DemoComponent.ts</span><br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* index.tsx */</span><br><br>...<br><span class="hljs-keyword">import</span> &#123; Provider &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;<br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./redux/store&#x27;</span>;<br><br>ReactDOM.render(<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.StrictMode</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">&#123;store&#125;</span>&gt;</span>   // 其实这里和 Context 的使用是异曲同工的</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">React.StrictMode</span>&gt;</span></span><br>)<br></code></pre></td></tr></table></figure>

<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli">/* DemoComponent.ts */<br><span class="hljs-string">...</span><br>import &#123; <span class="hljs-keyword">connect</span> &#125; from &#x27;react-redux&#x27;;   <span class="hljs-string">//</span> <span class="hljs-keyword">connect</span> 让store 和 UI组件连接起来了<br><br><span class="hljs-string">...</span>  <span class="hljs-string">//</span> 注意，这种<span class="hljs-keyword">connect</span>的方法，个人感觉已经有些过时了<span class="hljs-string">...</span>后面讲解redux的hooks，以及redux-toolkit的时候，会推翻这个的<span class="hljs-string">...</span><br></code></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/* store.ts */</span><br><span class="hljs-keyword">import</span> &#123;createStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;xxxReducer&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./xxxReducer&#x27;</span>;<br><br><span class="hljs-keyword">const</span> store = createStore(xxxReducer)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> RootState = ReturnType&lt;<span class="hljs-keyword">typeof</span> store.getState&gt;  <span class="hljs-comment">// 获取store中的state的数据类型</span><br></code></pre></td></tr></table></figure>

<hr>
<p>在 hooks 中使用 react-redux</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><code class="hljs pf">/* DemoComponent.ts */<br>...<br>import &#123; useSelector, useDispatch &#125; <span class="hljs-keyword">from</span> &#x27;react-redux&#x27;;  // useSelector帮助我们连接store里的数据, useDispatch帮助我们从组件中发送action到store里<br>import &#123; RootState &#125; <span class="hljs-keyword">from</span> &#x27;./redux/store&#x27;;<br><br>export <span class="hljs-keyword">const</span> DemoComponent() &#123;<br>  <span class="hljs-keyword">const</span> xxx = useSelector((<span class="hljs-keyword">state</span>:RootState) =&gt; <span class="hljs-keyword">state</span>.xxx)  // 选择store中的<span class="hljs-keyword">state</span>里面的数据<br>  <span class="hljs-keyword">const</span> dispatch = useDispatch();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>combineReducers</strong><br>有多个 reducer 的时候，需要把这些结合起来一起放进 store 里面</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/* store.ts */</span><br><span class="hljs-keyword">import</span> &#123;createStore, combineReducers&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;xxxReducer&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./xxxReducer&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;yyyReducer&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./yyyReducer&#x27;</span>;<br><br><span class="hljs-keyword">const</span> rootReducer = combineReducers(&#123;<br>  <span class="hljs-attr">xxx</span>: xxxReducer,<br>  <span class="hljs-attr">yyy</span>: yyyReducer<br>&#125;)<br><span class="hljs-keyword">const</span> store = createStore(rootReducer)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> RootState = ReturnType&lt;<span class="hljs-keyword">typeof</span> store.getState&gt;  <span class="hljs-comment">// 获取store中的state的数据类型</span><br></code></pre></td></tr></table></figure>

<h4 id="Redux-中间件"><a href="#Redux-中间件" class="headerlink" title="Redux 中间件"></a>Redux 中间件</h4><p>将一些 api 请求转义到 redux store 中执行(一些数据是需要全局共享的)</p>
<p>但是在 store 中，reducer 是纯函数(无副作用)，无法进行 api 的调用操作。而 action 存放的是一个对象(数据)，而不是一个过程(无法进行 api 请求这个过程)</p>
<p>因此需要中间件来解决这种 api 请求的异步问题</p>
<h5 id="redux-thunk"><a href="#redux-thunk" class="headerlink" title="redux-thunk"></a>redux-thunk</h5><p>对于异步的处理，redux 给出了一个官方的中间件： redux-thunk (它让 dispatch 的参数多支持了一种类型：函数类型)<br>redux-thunk 允许我们以函数的形式派发一个 action<br><code>redux-thunk</code> 安装方法：<code>npm i redux-thunk</code></p>
<p>注意：thunk 可以返回一个函数，而不一定是 JS 对象；在一个 thunk action 中可以完成一系列连续的 action 操作；并且可以处理异步逻辑</p>
<ul>
<li>中间件的执行时机，即 action 被分发(dispatch)之后、reducer 触发之前；</li>
<li>中间件的执行前提，即 applyMiddleware 将会对 dispatch 函数进行改写，使得 dispatch 在触发 reducer 之前，会首先执行对 Redux 中间件的链式调用。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/* store.ts */</span><br><span class="hljs-keyword">import</span> &#123;createStore, combineReducers, applyMiddleware&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<br><span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-thunk&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;xxxReducer&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./xxxReducer&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;yyyReducer&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./yyyReducer&#x27;</span>;<br><br><span class="hljs-keyword">const</span> rootReducer = combineReducers(&#123;<br>  <span class="hljs-attr">xxx</span>: xxxReducer,<br>  <span class="hljs-attr">yyy</span>: yyyReducer<br>&#125;)<br><span class="hljs-keyword">const</span> store = createStore(rootReducer, applyMiddleware(thunk))<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> RootState = ReturnType&lt;<span class="hljs-keyword">typeof</span> store.getState&gt;  <span class="hljs-comment">// 获取store中的state的数据类型</span><br></code></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/* xxxActioins.ts */</span><br><span class="hljs-comment">// 导入 Thunk 中间件</span><br><span class="hljs-keyword">import</span> &#123; ThunkAction &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-thunk&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; RootState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../store&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> DEMO1_XXX = <span class="hljs-string">&#x27;demo1_xxx&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> DEMO2_XXX = <span class="hljs-string">&#x27;demo2_xxx&#x27;</span>;<br><br><span class="hljs-comment">// 统一处理action的机制，action creator(工厂模式)</span><br><br><span class="hljs-keyword">interface</span> Demo1Action &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-keyword">typeof</span> DEMO1_XXX,   <span class="hljs-comment">// 这里typeof写得挺好</span><br>  <span class="hljs-attr">payload</span>: ...<br>&#125;<br><br><span class="hljs-keyword">interface</span> Demo2Action &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-keyword">typeof</span> DEMO2_XXX,   <span class="hljs-comment">// 这里typeof写得挺好</span><br>  <span class="hljs-attr">payload</span>: &#123;<span class="hljs-attr">param1</span>: ..., <span class="hljs-attr">param2</span>: ...&#125;<br>&#125;<br><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> xxxActioinTypes = Demo1Action | Demo2Action<br><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> demo1xxxActionCreator = (param: ...):<span class="hljs-function"><span class="hljs-params">Demo1Action</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">type</span>: DEMO1_XXX,<br>    <span class="hljs-attr">payload</span>: param<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> demo2xxxActionCreator = (param1:..., <span class="hljs-attr">param2</span>:...):<span class="hljs-function"><span class="hljs-params">Demo2Action</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">type</span>: DEMO2_XXX,<br>    <span class="hljs-attr">payload</span>: &#123;param1, param2&#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 中间件给 dispatch 多支持了一种类型，即函数类型</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> demo3yyyActionCreator = ():ThunkAction&lt;<span class="hljs-built_in">void</span>, RootState, unknown, xxxActioinTypes&gt; =&gt; <span class="hljs-keyword">async</span> (dispatch, getState) =&gt; &#123;<br>  dispatch(...)<br>  <span class="hljs-keyword">try</span> &#123;<br>    ...  异步数据获取(fetch、axios)<br>    dispatch(...);<br>  &#125; <span class="hljs-keyword">catch</span>(error) &#123;<br>    dispatch(...);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="中间件原理"><a href="#中间件原理" class="headerlink" title="中间件原理"></a>中间件原理</h4><p><strong>函数式编程的几个概念</strong></p>
<ul>
<li>复合函数</li>
<li>柯里化</li>
</ul>
<p>中间件原理：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">const applyMiddleware = <span class="hljs-keyword">function</span>(middleware) &#123;<br>  let <span class="hljs-keyword">next</span> = store.dispatch;<br>  <span class="hljs-regexp">//</span> 柯里化<br>  store.dispatch = middleware(store)(<span class="hljs-keyword">next</span>)<br>&#125;<br><br>applyMiddleware(dispatchAndLog)<br></code></pre></td></tr></table></figure>

<blockquote>
<p>Redux 中间件公式： const middleware = (store) =&gt; (next) =&gt; (action) =&gt; {}</p>
</blockquote>
<h4 id="redux-toolkit"><a href="#redux-toolkit" class="headerlink" title="redux-toolkit"></a>redux-toolkit</h4><p>在使用 redux 中，会出现各种各样的模板代码<br>例如 action 都有配套的常量字符串类型</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/* xxxActioins.ts */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> DEMO1_XXX = <span class="hljs-string">&#x27;demo1_xxx&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> DEMO2_XXX = <span class="hljs-string">&#x27;demo2_xxx&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>然后，每个 action 都还有对应的 action creator。以及对应的 reducer 来解决 action 指令</p>
<p>而 redux-toolkit 来解决 redux 的模板代码</p>
<p>并且 redux 也在大力推广 redux-toolkit</p>
<p><strong>redux-toolkit 的文件依赖</strong></p>
<ul>
<li>immer // 运行将 immutable 的数据转化为 mutable 数据</li>
<li>redux</li>
<li>redux-thunk // redux-thunky 在 redux-toolkit 中是默认开启的</li>
</ul>
<p>在 redux-toolkit 中，我们最需要注意的模块即： <code>configureStore</code>、<code>createSlice</code><br>在绝大多数的情况下，会用 <code>createSlice</code> 来代替 <code>createReducer</code>、<code>createAction</code>（后者其实在 createSlice 内部已经实现了）</p>
<p>在 <code>createSlice</code> 中的第三个参数：<code>reducers</code> 有以下几个特点：</p>
<ul>
<li>这里的 reducer 其实是把 action 和 reducer 捆绑在一起了(所以，不再需要单独定义 action 了即不再单独创建 action creator)</li>
<li>这里的 reducer 是一个对象，而非一个过程</li>
<li>不用再写 switch 语句了</li>
</ul>
<figure class="highlight pf"><table><tr><td class="code"><pre><code class="hljs pf">import &#123; createSlice &#125; <span class="hljs-keyword">from</span> &#x27;@reduxjs/toolkit&#x27;<br><br><span class="hljs-keyword">const</span> counterSlice = createSlice(&#123;<br>  name: &#x27;counter&#x27;,<br>  initialState: <span class="hljs-number">0</span>,<br>  reducers: &#123;<br>    increment(<span class="hljs-keyword">state</span>) &#123;  // 这里的<span class="hljs-keyword">state</span>是store里自动传过来的<br>      <span class="hljs-keyword">state</span>.value++<br>    &#125;,<br>    incrementByAmount:(<span class="hljs-keyword">state</span>, action) =&gt; &#123;  // 这里的action是，后面调用这个方法时传的参数：dispatch(counterSlice.actions.incrementByAmount(data))  data ==== action<br>      <span class="hljs-keyword">state</span>.value += action.payload<br>    &#125;,<br>  &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>具体操作可以看看文档：<a href="https://redux-toolkit.js.org/api/createSlice">redux-toolkit</a></p>
<h5 id="在-redux-toolkit-中使用-redux-thunk-来处理异步逻辑"><a href="#在-redux-toolkit-中使用-redux-thunk-来处理异步逻辑" class="headerlink" title="在 redux-toolkit 中使用 redux-thunk 来处理异步逻辑"></a>在 redux-toolkit 中使用 redux-thunk 来处理异步逻辑</h5><p>使用 <code>createAsyncThunk</code><br>注意：redux-toolkit 是自带 redux-thunk 的，且默认情况是开启的状态，所以不需要额外再下载 redux-thunk</p>
]]></content>
  </entry>
  <entry>
    <title>React-Query</title>
    <url>/2021/12/18/React-Query/</url>
    <content><![CDATA[<p><a href="https://github.com/tannerlinsley/react-query">react-query 文档</a><br><a href="https://github.com/Bruce-shuai/react-query-demo">react-query 小 demo</a><br><a href="https://github.com/Bruce-shuai/react-query-advance">react-query advance</a> —&gt; 这里有几乎所有常用的 react-query 操作</p>
<p>能够缓存接口获取的数据，提高用户体验(react-query 会在后端审核，该接口返回的数据是否更新了，没有更新的话仍使用缓存的数据，所以第二次使用该接口则极大的提高了用户的体验),你可以在 chrome 控制台设置网络速度为 Slow 3G 来试试</p>
<h4 id="利用-react-query-实现乐观更新-optimistic-updates-—-gt-装逼的时候说，因为别人可能都不知道这个词"><a href="#利用-react-query-实现乐观更新-optimistic-updates-—-gt-装逼的时候说，因为别人可能都不知道这个词" class="headerlink" title="利用 react-query 实现乐观更新 (optimistic updates) —&gt; 装逼的时候说，因为别人可能都不知道这个词~"></a>利用 react-query 实现乐观更新 (optimistic updates) —&gt; 装逼的时候说，因为别人可能都不知道这个词~</h4><p>在服务器返回之前就装作这个数据已经成功了~</p>
<p>优势： 使用了 react-Query, 就不再需要使用 useEffect + useState 来解决异步获取数据的问题了…</p>
]]></content>
  </entry>
  <entry>
    <title>React 知识总结</title>
    <url>/2021/12/02/React-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="public-文件夹"><a href="#public-文件夹" class="headerlink" title="public 文件夹"></a>public 文件夹</h4><p>我常常会使用 <code>npx create-react-app &#39;文件名&#39;</code> 来创建一个 <code>react</code> 项目。 这个脚手架工具帮助我们生成的基本项目中 会有 <code>public</code> 文件夹。这个文件夹是什么有什么用？</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">public<br>  <span class="hljs-string">|-favicon.ico</span><br>  <span class="hljs-string">|-index.html</span><br>  <span class="hljs-string">|-logoxx.png</span><br>  <span class="hljs-string">|-...</span><br>  <span class="hljs-string">|-mainifest.json</span><br>  <span class="hljs-string">| robots.txt</span><br></code></pre></td></tr></table></figure>

<p>事实上，public 文件夹是不参与打包的，它里面包含了真正的静态文件。 但是 react 项目的 src 文件夹里的所有文件最终会被打包工具例如：<code>webpack</code> 打包成一个 <code>bundle.js</code></p>
<p><code>public</code>文件夹里的<strong>图片、资源、字体等等内容</strong> 都是为 <code>public</code> 里面的<code>index.html</code>文件服务的<br><code>mainifest.json</code>是用来配置 <code>pwa</code> 的<br><code>robots.txt</code> 是想告诉搜索引擎如何来对待我们的项目(哪些内容可以访问，哪些内容不可以访问)</p>
<h4 id="现在的-react-项目不再需要手动引入-React-了"><a href="#现在的-react-项目不再需要手动引入-React-了" class="headerlink" title="现在的 react 项目不再需要手动引入 React 了"></a>现在的 react 项目不再需要手动引入 React 了</h4><p>现在不需要手动引入 <code>React</code> 了即：<code>import React, &#123;...&#125; from &#39;react&#39;</code> –&gt; <code>import &#123;...&#125; from &#39;react&#39;</code> 不过前提是当前这个文件里没有用到 React 对象的一系列内容才行…</p>
<p>我们的 jsx/tsx 文件是用的 babel 插件：<code>@babel/plugin-transform-react-jsx</code> 来转化成 js 代码的<br>新版本的<code>@babel/plugin-transform-react-jsx</code>新增了一些操作，让我们不必手动引入 <code>React </code>了</p>
<h4 id="env-和-env-development-环境变量文件的使用"><a href="#env-和-env-development-环境变量文件的使用" class="headerlink" title=".env 和 .env.development 环境变量文件的使用"></a>.env 和 .env.development 环境变量文件的使用</h4><p><code>process</code> 是 <code>Node.js</code> 中的 一个<strong>全局变量</strong><br><code>process.env</code> 能够拿到当前项目运行环境的信息(开发环境 和 上线环境)</p>
<p>我能想到的一个使用场景： 在开发和运行环境下不用自己手动更改 api。api 会根据当前环境自动更改内容</p>
<p>一般这两个文件是放在 <code>src</code> 根目录下：</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli">src<br> |-<span class="hljs-string">...</span><br> |-<span class="hljs-string">.env</span>             <span class="hljs-string">//</span> 上线环境<br> |-<span class="hljs-string">.env.development</span> <span class="hljs-string">//</span> 开发环境<br><br></code></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* .env */</span><br>REACT_APP_API_URL=http:<span class="hljs-regexp">//</span>online:<span class="hljs-number">3001</span>      <span class="hljs-regexp">//</span> REACT_APP_API_URL 变量名，自己任意取的  上线时的api：http:<span class="hljs-regexp">//</span>online:<span class="hljs-number">3001</span><br></code></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* .env.development */</span><br>REACT_APP_API_URL=http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">3001</span>   <span class="hljs-regexp">//</span> REACT_APP_API_URL 变量名，这和.env的要一样<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* 某个src文件夹下的一个react 组件文件 */</span><br><span class="hljs-keyword">import</span> ...<br><br><span class="hljs-keyword">const</span> apiUrl = process.env.REACT_APP_API_URL;  <span class="hljs-comment">// 获取值(根据当前的运行环境(上线和开发)，值是不一样的)</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-function"><span class="hljs-title">SomeComponent</span>(<span class="hljs-params"></span>)</span> &#123;<br><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    fetch(<span class="hljs-string">`<span class="hljs-subst">$&#123;apiUrl&#125;</span>`</span>)....<br>  &#125;, [...])<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="为什么在使用-map-函数的时候，列表值要写-key，且为何用-index-作为-key-是不好的？"><a href="#为什么在使用-map-函数的时候，列表值要写-key，且为何用-index-作为-key-是不好的？" class="headerlink" title="为什么在使用 map 函数的时候，列表值要写 key，且为何用 index 作为 key 是不好的？"></a>为什么在使用 map 函数的时候，列表值要写 key，且为何用 index 作为 key 是不好的？</h4><p><a href="https://coding.imooc.com/lesson/482.html#mid=41840">https://coding.imooc.com/lesson/482.html#mid=41840</a></p>
<h4 id="在-React-中一招特别的渲染-svg-图片的方法-能够轻易控制-svg-图片的样式"><a href="#在-React-中一招特别的渲染-svg-图片的方法-能够轻易控制-svg-图片的样式" class="headerlink" title="在 React 中一招特别的渲染 svg 图片的方法(能够轻易控制 svg 图片的样式)"></a>在 React 中一招特别的渲染 svg 图片的方法(能够轻易控制 svg 图片的样式)</h4><p><strong>普通的方法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> logo <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./xxx.svg&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  ...<br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;logo&#125;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;logo&quot;</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App-logo&quot;</span>/&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>更优秀的方法(能够以 svg 的形式渲染)</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;ReactComponent <span class="hljs-keyword">as</span> Logo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./xxx.svg&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  ...<br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Logo</span> <span class="hljs-attr">width</span>=<span class="hljs-string">...</span> <span class="hljs-attr">color</span>=<span class="hljs-string">...</span> /&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="注意，react-hooks-也是会受到闭包的影响的。毕竟这始终逃不出-react-本质是-js"><a href="#注意，react-hooks-也是会受到闭包的影响的。毕竟这始终逃不出-react-本质是-js" class="headerlink" title="注意，react hooks 也是会受到闭包的影响的。毕竟这始终逃不出 react 本质是 js"></a>注意，react hooks 也是会受到闭包的影响的。毕竟这始终逃不出 react 本质是 js</h4><p>特别是 useEffect 依赖项为 []的时候</p>
<figure class="highlight nim"><table><tr><td class="code"><pre><code class="hljs nim">useEffect(() =&gt; &#123;<br>  <span class="hljs-keyword">return</span> () =&gt; <span class="hljs-meta">&#123;...&#125;</span><br>&#125;, [])<br></code></pre></td></tr></table></figure>

<h4 id="让-react-项目实现-url-的状态管理-让-url-能实时表示我们当前所看的内容"><a href="#让-react-项目实现-url-的状态管理-让-url-能实时表示我们当前所看的内容" class="headerlink" title="让 react 项目实现 url 的状态管理(让 url 能实时表示我们当前所看的内容)"></a>让 react 项目实现 url 的状态管理(让 url 能实时表示我们当前所看的内容)</h4><p>单页面开发应用的特点就是当我们在切换路由的时候，并不会重新加载文档，无论我们怎么切换路由，它们都永远是在同一个文档里的，切换路径的时候页面也不会进行刷新。所有的切换都是通过 js 来实现的(使用 vue 或 react 开发的应用大多都是单页面应用)</p>
<p>对于单页面应用。<strong>url 的状态管理</strong>很多人都会去忽略…(非单页面应用，你点击任何内容，对应的 url 是会有对应参数的改变的，刷新页面，读取参数…) 自定义钩子 <code>useUrlQueryParam</code> 管理 URL 参数状态</p>
<h4 id="组件的状态提升是让多组件共用某些属性的比较优秀的方法"><a href="#组件的状态提升是让多组件共用某些属性的比较优秀的方法" class="headerlink" title="组件的状态提升是让多组件共用某些属性的比较优秀的方法"></a>组件的状态提升是让多组件共用某些属性的比较优秀的方法</h4><p>但是要注意一个问题，尽管状态提升是一种比较好的传递 props 的方法。但是当项目一复杂，嵌套组件的 props 传递难免繁琐，且不易维护(props drilling 现象)。定义 props 和使用 props 就离得太远啦！耦合性就太强了。爷爷辈的某 props 如果一旦修改，使用了该 props 的子子孙孙也要跟着改这个属性。</p>
<h4 id="状态提升的进阶版-组合组件"><a href="#状态提升的进阶版-组合组件" class="headerlink" title="状态提升的进阶版 组合组件"></a>状态提升的进阶版 组合组件</h4><p>即传递的 props，是传递的小组件，而非某一个属性。这样能够解耦 爷爷修改组件。子子孙孙跟着直接享福！而不用跟着再修改什么</p>
<blockquote>
<p>React 官方：如果你只是想避免层层传递一些属性，组件组合(component composition) 有时候是一个比 context 更好的解决方案</p>
</blockquote>
<h4 id="JSX-Element-ReactElement-ReactNode-三者的区别"><a href="#JSX-Element-ReactElement-ReactNode-三者的区别" class="headerlink" title="JSX.Element ReactElement ReactNode 三者的区别"></a>JSX.Element ReactElement ReactNode 三者的区别</h4><p><a href="https://stackoverflow.com/questions/58123398/when-to-use-jsx-element-vs-reactnode-vs-reactelement#:~:text=Element%20is%20ReactElement%20%2C%20whose%20props,render()%20in%20class%20components">stack overflow</a></p>
<h4 id="如果我们要在自定义的-hook-里返回一个函数的话，在-hook-上包装一个-useCallback"><a href="#如果我们要在自定义的-hook-里返回一个函数的话，在-hook-上包装一个-useCallback" class="headerlink" title="如果我们要在自定义的 hook 里返回一个函数的话，在 hook 上包装一个 useCallback"></a>如果我们要在自定义的 hook 里返回一个函数的话，在 hook 上包装一个 useCallback</h4><h4 id="注意，如果在-hook-中有好几个状态-useState-的数量很多-，而且这些状态是相互影响的，可以把状态合并"><a href="#注意，如果在-hook-中有好几个状态-useState-的数量很多-，而且这些状态是相互影响的，可以把状态合并" class="headerlink" title="注意，如果在 hook 中有好几个状态(useState 的数量很多)，而且这些状态是相互影响的，可以把状态合并"></a>注意，如果在 hook 中有好几个状态(useState 的数量很多)，而且这些状态是相互影响的，可以把状态合并</h4><figure class="highlight pf"><table><tr><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> Demo = () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> [age, <span class="hljs-built_in">set</span>Age] = useState(&#x27;<span class="hljs-number">20</span>&#x27;);<br>  <span class="hljs-keyword">const</span> [name, <span class="hljs-built_in">set</span>Name] = useState(&#x27;Bruce&#x27;);<br>  <span class="hljs-keyword">const</span> [sex, <span class="hljs-built_in">set</span>Sex = useState(&#x27;male&#x27;)];<br><br>  // -----------上述状态可以合并为如下状态----------<br><br>  <span class="hljs-keyword">const</span> [<span class="hljs-keyword">state</span>, <span class="hljs-built_in">set</span>State] = useState(&#123;<br>    age, name, sex<br>  &#125;)<br>  return ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>(所以说，对比于class组件而言，hooks的state的创建是分散的，但是要注意别分太散)</p>
<h4 id="useState-适合于定义单独的状态，useReducer-适合于定义一起相互影响的状态"><a href="#useState-适合于定义单独的状态，useReducer-适合于定义一起相互影响的状态" class="headerlink" title="useState 适合于定义单独的状态，useReducer 适合于定义一起相互影响的状态"></a>useState 适合于定义单独的状态，useReducer 适合于定义一起相互影响的状态</h4>]]></content>
      <categories>
        <category>React篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>SOLID Design Principles</title>
    <url>/2021/11/04/SOLID-Design-Principles/</url>
    <content><![CDATA[<h3 id="Single-Responsibility-Principle-唯一的-负责-原则"><a href="#Single-Responsibility-Principle-唯一的-负责-原则" class="headerlink" title="Single Responsibility Principle (唯一的 负责 原则)"></a>Single Responsibility Principle (唯一的 负责 原则)</h3><p>一个函数或一个类只能有一个原因去进行自身代码更改…<br>在 js 中用多函数(每个函数只能有一个功能)以及<code>ES Module</code>模块化来实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CalorieTracker</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">maxCalories</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.maxCalories = maxCalories;<br>    <span class="hljs-built_in">this</span>.currentCalories = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">trackCalories</span>(<span class="hljs-params">calorieCount</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.currentCalories += calorieCount;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.currentCalories &gt; <span class="hljs-built_in">this</span>.maxCalories) &#123;<br>      <span class="hljs-built_in">this</span>.logCalorieSurplus()<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">logCalorieSurplus</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Max calories exceeded&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述这个类看似非常正常完美…但事实上是有局限性的…<br>我们可以看见…这个类有两个方法：<code>trackCalories</code>、<code>logCalorieSurplus</code>。 我可以在这个类修改这两个函数…需求来了我有可能会在这个类中修改<code>trackCalories</code>函数或者修改<code>logCalorieSurplus</code>函数。但是当一个类有非常多这样的类。那么需求一来我就去修改这些…只会让代码变得非常臃肿且不好维护。更严重的是代码<strong>复用性</strong>太差</p>
<p><code>Single Responsibility Principle</code> 的原则是一个函数或一个类只能有一个原因去解析自身代码修改</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><code class="hljs coq">之前的文件夹：<br>   |<span class="hljs-type">- CalorieTracker</span>.js<br><br>利用ES <span class="hljs-keyword">Module</span>的特性<br><br>升级后的文件夹：<br>   |<span class="hljs-type">- CalorieTracker</span>.js<br>   |<span class="hljs-type">- logger</span>.js<br></code></pre></td></tr></table></figure>

<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">/* logger.js */</span><br><span class="hljs-function"><span class="hljs-title">logCalorieSurplus</span><span class="hljs-params">(info)</span></span> &#123;<br>  console<span class="hljs-selector-class">.log</span>(info)<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/* CalorieTracker.js */</span><br><span class="hljs-keyword">import</span> logCalorieSurplus from <span class="hljs-string">&#x27;./logger.js&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CalorieTracker</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span>(maxCalories) &#123;<br>    <span class="hljs-keyword">this</span>.maxCalories = maxCalories;<br>    <span class="hljs-keyword">this</span>.currentCalories = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  trackCalories(calorieCount) &#123;<br>    <span class="hljs-keyword">this</span>.currentCalories += calorieCount;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.currentCalories &gt; <span class="hljs-keyword">this</span>.maxCalories) &#123;<br>      logCalorieSurplus(<span class="hljs-string">&#x27;Max calories exceeded&#x27;</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在 <code>logCalorieSurplus</code> 已经模块化…可以在任何文件中去使用…复用性大大提高</p>
<p>而且现在的<code>CalorieTracker</code>只需管理<code>trackCalories</code>这一个函数… <code>logCalorieSurplus</code>函数也只会因自身想改变而改变… 都遵循了<strong>Single Responsibility Principle (唯一的 负责 原则)</strong></p>
<h3 id="Open-Closed-Principle"><a href="#Open-Closed-Principle" class="headerlink" title="Open/Closed Principle"></a>Open/Closed Principle</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> printQuiz(questions) &#123;<br>  questions.<span class="hljs-keyword">forEach</span>(question =&gt; &#123;<br>    console.log(question.<span class="hljs-keyword">type</span>);<br>    switch (question.<span class="hljs-keyword">type</span>) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;boolean&#x27;</span>:<br>        console.log(<span class="hljs-string">&#x27;1. True&#x27;</span>);<br>        console.log(<span class="hljs-string">&#x27;2. False&#x27;</span>);<br>        break;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;multipleChoice&#x27;</span>:<br>        question.<span class="hljs-keyword">options</span>.<span class="hljs-keyword">forEach</span>((<span class="hljs-keyword">option</span>, <span class="hljs-keyword">index</span>) =&gt; &#123;<br>          console.log(`$&#123;<span class="hljs-keyword">index</span> + <span class="hljs-number">1</span>&#125;. $&#123;<span class="hljs-keyword">option</span>&#125;`);<br>        &#125;)<br>        break;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;text&#x27;</span>:<br>        console.log(<span class="hljs-string">&#x27;Answer:____________________&#x27;</span>);<br>        break;<br>    &#125;<br>    console.log(<span class="hljs-string">&#x27;+++++++++&#x27;</span>);<br>  &#125;)<br>&#125;<br><br>const questions = [<br>  &#123;<br>    <span class="hljs-keyword">type</span>: <span class="hljs-string">&#x27;boolean&#x27;</span>,<br>    description: <span class="hljs-string">&#x27;This video is useful.&#x27;</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-keyword">type</span>: <span class="hljs-string">&#x27;multipleChoice&#x27;</span>,<br>    description: <span class="hljs-string">&#x27;What is your favorite language?&#x27;</span>,<br>    <span class="hljs-keyword">options</span>: [<span class="hljs-string">&#x27;CSS&#x27;</span>, <span class="hljs-string">&#x27;HTML&#x27;</span>, <span class="hljs-string">&#x27;JS&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>]<br>  &#125;,<br>  &#123;<br>    <span class="hljs-keyword">type</span>: <span class="hljs-string">&#x27;text&#x27;</span>,<br>    description: <span class="hljs-string">&#x27;Describe your favorite JS feature.&#x27;</span><br>  &#125;<br>]<br><br>printQuiz(questions);<br></code></pre></td></tr></table></figure>

<p>上述代码看着非常正常…但是还是思考下…如果当<code>questions</code>的数组元素增加，则既要更改<code>questions</code>的内容，又要更改<code>printQuiz</code>。 灵活性相当的差劲…</p>
<p>开始升级…</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ------------- 问题 ---------------</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BooleanQuestion</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">description</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.description = description;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">printQuestionChoices</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1. True&#x27;</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2. False&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultipleChoiceQuestion</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">description, options</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.description = description<br>    <span class="hljs-built_in">this</span>.options = options<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">printQuestionChoices</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.options.forEach(<span class="hljs-function">(<span class="hljs-params">option, index</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;index + <span class="hljs-number">1</span>&#125;</span>. <span class="hljs-subst">$&#123;option&#125;</span>`</span>);<br>    &#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestQuestion</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">description</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.description = description;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">printQuestionChoices</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Answer:____________________&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printQuiz</span>(<span class="hljs-params">questions</span>) </span>&#123;<br>  questions.forEach(<span class="hljs-function"><span class="hljs-params">question</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(question.description);<br>    question.printQuestionChoices()<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;&#x27;</span>);<br>  &#125;)<br>&#125;<br><br><span class="hljs-keyword">const</span> questions = [<br>  <span class="hljs-keyword">new</span> BooleanQuestion(<span class="hljs-string">&#x27;This video is useful.&#x27;</span>),<br>  <span class="hljs-keyword">new</span> MultipleChoiceQuestion(<br>    <span class="hljs-string">&#x27;What is your favorite language?&#x27;</span>,<br>    [<span class="hljs-string">&#x27;CSS&#x27;</span>, <span class="hljs-string">&#x27;HTML&#x27;</span>, <span class="hljs-string">&#x27;JS&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>]<br>  ),<br>  <span class="hljs-keyword">new</span> TestQuestion(<span class="hljs-string">&#x27;Describe your favorite JS feature.&#x27;</span>)<br>]<br>printQuiz(questions);<br></code></pre></td></tr></table></figure>

<p>现在，我对<code>question</code>的<strong>增删改查</strong>变得易如反掌…<br>将长长的 <strong>switch…case</strong> 打断…</p>
<blockquote>
<p>当前感觉 Open/Closed Principle 就是用来解决 长长的’switch…case 的…’</p>
</blockquote>
<h3 id="Liskov-Substitution-Principle"><a href="#Liskov-Substitution-Principle" class="headerlink" title="Liskov Substitution Principle"></a>Liskov Substitution Principle</h3><p>—&gt; 这个原则似乎更加的偏向面向对象…</p>
]]></content>
      <categories>
        <category>Clean Code篇</category>
      </categories>
      <tags>
        <tag>优质代码</tag>
      </tags>
  </entry>
  <entry>
    <title>React-随笔一</title>
    <url>/2021/10/18/React-%E9%9A%8F%E7%AC%94%E4%B8%80/</url>
    <content><![CDATA[<h4 id="推荐一个-vscode-的插件-针对-react-的-贼好用…"><a href="#推荐一个-vscode-的插件-针对-react-的-贼好用…" class="headerlink" title="推荐一个 vscode 的插件 针对 react 的(贼好用…)"></a>推荐一个 vscode 的插件 针对 react 的(贼好用…)</h4><p>ES7 React/Redux/GraphQL/React-Native snippets</p>
<p><code>rfc</code><br><code>rafc</code></p>
<h4 id="问题一：错误边界"><a href="#问题一：错误边界" class="headerlink" title="问题一：错误边界"></a>问题一：错误边界</h4><p>在<code>react</code>的渲染过程中如果出现了异常。那么整个组件树都会被卸载掉…(在开发环境下能够看见报错的原因…但是真正上线后。用户只能看见白茫茫的一片。其余什么也看不见…)<br><a href="https://reactjs.org/docs/error-boundaries.html">错误边界问题</a><br>注意，错误边界的实现是一定要使用<code>class component</code>来实现的。这也是<code>class 组件</code>和<code>函数组件</code>的区别。<br><a href="https://codesandbox.io/s/gong-ju-lei-oef90?file=/src/utils/error-bundary.tsx">我在 codesandbox 里写的一个 error-bundary 库</a></p>
<p>—&gt; 在思考这题的时候有两个小问题<br>—&gt; <a href="https://stackoverflow.com/questions/58123398/when-to-use-jsx-element-vs-reactnode-vs-reactelement">ReactNode 和 ReactElement 的区别</a><br>—&gt; <a href="https://www.newline.co/@bespoyasov/how-to-define-props-with-children-in-react-typescript-app--56bd18be">PropsWithChildren 的用法</a> 其实就是 <code>react官方</code> 自己定义的一个<code>type utility</code>。类似<code>omit</code>这类<code>type utility</code></p>
<p>注意：这个错误边界组件要包裹所有的项目组件</p>
<h4 id="问题二：自定义-hook，动态改变文档标题-即浏览器最上面的-title-以及闭包在-react-hook-中常见的坑…"><a href="#问题二：自定义-hook，动态改变文档标题-即浏览器最上面的-title-以及闭包在-react-hook-中常见的坑…" class="headerlink" title="问题二：自定义 hook，动态改变文档标题(即浏览器最上面的 title)(以及闭包在 react hook 中常见的坑…)"></a>问题二：自定义 hook，动态改变文档标题(即浏览器最上面的 title)(以及闭包在 react hook 中常见的坑…)</h4><ol>
<li>自定义 hook，动态改变文档标题 有两套方案：<ol>
<li>使用第三方库 <a href="https://github.com/nfl/react-helmet">react-helmet</a></li>
<li>自己写一个 hook</li>
</ol>
</li>
</ol>
<h4 id="问题三：-无限渲染问题-针对-useEffect…"><a href="#问题三：-无限渲染问题-针对-useEffect…" class="headerlink" title="问题三： 无限渲染问题(针对 useEffect…)"></a>问题三： 无限渲染问题(针对 useEffect…)</h4><p><a href="https://github.com/welldone-software/why-did-you-render">一个查找无限渲染原因的库-why-did-you-render</a></p>
<p>下面是自己写的一个无限死循环组件</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> React, &#123; useEffect, useState &#125; from <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> InfiniteLoop = () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> obj = &#123; name: <span class="hljs-string">&quot;bruce&quot;</span> &#125;; <span class="hljs-comment">// 按引用赋值</span><br>  <span class="hljs-keyword">const</span> [<span class="hljs-built_in">num</span>, setNum] = useState(<span class="hljs-number">0</span>);<br><br>  useEffect(() =&gt; &#123;<br>    console.log(<span class="hljs-string">&quot;effect&quot;</span>);<br>    <span class="hljs-comment">// num + 1 造成页面的重新渲染...</span><br>    <span class="hljs-comment">// 重新渲染后又会num + 1 又是重新渲染...</span><br>    <span class="hljs-comment">// 无限死循环...</span><br>    setNum(<span class="hljs-built_in">num</span> + <span class="hljs-number">1</span>);<br>  &#125;, [obj]);  <span class="hljs-comment">// 如果这里的依赖项是一个不变且不是引用类型的值，就不会触发useEffect，也就不会造成无限死循环...</span><br><br>  <span class="hljs-keyword">return</span> &lt;div&gt;<span class="hljs-built_in">num</span>: &#123;<span class="hljs-built_in">num</span>&#125;&lt;/div&gt;;<br>&#125;;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>React篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>Set和Map基本使用方法</title>
    <url>/2021/10/09/Set%E5%92%8CMap%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p><code>Map</code> <strong>(有道翻译)</strong> v.映射<br>的确，<code>Map</code> 强调的就是<strong>对应关系</strong><br>记住两个<strong>关键点</strong>：</p>
<ol>
<li>有序, 但有下标且下标唯一</li>
<li>键值对</li>
</ol>
<h5 id="Map-的基本用法"><a href="#Map-的基本用法" class="headerlink" title="Map 的基本用法"></a>Map 的基本用法</h5><p>（一）创建</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> m1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br></code></pre></td></tr></table></figure>

<p>（二）设置 (Map 可不像对象，键只能放字符，Map 的键可以是各种类型的值（包括对象）都可以当作键，如果你需要“键值对”的数据结构，Map 比 Object 更合适。)</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><code class="hljs lasso">m1.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;a1&#x27;</span>, <span class="hljs-string">&#x27;帅得乱七八糟&#x27;</span>)<br>m1.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;a2&#x27;</span>, <span class="hljs-string">&#x27;帅得歪瓜裂枣&#x27;</span>)<br>m1.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;a3&#x27;</span>, <span class="hljs-string">&#x27;帅得一塌糊涂&#x27;</span>)<br>m1.<span class="hljs-built_in">set</span>(() =&gt; &#123; console.<span class="hljs-keyword">log</span>(<span class="hljs-string">&#x27;func&#x27;</span>)&#125;, <span class="hljs-string">&#x27;小呆呆能找到女朋友&#x27;</span> )  <span class="hljs-comment">// 错误</span><br><span class="hljs-comment">// 对于除了字符串类型，最好是赋值到一个变量后再放入set里面去</span><br><span class="hljs-keyword">let</span> b = () =&gt; &#123; console.<span class="hljs-keyword">log</span>(<span class="hljs-string">&#x27;func&#x27;</span>)&#125;;<br>m1.<span class="hljs-built_in">set</span>(b, <span class="hljs-string">&#x27;小呆呆能找到女朋友&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>（三）获取</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver">console.<span class="hljs-built_in">log</span>(m1.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;a2&#x27;</span>));   <span class="hljs-comment"> // 帅得歪瓜裂枣</span><br>console.<span class="hljs-built_in">log</span>(m1.<span class="hljs-built_in">get</span>(b));      <span class="hljs-comment"> // &#x27;小呆呆能找到女朋友&#x27;</span><br></code></pre></td></tr></table></figure>

<p>（四）判断 —&gt; 只能放入键</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">console.<span class="hljs-built_in">log</span>(m1.has(<span class="hljs-string">&#x27;a2&#x27;</span>));         <span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-literal">true</span><br>console.<span class="hljs-built_in">log</span>(m1.has(<span class="hljs-string">&#x27;帅得一塌糊涂&#x27;</span>)); <span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>

<p>（五）删除</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">m1.<span class="hljs-keyword">delete</span>(<span class="hljs-string">&#x27;a3&#x27;</span>)<br>console.log(m1.has(<span class="hljs-string">&#x27;a3&#x27;</span>));  <span class="hljs-regexp">//</span> false<br></code></pre></td></tr></table></figure>

<p>（六）清空</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">m1.<span class="hljs-built_in">clear</span>();<br>console.<span class="hljs-built_in">log</span>(m1)<br></code></pre></td></tr></table></figure>

<p>（七）键值对个数</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing">m1.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;a1&#x27;</span>, <span class="hljs-string">&#x27;帅得乱七八糟&#x27;</span>)<br>m1.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;a2&#x27;</span>, <span class="hljs-string">&#x27;帅得歪瓜裂枣&#x27;</span>)<br>m1.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;a3&#x27;</span>, <span class="hljs-string">&#x27;帅得一塌糊涂&#x27;</span>)<br>console.<span class="hljs-built_in">log</span>(m1.<span class="hljs-built_in">size</span>)   <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure>

<p><strong>再次强调！！</strong> <code>Map</code> 比 <code>对象</code>强的地方在于 <code>Map</code> 的下标(键)比<code>对象</code>的键更灵活，可以是任何类型!</p>
<p>（八）遍历 Map (注意：遍历其实就是迭代)</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">m1.<span class="hljs-keyword">forEach</span>((item, <span class="hljs-keyword">index</span>) =&gt; console.log(item, <span class="hljs-keyword">index</span>))   //item只会显示值不会显示键而 <span class="hljs-keyword">index</span> 会显示出键，不会显示值<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><blockquote>
<p>巧记： for…of(遍历数组) for…in(遍历对象)</p>
</blockquote>
<p>事实上最好别拿 for…in 来遍历数组(for…of 同理，别拿来遍历对象)</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">let arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr.name = <span class="hljs-string">&#x27;我是谁&#x27;</span>;    <span class="hljs-regexp">//</span> 如果有人脑残，在arr中又以这样的方式增添了属性<br><br><span class="hljs-keyword">for</span> (let key <span class="hljs-keyword">in</span> arr) &#123;<br>  console.log(key);   <span class="hljs-regexp">//</span> 不仅arr下标打印还会把name也遍历了...<br>&#125;<br><br><span class="hljs-keyword">for</span> (let key of arr) &#123;<br>  <span class="hljs-regexp">//</span> <span class="hljs-keyword">for</span> of 相较于 forEach map 这些方法 能够有中断遍历功能<br>  <span class="hljs-regexp">//</span> <span class="hljs-keyword">break</span>;<br>  console.log(key);   <span class="hljs-regexp">//</span> 会遍历真正的数组元素。name 不会遍历<br>&#125;<br>let obj = &#123;<br>  name: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>  sex: <span class="hljs-string">&#x27;男&#x27;</span>,<br>  age: <span class="hljs-number">19</span><br>&#125;<br><br><span class="hljs-regexp">//</span> 遍历对象<br><span class="hljs-keyword">for</span> (let k <span class="hljs-keyword">in</span> obj) &#123;<br>  <span class="hljs-regexp">//</span> 如果是obj.k 以为是obj的k属性。但没有在obj里设置k<br>  <span class="hljs-regexp">//</span> 但要注意：如果是obj[k] k会被当成字符串的属性 例如 obj[<span class="hljs-string">&#x27;key&#x27;</span>]<br>  console.log(k, obj[k]);<br>&#125;<br><br>console.log(obj[<span class="hljs-string">&#x27;name&#x27;</span>]);   <span class="hljs-regexp">//</span> 小明<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p><strong>Set 容器(集合)</strong> ：有序 不可重复的多个 value 的集合体(不是键值对哦！)<br>理解为特殊数组，元素值不重复</p>
<p>其实和上面的 Map 的方法一样, 无外乎增删改查</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">// 创建一个空集合</span><br>let set1 = <span class="hljs-keyword">new</span> Set();<br><br><span class="hljs-comment">// 添加元素</span><br>set1.<span class="hljs-built_in">add</span>(<span class="hljs-string">&#x27;a&#x27;</span>)<br>set1.<span class="hljs-built_in">add</span>(<span class="hljs-string">&#x27;c&#x27;</span>)<br><br>console.<span class="hljs-built_in">log</span>(set1);<br>console.<span class="hljs-built_in">log</span>(set1.has(<span class="hljs-string">&#x27;b&#x27;</span>));  <span class="hljs-comment">// 集合中是否含有 &#x27;b&#x27;</span><br>set1.delete(<span class="hljs-string">&#x27;c&#x27;</span>);    <span class="hljs-comment">// 删除 &#x27;c&#x27;</span><br>set1.<span class="hljs-built_in">add</span>(<span class="hljs-string">&#x27;a&#x27;</span>);       <span class="hljs-comment">// 因为重复，所以只保留一个</span><br>console.<span class="hljs-built_in">log</span>(set1);<br>console.<span class="hljs-built_in">log</span>(set1.<span class="hljs-built_in">size</span>);   <span class="hljs-comment">// 元素个数</span><br>set1.<span class="hljs-built_in">clear</span>();        <span class="hljs-comment">// 清空集合</span><br>console.<span class="hljs-built_in">log</span>(set1);<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>TS + React</title>
    <url>/2021/12/02/TS-React/</url>
    <content><![CDATA[<h4 id="创建-TS-React-项目"><a href="#创建-TS-React-项目" class="headerlink" title="创建 TS + React 项目"></a>创建 TS + React 项目</h4><h5 id="从开始就创建-TS-React"><a href="#从开始就创建-TS-React" class="headerlink" title="从开始就创建 TS + React"></a>从开始就创建 TS + React</h5><p>创建一个 <code>react + ts</code> 的项目：<code>npx create-react-app &#39;项目名&#39; --template typescript</code></p>
<h5 id="React-项目做了一段时间后，中途增添-TS"><a href="#React-项目做了一段时间后，中途增添-TS" class="headerlink" title="React 项目做了一段时间后，中途增添 TS"></a>React 项目做了一段时间后，中途增添 TS</h5><p>… 这里有写操作 我还没写…<br>把原项目中 src 文件夹下 后缀名为 <code>.js/.jsx</code> 的改为 <code>.ts/.tsx</code><br>因为你改为<code>.ts/.tsx</code>文件后，因为你还是用的 <code>js</code> 语法会报一些错，所以按着报错的原因把 <code>js</code> 语法改为 <code>ts</code> 语法</p>
<h4 id="注意：当我们定义了一个东西-例如：组件或函数-，我们是要拿来给自己或其他人使用，既然如此，ts-要求我们要写一份说明书-interface-type-来告知使用者如何操作！"><a href="#注意：当我们定义了一个东西-例如：组件或函数-，我们是要拿来给自己或其他人使用，既然如此，ts-要求我们要写一份说明书-interface-type-来告知使用者如何操作！" class="headerlink" title="注意：当我们定义了一个东西(例如：组件或函数)，我们是要拿来给自己或其他人使用，既然如此，ts 要求我们要写一份说明书(interface / type)来告知使用者如何操作！"></a>注意：当我们定义了一个东西(例如：组件或函数)，我们是要拿来给自己或其他人使用，既然如此，ts 要求我们要写一份说明书(interface / type)来告知使用者如何操作！</h4><figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">|-src</span><br>   <span class="hljs-string">|-app.tsx</span><br>   <span class="hljs-string">|-test.tsx</span><br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* app.tsx */</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./styles.css&quot;</span>;<br><span class="hljs-keyword">import</span> Test <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Test&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Test</span> <span class="hljs-attr">param1</span>=<span class="hljs-string">&#123;</span>&quot;<span class="hljs-attr">param1</span>&quot;&#125; <span class="hljs-attr">param2</span>=<span class="hljs-string">&#123;</span>&quot;<span class="hljs-attr">param2</span>&quot;&#125; /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* test.tsx */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Test</span>(<span class="hljs-params">&#123; param1, param2 &#125;</span>) </span>&#123;   <span class="hljs-comment">// 报错！ 这在js中没问题，但是ts中会报错！因为这个组件的参数的类型是未知的，其他使用者是不知道的！</span><br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>这是测试代码<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>更改为下面这样就可以了！</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/* test.tsx */</span><br><span class="hljs-keyword">interface</span> TestProps &#123;<br>  <span class="hljs-attr">param1</span>: <span class="hljs-built_in">string</span>;<br>  param2: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Test</span>(<span class="hljs-params">&#123; param1, param2 &#125;: TestProps</span>) </span>&#123;  <span class="hljs-comment">// 现在我们知道 param1 是string类型，param2 是string 类型。</span><br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>这是测试代码<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样就大功告成！这里的优势在于 如果 <code>App 组件</code>传递给 <code>Test 组件</code>的 <code>param1</code> 或者 <code>param2</code> 不符合指定类型，则会报错！<br><strong>特别是组件或函数的参数，要自己去定义参数的类型</strong></p>
<h4 id="给钩子指定泛型"><a href="#给钩子指定泛型" class="headerlink" title="给钩子指定泛型"></a>给钩子指定泛型</h4><p>首先来说，ts 版的 react hooks 内部都是有泛型来定义的</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript">例如：useState<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useState</span>&lt;<span class="hljs-title">S</span>&gt;(<span class="hljs-params">initialState: S | (() =&gt; S)</span>): [<span class="hljs-title">S</span>, <span class="hljs-title">Dispatch</span>&lt;<span class="hljs-title">SetStateAction</span>&lt;<span class="hljs-title">S</span>&gt;&gt;]</span>;<br><br><br><span class="hljs-comment">// 一般我们在ts版本下使用useState是这样使用的</span><br><br><span class="hljs-comment">// const [user, setUser] = useState(value); // user的类型跟value的类型相关</span><br><span class="hljs-comment">// 不过，我们可以指定useState的泛型类型</span><br><br><span class="hljs-keyword">interface</span> User &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span><br>&#125;<br><span class="hljs-keyword">const</span> [user, setUser] = useState&lt;User | <span class="hljs-literal">null</span>&gt;(value); <span class="hljs-comment">// 此时user的类型就是 User | null 了</span><br></code></pre></td></tr></table></figure>

<h4 id="注意，children-是用-React-ReactNode-作为类型"><a href="#注意，children-是用-React-ReactNode-作为类型" class="headerlink" title="注意，children 是用 React.ReactNode 作为类型"></a>注意，children 是用 React.ReactNode 作为类型</h4><p>这种一般是在使用 context 的时候才会使用：</p>
<figure class="highlight nim"><table><tr><td class="code"><pre><code class="hljs nim">/* <span class="hljs-type">App</span>.tsx*/<br>&lt;<span class="hljs-type">AuthProvider</span>&gt;<br>  ....<br>&lt;/<span class="hljs-type">AuthProvider</span>&gt;<br><br>/* <span class="hljs-type">AuthContext</span> */<br><span class="hljs-keyword">export</span> function <span class="hljs-type">AuthProvider</span>(&#123;children&#125;:&#123;<span class="hljs-type">React</span>.<span class="hljs-type">ReactNode</span>&#125;) &#123;<br>  &lt;<span class="hljs-type">AuthContext</span>.<span class="hljs-type">Provider</span> value=<span class="hljs-meta">&#123;...&#125;</span>&gt;<br>    &#123;children&#125;<br>  &lt;/<span class="hljs-type">AuthContext</span>.<span class="hljs-type">Provider</span>&gt;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="注意-在-React-中使用-select-组件。它的-value-值始终是-string-类型"><a href="#注意-在-React-中使用-select-组件。它的-value-值始终是-string-类型" class="headerlink" title="注意 在 React 中使用 select 组件。它的 value 值始终是 string 类型"></a>注意 在 React 中使用 select 组件。它的 value 值始终是 string 类型</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;(e)</span> =&gt;</span> &#123;</span><br><span class="xml">    const value = e.target.value;</span><br><span class="xml">    console.log(value, typeof value)</span><br><span class="xml">  &#125;&#125;&gt;</span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;undefined&#125;</span>&gt;</span>默认选项<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;1&#125;</span>&gt;</span>选项一<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;true&#125;</span>&gt;</span>选项二<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>控制台打印结果：<br>默认选项 string<br>1 string<br>true string 全部都是 string 类型</p>
<h4 id="组件类型透传-这是结合了组件库-antd-来写的-这里展示了-TS-的一个大威力"><a href="#组件类型透传-这是结合了组件库-antd-来写的-这里展示了-TS-的一个大威力" class="headerlink" title="组件类型透传(这是结合了组件库(antd))来写的 这里展示了 TS 的一个大威力"></a>组件类型透传(这是结合了组件库(antd))来写的 这里展示了 TS 的一个大威力</h4><p>在日常 react 项目开发中，我们可能会遇见这样的一个问题。例如：我们要自定义一个 select 组件。如下</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> IdSelectProps &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span>;<br>  onChange: <span class="hljs-function">(<span class="hljs-params">value?: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>  options?: &#123; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; id: <span class="hljs-built_in">number</span> &#125;[];<br>&#125;<br><br><span class="hljs-keyword">const</span> IdSelect = <span class="hljs-function">(<span class="hljs-params">&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">  value,</span></span><br><span class="hljs-params"><span class="hljs-function">  onChange,</span></span><br><span class="hljs-params"><span class="hljs-function">  options</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;: IdSelectProps</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span></span></span><br><span class="hljs-tag"><span class="xml">      <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;toNumber(value)&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">      <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;(e)</span> =&gt;</span> onChange(toNumber(e.target.value) || undefined)&#125;</span><br><span class="xml">    &gt;</span><br><span class="xml">      &#123;defaultOptionName ? (</span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;0&#125;</span>&gt;</span>&#123;defaultOptionName&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><br><span class="xml">      ) : null&#125;</span><br><span class="xml">      &#123;options?.map((option) =&gt; &#123;</span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;option.name&#125;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;option.id&#125;</span>&gt;</span></span><br><span class="xml">          &#123;option.name&#125;</span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>;</span><br><span class="xml">      &#125;)&#125;</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>现在有出现一个问题。就是我想扩展我这个<code>IdSelect</code>组件。但是我如果一个一个的去更改组件的类型接口非常麻烦<br>而恰好在<code>antd库</code>里又有一个现有的<code>Select组件</code>功能齐全。我就想把我的组件和 Select 组件的<code>props的各种类型</code>结合起来。如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; Select &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;antd&#x27;</span>;  <span class="hljs-comment">// 导入antd里的Select组件</span><br><br><span class="hljs-comment">// React.ComponentProps 帮助我们获取一个组件的 props 类型声明</span><br><span class="hljs-keyword">type</span> SelectProps = React.ComponentProps&lt;<span class="hljs-keyword">typeof</span> Select&gt;<br><br><span class="hljs-comment">// Omit 是为了防止SelectProps类型中有些属性和IdSelectProps的属性发生冲突</span><br><span class="hljs-keyword">interface</span> IdSelectProps <span class="hljs-keyword">extends</span> Omit&lt;SelectProps, &#x27;value&#x27; | &#x27;onChange&#x27; | &#x27;option&#x27;&gt;&#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span>;<br>  onChange: <span class="hljs-function">(<span class="hljs-params">value?: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>  options?: &#123; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; id: <span class="hljs-built_in">number</span> &#125;[];<br>&#125;<br><br><span class="hljs-comment">// ... 后续代码一些正常</span><br></code></pre></td></tr></table></figure>

<p>这样之后，我的 <code>IdSelect</code> 组件的类型属性就会丰富很多…</p>
<h4 id="使用-tuple-的最大好处是可以给返回的元素任意拟定名字"><a href="#使用-tuple-的最大好处是可以给返回的元素任意拟定名字" class="headerlink" title="使用 tuple 的最大好处是可以给返回的元素任意拟定名字"></a>使用 tuple 的最大好处是可以给返回的元素任意拟定名字</h4><figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript">例如: <span class="hljs-keyword">const</span> [a, setA] = useState(...);   <span class="hljs-comment">// 这里的a， setA 都是自己随意拟定的名字</span><br></code></pre></td></tr></table></figure>

<p>但是，使用 tuple 的元素不要太多，tuple 超过了 3 个元素，其实还不如使用对象的键值对来表示数据</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>有时候你会遇见这样的问题：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">const Component = <span class="hljs-function"><span class="hljs-params">(xxx: XXX)</span> =&gt;</span> &#123;   <span class="hljs-regexp">//</span> 然后这里报错， 说需要 XXX | <span class="hljs-literal">undefined</span> 类型<br>  xxx.map(....)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>解决办法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> Component = <span class="hljs-function">(<span class="hljs-params">xxx?: XXX</span>) =&gt;</span> &#123;  <span class="hljs-comment">// 这样就可以解决问题了</span><br>  xxx?.map(....)<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="注意-无论写的是-type-还是-interface-首字母-一定要大写"><a href="#注意-无论写的是-type-还是-interface-首字母-一定要大写" class="headerlink" title="注意 无论写的是 type 还是 interface 首字母 一定要大写"></a>注意 无论写的是 type 还是 interface 首字母 一定要大写</h4><figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">interface</span> <span class="hljs-keyword">Task</span> &#123;<br>  ...<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-type">Task </span>= &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TypeScript篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>TS 基础知识</title>
    <url>/2021/12/03/TS-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h3 id="TS-的类型"><a href="#TS-的类型" class="headerlink" title="TS 的类型"></a>TS 的类型</h3><p><code>number</code>, <code>string</code>, <code>boolean</code>, <code>函数</code>, <code>array</code>, <code>any</code>, <code>void</code>, <code>object</code>, <code>tuple</code>, <code>enum</code>, <code>null</code>, <code>undefined</code>, <code>unknown</code>, <code>never</code></p>
<h4 id="number"><a href="#number" class="headerlink" title="number"></a>number</h4><p>数字类型，包含小数、其他进制的数字：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">let</span> decimal: number = <span class="hljs-number">6</span>;<br><span class="hljs-built_in">let</span> hex: number = <span class="hljs-number">0xf00d</span>;<br><span class="hljs-built_in">let</span> binary: number = <span class="hljs-number">0b1010</span>;<br><span class="hljs-built_in">let</span> octal: number = <span class="hljs-number">0o744</span>;<br><span class="hljs-built_in">let</span> big: bigint = 100n;    // 这个可以注意一下！<br></code></pre></td></tr></table></figure>

<h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">let</span> <span class="hljs-built_in">color</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;blue&quot;</span>;<br></code></pre></td></tr></table></figure>

<h4 id="array"><a href="#array" class="headerlink" title="array"></a>array</h4><p>在 TS 中，array 一般指<strong>所有元素类型相同的值</strong>的集合</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> list: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-comment">// or</span><br><br><span class="hljs-keyword">interface</span> User &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>&#125;<br><span class="hljs-keyword">const</span> john = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;john&#x27;</span>&#125;<br><span class="hljs-keyword">const</span> jack = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;jack&#x27;</span>&#125;<br><span class="hljs-keyword">let</span> personList = [john, jack];   <span class="hljs-comment">// 这里可以多注意一下</span><br></code></pre></td></tr></table></figure>

<h4 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h4><p>布尔值：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">let</span> isDone: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure>

<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>两种声明方法</p>
<h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><p>在 “JS 函数” 上直接声明参数和返回值的类型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> isFalsy = (value: <span class="hljs-built_in">any</span>): <span class="hljs-function"><span class="hljs-params">boolean</span> =&gt;</span> &#123;   <span class="hljs-comment">// 这里告诉了我们 参数是any类型，返回值是 boolean类型</span><br>  <span class="hljs-keyword">return</span> value === <span class="hljs-number">0</span> ? <span class="hljs-literal">true</span> : !!value;<br>&#125;;<br><br><span class="hljs-comment">// 当然！由于类型推断，返回值也可以不用自己手写，因为代码会自动推断返回值类型</span><br><span class="hljs-keyword">const</span> isFalsy = <span class="hljs-function">(<span class="hljs-params">value: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> value === <span class="hljs-number">0</span> ? <span class="hljs-literal">true</span> : !!value;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h5 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h5><p>直接声明你想要的函数类型：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> isFalsy: <span class="hljs-function">(<span class="hljs-params">value: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">boolean</span> = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;  <span class="hljs-comment">//: 之后的 (value: any) =&gt; boolean 就是函数类型</span><br>  <span class="hljs-keyword">return</span> value === <span class="hljs-number">0</span> ? <span class="hljs-literal">true</span> : !!value;<br>&#125;;<br><br><span class="hljs-keyword">const</span> func = (param: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>): <span class="hljs-function"><span class="hljs-params">any</span> =&gt;</span> &#123;  <span class="hljs-comment">// 参数param是函数() =&gt; void 类型， func返回值是any类型</span><br>  <span class="hljs-keyword">return</span> ...<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="any"><a href="#any" class="headerlink" title="any"></a>any</h4><p>any 表示这个值可以是任何值，被定义为 any 就意味着不做任何类型检查：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">let looselyTyped: any = <span class="hljs-number">4</span>;<br><span class="hljs-regexp">//</span> looselyTyped 的值明明是个<span class="hljs-number">4</span>，哪里来的ifItExists方法呢？<br><span class="hljs-regexp">//</span> 由于声明为any，我们没法在静态检查阶段发现这个错误<br>looselyTyped.ifItExists();<br></code></pre></td></tr></table></figure>

<h4 id="void"><a href="#void" class="headerlink" title="void"></a>void</h4><p>绝大部分情况下，只会用在这一个地方：表示函数不返回任何值或者返回 undefined (因为函数不返回任何值的时候 === 返回 undefined)</p>
<h4 id="object"><a href="#object" class="headerlink" title="object"></a>object</h4><p>除了 number, string, boolean, bigint, symbol, null, or undefined，其他都是 object</p>
<h4 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h4><p>tuple 是 “数量固定，类型可以各异” 版的数组</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> [value, setValue] = useState()  <span class="hljs-comment">// 这就是一个典型的tuple(数量固定，类型各异)</span><br></code></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">在 React 中有可能使用 tuple 的地方就是 custom hook 的返回值，注意 isHappy → tomIsHappy 以及其他名字的变化，这里使用 tuple 的好处就显现出来了：便于使用者重命名：<br><br><span class="hljs-keyword">const</span> useHappy = () =&gt; &#123;<br>   <span class="hljs-comment">//....</span><br>   <span class="hljs-keyword">return</span> [isHappy, makeHappy, makeUnHappy]<br>&#125;<br><br><span class="hljs-keyword">const</span> SomeComponent = () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> [tomIsHappy, makeTomHappy, makeTomUnHappy] = useHappy(<span class="hljs-keyword">false</span>)<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h4><figure class="highlight mathematica"><table><tr><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">enum</span> <span class="hljs-variable">Color</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-built_in">Red</span><span class="hljs-operator">,</span><br>  <span class="hljs-built_in">Green</span><span class="hljs-operator">,</span><br>  <span class="hljs-built_in">Blue</span><span class="hljs-operator">,</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-variable">let</span> <span class="hljs-variable">c</span><span class="hljs-operator">:</span> <span class="hljs-variable">Color</span> <span class="hljs-operator">=</span> <span class="hljs-variable">Color</span><span class="hljs-operator">.</span><span class="hljs-built_in">Green</span><span class="hljs-operator">;</span>  <span class="hljs-operator">//</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<h4 id="null-和-undefined"><a href="#null-和-undefined" class="headerlink" title="null 和 undefined"></a>null 和 undefined</h4><p><strong>注意：null 和 undefined 在 TypeScript 中既是一个值，也是一个类型：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> u: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-keyword">let</span> n: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure>

<h4 id="unknown"><a href="#unknown" class="headerlink" title="unknown"></a>unknown</h4><p>当你想用 <code>any</code> 的时候，尽量用 <code>unknown</code> 来代替<br><strong>unknown 是一个 “严格” 版的 any，同 any 一样可以被赋任何类型的值，但你要使用 unknown 就会有很多的限制</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> value:unknown;<br><span class="hljs-keyword">let</span> newValue = <span class="hljs-number">1</span>;<br>newValue = value;   <span class="hljs-comment">// 报错！unknown 不能赋值给任何的值</span><br><br><span class="hljs-keyword">const</span> isFalsy = <span class="hljs-function">(<span class="hljs-params">value: unknown</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(value.mayNotExist)  <span class="hljs-comment">// 报错！不能从unknown中读取任何的方法</span><br>  <span class="hljs-keyword">return</span> value === <span class="hljs-number">0</span> ? <span class="hljs-literal">true</span> : !!value;<br>&#125;;<br><br><br><span class="hljs-keyword">const</span> isFalsy = <span class="hljs-function">(<span class="hljs-params">value: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(value.mayNotExist)  <span class="hljs-comment">// 不报错！ 但本身一定应该是错的才行</span><br>  <span class="hljs-keyword">return</span> value === <span class="hljs-number">0</span> ? <span class="hljs-literal">true</span> : !!value;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="never"><a href="#never" class="headerlink" title="never"></a>never</h4><figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span> 这个 func返回的就是never类型，用到比较少，在类型操作等场景会用到<br>const func = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>()<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h5><p>interface 不是一种类型，应该被翻译成 接口，或者说使用上面介绍的类型，创建一个我们自己的类型：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">interface <span class="hljs-keyword">User</span> <span class="hljs-title">&#123;</span><br><span class="hljs-title">  id</span>: <span class="hljs-keyword">number</span>;<br>&#125;<br>const u: <span class="hljs-keyword">User</span> <span class="hljs-title">= &#123;id</span>: <span class="hljs-number">1</span>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="啥时候需要声明类型"><a href="#啥时候需要声明类型" class="headerlink" title="啥时候需要声明类型"></a>啥时候需要声明类型</h4><p>理论上来说在我们声明任何变量的时候都需要声明类型（包括普通变量、函数、组件、hook 等等），声明 函数、组件、hook 等需要声明参数 和 返回值的类型。</p>
<p>但是在很多情况下，TS 可以帮我们自动推断，我们就不用声明了，比如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 这里虽然没有显式声明，但是 ts 自动推断这是个 number</span><br><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span><br><br><span class="hljs-comment">// 自动推断返回值为 number</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">// 自动推断返回值为 boolean</span><br><span class="hljs-keyword">const</span> isFalsy = <span class="hljs-function">(<span class="hljs-params">value: unknown</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> value === <span class="hljs-number">0</span> ? <span class="hljs-literal">true</span> : !!value;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="d-ts"><a href="#d-ts" class="headerlink" title=".d.ts"></a>.d.ts</h4><p>JS 文件 + .d.ts 文件 === ts 文件。<br>.d.ts 一般是用于第三方库 <code>打补丁用的</code>。有些库为了方便更多用户使用没有直接用 ts 版本。但如果某些用户需要 ts 版本的这个库，可以下载该库的 ts 声明文件(前提是这个文件是别人已经写好的才行，写该库声明文件的人可以是原本库的作者或其他人)即 xxxx.d.ts 文件</p>
<p>.d.ts 文件可以让 JS 文件继续维持自己 JS 文件的身份，而拥有 TS 的类型保护。</p>
<p>一般我们写业务代码不会用到，但是点击类型跳转一般会跳转到 .d.ts 文件。</p>
<h3 id="TS-泛型"><a href="#TS-泛型" class="headerlink" title="TS 泛型"></a>TS 泛型</h3><p>函数中泛型的书写位置：</p>
<figure class="highlight nim"><table><tr><td class="code"><pre><code class="hljs nim">箭头函数：<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">func</span> = &lt;V&gt;(...) =&gt; <span class="hljs-meta">&#123;...&#125;</span><br><br>普通函数：<br>function <span class="hljs-keyword">func</span>&lt;V&gt;(...) <span class="hljs-meta">&#123;...&#125;</span><br></code></pre></td></tr></table></figure>

<p>泛型，先用占位符(自定义名字，一般用大写 T、V 表示)来占位。后用真实类型来替换占位符</p>
<p>泛型不仅仅可以用于函数，还可以用在<code>interface</code>上。例如：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">interface</span> <span class="hljs-symbol">FormEvent</span>&lt;<span class="hljs-symbol">T</span> = <span class="hljs-symbol">Element</span>&gt; <span class="hljs-symbol">extends</span> <span class="hljs-symbol">SyntheticEvent</span>&lt;<span class="hljs-symbol">T</span>&gt; &#123;&#125;   <span class="hljs-comment">// 这里也可以看出，TS具备接口继承和参数默认值的能力</span><br></code></pre></td></tr></table></figure>

<p>注意一个细节：一般在 react 项目中，我们会遇见一些标签事件，但是我们不好轻易找到这些事件它的参数类型</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;callback&#125;</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-12-03-at-11.23.57-PM.png" alt="找参数类型1"><br>我无法找到参数的类型，但下面的这种书写方式可以找到</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;(e)</span> =&gt;</span> &#123;&#125;&#125;&gt;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-12-03-at-11.26.17-PM.png" alt="找参数类型2"><br>我们可以发现：e 的类型为: <code>React.FormEvent&lt;HTMLFormElement&gt;</code></p>
<h3 id="TS-是鸭子类型"><a href="#TS-是鸭子类型" class="headerlink" title="TS 是鸭子类型"></a>TS 是鸭子类型</h3><p>即只要类型相同就可以, 不管你接口名是不是一致… 我这话说得不太官方，可能有错！有空改改</p>
<h3 id="TS-类型断言-as"><a href="#TS-类型断言-as" class="headerlink" title="TS 类型断言(as)"></a>TS 类型断言(as)</h3><p>… 有待补充</p>
<h3 id="类型别名-type"><a href="#类型别名-type" class="headerlink" title="类型别名 type"></a>类型别名 type</h3><p>// 类型别名 –&gt; 给自定义的类型取一个名字<br>type jackFavoriteNumber = string | number</p>
<p>在很多情况下，类型别名和 interface 是可以互换的。二者主要的两个区别如下：</p>
<ol>
<li>interface 无法实现联合类型或交叉类型,但是 type 可以实现</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> test1 = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> <span class="hljs-comment">// 联合类型</span><br><span class="hljs-keyword">type</span> test2 = <span class="hljs-built_in">string</span> &amp; <span class="hljs-built_in">number</span> <span class="hljs-comment">// 交叉类型</span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li>interface 没法实现 Utility Type</li>
</ol>
<h3 id="Utility-Type"><a href="#Utility-Type" class="headerlink" title="Utility Type"></a>Utility Type</h3><p><code>Utility Type</code> 是用 <code>Type</code> 来实现的</p>
<p><code>Utility Type</code>作用: 操作已有类型，生成新类型<br><code>Utility Type</code>用法：即利用泛型给 <code>Utility</code> 传入一个其他类型，然后 <code>Utility type</code> 对这个类型进行某种操作<br><a href="https://codesandbox.io/s/utilitytype-ts-75fi0">手写 utility</a></p>
]]></content>
      <categories>
        <category>TypeScript篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>TS 知识总结</title>
    <url>/2021/12/02/TS-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="TS-的优势"><a href="#TS-的优势" class="headerlink" title="TS 的优势"></a>TS 的优势</h4><p>使用 <code>JS</code> 的话，大部分的错误都是在 <code>runtime(运行时)</code>的时候发现的<br><code>TS</code> 能够在静态代码中，就能找到其中的一些错误 -&gt; 强类型</p>
<h4 id="尽量在-ts-中少用-any-类型"><a href="#尽量在-ts-中少用-any-类型" class="headerlink" title="尽量在 ts 中少用 any 类型"></a>尽量在 ts 中少用 any 类型</h4><h4 id="如果有-ts-的类型错误，但是现在又不想去修改-可以在出现问题的上一行使用：-ts-ignore-来压制错误"><a href="#如果有-ts-的类型错误，但是现在又不想去修改-可以在出现问题的上一行使用：-ts-ignore-来压制错误" class="headerlink" title="如果有 ts 的类型错误，但是现在又不想去修改 可以在出现问题的上一行使用： // @ts-ignore 来压制错误"></a>如果有 ts 的类型错误，但是现在又不想去修改 可以在出现问题的上一行使用： <code>// @ts-ignore</code> 来压制错误</h4><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><p>(ts 中的 typeof 和 js 中的 typeof 二者是不一样的， js 的 typeof，是在 runtime 时运行的，ts 中的 typeof 是在静态环境中运行的)</p>
<h4 id="给泛型限制类型"><a href="#给泛型限制类型" class="headerlink" title="给泛型限制类型"></a>给泛型限制类型</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func1</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">param:T</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> param;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(func1(<span class="hljs-number">1</span>));<br><span class="hljs-built_in">console</span>.log(func1(<span class="hljs-string">&#x27;str&#x27;</span>));<br><br><span class="hljs-comment">// 限制泛型只能传字符串</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func2</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">String</span>&gt;(<span class="hljs-params">param:T</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> param;<br>&#125;<br><span class="hljs-built_in">console</span>.log(func2(<span class="hljs-number">1</span>));  <span class="hljs-comment">// 报错</span><br><span class="hljs-built_in">console</span>.log(func2(<span class="hljs-string">&#x27;str&#x27;</span>));<br></code></pre></td></tr></table></figure>

<h4 id="类型守卫"><a href="#类型守卫" class="headerlink" title="类型守卫"></a>类型守卫</h4>]]></content>
      <categories>
        <category>TypeScript篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>TS类型体操</title>
    <url>/2022/03/09/TS%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D/</url>
    <content><![CDATA[<!-- (该博客是基于TypeScript类型体操通关秘籍，所做的笔记！) -->
<h3 id="TS的简介"><a href="#TS的简介" class="headerlink" title="TS的简介"></a>TS的简介</h3><p><strong>类型的意义</strong></p>
<ul>
<li>不同类型变量占据的内存大小不同 （各种类型所占用的字节数是不同的）</li>
<li>不同类型变量可做的操作不同</li>
</ul>
<p><strong>类型体操</strong>保证对某种类型只做该类型允许的操作  (比如不能在boolean中做加减乘除，这是类型不安全的做法)</p>
<p><strong>类型检查就是为了保证类型安全的</strong><br>类型检查可以在 运行时做 也可以在 编译器做。前者叫做动态类型检查  后者叫做静态类型检查<br>注意：动态类型代码虽然写起来简单，但代码中很容易藏着一些类型不匹配的隐患；静态类型写起来会麻烦一些，但是消除了类型不安全的问题</p>
<blockquote>
<p>动态类型只适合简单的场景，对于大项目却不太合适，因为代码中可能藏着的隐患太多了，万一线上报一个类型不匹配的错误，那可能就是大问题。而静态类型虽然会增加写代码的成本，但是却能更好的保证代码的健壮性，减少 Bug 率。</p>
</blockquote>
<h4 id="TS给JS带来的优势"><a href="#TS给JS带来的优势" class="headerlink" title="TS给JS带来的优势"></a>TS给JS带来的优势</h4><p>TS 给 JS 添加了一套静态类型系统，从动态类型语言变成了静态类型语言，可以在<strong>编译期间</strong>做<strong>类型检查</strong>，提前发现一些类型安全问题<br>因为有了<strong>静态类型</strong>，也就可以配合<strong>编译器</strong>来实现更好的<strong>提示、重构</strong>等</p>
<h4 id="TS类型编程-类型体操"><a href="#TS类型编程-类型体操" class="headerlink" title="TS类型编程(类型体操)"></a>TS类型编程(类型体操)</h4><p>很多语言都有类型系统(Java、C++等)，但只有TS的类型编程被叫做<strong>类型体操</strong></p>
<p>TS给JS添加了一套静态类型系统，通过TS Compiler编译JS，编译的过程叫做类型检查。但是它并没有改变JS的语法，只是在JS的基础上添加了类型语法，所以被叫做JS的超集</p>
<h5 id="类型系统分类"><a href="#类型系统分类" class="headerlink" title="类型系统分类"></a>类型系统分类</h5><ul>
<li><p><strong>简单类型系统</strong><br>给变量、函数、类声明类型，编译器会基于声明的类型做类型检查，类型不匹配就报错</p>
</li>
<li><p><strong>支持泛型的类型系统</strong><br>用通用的字符表示任何一种类型，利用代码模板的方式减少了很多重复的代码 (如Java、C++)</p>
</li>
<li><p><strong>支持类型编程的类型系统</strong><br>对传入的泛型做各种逻辑运算，产生新的类型，这就是类型编程</p>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPropValue</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">object</span>, <span class="hljs-title">Key</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">T</span>&gt;(<span class="hljs-params">obj: T, key: Key</span>): <span class="hljs-title">T</span>[<span class="hljs-title">Key</span>] </span>&#123;<br>  <span class="hljs-keyword">return</span> obj[key]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>TS 就具备类型编程。Java这些语言只支持普通的泛型操作</p>
<p>注意：TS的类型系统是图灵完备的，JS可以写的逻辑，用TS类型都可以写</p>
<h4 id="TS类型"><a href="#TS类型" class="headerlink" title="TS类型"></a>TS类型</h4><p>静态类型系统的目的是把类型检查从运行时提前到编译时(因此要把JS运行时的类型拿过来：8种)，在此基础上增加了三种类型，元组(Tuple)，接口(interface)，枚举(Enum)，字面量类型以及等等类型</p>
<ul>
<li><p>元组</p>
<blockquote>
<p>就是元素个数和类型固定的数组类型： type Tuple = [number, string];</p>
</blockquote>
</li>
<li><p>接口 (type却不是一种类型，这也是type 和 interface的区别)</p>
<blockquote>
<p>可以描述函数、对象、构造器的结构</p>
</blockquote>
</li>
</ul>
<p>对象类型、class 类型在 TypeScript 里也叫做<strong>索引类型</strong>，也就是索引了多个元素的类型的意思。对象可以动态添加属性，如果不知道会有什么属性，可以用<strong>可索引签名</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> IPerson &#123;<br>  [prop: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">const</span> obj:IPerson = &#123;&#125;;<br>obj.name = <span class="hljs-string">&#x27;heyang&#x27;</span>;<br>obj.age = <span class="hljs-number">18</span>;<br></code></pre></td></tr></table></figure>

<p>总之，<strong>接口可以用来描述函数、构造器、索引类型（对象、class、数组）等复合类型</strong></p>
<h4 id="TS的类型运算"><a href="#TS的类型运算" class="headerlink" title="TS的类型运算"></a>TS的类型运算</h4><blockquote>
<p>通过type来进行类型运算</p>
</blockquote>
<ul>
<li><p>条件：extends ? :  –&gt; TS 版的if else</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> isTwo&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-number">2</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">type</span> res = isTwo&lt;<span class="hljs-number">1</span>&gt;;<br><span class="hljs-keyword">type</span> res2 = isTwo&lt;<span class="hljs-number">2</span>&gt;;<br></code></pre></td></tr></table></figure></li>
<li><p>推导：infer<br>用来提取元素的一部分</p>
</li>
</ul>
<p>比如提取元组类型的第一个元素</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> First&lt;Tuple <span class="hljs-keyword">extends</span> unknown[]&gt; = Tuple <span class="hljs-keyword">extends</span> [infer T, ...infer R] ? T : <span class="hljs-built_in">never</span>;<br><span class="hljs-keyword">type</span> res = First&lt;[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]&gt;<br></code></pre></td></tr></table></figure>
<p>注意：上面的extends是约束的意思，也就是约束类型参数只能是数组类型<br>因为不知道数组元素的具体类型，所以用 unkown。</p>
<ul>
<li><p>联合： |   –&gt; 因为interface是类型，所以不具备运算能力<br>联合类型（Union）类似 js 里的或运算符 |，但是作用于类型，代表类型可以是几个类型之一。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Union = <span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure></li>
<li><p>交叉： &amp;<br>交叉类型（Intersection）类似 js 中的与运算符 &amp;，但是作用于类型，代表对类型做合并。<br>交叉类型会把同一类型做合并，不同类型舍弃</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> ObjType = &#123;<span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>&#125; &amp; &#123;<span class="hljs-attr">c</span>: <span class="hljs-built_in">boolean</span>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p>映射类型<br>通过<strong>映射类型</strong>来解决对象、class这类<strong>索引类型</strong>的修改</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> MapType&lt;T&gt; = &#123;<br>  [Key <span class="hljs-keyword">in</span> keyof T]?:T[Key] <br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>keyof T</code> 是查询索引类型中所有的索引，叫做<code>索引查询</code><br><code>T[Key]</code> 是取索引类型某个索引的值，叫做<code>索引访问</code><br><code>in</code> 是用于遍历<strong>联合类型</strong>的运算符</p>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> MapType&lt;T&gt; = &#123;<br>  [Key <span class="hljs-keyword">in</span> keyof T]: [T[Key], T[Key], T[Key]]<br>&#125;<br><br><span class="hljs-keyword">type</span> res = MapType&lt;&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>&#125;&gt;<br></code></pre></td></tr></table></figure>

<p>索引也可以做变化，使用as运算符，叫做重映射</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> MapType&lt;T&gt; = &#123;<br>    [<br>        Key <span class="hljs-keyword">in</span> keyof T <br>            <span class="hljs-keyword">as</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;Key &amp; <span class="hljs-built_in">string</span>&#125;</span><span class="hljs-subst">$&#123;Key &amp; <span class="hljs-built_in">string</span>&#125;</span><span class="hljs-subst">$&#123;Key &amp; <span class="hljs-built_in">string</span>&#125;</span>`</span><br>    ]: [T[Key], T[Key], T[Key]]<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="类型体操的套路"><a href="#类型体操的套路" class="headerlink" title="类型体操的套路"></a>类型体操的套路</h3><h4 id="套路一：-模式匹配做提取"><a href="#套路一：-模式匹配做提取" class="headerlink" title="套路一： 模式匹配做提取"></a>套路一： 模式匹配做提取</h4><p>例如：提取Promise里面的value值</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> p = <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-string">&#x27;guang&#x27;</span>&gt;;<br><span class="hljs-keyword">type</span> GetValueType&lt;P&gt; = P <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Promise</span>&lt;infer Value&gt; ? Value : <span class="hljs-built_in">never</span>;<br><span class="hljs-keyword">type</span> GetValueResult = GetValueType&lt;p&gt;;   <span class="hljs-comment">// &#x27;guang&#x27;</span><br></code></pre></td></tr></table></figure>
<p>Typescript 类型的模式匹配是通过 extends 对类型参数做匹配，结果保存到通过 infer 声明的局部类型变量里，如果匹配就能从该局部变量里拿到提取出的类型。</p>
<hr>
<p>再来点例子：</p>
<ul>
<li>数组<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];   <span class="hljs-comment">// 字面量做类型</span><br><span class="hljs-comment">// 先在要提取数组类型的第一个元素</span><br><span class="hljs-keyword">type</span> GetFirst&lt;Arr <span class="hljs-keyword">extends</span> unknown[]&gt; = Arr <span class="hljs-keyword">extends</span> [infer First, ...unknow[]] ? First : <span class="hljs-built_in">never</span>;<br></code></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p><strong>any 和 unknown 的区别：</strong> any 和 unknown 都代表任意类型，但是 unknown 只能接收任意类型的值，而 any 除了可以接收任意类型的值，也可以赋值给任意类型。类型体操中经常用 unknown 接受和匹配任何类型，而很少把任何类型赋值给某个类型变量。</p>
</blockquote>
<ul>
<li>字符串<br>判断字符串是否以某个前缀开头，也是通过模式匹配：<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> StartsWith&lt;Str <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>, Prefix <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; = Str <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;Prefix&#125;</span><span class="hljs-subst">$&#123;<span class="hljs-built_in">string</span>&#125;</span>`</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">type</span> StartsWithResult = StartsWith&lt;<span class="hljs-string">&#x27;heyang&#x27;</span>, <span class="hljs-string">&#x27;he&#x27;</span>&gt;  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> ReplaceStr&lt;Str <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>, From <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>, To <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; = Str <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;infer Prefix&#125;</span><span class="hljs-subst">$&#123;From&#125;</span><span class="hljs-subst">$&#123;infer Suffix&#125;</span>`</span> ？ <span class="hljs-string">`<span class="hljs-subst">$&#123;Prefix&#125;</span><span class="hljs-subst">$&#123;To&#125;</span><span class="hljs-subst">$&#123;Suffix&#125;</span>`</span> : Str;   <br><span class="hljs-comment">// infer 真的牛啊</span><br></code></pre></td></tr></table></figure>

<ul>
<li>函数<br>函数同样也可以做类型匹配，比如提取参数、返回值的类型。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> GetParameters&lt;Func <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Function</span>&gt; = <br></code></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>TypeScript-随笔一</title>
    <url>/2021/10/20/TypeScript-%E9%9A%8F%E7%AC%94%E4%B8%80/</url>
    <content><![CDATA[<h4 id="对于-interface-书写的小技巧"><a href="#对于-interface-书写的小技巧" class="headerlink" title="对于 interface 书写的小技巧"></a>对于 interface 书写的小技巧</h4><figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts">interface <span class="hljs-class">User </span>&#123;<br><span class="hljs-symbol">  name:</span> string;<br><span class="hljs-symbol">  age:</span> number;<br>&#125;<br>interface <span class="hljs-class">SomeProps </span>&#123;<br><span class="hljs-symbol">  users:</span> User[]; <span class="hljs-comment">// 可以嵌套其他interface</span><br><span class="hljs-symbol">  param:</span> &#123;<br><span class="hljs-symbol">    id:</span> number;<br>  &#125;;<br><span class="hljs-symbol">  setParam:</span> (param: SomeProps[<span class="hljs-string">&quot;param&quot;</span>]) =&gt; void; <span class="hljs-comment">// 可以很方便的使用自己本身的属性</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="ts-中的类型-object-有点特殊"><a href="#ts-中的类型-object-有点特殊" class="headerlink" title="ts 中的类型 object 有点特殊"></a>ts 中的类型 object 有点特殊</h4><p>object 的类型覆盖是很广的…</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> a: <span class="hljs-built_in">object</span>;<br>a = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;jack&#x27;</span>&#125;;   <span class="hljs-comment">// 不报错！</span><br>a = <span class="hljs-function">() =&gt;</span> &#123;&#125;          <span class="hljs-comment">// 还是不报错！</span><br>a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&#x27;&#x27;</span>)    <span class="hljs-comment">// 这里还是不会报错</span><br><br><span class="hljs-comment">// 但是这就会出现一种情况</span><br><br><span class="hljs-keyword">const</span> b = &#123;...(<span class="hljs-function">() =&gt;</span> &#123;&#125;)&#125; <span class="hljs-comment">// 解构一个函数是没有意义的，得到的值是一个空对象</span><br></code></pre></td></tr></table></figure>

<p>所以如果是想表示一个键值对类型的对象，类型不要写成 object。<br>换成下面这样就很好</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">let</span> a: &#123;[<span class="hljs-built_in">key</span>:<span class="hljs-keyword">string</span>]:unknown&#125;  <span class="hljs-comment">// 其实我有个疑惑就是[]是什么效果呢？</span><br></code></pre></td></tr></table></figure>

<h4 id="注意，有些第三方库没有自带-ts-的类型声明文件-即-ts-的“说明书功能”-该词参考博客-TS-React-，所以你在下载该库的时候，还要多下载一个该库的-ts-类型声明文件，这样，该库也有了-ts-的系列功能"><a href="#注意，有些第三方库没有自带-ts-的类型声明文件-即-ts-的“说明书功能”-该词参考博客-TS-React-，所以你在下载该库的时候，还要多下载一个该库的-ts-类型声明文件，这样，该库也有了-ts-的系列功能" class="headerlink" title="注意，有些第三方库没有自带 ts 的类型声明文件(即 ts 的“说明书功能” 该词参考博客 TS + React)，所以你在下载该库的时候，还要多下载一个该库的 ts 类型声明文件，这样，该库也有了 ts 的系列功能"></a>注意，有些第三方库没有自带 ts 的类型声明文件(即 ts 的“说明书功能” 该词参考博客 TS + React)，所以你在下载该库的时候，还要多下载一个该库的 ts 类型声明文件，这样，该库也有了 ts 的系列功能</h4><h4 id="as-const-的妙用！"><a href="#as-const-的妙用！" class="headerlink" title="as const 的妙用！"></a>as const 的妙用！</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">const <span class="hljs-selector-tag">a</span> = <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;jack&#x27;</span>, 12, &#123;gender: <span class="hljs-string">&#x27;male&#x27;</span>&#125;]</span>  <span class="hljs-comment">// ts 会默认认为这个a是数组,所以里面的元素类型都应该是保持一致的才行...</span><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-20-at-9.26.54-AM.44u177wjacg0.png" alt="未添加as const"></p>
<p>如果要本身的原始类型则加上<code>as const</code></p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> a = [<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-number">12</span>, &#123;gender: <span class="hljs-string">&#x27;male&#x27;</span>&#125;] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-20-at-9.28.46-AM.4pkaih8rjje0.png" alt="添加as const"></p>
<hr>
<p>再来一个例子：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> a = [<span class="hljs-string">&#x27;12&#x27;</span>]          <span class="hljs-comment">// const a: string[]</span><br><span class="hljs-keyword">const</span> b = [<span class="hljs-string">&#x27;12&#x27;</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span> <span class="hljs-comment">// const b: readonly [&quot;12&quot;]</span><br></code></pre></td></tr></table></figure>

<p>注意：有了<code>as const</code>后,属性类型变成 <code>readonly</code></p>
<h4 id="给已经存在的-react-项目添加-ts"><a href="#给已经存在的-react-项目添加-ts" class="headerlink" title="给已经存在的 react 项目添加 ts"></a>给已经存在的 react 项目添加 ts</h4><p><a href="https://create-react-app.dev/docs/adding-typescript/">安装教程</a></p>
<h4 id="注意：给-react-项目添加-ts-后。对于-ts-后缀和-tsx-后缀是有讲究的"><a href="#注意：给-react-项目添加-ts-后。对于-ts-后缀和-tsx-后缀是有讲究的" class="headerlink" title="注意：给 react 项目添加 ts 后。对于 ts 后缀和 tsx 后缀是有讲究的"></a>注意：给 react 项目添加 ts 后。对于 ts 后缀和 tsx 后缀是有讲究的</h4><p>例如：<code>src/index.js</code> –&gt; 改为 ts 版本应该为 –&gt; <code>src/index.tsx(不是 ts)</code> 因为如果是 <code>ts</code> 的话 <code>&lt;React.StrictMode&gt;</code>这里会报错…需要的是 <code>tsx</code> 语法…</p>
]]></content>
      <categories>
        <category>TypeScript篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>WebPack 小知识</title>
    <url>/2021/12/13/WebPack-%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h4 id="source-map-最佳实践搭配"><a href="#source-map-最佳实践搭配" class="headerlink" title="source-map 最佳实践搭配"></a>source-map 最佳实践搭配</h4><p><a href="https://segmentfault.com/a/1190000008315937">链接 1</a><br><a href="https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/">链接 2</a><br><a href="http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html">链接 3</a><br><a href="https://www.youtube.com/watch?v=NkVes0UMe9Y">链接 4</a></p>
<h4 id="一个-webpack-官方提供的分析仓库-主要是教你如何使用-："><a href="#一个-webpack-官方提供的分析仓库-主要是教你如何使用-：" class="headerlink" title="一个 webpack 官方提供的分析仓库(主要是教你如何使用)："></a>一个 webpack 官方提供的分析仓库(主要是教你如何使用)：</h4><p><a href="https://github.com/webpack/analyse">点击</a><br>webpack 数据分析 可视化网页：<br><a href="http://webpack.github.io/analyse/#chunks">点击</a></p>
<h4 id="前端性能优化中，最重要的不是缓存，而是代码覆盖率上-code-coverage-看-imooc-webpack-4-8"><a href="#前端性能优化中，最重要的不是缓存，而是代码覆盖率上-code-coverage-看-imooc-webpack-4-8" class="headerlink" title="前端性能优化中，最重要的不是缓存，而是代码覆盖率上 code coverage 看 imooc webpack 4-8"></a>前端性能优化中，最重要的不是缓存，而是代码覆盖率上 code coverage 看 imooc webpack 4-8</h4><h4 id="按需加载-好像-就是懒加载"><a href="#按需加载-好像-就是懒加载" class="headerlink" title="按需加载 好像 就是懒加载"></a>按需加载 好像 就是懒加载</h4><h4 id="webpack-dev-server-中-proxy-能够实现跨域的原因：点击"><a href="#webpack-dev-server-中-proxy-能够实现跨域的原因：点击" class="headerlink" title="webpack-dev-server 中 proxy 能够实现跨域的原因：点击"></a>webpack-dev-server 中 proxy 能够实现跨域的原因：<a href="https://www.cnblogs.com/houxianzhou/p/14743623.html">点击</a></h4>]]></content>
  </entry>
  <entry>
    <title>WebSocket</title>
    <url>/2021/11/30/WebSocket/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>WebSocket篇</category>
      </categories>
      <tags>
        <tag>全栈</tag>
      </tags>
  </entry>
  <entry>
    <title>async/await</title>
    <url>/2021/10/31/async-await/</url>
    <content><![CDATA[<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p><code>Promise</code> n. 许诺，允诺；希望<br>这个单词其实和真实生活中的<strong>承诺</strong>非常像<br>我承诺要做什么什么… 总共会得到两种结果<br>一种是承诺得以实现(<code>resolved</code>) 一种是承诺没有被实现(<code>rejected</code>)<br><code>Promise</code> 接受一个参数，该参数必须是一个函数,并且这个函数有两个参数(<code>resolve</code>, <code>reject</code>)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span> + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (a === <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-comment">// resolve 可以传入任何我想传入的内容(任何类型)</span><br>    resolve(<span class="hljs-string">&#x27;Success&#x27;</span>)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// reject 可以传入任何我想传入的内容(任何类型)</span><br>    reject(<span class="hljs-string">&#x27;Failed&#x27;</span>);<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p><code>then</code> 的内容(参数)执行的是 <code>resolve</code> 传入的内容。即 p 完成它的承诺后，然后做什么什么事<br><code>catch</code> 的内容(参数)执行的是 <code>reject</code> 传入的内容。即 p 没有完成它的承诺，然后会做什么什么事</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">p.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(message)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;This is in the then&#x27;</span> + message);<br>&#125;).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">(message)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;This is in the catch&#x27;</span> + message);<br>&#125;)<br></code></pre></td></tr></table></figure>

<p><strong>举个例子来看看 Promise 给我们带来的变化…</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> userLeft = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">const</span> userWatchingCatMeme = <span class="hljs-literal">false</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">watchTutorialCallback</span>(<span class="hljs-params">callback, errorCallback</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (userLeft) &#123;<br>    errorCallback(&#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;User Left&#x27;</span>,<br>      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;:(&#x27;</span><br>    &#125;)<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (userWatchingCatMeme) &#123;<br>    errorCallback(&#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;User Watching Cat Meme&#x27;</span>,<br>      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;WebDevSimplified &lt; Cat&#x27;</span><br>    &#125;)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    callback(<span class="hljs-string">&#x27;Thumbs up and Subscribe&#x27;</span>)<br>  &#125;<br>&#125;<br>watchTutorialCallback(<span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Success &#x27;</span> + message);<br>&#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(error.name + <span class="hljs-string">&#x27; &#x27;</span> + error.message);<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>—————-用 Promise 来改造—————-</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span> 避免烦人的回调函数...<br>function watchTutorialPromise() &#123;<br>  let p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (userLeft) &#123;<br>      reject(&#123;<br>        name: <span class="hljs-string">&#x27;User Left&#x27;</span>,<br>        message: <span class="hljs-string">&#x27;:(&#x27;</span><br>      &#125;)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (userWatchingCatMeme) &#123;<br>      reject(&#123;<br>        name: <span class="hljs-string">&#x27;User Watching Cat Meme&#x27;</span>,<br>        message: <span class="hljs-string">&#x27;WebDevSimplified &lt; Cat&#x27;</span><br>      &#125;)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      resolve(<span class="hljs-string">&#x27;Thumbs up and Subscribe&#x27;</span>)<br>    &#125;<br>  &#125;)<br>  p.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(message)</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Success &#x27;</span> + message);<br>  &#125;).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">(error)</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(error.name + <span class="hljs-string">&#x27; &#x27;</span> + error.message);<br>  &#125;)<br>&#125;<br>watchTutorialPromise();<br></code></pre></td></tr></table></figure>

<p>————Promise 的其他一些功能————</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">const recordVideoOne = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>  <span class="hljs-regexp">//</span> resolve(<span class="hljs-string">&#x27;Video 1 Recorded&#x27;</span>)<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span> &#123;resolve(<span class="hljs-string">&#x27;Video 1 Recorded&#x27;</span>)&#125;, <span class="hljs-number">3000</span>);<br>&#125;)<br>const recordVideoTwo = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>  resolve(<span class="hljs-string">&#x27;Video 2 Recorded&#x27;</span>)<br>&#125;)<br>const recordVideoThree = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>  resolve(<span class="hljs-string">&#x27;Video 3 Recorded&#x27;</span>)<br>&#125;)<br><br><span class="hljs-regexp">//</span> 同时获取三个数据 (放入的参数是一个数组哦！)<br><span class="hljs-built_in">Promise</span>.all([<br>  recordVideoOne,<br>  recordVideoTwo,<br>  recordVideoThree<br>]).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(messages)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Promise.all&#x27;</span>, messages);<br>&#125;)<br><br><span class="hljs-regexp">//</span> 数据谁先到就用谁的<br><span class="hljs-built_in">Promise</span>.race([<br>  recordVideoOne,<br>  recordVideoTwo,<br>  recordVideoThree<br>]).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(messages)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Promise.race&#x27;</span>, messages);<br>&#125;)<br></code></pre></td></tr></table></figure>

<h4 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async/Await"></a>Async/Await</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeRequest</span>(<span class="hljs-params">location</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Making Request to <span class="hljs-subst">$&#123;location&#125;</span>`</span>);<br>    <span class="hljs-keyword">if</span> (location === <span class="hljs-string">&#x27;Google&#x27;</span>) &#123;<br>      resolve(<span class="hljs-string">&#x27;Google says hi&#x27;</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      reject(<span class="hljs-string">&#x27;We can only talk to Google&#x27;</span>)<br>    &#125;<br>  &#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processRequest</span>(<span class="hljs-params">response</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Processing response&#x27;</span>);<br>    resolve(<span class="hljs-string">`Extra Information + <span class="hljs-subst">$&#123;response&#125;</span>`</span>)<br>  &#125;)<br>&#125;<br><br>makeRequest(<span class="hljs-string">&#x27;Google&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Response Received&#x27;</span>);<br>  <span class="hljs-keyword">return</span> processRequest(response)<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">processResponse</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(processResponse);<br>&#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(err);<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>利用 <code>async</code> 和 <code>await</code> 来化简上述的代码</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">async</span> function doWork() &#123;<br>  <span class="hljs-regexp">//</span> <span class="hljs-keyword">try</span>……<span class="hljs-keyword">catch</span> 来解决<span class="hljs-built_in">Promise</span>.<span class="hljs-keyword">catch</span> 这种问题....<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-regexp">//</span> <span class="hljs-keyword">await</span> 放在会异步的代码前面。不放的话，返回的是<span class="hljs-built_in">Promise</span> 而非 <span class="hljs-built_in">Promise</span> 执行的结果...<br>    <span class="hljs-regexp">//</span> 当执行到<span class="hljs-keyword">await</span>的时候，程序会识别出<span class="hljs-keyword">await</span>后面是异步函数。然后就会跳出去执行其他同步函数。当<span class="hljs-keyword">await</span>的异步函数执行完且当前已无(<span class="hljs-keyword">async</span>函数外的)同步代码的时候，就会调回来继续执行后续代码<br>    <span class="hljs-regexp">//</span> 以及<span class="hljs-keyword">await</span> 必须要有<span class="hljs-keyword">async</span>来搭配才行...<br>    <span class="hljs-regexp">//</span> <span class="hljs-keyword">await</span> 就像在说 要等待 makeRequest 执行完后 才能继续往下运行(这里的往下运行是指的将结果赋值个变量response以及执行下一行代码...不是跳出去执行<span class="hljs-keyword">async</span>函数外部的同步代码)<br>    const response = <span class="hljs-keyword">await</span> makeRequest(<span class="hljs-string">&#x27;Google&#x27;</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Response Received&#x27;</span>);<br>    <span class="hljs-regexp">//</span> 等待processRequest执行完后，才会把结果赋值给processedResponse，才会往下一步执行<br>    const processedResponse = <span class="hljs-keyword">await</span> processRequest(response);<br>    <span class="hljs-built_in">console</span>.log(processedResponse);<br>  &#125; <span class="hljs-keyword">catch</span>(err) &#123;<br>    <span class="hljs-built_in">console</span>.log(err);<br>  &#125;<br>&#125;<br>doWork();<br></code></pre></td></tr></table></figure>

<p>为了推论上述的 await 代码跳转问题。有了下述代码论证</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>);<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2&#x27;</span>);<br>  <span class="hljs-comment">// fetch是异步请求。所以执行栈先跳转到当前async函数外面的同步代码并且fetch以及其附带的then、catch执行完后继续执行赋值代码给data以及完成下一行代码</span><br>  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/todos/1&#x27;</span>)<br>  .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())<br>  .then(<span class="hljs-function"><span class="hljs-params">json</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(json))<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3&#x27;</span>);<br>&#125;<br>func1();<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func2</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// console.log(&#x27;4&#x27;);是同步代码</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;4&#x27;</span>);<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/todos/2&#x27;</span>)<br>  .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())<br>  .then(<span class="hljs-function"><span class="hljs-params">json</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(json))<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;5&#x27;</span>);<br>&#125;<br>func2();<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;6&#x27;</span>);<br><span class="hljs-comment">// 执行结果顺序：</span><br><span class="hljs-comment">// 1、 2、 4、 6、 api_1、 3、 api_2、 5</span><br><span class="hljs-comment">// 或者 1、 2、 4、 6、 api_2、 5、 api_1、 3 (因为可能第二个接口请求数据更快所以更快完成await代码...)</span><br></code></pre></td></tr></table></figure>

<p>还有个细节： 使用 async 后，不管你是不是 promise 类型的都会被转化为 promise</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">例如：<br><span class="hljs-keyword">const</span> test = <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>&#125;         <span class="hljs-comment">// 普通函数</span><br><span class="hljs-keyword">const</span> test2 = <span class="hljs-keyword">async</span> () =&gt; &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">123</span>&#125;   <span class="hljs-comment">// promse版的函数</span><br>test().then(<span class="hljs-function">(<span class="hljs-params">param</span>) =&gt;</span> &#123;   <span class="hljs-comment">// 报错！</span><br>    <span class="hljs-built_in">console</span>.log(param);<br>&#125;)<br><br>test2().then(<span class="hljs-function"><span class="hljs-params">param</span> =&gt;</span> &#123;    <span class="hljs-comment">// 能够执行</span><br>    <span class="hljs-built_in">console</span>.log(param);<br>&#125;)<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>axios 使用方法</title>
    <url>/2021/10/25/axios-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://axios-http.com/zh/docs/intro">官方文档</a><br><code>Axios</code> 是一个基于 <code>promise</code> 网络请求库，既可以作用于 <code>node.js</code> 也可以作用于<code>浏览器</code>中。 它是 isomorphic 的(即同一套代码可以运行在<code>浏览器</code>和 <code>node.js</code> 中)。在服务端它使用原生 <code>node.js</code> http 模块, 而在客户端 (浏览端) 则使用 <code>XMLHttpRequests</code>。</p>
<blockquote>
<p>这个不像<code>fetch</code>。<code>axios</code> 是需要在项目中额外安装的</p>
</blockquote>
<p>下面的代码段全是基于此篇代码所写：<a href="https://github.com/Bruce-shuai/axios-study">axios-study</a></p>
<h3 id="Axios-基本玩法"><a href="#Axios-基本玩法" class="headerlink" title="Axios 基本玩法"></a>Axios 基本玩法</h3><blockquote>
<p><code>即 增、删、改、查</code></p>
</blockquote>
<h4 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h4><p>3 种书写方法(大同小异，推荐第二种，更直观…)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/* 方法1 */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTodo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  axios(&#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;GET&#x27;</span>,<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/todos&#x27;</span>,<br>    <span class="hljs-comment">// 参数项： _limit 应该是后端自己做的...</span><br>    <span class="hljs-attr">params</span>: &#123;<br>      <span class="hljs-attr">_limit</span>:<span class="hljs-number">5</span><br>    &#125;<br>  &#125;)<br>  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;res&#x27;</span>, res.data))<br>  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;err&#x27;</span>, err))<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/* 方法2 */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTodo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  axios.get(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/todos&#x27;</span>, &#123;<br>    <span class="hljs-attr">params</span>: &#123;<br>      <span class="hljs-attr">_limit</span>: <span class="hljs-number">5</span><br>    &#125;<br>  &#125;)<br>  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;res&#x27;</span>, res.data))<br>  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;err&#x27;</span>, err))<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/* 方法3 */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTodo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 因为get方法是默认方法，可以省略get的书写</span><br>  <span class="hljs-comment">// _limit=5是参数 直接以键值对的方式作为url参数来写入(这也是get 方法的用途...)</span><br>  axios(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/todos?_limit=5)</span><br><span class="hljs-string">  .then(res =&gt; console.log(&#x27;</span>res<span class="hljs-string">&#x27;, res.data))</span><br><span class="hljs-string">  .catch(err =&gt; console.log(&#x27;</span>err<span class="hljs-string">&#x27;, err))</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure>

<h4 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h4><p>两种书写方法(推荐第二种书写方法…)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// POST REQUEST</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">postTodo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  axios(&#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/todos&#x27;</span>,<br>    <span class="hljs-comment">// 不是params哦~ 这是POST的特殊之处...</span><br>    <span class="hljs-attr">data</span>: &#123;<br>      <span class="hljs-comment">// 这些属性是自己随意拟定的...</span><br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;New To Do&#x27;</span>,<br>      <span class="hljs-attr">complete</span>: <span class="hljs-literal">false</span>,<br>    &#125;<br>  &#125;)<br>  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;res&#x27;</span>, res.data))<br>  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;err&#x27;</span>, err))<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">postTodo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 下述方法同上</span><br>  axios.post(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/todos&#x27;</span>, &#123;<br>    <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;New To Do&#x27;</span>,<br>    <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span>,<br>  &#125;)<br>  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;res&#x27;</span>, res.data))<br>  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;err&#x27;</span>, err))<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="PUT-PATCH-方法"><a href="#PUT-PATCH-方法" class="headerlink" title="PUT/PATCH 方法"></a>PUT/PATCH 方法</h4><ul>
<li>PUT/PATCH 注意 PUT 一般是更换整体 而 PATCH 一般是更换局部内容</li>
<li>注意 一般使用 PUT 或 PATCH 都是要有参数具体指定修改哪一个内容的</li>
<li>所以 PUT 既要指定 params 属性 又要修改 data 属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">putTodo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  axios(&#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;PUT&#x27;</span>,<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/todos/1&#x27;</span>,<br>    <span class="hljs-comment">// 不是params哦~</span><br>    <span class="hljs-attr">data</span>: &#123;<br>      <span class="hljs-comment">// 这些属性是自己随意拟定的...</span><br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Update To Do&#x27;</span>,<br>      <span class="hljs-attr">completed</span>: <span class="hljs-literal">true</span>,<br>    &#125;<br>  &#125;)<br>  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;res&#x27;</span>, res.data))<br>  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;err&#x27;</span>, err))<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="DELETE-方法"><a href="#DELETE-方法" class="headerlink" title="DELETE 方法"></a>DELETE 方法</h4><p><code>DELETE</code> 这个只需指定<code>params</code> 而没有<code>data</code>属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deleteTodo</span>(<span class="hljs-params"></span>)</span>&#123;<br>  axios(&#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;DELETE&#x27;</span>,<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/todos/1&#x27;</span>,<br>  &#125;)<br>  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;res&#x27;</span>, res.data))<br>  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;err&#x27;</span>, err))<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Axios-高级玩法"><a href="#Axios-高级玩法" class="headerlink" title="Axios 高级玩法"></a>Axios 高级玩法</h3><h4 id="并发请求"><a href="#并发请求" class="headerlink" title="并发请求"></a>并发请求</h4><p><code>SIMULATANEOUS DATA</code> (同时请求多种数据)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getData</span>(<span class="hljs-params"></span>) </span>&#123;<br>  axios<br>  .all([<br>    axios.get(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/todos&#x27;</span>),<br>    axios.get(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/posts&#x27;</span>)<br>  ])<br>  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(res[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">console</span>.log(res[<span class="hljs-number">1</span>]);<br>  &#125;)<br>  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(err));<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 方法同上</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getData</span>(<span class="hljs-params"></span>) </span>&#123;<br>axios.<br>all([<br>  axios.get(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/todos&#x27;</span>),<br>  axios.get(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/posts&#x27;</span>)<br>]).then(axios.spread(<span class="hljs-function">(<span class="hljs-params">todos,posts</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(todos);<br>  <span class="hljs-built_in">console</span>.log(posts)<br>&#125;))<br>.catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(err))<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="INTERCEPTING-REQUESTS-amp-RESPONSES"><a href="#INTERCEPTING-REQUESTS-amp-RESPONSES" class="headerlink" title="INTERCEPTING REQUESTS &amp; RESPONSES"></a>INTERCEPTING REQUESTS &amp; RESPONSES</h4><p>拦截器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">axios.interceptors.request.use(<br>  <span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<br>      <span class="hljs-string">`<span class="hljs-subst">$&#123;config.method.toUpperCase()&#125;</span> request sent to <span class="hljs-subst">$&#123;config.url&#125;</span> at <span class="hljs-subst">$&#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime()&#125;</span>`</span><br>    )<br>    <span class="hljs-keyword">return</span> config;<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error);<br>  &#125;<br>)<br></code></pre></td></tr></table></figure>

<p><a href="https://segmentfault.com/a/1190000039030830">拦截器</a></p>
<h4 id="axios-default…-这个有待学习呀"><a href="#axios-default…-这个有待学习呀" class="headerlink" title="axios.default…. // 这个有待学习呀"></a>axios.default…. // 这个有待学习呀</h4>]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>classList的一系列操作</title>
    <url>/2021/11/25/classList%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h4 id="add-remove-value"><a href="#add-remove-value" class="headerlink" title="add / remove / value"></a>add / remove / value</h4><figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">/* index.html */</span><br>&lt;<span class="hljs-keyword">div</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">/* script.js */</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">div</span> = document.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);<br><span class="hljs-keyword">div</span>.classList.add(<span class="hljs-string">&#x27;new-class&#x27;</span>, <span class="hljs-string">&#x27;another-class&#x27;</span>)  <span class="hljs-comment">// 我可以一次性放入多个class 类名</span><br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-25-at-11.26.16-PM.png" alt="add/remove" width="400px"/>

<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">/* script.js */</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">div</span> = document.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);<br><span class="hljs-keyword">div</span>.classList.add(<span class="hljs-string">&#x27;new-class&#x27;</span>, <span class="hljs-string">&#x27;another-class&#x27;</span>)<br><span class="hljs-keyword">div</span>.classList.remover(<span class="hljs-string">&#x27;new-class&#x27;</span>, <span class="hljs-string">&#x27;another-class&#x27;</span>) <span class="hljs-comment">// 我也可以一次性删减多个 class 类名</span><br><br>console.log(<span class="hljs-keyword">div</span>.classList.value)   <span class="hljs-comment">// 我可以获取当前这个元素的所有类名</span><br></code></pre></td></tr></table></figure>

<h4 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h4><p>用于检查是否有这个类名( <code>true</code>表示有 <code>false</code>表示没有)</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">const <span class="hljs-keyword">div</span> = document.querySelector(&#x27;<span class="hljs-keyword">div</span>&#x27;);<br><span class="hljs-keyword">div</span>.classList.add(&#x27;new-<span class="hljs-built_in">class</span>&#x27;, &#x27;another-<span class="hljs-built_in">class</span>&#x27;);<br>console.<span class="hljs-built_in">log</span>(&#x27;new-<span class="hljs-built_in">class</span>&#x27;, <span class="hljs-keyword">div</span>.classList.<span class="hljs-keyword">contains</span>(&#x27;new-<span class="hljs-built_in">class</span>&#x27;));<br>console.<span class="hljs-built_in">log</span>(&#x27;nothing&#x27;, <span class="hljs-keyword">div</span>.classList.<span class="hljs-keyword">contains</span>(&#x27;nothing&#x27;));<br></code></pre></td></tr></table></figure>

<p>控制台打印结果：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">new</span>-<span class="hljs-keyword">class</span> <span class="hljs-keyword">true</span><br><span class="hljs-keyword">nothing</span> <span class="hljs-keyword">false</span><br></code></pre></td></tr></table></figure>

<h4 id="toggle"><a href="#toggle" class="headerlink" title="toggle"></a>toggle</h4><p>有两个参数，第一个参数 是 指定一个类名。第二个参数是布尔值。<code>true</code> 表示添加这个类名。<code>false</code>表示去掉这个类名</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">const</span> <span class="hljs-keyword">div</span> = document.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);<br><span class="hljs-keyword">div</span>.classList.add(<span class="hljs-string">&#x27;new-class&#x27;</span>, <span class="hljs-string">&#x27;another-class&#x27;</span>);<br><span class="hljs-keyword">div</span>.innerText = <span class="hljs-string">&#x27;点击&#x27;</span><br>let tog = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">div</span>.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, () =&gt; &#123;<br>  tog = tog ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>;<br>  console.log(tog);   <span class="hljs-comment">// 点击一次 变换一次</span><br>  <span class="hljs-keyword">div</span>.classList.toggle(<span class="hljs-string">&#x27;new&#x27;</span>, tog)<br>&#125;)<br><br>console.log(tog);  <span class="hljs-comment">// 这里始终为true  我估计是 因为这行代码在整个流程中只执行了一次。和react执行逻辑是不一样的</span><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-25-at-11.44.27-PM.gif" alt="toggle"></p>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>这里的 <code>forEach</code> 是来检索某个元素的系列类名的。操作和数组的<code>forEach</code>逻辑非常相似</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/* index.html */</span><br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">/* script.js */</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">div</span> = document.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);<br><span class="hljs-keyword">div</span>.classList.add(<span class="hljs-string">&#x27;new-class&#x27;</span>, <span class="hljs-string">&#x27;another-class&#x27;</span>);<br><br><span class="hljs-keyword">div</span>.classList.forEach(className =&gt; &#123;<br>  console.log(className);<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><code class="hljs smali">name<span class="hljs-built_in"></span><br><span class="hljs-built_in">new-class</span><br><span class="hljs-built_in"></span>another-class<br></code></pre></td></tr></table></figure>

<h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><p>用新的类名 代替旧的类名</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">const div = document.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);<br>div.classList.<span class="hljs-keyword">add</span>(<span class="hljs-string">&#x27;new-class&#x27;</span>, <span class="hljs-string">&#x27;another-class&#x27;</span>);<br><br>div.classList.replace(<span class="hljs-string">&#x27;new-class&#x27;</span>, <span class="hljs-string">&#x27;old-class&#x27;</span>)  // 用 <span class="hljs-built_in">old</span>-<span class="hljs-keyword">class</span> 代替了 <span class="hljs-built_in">new</span>-<span class="hljs-keyword">class</span><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-26-at-2.12.20-PM.png" alt="replace"></p>
]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>clean Code</title>
    <url>/2021/11/04/clean-Code/</url>
    <content><![CDATA[<h3 id="停止使用继承-迎接函数式组合"><a href="#停止使用继承-迎接函数式组合" class="headerlink" title="停止使用继承, 迎接函数式组合"></a>停止使用继承, 迎接函数式组合</h3><h4 id="继承法"><a href="#继承法" class="headerlink" title="继承法"></a>继承法</h4><p>试想用 class 的方法来完成一个继承问题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monster</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">attack</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span> attacked`</span>);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">walk</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span> walked`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建一个飞行的怪物类(利用传统的继承方法)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyingMonster</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Monster</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">fly</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span> flew`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建一个游泳的怪物类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwimmingMonster</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Monster</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">swim</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span> swam`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> bear = <span class="hljs-keyword">new</span> Monster(<span class="hljs-string">&#x27;bear&#x27;</span>);<br>bear.walk();<br>bear.attack();<br><br><span class="hljs-keyword">const</span> eagle = <span class="hljs-keyword">new</span> FlyingMonster(<span class="hljs-string">&#x27;eagle&#x27;</span>);<br>eagle.walk();<br>eagle.attack();<br>eagle.fly();<br><br><span class="hljs-keyword">const</span> shark = <span class="hljs-keyword">new</span> SwimmingMonster(<span class="hljs-string">&#x27;shark&#x27;</span>);<br>shark.walk();<br>shark.attack();<br>shark.swim();<br></code></pre></td></tr></table></figure>

<p>上述一些都比较的正常…<br>但是现在有个问题。如果我想创建一个即能够游泳又可以飞行的怪物类怎么办？<br>只能凉凉，js 只能支持单继承…<br>class FlyingSwimmingMonster extends FlyingMonster … ❌</p>
<h4 id="组合大法"><a href="#组合大法" class="headerlink" title="组合大法"></a>组合大法</h4><p>现在抛开传统的类继承方法<br>以函数式编程的思维来解决问题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个游泳函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swimmer</span>(<span class="hljs-params">&#123;name&#125;</span>) </span>&#123;<br>  <span class="hljs-comment">// 返回的是一个对象</span><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">swim</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span> swam`</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建一个飞行函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flyer</span>(<span class="hljs-params">&#123;name&#125;</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">fly</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span> fly`</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 现在我想创建一个能够产生会游泳的怪物的函数</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swimmingMonsterCreator</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> monster = &#123;<span class="hljs-attr">name</span>: name&#125;<br>  <span class="hljs-comment">// 这里的解构用得挺好</span><br>  <span class="hljs-keyword">return</span> &#123;<br>    ...monster,<br>    ...swimmer(monster)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 现在我想创建一个既可以游泳又可以飞行的怪物的函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SwimmingFlyingMonsterCreator</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> monster = &#123;<span class="hljs-attr">name</span>: name&#125;<br>  <span class="hljs-keyword">return</span> &#123;<br>    ...monster,<br>    ...swimmer(monster),<br>    ...flyer(monster)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj1 = swimmingMonsterCreator(<span class="hljs-string">&#x27;Monster&#x27;</span>);<br>obj1.swim();<br><br><span class="hljs-keyword">const</span> obj2 = SwimmingFlyingMonsterCreator(<span class="hljs-string">&#x27;Monster2&#x27;</span>)<br>obj2.swim();<br>obj2.fly();<br></code></pre></td></tr></table></figure>

<p>可见…组合的方法，非常方便且灵活~</p>
]]></content>
      <categories>
        <category>Clean Code篇</category>
      </categories>
      <tags>
        <tag>优质代码</tag>
      </tags>
  </entry>
  <entry>
    <title>css-color hsl</title>
    <url>/2021/11/06/css-color-hsl/</url>
    <content><![CDATA[<p>不多说…以后如果是自己来控制颜色，就采用 hsl()方法，而不是使用#十六进制、rgba、rgb 这种颜色控制…</p>
<p>hsl 的优势，下面我一一列举</p>
<h4 id="hsl-能让你具体把握住当前你想要的颜色大致是什么颜色"><a href="#hsl-能让你具体把握住当前你想要的颜色大致是什么颜色" class="headerlink" title="hsl 能让你具体把握住当前你想要的颜色大致是什么颜色"></a>hsl 能让你具体把握住当前你想要的颜色大致是什么颜色</h4><p>如果是十六进制、或者 rgb 你是不好掌握当前是什么颜色的。例如</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">/* css样式 */</span><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">40px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">40px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><span class="hljs-selector-class">.sixteen</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#3b3b3a</span>;         <span class="hljs-comment">// 你能看出这是什么颜色？？</span><br>&#125;<br><span class="hljs-selector-class">.rgb</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: rgb(<span class="hljs-number">59</span>, <span class="hljs-number">59</span>, <span class="hljs-number">58</span>); <span class="hljs-comment">// 你能看出这是什么颜色？？</span><br>&#125;<br><br><span class="hljs-comment">/* html样式 */</span><br>&lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;sixteen box&quot;</span>&gt;&lt;/div&gt;<br>&lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;rgb box&quot;</span>&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<p><strong>现在开始重点</strong><br><code>hsl</code> –&gt; <code>hue(色彩)</code>、<code>saturation(色彩饱和度)</code>、<code>lightness(明亮度)</code> 由这三者来控制</p>
<p><code>hue</code>的范围在 0<del>360<br><code>saturation</code>的范围在 0</del>100%<br><code>lightness</code>的范围在 0~100%</p>
<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-06-at-4.02.10-PM.7a8g6h4qx7w0.png" alt="hue"><br>hue 为 0 的时候是红色 为 360 的时候是紫色。刚好一圈…<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-06-at-4.03.59-PM.1j8w24mrjxz4.png" alt="saturation"><br>saturation 为 100%的时候是正常饱和色度<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-06-at-4.04.46-PM.2vzblim4bai0.png" alt="lightness"><br>lightness 为 50%的时候是正常亮度 0% 永远是黑色 100% 永远是白色</p>
<h4 id="hsl-的使用案例"><a href="#hsl-的使用案例" class="headerlink" title="hsl 的使用案例"></a>hsl 的使用案例</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">/* css样式 */</span><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">80px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">80px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.hsl</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: hsl(<span class="hljs-number">0</span>, <span class="hljs-number">100%</span>, <span class="hljs-number">50%</span>)<br>&#125;<br><span class="hljs-selector-class">.hsl</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: hsl(<span class="hljs-number">0</span>, <span class="hljs-number">100%</span>, <span class="hljs-number">30%</span>)  <span class="hljs-comment">/* 颜色会更暗 */</span><br>&#125;<br><br><span class="hljs-comment">/* html样式 */</span><br>&lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;hsl box&quot;</span>&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-06-at-4.09.56-PM.7bpmbivvdrg0.gif" alt="hsl效果显示1"></p>
<p>试想，如果使用的是十六进制或者 rgb。想要颜色更暗淡…是有多麻烦…</p>
<p><strong>下面结合 css variable 来让功能更加的强大</strong></p>
<figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">/* css样式 */</span><br>.<span class="hljs-built_in">box</span> &#123;<br>  <span class="hljs-built_in">width</span>: <span class="hljs-number">80</span>px;<br>  <span class="hljs-built_in">height</span>: <span class="hljs-number">80</span>px;<br>  margin: <span class="hljs-number">10</span>px;<br>&#125;<br><br>.hsl &#123;<br>  --<span class="hljs-built_in">hue</span>: <span class="hljs-number">200</span>;<br>  --<span class="hljs-built_in">saturation</span>: <span class="hljs-number">100</span>%;<br>  --lightness: <span class="hljs-number">50</span>%;<br>    <span class="hljs-built_in">background</span>-<span class="hljs-built_in">color</span>: hsl(var(--<span class="hljs-built_in">hue</span>), var(--<span class="hljs-built_in">saturation</span>), var(--lightness))<br>&#125;<br>.hsl:hover &#123;<br>  --lightness: <span class="hljs-number">30</span>%<br>&#125;<br><br><span class="hljs-comment">/* html样式 */</span><br>&lt;div class=<span class="hljs-string">&quot;hsl box&quot;</span>&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-06-at-4.17.09-PM.6pt7vgotqk40.gif" alt="hsl效果显示2"></p>
<p>这样，对于控制颜色更加的方便灵活了。</p>
<h4 id="额外话题"><a href="#额外话题" class="headerlink" title="额外话题"></a>额外话题</h4><p>我个人认为 hsl 对于灰色的表示其实不太方便。反倒用 十六进制挺好</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">十六进制 灰色： <span class="hljs-meta">#F3F3F3  等等系列</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>高级</tag>
      </tags>
  </entry>
  <entry>
    <title>css transform</title>
    <url>/2021/11/09/css-transform/</url>
    <content><![CDATA[<h4 id="rotate"><a href="#rotate" class="headerlink" title="rotate"></a>rotate</h4><blockquote>
<p>让元素旋转</p>
</blockquote>
<p>rotate<br>rotate3d</p>
<p>展示<code>rotate</code>效果:<br><code>rotate</code>有两个单位：<code>deg</code>、<code>turn</code><br><code>deg</code>范围：<code>0~360</code><br><code>turn</code>范围：<code>0~1</code></p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/* html文件 */</span><br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box--default rotate-0&quot;</span>&gt;Box&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box--default rotate-45&quot;</span>&gt;Box&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box--default rotate-90&quot;</span>&gt;Box&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box--default rotate-135&quot;</span>&gt;Box&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* css文件 */</span><br><br><span class="hljs-selector-class">.box--default</span> &#123;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">40px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">color</span>: white;<br>  <span class="hljs-attribute">background-color</span>: red;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>  <span class="hljs-attribute">align-items</span>: center;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2rem</span>;<br>&#125;<br><br><span class="hljs-selector-class">.rotate-0</span> &#123;<br>  <span class="hljs-comment">/*    transform: rotate(0turn);  */</span><br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">0deg</span>);<br>&#125;<br><br><span class="hljs-selector-class">.rotate-45</span> &#123;<br>  <span class="hljs-comment">/*    transform: rotate(0.125turn);  */</span><br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">45deg</span>);<br>&#125;<br><br><span class="hljs-selector-class">.rotate-90</span> &#123;<br>  <span class="hljs-comment">/*    transform: rotate(0.25turn);  */</span><br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">90deg</span>);<br>&#125;<br><br><span class="hljs-selector-class">.rotate-135</span> &#123;<br>  <span class="hljs-comment">/*     transform: rotate(0.375turn);  */</span><br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">135deg</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<!-- ![rotate](https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-09-at-8.09.50-PM.png) -->
<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-09-at-8.09.50-PM.png" width="200px">

<p><code>rotate3D</code>的使用比较的复杂，所以一般要使用 <code>rotate3D</code>，推荐单独使用<code>rotateX</code>、<code>rotateY</code>、<code>rotateZ</code>来进行控制</p>
<p>例如：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/* html文件 */</span><br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box--default rotateX-0&quot;</span>&gt;Box&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box--default rotateX-45&quot;</span>&gt;Box&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box--default rotateX-90&quot;</span>&gt;Box&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box--default rotateX-135&quot;</span>&gt;Box&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* css文件 */</span><br><span class="hljs-selector-class">.box--default</span> &#123;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">40px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">color</span>: white;<br>  <span class="hljs-attribute">background-color</span>: red;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>  <span class="hljs-attribute">align-items</span>: center;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2rem</span>;<br>&#125;<br><br><span class="hljs-selector-class">.rotateX-0</span> &#123;<br>  <span class="hljs-comment">/*    transform: rotate(0turn);  */</span><br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateX</span>(<span class="hljs-number">0deg</span>);<br>&#125;<br><br><span class="hljs-selector-class">.rotateX-45</span> &#123;<br>  <span class="hljs-comment">/*    transform: rotate(0.125turn);  */</span><br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateX</span>(<span class="hljs-number">45deg</span>);<br>&#125;<br><br><span class="hljs-selector-class">.rotateX-90</span> &#123;<br>  <span class="hljs-comment">/*    transform: rotate(0.25turn);  */</span><br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateX</span>(<span class="hljs-number">90deg</span>);<br>&#125;<br><br><span class="hljs-selector-class">.rotateX-135</span> &#123;<br>  <span class="hljs-comment">/*      transform: rotate(0.375turn);  */</span><br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateX</span>(<span class="hljs-number">135deg</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<!-- ![rotate3D-X](https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-09-at-8.28.03-PM.png) -->
<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-09-at-8.28.03-PM.png" alt="rotate3D-X" width="200px"/>

<p><code>rotateY</code></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;box--default rotateY-0&quot;</span>&gt;Box&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;box--default rotateY-45&quot;</span>&gt;Box&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;box--default rotateY-90&quot;</span>&gt;Box&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;box--default rotateY-135&quot;</span>&gt;Box&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box--default</span> &#123;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">40px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">color</span>: white;<br>  <span class="hljs-attribute">background-color</span>: red;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>  <span class="hljs-attribute">align-items</span>: center;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2rem</span>;<br>&#125;<br><br><span class="hljs-selector-class">.rotateY-0</span> &#123;<br>  <span class="hljs-comment">/*    transform: rotate(0turn);  */</span><br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">0deg</span>);<br>&#125;<br><br><span class="hljs-selector-class">.rotateY-45</span> &#123;<br>  <span class="hljs-comment">/*    transform: rotate(0.125turn);  */</span><br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">45deg</span>);<br>&#125;<br><br><span class="hljs-selector-class">.rotateY-90</span> &#123;<br>  <span class="hljs-comment">/*    transform: rotate(0.25turn);  */</span><br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">90deg</span>);<br>&#125;<br><br><span class="hljs-selector-class">.rotateY-135</span> &#123;<br>  <span class="hljs-comment">/*      transform: rotate(0.375turn);  */</span><br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">135deg</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<!--
![rotate3d-Y](https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-09-at-8.30.25-PM.png) -->

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-09-at-8.30.25-PM.png" alt="rotate3d-Y" width="200px"/>

<p><code>rotateZ</code></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;box--default rotateZ-0&quot;</span>&gt;Box&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;box--default rotateZ-45&quot;</span>&gt;Box&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;box--default rotateZ-90&quot;</span>&gt;Box&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;box--default rotateZ-135&quot;</span>&gt;Box&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box--default</span> &#123;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">40px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">color</span>: white;<br>  <span class="hljs-attribute">background-color</span>: red;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>  <span class="hljs-attribute">align-items</span>: center;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2rem</span>;<br>&#125;<br><br><span class="hljs-selector-class">.rotateZ-0</span> &#123;<br>  <span class="hljs-comment">/*    transform: rotate(0turn);  */</span><br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateZ</span>(<span class="hljs-number">0deg</span>);<br>&#125;<br><br><span class="hljs-selector-class">.rotateZ-45</span> &#123;<br>  <span class="hljs-comment">/*    transform: rotate(0.125turn);  */</span><br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateZ</span>(<span class="hljs-number">45deg</span>);<br>&#125;<br><br><span class="hljs-selector-class">.rotateZ-90</span> &#123;<br>  <span class="hljs-comment">/*    transform: rotate(0.25turn);  */</span><br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateZ</span>(<span class="hljs-number">90deg</span>);<br>&#125;<br><br><span class="hljs-selector-class">.rotateZ-135</span> &#123;<br>  <span class="hljs-comment">/*      transform: rotate(0.375turn);  */</span><br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateZ</span>(<span class="hljs-number">135deg</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<!-- ![rotate3d-Z](https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-09-at-8.32.31-PM.png) -->
<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-09-at-8.32.31-PM.png" src="rotate3d-Z" width="200px"/>

<p>事实上，<code>rotate3d</code>用到的情况很少。一般都是用的<code>rotate</code></p>
<h4 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h4><blockquote>
<p>让元素放大或缩小</p>
</blockquote>
<p>scale<br>scale3d</p>
<p><code>scale</code> 注意：放 1 个参数，和放 2 个参数的意义不同哦~</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima"><span class="hljs-comment">/* html文件 */</span><br><br>&lt;div class=<span class="hljs-string">&quot;box--default scale-1&quot;</span>&gt;Box&lt;/div&gt;<br>&lt;div class=<span class="hljs-string">&quot;box--default scale-2&quot;</span>&gt;Box&lt;/div&gt;<br><br><span class="hljs-comment">/* css文件 */</span><br>.<span class="hljs-built_in">box</span>--default &#123;<br>  margin: 100px;<br>  <span class="hljs-built_in">width</span>: 100px;<br>  <span class="hljs-built_in">height</span>: 100px;<br>  <span class="hljs-built_in">color</span>: white;<br>  <span class="hljs-built_in">background</span>-<span class="hljs-built_in">color</span>: red;<br>  <span class="hljs-built_in">display</span>: flex;<br>  justify-<span class="hljs-built_in">content</span>: <span class="hljs-built_in">center</span>;<br>  align-items: <span class="hljs-built_in">center</span>;<br>  <span class="hljs-built_in">font</span>-size: 2<span class="hljs-built_in">rem</span>;<br>&#125;<br><br>.<span class="hljs-built_in">scale</span>-<span class="hljs-number">1</span> &#123;<br>  <span class="hljs-built_in">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br>.<span class="hljs-built_in">scale</span>-<span class="hljs-number">2</span> &#123;<br><span class="hljs-comment">/*   transform: scale(2); <span class="hljs-comment">/* 比原来的样子整体放大了两倍 */</span></span><br><span class="hljs-comment">  transform: scale(2, 2); <span class="hljs-comment">/* 比原来的样子在x、y轴分别放大了两倍 */</span></span><br><span class="hljs-comment">&#125;</span><br></code></pre></td></tr></table></figure>

<!-- ![scale](https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-09-at-8.40.13-PM.png) -->

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-09-at-8.40.13-PM.png" alt="scale" width="200px"/>

<p>和上述的<code>rotate3D</code>类似，这个<code>scale</code>也有<code>scale3D</code>。也建议分别使用<code>scaleX</code>、<code>scaleY</code>、<code>scaleZ</code>来表示…不过多赘述</p>
<h4 id="比较难的用法：-translate"><a href="#比较难的用法：-translate" class="headerlink" title="比较难的用法： translate"></a>比较难的用法： translate</h4><blockquote>
<p>用于位置的移动</p>
</blockquote>
<p>translate<br>translate3D</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">/* html文件 */</span><br>&lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;box--default&quot;</span>&gt;Box&lt;/div&gt;<br>&lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;box--default tranlate-30&quot;</span>&gt;Box&lt;/div&gt;<br>&lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;box--default tranlate-30-40&quot;</span>&gt;Box&lt;/div&gt;<br><br><span class="hljs-comment">/* css文件 */</span><br><span class="hljs-selector-class">.box--default</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">color</span>: white;<br>  <span class="hljs-attribute">background-color</span>: red;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>  <span class="hljs-attribute">align-items</span>: center;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2rem</span>;<br>&#125;<br><span class="hljs-selector-class">.tranlate-30</span> &#123;<br>  <span class="hljs-comment">// 正值是向右移动  负值是向左移动</span><br>  <span class="hljs-attribute">transform</span>: translate(<span class="hljs-number">100px</span>);<br>&#125;<br><span class="hljs-selector-class">.tranlate-30-40</span> &#123;<br>  <span class="hljs-comment">/*  向右移动100px，再向下移动100px  */</span><br>  <span class="hljs-attribute">transform</span>: translate(<span class="hljs-number">100px</span>, <span class="hljs-number">100px</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<!-- ![translate](https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-09-at-8.50.55-PM.png) -->

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-09-at-8.50.55-PM.png" alt="translate" width="200px"/>

<p><code>translateX</code>、<code>translateY</code> 同理…<br>注意：<code>translateZ</code>效果只有在 3d 图中才会发挥效果</p>
<p><code>translate</code> 的另一个单位 <code>%</code></p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima"><span class="hljs-comment">/* html文件 */</span><br>&lt;div class=<span class="hljs-string">&quot;box--default&quot;</span>&gt;Box&lt;/div&gt;<br>&lt;div class=<span class="hljs-string">&quot;box--default hundred-100&quot;</span>&gt;Box&lt;/div&gt;<br><br><span class="hljs-comment">/* css文件 */</span><br>.<span class="hljs-built_in">box</span>--default &#123;<br>  <span class="hljs-built_in">width</span>: 100px;<br>  <span class="hljs-built_in">height</span>: 100px;<br>  <span class="hljs-built_in">color</span>: white;<br>  <span class="hljs-built_in">background</span>-<span class="hljs-built_in">color</span>: red;<br>  <span class="hljs-built_in">display</span>: flex;<br>  justify-<span class="hljs-built_in">content</span>: <span class="hljs-built_in">center</span>;<br>  align-items: <span class="hljs-built_in">center</span>;<br>  <span class="hljs-built_in">font</span>-size: 2<span class="hljs-built_in">rem</span>;<br>&#125;<br><br>.hundred-<span class="hljs-number">100</span> &#123;<br>  <span class="hljs-comment">/* 表示向右移动自身宽度的100%的位置 */</span><br>  <span class="hljs-built_in">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">100</span><span class="hljs-symbol">%</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<!-- ![translate-100%](https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-09-at-9.05.57-PM.png) -->

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-09-at-9.05.57-PM.png" alt="translate-100%" width="200px"/>

<p><strong>translate 常用于调整元素居中</strong></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">/* html文件 */</span><br>&lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;box--default&quot;</span>&gt;&lt;/div&gt;<br><br><span class="hljs-comment">/* css文件 */</span><br><span class="hljs-selector-class">.box--default</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">color</span>: white;<br>  <span class="hljs-attribute">background-color</span>: red;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2rem</span>;<br>&#125;<br><br><span class="hljs-selector-class">.box--default</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;After&quot;</span>;<br>  <span class="hljs-attribute">position</span>: absolute;<br><br>  <span class="hljs-comment">/*  相对于父元素 以子元素的左上角为动点，往下移动50%的位置，往右移动50%的距离  */</span><br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br><br>  <span class="hljs-comment">/*  因为是参照的子元素本身，所以向左移动50%，向上移动50%都是参照的自身大小  */</span><br>  <span class="hljs-attribute">transform</span>: translate(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<!-- ![translate居中设置](https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-10-at-8.33.12-AM.png) -->

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-10-at-8.33.12-AM.png" alt="translate居中设置" width="200px"/>

<h4 id="skew"><a href="#skew" class="headerlink" title="skew"></a>skew</h4><p><code>skew</code>(如果只有一个参数则默认是沿着 x 轴歪斜，如果有两个参数，左边一个是沿着 x 轴歪斜，右边一个沿着 y 轴歪斜)<br><code>skewX</code>(沿着 x 轴歪斜)<br><code>skewY</code>(沿着 y 轴歪斜)</p>
<p>这个 <code>skew</code> 是没有<code>3d</code>效果的</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima"><span class="hljs-comment">/* html文件 */</span><br>&lt;div class=<span class="hljs-string">&quot;box--default skew-30&quot;</span>&gt;Box&lt;/div&gt;<br><br><span class="hljs-comment">/* css文件 */</span><br>.<span class="hljs-built_in">box</span>--default &#123;<br>  <span class="hljs-built_in">display</span>: flex;<br>  justify-<span class="hljs-built_in">content</span>: <span class="hljs-built_in">center</span>;<br>  align-items: <span class="hljs-built_in">center</span>;<br>  <span class="hljs-built_in">width</span>: 100px;<br>  <span class="hljs-built_in">height</span>: 100px;<br>  margin: 50px;<br>  <span class="hljs-built_in">color</span>: white;<br>  <span class="hljs-built_in">background</span>-<span class="hljs-built_in">color</span>: red;<br>  <span class="hljs-built_in">font</span>-size: 2<span class="hljs-built_in">rem</span>;<br>&#125;<br><br>.skew-<span class="hljs-number">30</span> &#123;<br>  <span class="hljs-built_in">transform</span>: skew(30deg)<br>&#125;<br></code></pre></td></tr></table></figure>

<!-- ![skew效果](https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-10-at-8.43.08-AM.png) -->

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-10-at-8.43.08-AM.png" alt="skew效果" width="200px"/>

<h4 id="结合各种-transform-属性-以及-注意事项"><a href="#结合各种-transform-属性-以及-注意事项" class="headerlink" title="结合各种 transform 属性 以及 注意事项"></a>结合各种 transform 属性 以及 注意事项</h4><p>我可以任意任意组合：<code>rotate</code>、<code>scale</code>、<code>translate</code>、<code>skew</code></p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima"><span class="hljs-comment">/* html文件 */</span><br>&lt;div class=<span class="hljs-string">&quot;box--default&quot;</span>&gt;Box&lt;/div&gt;<br>&lt;div class=<span class="hljs-string">&quot;box--default combine&quot;</span>&gt;Box&lt;/div&gt;<br><br><span class="hljs-comment">/* css文件 */</span><br>.<span class="hljs-built_in">box</span>--default &#123;<br>  <span class="hljs-built_in">display</span>: flex;<br>  justify-<span class="hljs-built_in">content</span>: <span class="hljs-built_in">center</span>;<br>  align-items: <span class="hljs-built_in">center</span>;<br>  <span class="hljs-built_in">width</span>: 100px;<br>  <span class="hljs-built_in">height</span>: 100px;<br>  margin: 50px;<br>  <span class="hljs-built_in">color</span>: white;<br>  <span class="hljs-built_in">background</span>-<span class="hljs-built_in">color</span>: red;<br>  <span class="hljs-built_in">font</span>-size: 2<span class="hljs-built_in">rem</span>;<br>&#125;<br>.<span class="hljs-built_in">combine</span> &#123;<br>  <span class="hljs-built_in">transform</span>: rotate(45deg) <span class="hljs-built_in">translate</span>(100px)<br>&#125;<br><br></code></pre></td></tr></table></figure>

<!-- ![transform属性结合1](https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-10-at-8.49.56-AM.png) -->

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-10-at-8.49.56-AM.png" alt="transform属性结合" width="200px"/>

<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>使用 transform 的属性组合，要注意一个问题， <strong><code>transform</code>不支持属性覆盖</strong></p>
<p>例如：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima"><span class="hljs-comment">/* html文件 */</span><br>&lt;div class=<span class="hljs-string">&quot;box--default&quot;</span>&gt;Box&lt;/div&gt;<br>&lt;div class=<span class="hljs-string">&quot;box--default combine&quot;</span>&gt;Box&lt;/div&gt;<br><br><span class="hljs-comment">/* css文件 */</span><br>.<span class="hljs-built_in">box</span>--default &#123;<br>  <span class="hljs-built_in">display</span>: flex;<br>  justify-<span class="hljs-built_in">content</span>: <span class="hljs-built_in">center</span>;<br>  align-items: <span class="hljs-built_in">center</span>;<br>  <span class="hljs-built_in">width</span>: 100px;<br>  <span class="hljs-built_in">height</span>: 100px;<br>  margin: 50px;<br>  <span class="hljs-built_in">color</span>: white;<br>  <span class="hljs-built_in">background</span>-<span class="hljs-built_in">color</span>: red;<br>  <span class="hljs-built_in">font</span>-size: 2<span class="hljs-built_in">rem</span>;<br>&#125;<br>.<span class="hljs-built_in">combine</span> &#123;<br>  <span class="hljs-built_in">transform</span>: rotate(45deg) <span class="hljs-built_in">translate</span>(100px);<br>&#125;<br>.<span class="hljs-built_in">combine</span> &#123;<br>  <span class="hljs-built_in">transform</span>: rotate(90deg);<br>&#125;<br></code></pre></td></tr></table></figure>

<!-- ![属性覆盖失效](https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-10-at-8.54.14-AM.png) -->

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-10-at-8.54.14-AM.png" alt="属性覆盖失效" width="200px"/>

<p>上图看见，尽管我只是将<code>rotate</code>属性进行覆盖，但是由于没有重新设置<code>translate</code>，这在<code>transform</code>中是不会识别到<code>translate</code>效果的。所以，<code>translate</code>如果想要覆盖某个属性，则需所有属性都进行重写才行…</p>
<h5 id="利用-css-变量解决上述这种覆盖问题-css-变量是牛爷爷"><a href="#利用-css-变量解决上述这种覆盖问题-css-变量是牛爷爷" class="headerlink" title="利用 css 变量解决上述这种覆盖问题(css 变量是牛爷爷)"></a>利用 css 变量解决上述这种覆盖问题(css 变量是牛爷爷)</h5><figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima"><span class="hljs-comment">/* html文件 */</span><br>&lt;div class=<span class="hljs-string">&quot;box--default&quot;</span>&gt;Box&lt;/div&gt;<br>&lt;div class=<span class="hljs-string">&quot;box--default big&quot;</span>&gt;Box&lt;/div&gt;<br>&lt;div class=<span class="hljs-string">&quot;box--default move&quot;</span>&gt;Box&lt;/div&gt;<br>&lt;div class=<span class="hljs-string">&quot;box--default big move&quot;</span>&gt;Box&lt;/div&gt;<br><br><span class="hljs-comment">/* css文件 */</span><br>.<span class="hljs-built_in">box</span>--default &#123;<br>  <span class="hljs-built_in">display</span>: flex;<br>  justify-<span class="hljs-built_in">content</span>: <span class="hljs-built_in">center</span>;<br>  align-items: <span class="hljs-built_in">center</span>;<br>  <span class="hljs-built_in">width</span>: 100px;<br>  <span class="hljs-built_in">height</span>: 100px;<br>  margin: 50px;<br>  <span class="hljs-built_in">color</span>: white;<br>  <span class="hljs-built_in">background</span>-<span class="hljs-built_in">color</span>: red;<br>  <span class="hljs-built_in">font</span>-size: 2<span class="hljs-built_in">rem</span>;<br><br>  <span class="hljs-comment">/*  利用css变量  */</span><br>  <span class="hljs-built_in">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-built_in">var</span>(--<span class="hljs-built_in">scale</span>, <span class="hljs-number">1.2</span>)) translateX(<span class="hljs-built_in">var</span>(--<span class="hljs-built_in">translate</span>-x, 50px))<br>&#125;<br><br>.big &#123;<br>  --<span class="hljs-built_in">scale</span>: <span class="hljs-number">1.5</span>;<br>&#125;<br>.move &#123;<br>  --<span class="hljs-built_in">translate</span>-x: 150px;<br>&#125;<br></code></pre></td></tr></table></figure>

<!-- ![css变量+transform](https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-10-at-9.06.25-AM.png) -->

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-10-at-9.06.25-AM.png" alt="css变量+transform" width="250px"/>
]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>css variable</title>
    <url>/2021/11/06/css-variable/</url>
    <content><![CDATA[<p>如果你想使用<code>CSS Variable</code>。大多数情况下，你可以把<code>CSS Variable</code>放在<code>:root</code>或者<code>html</code>选择器上。因为<code>CSS Variable</code>其实也和其他的 css 属性无太多区别…放在<strong>文件顶部</strong>其属性可以被后续选择器继承或覆盖属性等等操作。</p>
<h4 id="CSS-Variable定义方法"><a href="#CSS-Variable定义方法" class="headerlink" title="CSS Variable定义方法"></a><code>CSS Variable</code>定义方法</h4><blockquote>
<p><code>--dataName</code> 格式。 名字前有两条横杠</p>
</blockquote>
<p>例如：<code>--div-background-color</code>、<code>--text-color</code></p>
<h4 id="CSS-Variable使用方法"><a href="#CSS-Variable使用方法" class="headerlink" title="CSS Variable使用方法"></a><code>CSS Variable</code>使用方法</h4><blockquote>
<p>css 属性: var(–dataName)</p>
</blockquote>
<p>重点在于 var(),这个是让<code>CSS Variable</code>发挥作用的关键步骤</p>
<h4 id="下面进行代码实战"><a href="#下面进行代码实战" class="headerlink" title="下面进行代码实战"></a>下面进行代码实战</h4><p>CSS 变量用法灵活~<br>无任何 css 修饰的情况下</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/* html代码段 */</span><br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;one&quot;</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span>&gt;<span class="hljs-number">1</span>-<span class="hljs-number">1</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span>&gt;<span class="hljs-number">1</span>-<span class="hljs-number">2</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span>&gt;<span class="hljs-number">1</span>-<span class="hljs-number">3</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;two&quot;</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span>&gt;<span class="hljs-number">2</span>-<span class="hljs-number">1</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span>&gt;<span class="hljs-number">2</span>-<span class="hljs-number">2</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<p>页面显示效果：<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-06-at-8.10.05-AM.3qstbnzfywu0.png" alt="页面显示效果1"></p>
<p>好！ 现在样式修饰。 注意一下，我如何使用的 <code>css 代码段</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* css代码段 */</span><br><span class="hljs-selector-pseudo">:root</span> &#123;<br>  --<span class="hljs-selector-tag">div</span>-<span class="hljs-attribute">background-color</span>: red;<br>  --text-<span class="hljs-attribute">color</span>: black;<br>  --<span class="hljs-selector-tag">div</span>-<span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  --<span class="hljs-selector-tag">div</span>-<span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">var</span>(--div-background-color);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/* html代码段 */</span><br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;one&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;<span class="hljs-number">1</span>-<span class="hljs-number">1</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;<span class="hljs-number">1</span>-<span class="hljs-number">2</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;<span class="hljs-number">1</span>-<span class="hljs-number">3</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;two&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;<span class="hljs-number">2</span>-<span class="hljs-number">1</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;<span class="hljs-number">2</span>-<span class="hljs-number">2</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-06-at-8.31.02-AM.5x1yurh3ff80.png" alt="页面显示效果2"></p>
<h4 id="CSS-Variable-属性值覆盖"><a href="#CSS-Variable-属性值覆盖" class="headerlink" title="CSS Variable 属性值覆盖"></a><code>CSS Variable</code> 属性值覆盖</h4><p>好，现在我来展示一下<code>CSS Variable</code>属性<strong>覆盖效果</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-pseudo">:root</span> &#123;<br>  --<span class="hljs-selector-tag">div</span>-<span class="hljs-attribute">background-color</span>: red;<br>  --text-<span class="hljs-attribute">color</span>: black;<br>  --<span class="hljs-selector-tag">div</span>-<span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  --<span class="hljs-selector-tag">div</span>-<span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">var</span>(--div-background-color);<br>&#125;<br><span class="hljs-selector-class">.one</span> &#123;<br>  --<span class="hljs-selector-tag">div</span>-<span class="hljs-attribute">background-color</span>: blue;   // 此时，--<span class="hljs-selector-tag">div</span>-<span class="hljs-attribute">background-color</span>变量的值是blue，覆盖上了上述的red(仅限所有被<span class="hljs-selector-class">.one</span> 所在元素及元素包裹的部分)<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-06-at-8.35.11-AM.2kv9gq9zriw0.png" alt="页面显示效果3"></p>
<h4 id="CSS-Variable优势之修改一次全局生效…"><a href="#CSS-Variable优势之修改一次全局生效…" class="headerlink" title="CSS Variable优势之修改一次全局生效…"></a><code>CSS Variable</code>优势之修改一次全局生效…</h4><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-pseudo">:root</span> &#123;<br>  --<span class="hljs-selector-tag">div</span>-<span class="hljs-attribute">background-color</span>: red;<br>  --text-<span class="hljs-attribute">color</span>: black;<br>  --<span class="hljs-selector-tag">div</span>-<span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  --<span class="hljs-selector-tag">div</span>-<span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">var</span>(--div-background-color);<br>&#125;<br><br><span class="hljs-selector-class">.one</span> &#123;<br>  --<span class="hljs-selector-tag">div</span>-<span class="hljs-attribute">background-color</span>: blue;<br>  --text-<span class="hljs-attribute">color</span>: white;<br>&#125;<br><br>// one-one 和 one-two 都拥有了css 变量效果。<br>// 如果我修改<span class="hljs-selector-pseudo">:root</span> 中--<span class="hljs-selector-tag">div</span>-<span class="hljs-attribute">padding</span>值。则one-one 和 one-two对应<span class="hljs-attribute">padding</span>都会跟着变化<br><span class="hljs-selector-class">.one-one</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-built_in">var</span>(--div-padding);<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-built_in">var</span>(--div-margin);<br>&#125;<br><br><span class="hljs-selector-class">.one-two</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-built_in">var</span>(--div-padding);<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-built_in">var</span>(--div-margin);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/* html代码段 */</span><br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;one&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;one-one child&quot;</span>&gt;<span class="hljs-number">1</span>-<span class="hljs-number">1</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;one-two child&quot;</span>&gt;<span class="hljs-number">1</span>-<span class="hljs-number">2</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;<span class="hljs-number">1</span>-<span class="hljs-number">3</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;two&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;<span class="hljs-number">2</span>-<span class="hljs-number">1</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;<span class="hljs-number">2</span>-<span class="hljs-number">2</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-06-at-8.45.55-AM.7iz1ichqsao0.png" alt="页面显示效果4"></p>
<h4 id="CSS-Variable优势之专属回调函数，用于CSS-Variable未被定义时"><a href="#CSS-Variable优势之专属回调函数，用于CSS-Variable未被定义时" class="headerlink" title="CSS Variable优势之专属回调函数，用于CSS Variable未被定义时"></a><code>CSS Variable</code>优势之专属回调函数，用于<code>CSS Variable</code>未被定义时</h4><p>接着上面的例子来讲：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-pseudo">:root</span> &#123;<br>  --<span class="hljs-selector-tag">div</span>-<span class="hljs-attribute">background-color</span>: red;<br>  --text-<span class="hljs-attribute">color</span>: black;<br>  --<span class="hljs-selector-tag">div</span>-<span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  --<span class="hljs-selector-tag">div</span>-<span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><br><span class="hljs-comment">/* 放置一个未被定义的css变量 --background-color */</span><br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-comment">/* pink 属于默认值。当--background-color未被定义时，pink显示效果 */</span><br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">var</span>(--background-color, pink)<br>&#125;<br><br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">var</span>(--div-background-color);<br>  <span class="hljs-attribute">color</span>:<span class="hljs-built_in">var</span>(--text-color);<br>&#125;<br><br><span class="hljs-selector-class">.one</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: blue;<br>  --text-<span class="hljs-attribute">color</span>: white;<br>&#125;<br><br><span class="hljs-selector-class">.one-one</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-built_in">var</span>(--div-padding);<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-built_in">var</span>(--div-margin);<br>&#125;<br><br><span class="hljs-selector-class">.one-two</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-built_in">var</span>(--div-padding);<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-built_in">var</span>(--div-margin);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意：<code>CSS Variable</code> 未被定义的问题可以用 JS 来解决…</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// JS 代码段</span><br>document.get<span class="hljs-constructor">ElementById(&#x27;<span class="hljs-params">dark</span>-<span class="hljs-params">theme</span>-<span class="hljs-params">btn</span>&#x27;)</span>.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">click</span>&#x27;, ()</span> =&gt; &#123;<br>  document.documentElement.style.set<span class="hljs-constructor">Property(&#x27;--<span class="hljs-params">background</span>-<span class="hljs-params">color</span>&#x27;, &#x27;#333&#x27;)</span><br>&#125;)<br>document.get<span class="hljs-constructor">ElementById(&#x27;<span class="hljs-params">light</span>-<span class="hljs-params">theme</span>-<span class="hljs-params">btn</span>&#x27;)</span>.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">click</span>&#x27;, ()</span> =&gt; &#123;<br>  document.documentElement.style.set<span class="hljs-constructor">Property(&#x27;--<span class="hljs-params">background</span>-<span class="hljs-params">color</span>&#x27;, &#x27;#<span class="hljs-params">fff</span>&#x27;)</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">/* html 代码段 */<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;one&quot;</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;one-one child&quot;</span>&gt;<span class="hljs-number">1</span><span class="hljs-number">-1</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;one-two child&quot;</span>&gt;<span class="hljs-number">1</span><span class="hljs-number">-2</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;<span class="hljs-number">1</span><span class="hljs-number">-3</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;two&quot;</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;<span class="hljs-number">2</span><span class="hljs-number">-1</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;<span class="hljs-number">2</span><span class="hljs-number">-2</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;button <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;dark-theme-btn&quot;</span>&gt;Dark-Theme&lt;/button&gt;<br>  &lt;button <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;light-theme-btn&quot;</span>&gt;Light-Theme&lt;/button&gt;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-06-at-9.15.52-AM.3bf5galhx4w0.gif" alt="页面效果展示5"></p>
]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>高级</tag>
      </tags>
  </entry>
  <entry>
    <title>css 三角形</title>
    <url>/2021/11/10/css-%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
    <content><![CDATA[<p>三角形是 CSS 中最常用的形状之一，因为它们非常适合对话框弹出、工具提示等</p>
<h4 id="普通方法-取巧采用遮盖方法"><a href="#普通方法-取巧采用遮盖方法" class="headerlink" title="普通方法(取巧采用遮盖方法)"></a>普通方法(取巧采用遮盖方法)</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">/* html文件 */</span><br>&lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;triangle&quot;</span>&gt;&lt;/div&gt;<br><br><span class="hljs-comment">/* css文件 */</span><br><span class="hljs-selector-class">.triangle</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: hsl(<span class="hljs-number">0</span>, <span class="hljs-number">100%</span>, <span class="hljs-number">50%</span>);<br><br>  <span class="hljs-comment">/*  使用::after 日常子绝父相  */</span><br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><br><span class="hljs-selector-class">.triangle</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">background-color</span>: hsl(<span class="hljs-number">50</span>, <span class="hljs-number">100%</span>, <span class="hljs-number">50%</span>);<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">40px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">40px</span>;<br>  <span class="hljs-attribute">right</span>: -<span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">30px</span>;<br>  <span class="hljs-attribute">transform</span>: rotate(<span class="hljs-number">45deg</span>);<br>  <span class="hljs-attribute">z-index</span>:-<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-10-at-2.12.12-PM.png" alt="取巧的三角形" width="100px">

<h4 id="利用元素的-border-来实现"><a href="#利用元素的-border-来实现" class="headerlink" title="利用元素的 border 来实现"></a>利用元素的 border 来实现</h4><figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima"><span class="hljs-comment">/* html文件 */</span><br>&lt;div class=<span class="hljs-string">&quot;triangle&quot;</span>&gt;&lt;/div&gt;<br><br><span class="hljs-comment">/* css文件 */</span><br>.<span class="hljs-built_in">triangle</span> &#123;<br>  <span class="hljs-built_in">width</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">height</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">border</span>-<span class="hljs-built_in">width</span>:40px;<br>  <span class="hljs-built_in">border</span>-<span class="hljs-built_in">style</span>: solid;<br>  <span class="hljs-built_in">border</span>-top-<span class="hljs-built_in">color</span>: hsl(<span class="hljs-number">0</span>, <span class="hljs-number">100</span><span class="hljs-symbol">%</span>, <span class="hljs-number">50</span><span class="hljs-symbol">%</span>);<br>  <span class="hljs-built_in">border</span>-right-<span class="hljs-built_in">color</span>: hsl(<span class="hljs-number">40</span>, <span class="hljs-number">100</span><span class="hljs-symbol">%</span>, <span class="hljs-number">50</span><span class="hljs-symbol">%</span>);<br>  <span class="hljs-built_in">border</span>-bottom-<span class="hljs-built_in">color</span>: hsl(<span class="hljs-number">80</span>, <span class="hljs-number">100</span><span class="hljs-symbol">%</span>, <span class="hljs-number">50</span><span class="hljs-symbol">%</span>);<br>  <span class="hljs-built_in">border</span>-left-<span class="hljs-built_in">color</span>: hsl(<span class="hljs-number">120</span>, <span class="hljs-number">100</span><span class="hljs-symbol">%</span>, <span class="hljs-number">50</span><span class="hljs-symbol">%</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-10-at-2.21.29-PM.png" alt="利用border实现三角形" width="100px">

<p>进一步获取单个三角形</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima"><span class="hljs-comment">/* html文件 */</span><br>&lt;div class=<span class="hljs-string">&quot;triangle&quot;</span>&gt;&lt;/div&gt;<br><br><span class="hljs-comment">/* css文件 */</span><br>.<span class="hljs-built_in">triangle</span> &#123;<br>  <span class="hljs-built_in">width</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">height</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">border</span>-<span class="hljs-built_in">width</span>:40px;<br>  <span class="hljs-built_in">border</span>-<span class="hljs-built_in">style</span>: solid;<br>  <span class="hljs-built_in">border</span>: 50px solid <span class="hljs-built_in">transparent</span>;<br>  <span class="hljs-built_in">border</span>-top-<span class="hljs-built_in">color</span>: hsl(<span class="hljs-number">0</span>, <span class="hljs-number">100</span><span class="hljs-symbol">%</span>, <span class="hljs-number">50</span><span class="hljs-symbol">%</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-10-at-2.23.36-PM.png" alt="利用border实现三角形2" width="100px">

<p>好，我现在结合上面两种方法：实现一种比较优秀的制作箭头的方法：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima"><span class="hljs-comment">/* html文件 */</span><br>&lt;div class=<span class="hljs-string">&quot;triangle&quot;</span>&gt;&lt;/div&gt;<br><br><span class="hljs-comment">/* css文件 */</span><br>.<span class="hljs-built_in">triangle</span> &#123;<br>  <span class="hljs-built_in">width</span>: 100px;<br>  <span class="hljs-built_in">height</span>: 100px;<br>  <span class="hljs-built_in">background</span>-<span class="hljs-built_in">color</span>: hsl(<span class="hljs-number">0</span>, <span class="hljs-number">100</span><span class="hljs-symbol">%</span>, <span class="hljs-number">50</span><span class="hljs-symbol">%</span>);<br><br>  <span class="hljs-comment">/*  要使用::after, 所以采用子绝父相  */</span><br>  <span class="hljs-built_in">position</span>: relative;<br>&#125;<br><br>.<span class="hljs-built_in">triangle</span>::after &#123;<br>  <span class="hljs-built_in">content</span>: &#x27;&#x27;;<br>  <span class="hljs-built_in">position</span>: absolute;<br>  --self-<span class="hljs-built_in">border</span>: 40px;<br>  <span class="hljs-built_in">border</span>: <span class="hljs-built_in">var</span>(--self-<span class="hljs-built_in">border</span>) solid <span class="hljs-built_in">transparent</span>;<br>  <span class="hljs-built_in">border</span>-left-<span class="hljs-built_in">color</span>: hsl(<span class="hljs-number">50</span>, <span class="hljs-number">100</span><span class="hljs-symbol">%</span>, <span class="hljs-number">50</span><span class="hljs-symbol">%</span>);<br>  top: calc(50px - <span class="hljs-built_in">var</span>(--self-<span class="hljs-built_in">border</span>));<br>  right: calc(-<span class="hljs-number">2</span> * <span class="hljs-built_in">var</span>(--self-<span class="hljs-built_in">border</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-10-at-2.58.16-PM.png" alt="三角形的最佳实践" width="100px">
]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>css 命名艺术</title>
    <url>/2021/11/06/css-%E5%91%BD%E5%90%8D%E8%89%BA%E6%9C%AF/</url>
    <content><![CDATA[<p>(突然想到一个问题，是否我可以使用 BEM 的命名方式来解决 react 项目中，css 模块化问题？？)</p>
<blockquote>
<p>– 表示同种类型的样式种类</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">例如：<span class="hljs-selector-class">.btn</span>(按钮)   <span class="hljs-selector-class">.btn--primary</span>(基础样式按钮)   <span class="hljs-selector-class">.btn--danger</span>(警示按钮)<br><br><span class="hljs-selector-class">.btn</span> &#123;<br>  <span class="hljs-attribute">background</span>: none;<br>  <span class="hljs-attribute">border</span>: none;<br>  <span class="hljs-attribute">outline</span>: none;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>  <span class="hljs-attribute">font-size</span>: inherit;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span> <span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">cursor</span>: pointer;<br>&#125;<br><br><span class="hljs-selector-class">.btn--primary</span> &#123;<br>  <span class="hljs-attribute">color</span>: white;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">hsl</span>(<span class="hljs-number">200</span>, <span class="hljs-number">100%</span>, <span class="hljs-number">50%</span>);<br>&#125;<br><br><span class="hljs-selector-class">.btn--primary</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">hsl</span>(<span class="hljs-number">200</span>, <span class="hljs-number">100%</span>, <span class="hljs-number">35%</span>);<br>&#125;<br><br><span class="hljs-selector-class">.btn--danger</span> &#123;<br>  <span class="hljs-attribute">color</span>: white;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">hsl</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100%</span>, <span class="hljs-number">50%</span>);<br>&#125;<br><br><span class="hljs-selector-class">.btn--primary</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">hsl</span>(<span class="hljs-number">200</span>, <span class="hljs-number">100%</span>, <span class="hljs-number">35%</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">/* html文件 */<br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn--primary&quot;</span>&gt;</span>btn<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn--danger&quot;</span>&gt;</span>btn<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-08-at-5.05.05-PM.gif" alt="--"></p>
<blockquote>
<p>__ 表示大组件中的某个部分</p>
</blockquote>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/* html文件 */</span><br><br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;recipe&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;recipe__header&quot;</span>&gt;菜谱&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;recipe__content&quot;</span>&gt;内容&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;recipe__foot&quot;</span>&gt;结尾&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<p>好吧， 下面来讲讲<strong>BEM</strong><br><a href="https://css-tricks.com/bem-101/">BEM 比较好的文章</a></p>
<hr>
<h3 id="BEM"><a href="#BEM" class="headerlink" title="BEM"></a>BEM</h3><p><code>BEM</code> 用于缓解 css 命名苦恼以及 css 继承问题出现的命名标准！<br><code>BEM</code>: <code>Blocks</code>, <code>Elements</code>, and <code>Modifiers</code></p>
<p>下面我来一一讲解：</p>
<h4 id="Blocks"><a href="#Blocks" class="headerlink" title="Blocks"></a><code>Blocks</code></h4><p>以下面的代码为例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Brand Name<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Pricing<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Contact<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>就<code>BEM</code>而言，整个导航栏将被视为一个<code>Block</code>(块)<br>因为这个导航栏是页面上的一个独立的组件。事实上，任何独立的组件都可以被设置为<code>Block</code>。例如：按钮、输入框、一张小卡片等等都可以。</p>
<p>如果要命名一个<code>Block</code>。仅限使用<code>字母</code>、<code>数字</code>、<code>-</code>来表示名称。本质上，块的命名遵循标准的 CSS 命名惯例</p>
<h4 id="Elements"><a href="#Elements" class="headerlink" title="Elements"></a><code>Elements</code></h4><p>如果<code>Block</code>(块)是页面上的任何独立组件，那么(Element)元素是块中<strong>无法独立存在</strong>的任何组件/部件(这里的无法独立存在就是要和上述的<code>Block</code>的内容形成对比，相区分开来)。<br>例如，我们导航栏中的列表(list)直接绑定到我们的导航栏，不能独立存在，因为它在导航栏之外毫无意义, 因此，该列表将被视为我们导航栏块中的一个元素</p>
<p>要命名<code>Element</code>(元素)，您必须在它前面加上<code>Block</code>(块)的名称，后跟两个下划线<code>__</code>。例如，这些元素将以<code>.navbar__</code>作为前缀，因为我们的块称为<code>.navbar</code>。在前缀之后，我们的命名遵循正常的 CSS 命名标准，就像块一样。</p>
<p>其实我们还会注意到，列表项不包含其父项作为前缀的选择器（<code>.navbar__list__list-item</code>）。这是因为在 BEM 中，我们在创建名称时不需要关心元素的层次结构。我们唯一需要担心的是元素在哪个块里面。这有助于使名字更清晰、更容易读/写。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">nav</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;navbar&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;navbar__brand-name&quot;</span>&gt;</span>Brand Name<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;navbar__list&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;navbar__list-item&quot;</span>&gt;</span>Pricing<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;navbar__list-item&quot;</span>&gt;</span>Contact<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<h4 id="Modifiers"><a href="#Modifiers" class="headerlink" title="Modifiers"></a><code>Modifiers</code></h4><p>BEM 的最后一部分是<code>Modifier</code>。这些修饰符本质上类似于主题，因为它们可以应用于任何元素或块，以更改元素或块的外观。<code>Modifier</code>(修饰符)的常见用例是主(primary)/危险(danger)按钮、活动状态(active)和主题</p>
<p>要命名<code>Modifier</code>(修饰符)，您只需要为您正在修改的块/元素取整个选择器，添加两个连字符(<code>--</code>)，然后将其用作选择器的前缀。例如，要修改.navbar 块，您将使用前缀.navbar–。在此前缀之后，我们再次可以使用正常的 CSS 命名标准，就像使用块和元素一样</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">nav</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;navbar navbar--dark&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;navbar__brand-name&quot;</span>&gt;</span>Brand Name<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;navbar__list&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;navbar__list-item navbar__list-item--active&quot;</span>&gt;</span><br>      Pricing<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;navbar__list-item&quot;</span>&gt;</span>Contact<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<p>额外补充一下 <code>-</code> 一般用于名字的过渡。例如</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-title">.plan &#123;</span><br><br>&#125;<br><span class="hljs-title">.plan-list &#123;</span><br><br>&#125;<br><span class="hljs-title">.plan-list__title &#123;</span><br><br>&#125;<br><span class="hljs-title">.plan-list__something-title &#123;</span><br><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="BEM-的优势"><a href="#BEM-的优势" class="headerlink" title="BEM 的优势"></a>BEM 的优势</h4><ol>
<li>让你不再困扰与如何为 css 指定恰当的名字了</li>
<li>让整个 css 命名非常规范，针对中大型项目而言，层次会非常清晰</li>
<li>修复继承问题(…有待进一步思考…)</li>
</ol>
]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>优质代码</tag>
      </tags>
  </entry>
  <entry>
    <title>css 垂直居中</title>
    <url>/2021/11/10/css-%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/</url>
    <content><![CDATA[<p>在上古时代，想要实现 CSS 的垂直居中，挺难的。而如今，想要实现垂直居中非常容易…</p>
<h4 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a>普通方法</h4><p>(利用子绝父相，并且要根据子元素的宽高和父元素的宽高进行计算)：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">/* html文件 */</span><br>&lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;parent&quot;</span>&gt;<br>  &lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;child&quot;</span>&gt;&lt;/div&gt;<br>&lt;/div&gt;<br><br><span class="hljs-comment">/* css文件 */</span><br><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br><br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>缺点： 自己计算，比较麻烦。以及如果没有定义父元素的高度，那么上面的方法就不起作用…</p>
<p>例如：如果盒子里全装的文本。未设置高度。就需要<code>margin-auto</code>来救场</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">/* html文件 */</span><br>&lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;parent&quot;</span>&gt;<br>   自己计算，比较麻烦。以及如果没有定义父元素的高度，那么上面的方法就不起作用...<br>   例如：如果盒子里全装的文本。未设置高度。就需要<span class="hljs-attribute">margin</span>-auto来救场<br>    自己计算，比较麻烦。以及如果没有定义父元素的高度，那么上面的方法就不起作用...<br>   例如：如果盒子里全装的文本。未设置高度。就需要<span class="hljs-attribute">margin</span>-auto来救场<br>     自己计算，比较麻烦。以及如果没有定义父元素的高度，那么上面的方法就不起作用...<br>   例如：如果盒子里全装的文本。未设置高度。就需要<span class="hljs-attribute">margin</span>-auto来救场<br>  &lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;child&quot;</span>&gt;<br>  &lt;/div&gt;<br>&lt;/div&gt;<br><span class="hljs-comment">/* css文件 */</span><br><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-comment">/*  未设置高度  */</span><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br><br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br><br>  <span class="hljs-comment">/*  ---上下左右都为0 才让margin:auto发挥了真实的作用  */</span><br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>:<span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">margin</span>: auto;<br>  <span class="hljs-attribute">background-color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-10-at-9.54.48-AM.png" alt="margin:auto"></p>
<p>注意：absolute 会让元素脱离文档流。所以蓝色方块遮盖住了它下面的文字</p>
<h4 id="使用-transform"><a href="#使用-transform" class="headerlink" title="使用 transform"></a>使用 transform</h4><blockquote>
<p>其实我在 transform 那篇文章也有提到。我直接展示一下如何实现</p>
</blockquote>
<p>(还是需要子绝父相)</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">/* html文件 */</span><br>&lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;parent&quot;</span>&gt;<br>   自己计算，比较麻烦。以及如果没有定义父元素的高度，那么上面的方法就不起作用...<br>   例如：如果盒子里全装的文本。未设置高度。就需要<span class="hljs-attribute">margin</span>-auto来救场<br>    自己计算，比较麻烦。以及如果没有定义父元素的高度，那么上面的方法就不起作用...<br>   例如：如果盒子里全装的文本。未设置高度。就需要<span class="hljs-attribute">margin</span>-auto来救场<br>     自己计算，比较麻烦。以及如果没有定义父元素的高度，那么上面的方法就不起作用...<br>   例如：如果盒子里全装的文本。未设置高度。就需要<span class="hljs-attribute">margin</span>-auto来救场<br>  &lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;child&quot;</span>&gt;<br>  &lt;/div&gt;<br>&lt;/div&gt;<br><br><span class="hljs-comment">/* css文件 */</span><br><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-comment">/*  未设置高度  */</span><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br><br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br><br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">transform</span>: translate(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);<br><br>  <span class="hljs-attribute">background-color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-10-at-9.54.48-AM.png" alt="transform-translate"></p>
<p>事实上，上述的居中，我还是说的最简单的情况。如果居中的元素多了，有大有小的盒子需要居中，那么用上面的方法就很难实现。并且为了实现一个居中对齐，需要父元素和子元素都进行修改，非常麻烦。而下面的 flex 就非常容易就能实现，以及只需要对父元素进行修改就行了…</p>
<h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">/* html文件 */</span><br>&lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;parent&quot;</span>&gt;<br>  &lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;child&quot;</span>&gt;<br>  &lt;/div&gt;<br><br>&lt;/div&gt;<br><br><span class="hljs-comment">/* css文件 */</span><br><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">background-color</span>: red;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>  <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br><br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-10-at-10.07.46-AM.png" alt="flex-居中"></p>
<h4 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h4><figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima"><span class="hljs-comment">/* html文件 */</span><br>&lt;div class=<span class="hljs-string">&quot;parent&quot;</span>&gt;<br>  &lt;div class=<span class="hljs-string">&quot;child&quot;</span>&gt;<br>  &lt;/div&gt;<br><br>&lt;/div&gt;<br><br><span class="hljs-comment">/* css文件 */</span><br>.parent &#123;<br>  <span class="hljs-built_in">width</span>: 300px;<br>  <span class="hljs-built_in">height</span>: 300px;<br>  <span class="hljs-built_in">background</span>-<span class="hljs-built_in">color</span>: red;<br>  <span class="hljs-built_in">display</span>: <span class="hljs-built_in">grid</span>;<br>  justify-<span class="hljs-built_in">content</span>: <span class="hljs-built_in">center</span>;<br>  align-items: <span class="hljs-built_in">center</span>;<br>&#125;<br><br>.child &#123;<br>  <span class="hljs-built_in">width</span>: 100px;<br>  <span class="hljs-built_in">height</span>: 100px;<br>  <span class="hljs-built_in">background</span>-<span class="hljs-built_in">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-10-at-10.07.46-AM.png" alt="grid-居中"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>事实上，如果当前你的元素处于绝对定位。用<code>flex</code>之前的方法都比较好。如果没有处于绝对定位。用<code>flex</code>、<code>grid</code>定位都比较好！</p>
]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>css-小知识点</title>
    <url>/2021/12/06/css-%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h4 id="box-sizing-boder-box"><a href="#box-sizing-boder-box" class="headerlink" title="box-sizing:boder-box"></a>box-sizing:boder-box</h4><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">*,<br>*<span class="hljs-selector-pseudo">::before</span>,<br>*<span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">box-sizing</span>: border-box;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述操作是将所有元素，包括伪元素 都进行怪异盒模型操作(即我们设置的 <code>width</code> 或 <code>height</code> 等于盒子的 <code>content</code> + <code>padding</code> + <code>border</code> 的宽度)</p>
<h4 id="top-0-left-0-right-0-bottom-0"><a href="#top-0-left-0-right-0-bottom-0" class="headerlink" title="top:0 left:0 right:0 bottom:0"></a>top:0 left:0 right:0 bottom:0</h4><p>在子绝父相中 如果子类这样操作,则表示子类覆盖父类的所有面积</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.test</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background-color</span>: black;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.test</span><span class="hljs-selector-pseudo">::before</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">transition</span>: background-color <span class="hljs-number">1s</span> ease-in-out;<br>&#125;<br><span class="hljs-selector-class">.test</span><span class="hljs-selector-pseudo">:hover</span><span class="hljs-selector-pseudo">::before</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/屏幕录制2021-12-06-下午11.23.27.gif" width="200px" alt="效果图1"/>

<h4 id="attr"><a href="#attr" class="headerlink" title="attr()"></a>attr()</h4><p>目前仅支持在 <code>content:</code> 里面使用<br>CSS 表达式 attr() 用来获取选择到的元素的某一 HTML 属性值，并用于其样式。attr() 表达式可以用于任何 CSS 属性。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.test</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background-color</span>: black;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.test</span><span class="hljs-selector-pseudo">::before</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-built_in">attr</span>(data-content);<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">color</span>:white;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle">&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;test&quot;</span> data-content=<span class="hljs-string">&#x27;乱写的&#x27;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/截屏2021-12-06-下午11.28.21.png" width="200px" alt="效果图2"/>

<h4 id="min-width、max-width"><a href="#min-width、max-width" class="headerlink" title="min-width、max-width"></a>min-width、max-width</h4><p>实际上，当你设置这两个属性的时候，不会真正起到效果(但如果你 <code>min-width</code> 设置得比初始宽度更大，则会跟着 <code>min-width</code> 走)。但是当你使用变量，或者有 <code>js</code> 操作的时候。则元素的最小宽度就是 <code>min-width</code>、最大宽度就是 <code>max-witdh</code></p>
<h4 id="注意，如果伪类和伪元素要一起使用，则伪类要放在伪元素前面"><a href="#注意，如果伪类和伪元素要一起使用，则伪类要放在伪元素前面" class="headerlink" title="注意，如果伪类和伪元素要一起使用，则伪类要放在伪元素前面"></a>注意，如果伪类和伪元素要一起使用，则伪类要放在伪元素前面</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-class">.box</span><span class="hljs-selector-pseudo">::before</span><span class="hljs-selector-pseudo">:hover</span> &#123;   <span class="hljs-comment">// 这里是错误的用法</span><br>&#125;<br><br><span class="hljs-selector-class">.box</span><span class="hljs-selector-pseudo">:hover</span><span class="hljs-selector-pseudo">::before</span> &#123;   <span class="hljs-comment">// 这里才是正确的用法</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="多个类放在一个元素上搭配伪元素的神奇操作"><a href="#多个类放在一个元素上搭配伪元素的神奇操作" class="headerlink" title="多个类放在一个元素上搭配伪元素的神奇操作"></a>多个类放在一个元素上搭配伪元素的神奇操作</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">box</span> <span class="hljs-symbol">text</span>&quot;&gt;<span class="hljs-symbol">BOX</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: grey;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">color</span>: white;<br>&#125;<br><br><span class="hljs-selector-class">.box</span><span class="hljs-selector-pseudo">::before</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/截屏2021-12-07-上午10.15.24.png" width="100px"/>

<p>此时，伪元素完全覆盖住了元素本身。连 BOX 也被覆盖住。 解决方法</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: grey;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">color</span>: white;<br>&#125;<br><br><span class="hljs-selector-class">.box</span><span class="hljs-selector-pseudo">::before</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">z-index</span>: -<span class="hljs-number">1</span>;  <span class="hljs-comment">// 注意这里</span><br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br><br><span class="hljs-selector-class">.text</span> &#123;<br>  <span class="hljs-attribute">z-index</span>: <span class="hljs-number">1</span>;   <span class="hljs-comment">// 注意这里</span><br>&#125;<br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/截屏2021-12-07-上午10.17.56.png" width="100px"/>

<h4 id="针对-svg-标签的颜色修改"><a href="#针对-svg-标签的颜色修改" class="headerlink" title="针对 svg 标签的颜色修改"></a>针对 svg 标签的颜色修改</h4><p>如果是<code>svg标签</code>，颜色修改属性是 <code>fill</code></p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli">&lt;svg class=<span class="hljs-string">&quot;icon&quot;</span><span class="hljs-string">....</span>&gt;<span class="hljs-string">...</span>&lt;<span class="hljs-string">/svg</span>&gt;<br><br><span class="hljs-string">.icon</span> &#123;<br>  fill: red;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当然，也可以在 path 里面修改 fill 的颜色</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;xxx&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="top-0-right-0-bottom-0-left-0-可以用-inset-0-来代替"><a href="#top-0-right-0-bottom-0-left-0-可以用-inset-0-来代替" class="headerlink" title="top: 0 right: 0 bottom: 0 left: 0 可以用 inset: 0;来代替"></a>top: 0 right: 0 bottom: 0 left: 0 可以用 inset: 0;来代替</h4><h4 id="注意：例如-img、input、iframe-标签，是没有伪元素的-没有-before-after"><a href="#注意：例如-img、input、iframe-标签，是没有伪元素的-没有-before-after" class="headerlink" title="注意：例如 img、input、iframe 标签，是没有伪元素的(没有::before, ::after)"></a>注意：例如 img、input、iframe 标签，是没有伪元素的(没有::before, ::after)</h4><h4 id="margin、padding-的正负数搭配"><a href="#margin、padding-的正负数搭配" class="headerlink" title="margin、padding 的正负数搭配"></a>margin、padding 的正负数搭配</h4><p><a href="https://codepen.io/bruce-shuai/pen/KKXgdLq">codepen</a></p>
<h4 id="尽量减少自己手动设置一个元素的长宽，而是利用-100-max-width-flex-grid-等操作来灵活控制元素的大小"><a href="#尽量减少自己手动设置一个元素的长宽，而是利用-100-max-width-flex-grid-等操作来灵活控制元素的大小" class="headerlink" title="尽量减少自己手动设置一个元素的长宽，而是利用 100%, max-width, flex, grid 等操作来灵活控制元素的大小"></a>尽量减少自己手动设置一个元素的长宽，而是利用 100%, max-width, flex, grid 等操作来灵活控制元素的大小</h4><h4 id="对于使用-grid，-其实你可以专门弄个-css-类选择器-就叫做-grid-然后进行-grid-的配置。这样就方便其他元素来复用这个-grid-类选择器"><a href="#对于使用-grid，-其实你可以专门弄个-css-类选择器-就叫做-grid-然后进行-grid-的配置。这样就方便其他元素来复用这个-grid-类选择器" class="headerlink" title="对于使用 grid， 其实你可以专门弄个 css 类选择器 就叫做 grid 然后进行 grid 的配置。这样就方便其他元素来复用这个 .grid 类选择器"></a>对于使用 grid， 其实你可以专门弄个 css 类选择器 就叫做 grid 然后进行 grid 的配置。这样就方便其他元素来复用这个 .grid 类选择器</h4><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>奇淫技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>express middleware</title>
    <url>/2021/11/23/express-middleware/</url>
    <content><![CDATA[<p>这篇博客是作为 ExpressJS 知识点总结 这篇文章的补充</p>
<h4 id="中间件基础知识"><a href="#中间件基础知识" class="headerlink" title="中间件基础知识"></a>中间件基础知识</h4><p><code>middleware</code> 即 中间件。是在服务器发送响应或接受请求这一中间过程中执行的代码</p>
<p>下面用代码来说话</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><code class="hljs livescript"><span class="hljs-comment">/* 老三样 */</span><br><span class="hljs-built_in">npm</span> init -y<br><span class="hljs-built_in">npm</span> i nodemon<br><span class="hljs-built_in">npm</span> i express<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* server.js */</span><br><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> app = express()<br><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">&#x27;Home Page&#x27;</span>)<br>&#125;)<br><br>app.get(<span class="hljs-string">&#x27;/users&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">&#x27;Users Page&#x27;</span>)<br>&#125;)<br><br>app.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Server Started&#x27;</span>))<br></code></pre></td></tr></table></figure>

<p><strong>中间件</strong>(注意：中间件本身是一个函数)可以访问响应（res）和请求（req）变量，并可以根据需要修改或使用它们。<br><strong>中间件函数</strong> 接受三个参数 <code>响应(res)</code>、<code>请求(req)</code>、<code>next</code>。重点来看看<code>next</code><br><code>next</code> 是一个函数。该函数很重要，因为它必须从中间件调用才能执行下一个中间件。如果不调用此函数，则不会调用包括控制器(这里指例如 app.get()的函数)操作在内的其他中间件</p>
<p>用例子来讲解：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* server.js */</span><br><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> app = express()<br><br><span class="hljs-comment">// 使用 中间件</span><br>app.use(loggingMiddleware)   <span class="hljs-comment">// 注意：这个中间件应该放在所有控制器前面</span><br><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">&#x27;Home Page&#x27;</span>)<br>&#125;)<br><br>app.get(<span class="hljs-string">&#x27;/users&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">&#x27;Users Page&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 定义一个关于打印的中间件</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loggingMiddleware</span>(<span class="hljs-params">req, res, next</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Inside Middleware&#x27;</span>)<br>&#125;<br><br>app.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Server Started&#x27;</span>))<br></code></pre></td></tr></table></figure>

<p>此时会有比较有趣的事情发生！ 我重启服务器后，在本地 3000 端口的任何路由刷新，在终端控制台都会打印<code>Inside Middleware</code>。但是应用程序现在<strong>永远加载，从未实际完成请求</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-23-at-5.19.24-PM.gif" alt="loading..." width="300px"/>

<p>出现问题的原因在于我在<code>loggingMiddleware</code>这个中间件里，没有调用 <code>next</code> 函数，所以永远不会调用控制器(例如 <code>app.get()</code>)操作(前文也提过)</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 定义一个关于打印的中间件<br><span class="hljs-keyword">function</span> loggingMiddleware(req, res, <span class="hljs-keyword">next</span>) &#123;<br>  console.log(<span class="hljs-string">&#x27;Inside Middleware&#x27;</span>);<br>  <span class="hljs-keyword">next</span>();     <span class="hljs-regexp">//</span> 这里用了<span class="hljs-keyword">next</span>()<br>&#125;<br><br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-23-at-5.26.05-PM.gif" alt="next" width="400px"/>

<p>此时，我会发现无论进入哪条路由都顺通无阻，且中间件的记录一条不落！！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> app = express()<br>app.use(loggingMiddleware)<br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">&#x27;Home Page&#x27;</span>)<br>&#125;)<br><br>app.get(<span class="hljs-string">&#x27;/users&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">&#x27;Users Page&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 一个关于打印的中间件</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loggingMiddleware</span>(<span class="hljs-params">req, res, next</span>) </span>&#123;<br>  <span class="hljs-comment">// req.originalUrl 获取浏览器当前路由</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()&#125;</span>: <span class="hljs-subst">$&#123;req.originalUrl&#125;</span>`</span>)<br>  next();<br>&#125;<br><br><span class="hljs-comment">// 新的中间件 用于用户认证</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">authorizeUsersAccess</span>(<span class="hljs-params">req, res, next</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;authorizeUsersAccess Middleware&#x27;</span>)<br>  next()<br>&#125;<br><br>app.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Server Started&#x27;</span>))<br><br></code></pre></td></tr></table></figure>

<p>现在我不把<code>authorizeUsersAccess</code>通过<code>app.use()</code>使用，而是放在 <code>app.get(&#39;/users&#39;, ...)</code> 这个控制器里</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">app.get(<span class="hljs-string">&#x27;/users&#x27;</span>, authorizeUsersAccess, <span class="hljs-function"><span class="hljs-params">(req, res)</span> =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">&#x27;Users Page&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>此时，我们尝试调用页面的路由，我们会惊奇的发现 只有在<code>/users</code>这条路由时，控制台会打印</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">authorizeUsersAccess</span> Middleware   ---&gt;</span> authorizeUsersAccess 发挥的效果<br></code></pre></td></tr></table></figure>

<p>而在所有路由上，控制台都会打印</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Tue</span> Nov <span class="hljs-number">23</span> <span class="hljs-number">2021</span> <span class="hljs-number">17</span>:<span class="hljs-number">35</span>:<span class="hljs-number">25</span> GMT+<span class="hljs-number">0800</span> (中国标准时间): /users   ---&gt; loggingMiddleware 发挥的效果<br></code></pre></td></tr></table></figure>

<p>说明，现在中间件<code>authorizeUsersAccess</code>只能在<code>/users</code>这条路由里起作用</p>
<p>现在来丰富一下<code>authorizeUsersAccess</code>这个中间件的功能</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> app = express()<br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">&#x27;Home Page&#x27;</span>)<br>&#125;)<br><br>app.get(<span class="hljs-string">&#x27;/users&#x27;</span>, authorizeUsersAccess, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">&#x27;Users Page&#x27;</span>)<br>&#125;)<br><br><br><span class="hljs-comment">// 新的中间件 用于用户认证</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">authorizeUsersAccess</span>(<span class="hljs-params">req, res, next</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (req.query.admin === <span class="hljs-string">&#x27;true&#x27;</span>) &#123;<br>    next()<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    res.send(<span class="hljs-string">&#x27;错误！你必须要admin === true&#x27;</span>)<br>  &#125;<br>&#125;<br><br>app.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Server Started&#x27;</span>))<br><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-23-at-5.54.15-PM.gif" alt="升级的中间件"></p>
<p>我们可以在中间件里设置新的变量，然后在所起效的控制器里使用 例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* server.js */</span><br><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> app = express()<br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">&#x27;Home Page&#x27;</span>)<br>&#125;)<br><br>app.get(<span class="hljs-string">&#x27;/users&#x27;</span>, authorizeUsersAccess, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">&#x27;Users Page&#x27;</span>)<br>&#125;)<br><br><br><span class="hljs-comment">// 新的中间件 用于用户认证</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">authorizeUsersAccess</span>(<span class="hljs-params">req, res, next</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (req.query.admin === <span class="hljs-string">&#x27;true&#x27;</span>) &#123;<br>    req.<br>    next()<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    res.send(<span class="hljs-string">&#x27;错误！你必须要admin === true&#x27;</span>)<br>  &#125;<br>&#125;<br><br>app.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Server Started&#x27;</span>))<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-23-at-6.03.39-PM.gif" alt="升级的中间件"></p>
<h4 id="中间件额外知识"><a href="#中间件额外知识" class="headerlink" title="中间件额外知识"></a>中间件额外知识</h4><h5 id="控制器也是中间件"><a href="#控制器也是中间件" class="headerlink" title="控制器也是中间件"></a>控制器也是中间件</h5><p>事实上控制器(例如 app.get())也是中间件。因为也是有<code>res</code>、<code>req</code>、<code>next()</code>(next 在这使用情况非常少)，但是控制器后面没有紧随其后的其他中间件。它们就是这条<strong>链</strong>的末端，这就是为什么在控制器动作中永远不会有任何下一个调用。</p>
<h5 id="next-调用-不等于-return"><a href="#next-调用-不等于-return" class="headerlink" title="next()调用 不等于 return"></a>next()调用 不等于 return</h5><p>(注意：这里的理解其实我现在还不到位…)<br>例如</p>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">function</span> <span class="hljs-selector-tag">middleware</span>(req, res, next) &#123;<br>  <span class="hljs-selector-tag">if</span> (req.valid) &#123;<br>    <span class="hljs-selector-tag">next</span>()<br>  &#125;<br>  <span class="hljs-selector-tag">res</span><span class="hljs-selector-class">.send</span>(<span class="hljs-string">&#x27;无效请求&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">middleware</span>(req, res, next) &#123;<br>  if (req.valid) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">next()</span><br>  &#125;<br>  res.send(<span class="hljs-symbol">&#x27;Invalid</span> Request&#x27;)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在，代码在<code>next</code>调用后将不再执行，因为它将从函数中返回</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> app = express()<br><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, middleware, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Inside Home Page&#x27;</span>)<br>  res.send(<span class="hljs-string">&#x27;Home Page&#x27;</span>)<br>&#125;)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">middleware</span>(<span class="hljs-params">req, res, next</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Before Next&#x27;</span>)<br>  next()<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;After Next&#x27;</span>)<br>&#125;<br><br>app.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Server Started&#x27;</span>))<br></code></pre></td></tr></table></figure>

<p>运行此代码并转到主页时，控制台将按顺序打印下面内容</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Before</span> <span class="hljs-built_in">Next</span><br><span class="hljs-variable">Inside</span> <span class="hljs-variable">Home</span> <span class="hljs-variable">Page</span><br><span class="hljs-built_in">After</span> <span class="hljs-built_in">Next</span><br></code></pre></td></tr></table></figure>

<h5 id="中间件的执行顺序"><a href="#中间件的执行顺序" class="headerlink" title="中间件的执行顺序"></a>中间件的执行顺序</h5><figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">const express = require(<span class="hljs-string">&#x27;express&#x27;</span>)<br>const app = express()<br><br>app.use(middlewareThree)<br>app.use(middlewareOne)<br><br>app.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, middlewareTwo, middlewareFour, (req, <span class="hljs-keyword">res</span>) =&gt; &#123;<br>  console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Inside Home Page&#x27;</span>)<br>  <span class="hljs-keyword">res</span>.send(<span class="hljs-string">&#x27;Home Page&#x27;</span>)<br>&#125;)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">middlewareOne</span><span class="hljs-params">(req, res, next)</span> &#123;</span><br>  console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Middleware One&#x27;</span>)<br>  <span class="hljs-keyword">next</span>()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">middlewareTwo</span><span class="hljs-params">(req, res, next)</span> &#123;</span><br>  console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Middleware Two&#x27;</span>)<br>  <span class="hljs-keyword">next</span>()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">middlewareThree</span><span class="hljs-params">(req, res, next)</span> &#123;</span><br>  console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Middleware Three&#x27;</span>)<br>  <span class="hljs-keyword">next</span>()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">middlewareFour</span><span class="hljs-params">(req, res, next)</span> &#123;</span><br>  console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Middleware Four&#x27;</span>)<br>  <span class="hljs-keyword">next</span>()<br>&#125;<br><br>app.listen(<span class="hljs-number">3000</span>, () =&gt; console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Server Started&#x27;</span>))<br></code></pre></td></tr></table></figure>

<p>由于<code>app.use</code>语句是第一位的，这些语句中的中间件将首先按照添加的顺序执行。接下来定义<code>app.get</code>中间件，然后按照<code>app.get</code>函数中的顺序执行它们。如果运行，这将导致以下控制台输出。</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata">Middleware Three<br>Middleware <span class="hljs-keyword">One</span><br>Middleware <span class="hljs-keyword">Two</span><br>Middleware Four<br></code></pre></td></tr></table></figure>

<p><strong>总结：中间件在清理代码和使用户授权和身份验证等事情变得容易得多方面非常强大，但由于中间件令人难以置信的灵活性，它可以用于更多用途。</strong></p>
]]></content>
      <categories>
        <category>Node.JS篇</category>
      </categories>
      <tags>
        <tag>全栈</tag>
      </tags>
  </entry>
  <entry>
    <title>fetch知识</title>
    <url>/2021/12/02/fetch%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h3 id="fetch-的基本操作"><a href="#fetch-的基本操作" class="headerlink" title="fetch 的基本操作"></a>fetch 的基本操作</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">/* index.html */<br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./script.js&quot;</span> <span class="hljs-attr">defer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/* script.js */</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-keyword">fetch</span>(<span class="hljs-string">&#x27;https://reqres.in/api/users/1&#x27;</span>)  <span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-keyword">fetch</span>的第二个参数是可选的，例如你想使用post请求而非<span class="hljs-keyword">get</span>请求...<br><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">fetch</span>(<span class="hljs-string">&#x27;https://reqres.in/api/users/1&#x27;</span>));<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-12-02-at-9.07.18-PM.png" alt="fetch是基于Promise的"></p>
<p>上图已说明了 <code>fetch</code> 是基于 <code>promise</code> 来创造的… 意味着你可以使用 <code>async</code>, <code>await</code>, <code>try...catch...</code> 这些操作！</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">/* script.js */</span><br>fetch(<span class="hljs-string">&#x27;https://reqres.in/api/users/1&#x27;</span>)<br><span class="hljs-comment">// fetch 会返回一个response，所以我们会拥有一个response对象</span><br>.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>  console.log(<span class="hljs-string">&#x27;res&#x27;</span>, res);<br>&#125;)<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-12-02-at-9.10.29-PM.png" alt="response"></p>
<p>重点注意上图中的<code>body</code>属性！,<code>body</code>里有响应的核心内容</p>
<p>但是我们无法直接访问 <code>res.body</code> 的内容，我们必须利用 <code>json()</code> 这个方法将其 <code>json</code> 化, 这又会有一个新的 <code>promise</code> 出现…</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><code class="hljs sas">fetch(<span class="hljs-string">&#x27;https://reqres.in/api/users/1&#x27;</span>)<br>.th<span class="hljs-meta">en(</span>res =&gt; &#123;<br>  // console<span class="hljs-meta">.log(</span><span class="hljs-string">&#x27;res.json&#x27;</span>, res.js<span class="hljs-meta">on(</span>))  // promise<br>  <span class="hljs-meta">return</span> res.js<span class="hljs-meta">on(</span>); // 要将其返回才行,这样下一个<span class="hljs-meta">then</span>的参数才会是这个 res.js<span class="hljs-meta">on(</span>) 执行完的结果...<br>&#125;)<br>.th<span class="hljs-meta">en(</span>data =&gt; console<span class="hljs-meta">.log(</span><span class="hljs-string">&#x27;data&#x27;</span>, data))<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-12-02-at-9.15.18-PM.png" alt="获取数据"></p>
<h3 id="fetch-特殊的错误处理机制"><a href="#fetch-特殊的错误处理机制" class="headerlink" title="fetch 特殊的错误处理机制"></a>fetch 特殊的错误处理机制</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 现在我传入一个错误的api</span><br><span class="hljs-function"><span class="hljs-title">fetch</span><span class="hljs-params">(<span class="hljs-string">&#x27;https://reqres.in/api/users/110&#x27;</span>)</span></span><br><span class="hljs-selector-class">.then</span>(res =&gt; &#123;<br>  return res<span class="hljs-selector-class">.json</span>()<br>&#125;)<br><span class="hljs-selector-class">.then</span>(data =&gt; console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;data&#x27;</span>, data))   <span class="hljs-comment">// 奇怪的事，是我仍能够运行成功</span><br><span class="hljs-selector-class">.catch</span>(error =&gt; console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;Error&#x27;</span>))      <span class="hljs-comment">// 这里是没有执行的,我们得不到任何的错误</span><br></code></pre></td></tr></table></figure>

<p>控制台也无任何报错！<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-12-02-at-9.17.32-PM.png" alt="fetch-error1"></p>
<p>事实上，<code>fetch</code> 出错的情况只有在真实的网络连接出现问题时才会出现！ <code>api</code> 是否有误不影响 <code>fetch</code> 的运行！<br>所以你需要自己进行手动的设置一些东西来检测 <code>api</code> 获取数据是否有问题</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">fetch(<span class="hljs-string">&#x27;https://reqres.in/api/users/110&#x27;</span>)<br> .<span class="hljs-keyword">then</span>(res =&gt; &#123;<br>   <span class="hljs-keyword">if</span> (res.ok) &#123;  <span class="hljs-regexp">//</span> 这里的res.ok 表示 只有状态码在<span class="hljs-number">200</span>~<span class="hljs-number">299</span>之间的时候才会返回<span class="hljs-literal">true</span><br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;SUCCESS!&#x27;</span>)<br>     <span class="hljs-keyword">return</span> res.json()<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Not SUCCESS&#x27;</span>);<br>     <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>();<br>   &#125;<br> &#125;)<br> .<span class="hljs-keyword">then</span>(data =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;data&#x27;</span>, data))   <span class="hljs-regexp">//</span> 奇怪的事，是我仍能够运行成功<br> .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Error&#x27;</span>))<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-12-02-at-9.19.40-PM.png" alt="fetch-error2"></p>
<h3 id="fetch-的更多功能"><a href="#fetch-的更多功能" class="headerlink" title="fetch 的更多功能"></a>fetch 的更多功能</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">/* script.js */</span><br><span class="hljs-keyword">fetch</span>(<span class="hljs-string">&#x27;https://reqres.in/api/users&#x27;</span>, &#123;<br>  <span class="hljs-keyword">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,    // 你可以在这里写任何类型的HTTP请求方法<br>  // 并且<span class="hljs-keyword">fetch</span>要求你发送的数据是要<span class="hljs-type">JSON</span>化的<br>  headers: &#123;<br>    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>  // 告诉<span class="hljs-keyword">fetch</span>，我要传的数据是<span class="hljs-type">json</span>数据<br>  &#125;,<br>  body: <span class="hljs-type">JSON</span>.stringify(&#123;<br>    // 传递一些数据<br>    <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;帅得乱七八糟&#x27;</span>,<br>    age: <span class="hljs-string">&#x27;21&#x27;</span><br>  &#125;)<br>&#125;)<br>.<span class="hljs-keyword">then</span>(res =&gt; res.json())<br>.<span class="hljs-keyword">then</span>(data =&gt; console.log(data))<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-12-02-at-9.21.11-PM.png" alt="其他请求方法"></p>
<p><strong>注意：只要你想将<code>json</code>数据以<code>post</code>方式发送给<code>server</code>端，你需要有 <code>headers: &#123;&#39;Content-Type&#39;: &#39;application/json&#39;&#125;</code> 内容，同时将<code>body</code>数据<code>json字符串化</code></strong></p>
]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>flex 布局解析</title>
    <url>/2021/11/09/flex-%E5%B8%83%E5%B1%80%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p><a href="https://lhammer.cn/You-need-to-know-css/#/zh-cn/flexbox-layout">flex 可视化网站</a></p>
<p>//TODO 这篇文章要参考一下其他文章</p>
<blockquote>
<p>flex 弹性布局 —&gt; 顾名思义，具备弹性</p>
</blockquote>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;flexbox-container&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;flexbox-item&quot;</span>&gt;flex-<span class="hljs-built_in">item</span><span class="hljs-number">-1</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;flexbox-item&quot;</span>&gt;flex-<span class="hljs-built_in">item</span><span class="hljs-number">-2</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;flexbox-item&quot;</span>&gt;flex-<span class="hljs-built_in">item</span><span class="hljs-number">-3</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">background</span>: grey;<br>&#125;<br><br><span class="hljs-selector-class">.flexbox-container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;      <span class="hljs-comment">/* 注意：flex 默认是主横向布局 */</span><br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid black;<br>&#125;<br><br><span class="hljs-selector-class">.flexbox-item</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid <span class="hljs-number">#333</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#dfdfdf</span>;<br>  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>由于 flex 是弹性布局，可压缩，可伸长 但由于这里我设置可子元素为 <code>200px</code> 所以不会无缘无故的伸长, 但收缩仍有效</p>
<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-22-at-8.01.23-PM.gif" alt="flex 弹性布局"></p>
<h4 id="main-axis-cross-axis"><a href="#main-axis-cross-axis" class="headerlink" title="main axis / cross axis"></a>main axis / cross axis</h4><p><code>main axis 主轴</code>: 默认是水平的<br><code>cross axis</code>: 默认是纵向的<br>即 <code>flex-direction: row;</code> 默认是<code>row</code><br>如果是<code>column</code> 则：<code>main axis 主轴</code>是纵向 | <code>cross axis</code> 是横向 –&gt; 这里严谨点</p>
<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Snipaste_2021-11-22_20-24-18.png" alt="main/cross axis"></p>
<h4 id="justify-content-align-items"><a href="#justify-content-align-items" class="headerlink" title="justify-content/align-items"></a>justify-content/align-items</h4><p><strong>justify-content 作用：定义项目在主轴上的对齐方式。</strong></p>
<p><code>justify-content</code>的效果是相对于<code>main axis</code>的前 中 后位置</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.flexbox-container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid black;<br>  <span class="hljs-attribute">flex-direction</span>: row;<br>  <span class="hljs-attribute">justify-content</span>: flex-end;  <span class="hljs-comment">/* 相对于主轴靠后*/</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-22-at-8.34.35-PM.png" alt="justify-content"></p>
<p><strong>align-items 作用：定义项目在交叉轴（默认方向从上到下）上的对齐方式</strong></p>
<p><code>align-items</code>的效果是相对于<code>cross axis</code>的前 中 后位置<br><code>align-items</code>默认值是 <code>stretch</code> 拉伸效果</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.flexbox-container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid black;<br>  <span class="hljs-attribute">flex-direction</span>: row;<br>  <span class="hljs-attribute">justify-content</span>: flex-end;<br>  <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-22-at-8.34.35-PM.png" alt="align-items"></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.flexbox-container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid black;<br>  <span class="hljs-attribute">flex-direction</span>: row;<br>  <span class="hljs-attribute">justify-content</span>: flex-end;<br>  <span class="hljs-attribute">align-items</span>: flex-start;   <span class="hljs-comment">/* cross axis顶部对齐 */</span><br>&#125;<br><br><span class="hljs-selector-class">.flexbox-item</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid <span class="hljs-number">#333</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#dfdfdf</span>;<br>  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.flexbox-item</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.flexbox-item</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>) &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.flexbox-item</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-22-at-10.14.48-PM.png" alt="align-items"></p>
<h4 id="align-content-flex-wrap"><a href="#align-content-flex-wrap" class="headerlink" title="align-content/flex-wrap"></a>align-content/flex-wrap</h4><p><strong>flex-wrap 作用：决定项目在一条轴线排不下时如何换行。</strong></p>
<p><strong>align-content 作用：定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用</strong></p>
<p><code>align-content</code> 一般用于多行控制。<br>但是 <code>flex</code> 是收缩布局，尽管一再压缩盒子，也不会换行。因为有一个属性：<code>flex-wrap: nowrap;</code> // nowrap 是默认属性,表示不会换行</p>
<p>我把 <code>flex-wrap: wrap</code> 就可以换行了</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.flexbox-container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid black;<br>  <span class="hljs-attribute">flex-direction</span>: row;<br>  <span class="hljs-attribute">justify-content</span>: flex-end;<br>  <span class="hljs-attribute">align-items</span>: flex-start;<br>  <span class="hljs-attribute">flex-wrap</span>: wrap;   <span class="hljs-comment">/* 注意！*/</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-22-at-10.21.37-PM.gif" alt="wrap"></p>
<p>有了多行<code>flex</code>子元素就可以用<code>flex-content</code>来显示应该有的效果了</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.flexbox-container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid black;<br>  <span class="hljs-attribute">flex-direction</span>: row;<br>  <span class="hljs-attribute">justify-content</span>: flex-end;<br>  <span class="hljs-attribute">flex-wrap</span>: wrap;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;<br>  <span class="hljs-attribute">align-items</span>: center;<br>  <span class="hljs-comment">/*   align-content: center; */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Snipaste_2021-11-22_22-28-24.png" alt="align-itemsVSalign-content1"></p>
<p>对于多行 flex 布局使用<code>align-items</code>。则每行自成一个 flex 的布局。所以如果是 <code>align-items: center;</code> 则每一行都是 <code>center</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.flexbox-container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid black;<br>  <span class="hljs-attribute">flex-direction</span>: row;<br>  <span class="hljs-attribute">justify-content</span>: flex-end;<br>  <span class="hljs-attribute">flex-wrap</span>: wrap;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;<br><span class="hljs-comment">/*   align-items: center; */</span><br>    <span class="hljs-attribute">align-content</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Snipaste_2021-11-22_22-32-30.png" alt="align-itemsVSalign-content2"></p>
<p><code>align-content</code>会让多行 <code>flex</code> 成为一个整体.所以如果是 <code>align-content: center;</code> 则整体是 <code>center</code></p>
<p>(注意：对于只有单行的 <code>flex</code>。<code>align-content</code>似乎不起效果)</p>
<h4 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h4><p><strong>作用：决定主轴的方向</strong></p>
<p>默认是<code>flex-direction:row</code> 即 主轴是横向的<br>也可以设置为：<code>flex-direction:colum</code> 即 主轴是纵向的(<code>cross axis</code> 就变成横向的了)，这样 <code>justify-content</code>、<code>align-items</code>、<code>align-content</code> 方向也会跟着主轴的变化</p>
<h4 id="flex-shrink-flex-grow"><a href="#flex-shrink-flex-grow" class="headerlink" title="flex-shrink/flex-grow"></a>flex-shrink/flex-grow</h4><p>(具体占比 有待补充)</p>
<p><code>flex-shrink</code> 是针对<code>flex</code>布局下的子元素的。顾名思义，<code>shrink</code>是关于收缩的。因为<code>flex</code>是弹性布局。所以<code>flex-shrink</code>默认是<code>1</code>。``</p>
<p><code>flex-grow</code> 是扩充。<code>flex-grow</code> 默认是<code>0</code>即无扩充</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.flexbox-container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid black;<br>  <span class="hljs-attribute">flex-direction</span>: row;<br>  <span class="hljs-attribute">justify-content</span>: flex-end;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;<br>  <span class="hljs-attribute">align-content</span>: center;<br>&#125;<br><br><span class="hljs-selector-class">.flexbox-item</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid <span class="hljs-number">#333</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#dfdfdf</span>;<br>  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.flexbox-item</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">flex-shrink</span>: <span class="hljs-number">0</span>; <span class="hljs-comment">/* 不会进行压缩 */</span><br>&#125;<br><br><span class="hljs-selector-class">.flexbox-item</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>) &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.flexbox-item</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">flex-grow</span>: <span class="hljs-number">1</span>; <span class="hljs-comment">/* 把剩余的空间都占满*/</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-22-at-10.53.05-PM.gif" alt="flex-shrinkVSflex-grow"></p>
<p>事实上，如果多个子元素使用了 flex-grow。他们占剩余空间是有比例划分的<br>具体如下：</p>
<h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><p>flex-basis :定义项目在分配多余的空间之前，项目占据的主轴空间 默认为 auto（item 本来大小）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span><br>--&gt;<br>flex-grow: <span class="hljs-number">1</span>;<br><span class="hljs-attribute">flex-shrink</span>: <span class="hljs-number">1</span>;<br><span class="hljs-attribute">flex-basis</span>: <span class="hljs-number">0%</span>;<br><br><span class="hljs-attribute">flex</span>: <span class="hljs-number">0</span><br>--&gt;<br>flex-grow: <span class="hljs-number">0</span>;<br><span class="hljs-attribute">flex-shrink</span>: <span class="hljs-number">1</span>;<br><span class="hljs-attribute">flex-basis</span>: <span class="hljs-number">0%</span>;<br><br><span class="hljs-attribute">flex</span>: auto<br>--&gt;<br>flex-grow: <span class="hljs-number">1</span>;<br><span class="hljs-attribute">flex-shrink</span>: <span class="hljs-number">1</span>;<br><span class="hljs-attribute">flex-basis</span>: auto;<br></code></pre></td></tr></table></figure>

<p>flex: 1 不管内容多少，一般都是平分空间，空间大小都一致<br>而 flex: auto 是根据内容的大小来分，不是均分的（除非内容都是一样，才均分）<br><a href="https://juejin.cn/post/6967177565458923557">flex: 1 flex:0 flex:auto</a></p>
<h4 id="align-self-似乎-justify-self-不起效果"><a href="#align-self-似乎-justify-self-不起效果" class="headerlink" title="align-self (似乎 justify-self 不起效果)"></a>align-self (似乎 justify-self 不起效果)</h4><p><strong>align-self 作用：定义单个项目的对齐方式，可覆盖 align-items 属性。</strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">background</span>: grey;<br>&#125;<br><br><span class="hljs-selector-class">.flexbox-container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid black;<br>  <span class="hljs-attribute">flex-direction</span>: row;<br>  <span class="hljs-attribute">justify-content</span>: flex-start;<br>  <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br><br><span class="hljs-selector-class">.flexbox-item</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid <span class="hljs-number">#333</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#dfdfdf</span>;<br>  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.flexbox-item</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">align-self</span>: flex-start;  <span class="hljs-comment">/* 单个子元素覆盖了align-items对其的影响 */</span><br>&#125;<br><br><span class="hljs-selector-class">.flexbox-item</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>) &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.flexbox-item</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-22-at-11.15.18-PM.png" alt="align-self"></p>
<h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4><p><strong>作用：定义项目的排列顺序。 值为整数，数值越小，排列越靠前，默认为 0</strong></p>
<p>在子元素起效果</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.flexbox-item</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">order</span>: <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-selector-class">.flexbox-item</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>) &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;<br>  <span class="hljs-attribute">order</span>:<span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-selector-class">.flexbox-item</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-22-at-11.11.25-PM.png" alt="order"></p>
<h4 id="额外补充"><a href="#额外补充" class="headerlink" title="额外补充"></a>额外补充</h4><p>在 flex 中使用 gap 这个属性也是非常方便的~</p>
]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>git 高级指令</title>
    <url>/2021/11/10/git-%E9%AB%98%E7%BA%A7%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>一般情况下我们提交代码到 git 的指令如下：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">add</span> .<br>git <span class="hljs-keyword">commit</span> -m &quot;Message&quot;<br></code></pre></td></tr></table></figure>

<p>我们可以等同于下面这条命令</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver">git commit -<span class="hljs-keyword">a</span> -m <span class="hljs-string">&quot;Message&quot;</span><br></code></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>grid 布局解析</title>
    <url>/2021/11/09/grid-%E5%B8%83%E5%B1%80%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-22-at-5.06.43-PM.png" alt="flex-VS-grid"></p>
<h4 id="grid-template-columns-（grid-template-rows-方法同样如下）"><a href="#grid-template-columns-（grid-template-rows-方法同样如下）" class="headerlink" title="grid-template-columns （grid-template-rows 方法同样如下）"></a>grid-template-columns （grid-template-rows 方法同样如下）</h4><p>展示有多少条<code>列</code>以及每条<code>列</code>的宽度</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;grid-container&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;grid-item&quot;</span>&gt; Grid Item <span class="hljs-number">1</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;grid-item&quot;</span>&gt; Grid Item <span class="hljs-number">2</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;grid-item&quot;</span>&gt; Grid Item <span class="hljs-number">3</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;grid-item&quot;</span>&gt; Grid Item <span class="hljs-number">4</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;grid-item&quot;</span>&gt; Grid Item <span class="hljs-number">5</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">background</span>: grey;<br>&#125;<br><span class="hljs-selector-class">.grid-container</span> <span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">hsl</span>(<span class="hljs-number">200</span>, <span class="hljs-number">100%</span>, <span class="hljs-number">50%</span>);<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;<br>&#125;<br><br><span class="hljs-selector-class">.grid-container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-comment">/* 选择列的宽度 */</span><br>  grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-number">200px</span> <span class="hljs-number">100px</span>; <span class="hljs-comment">/* 单位可以是任意的：例如 px、em、rem、% */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-22-at-5.41.59-PM.png" alt="grid-template-columns1" width="300px"/>

<h5 id="fr-单位"><a href="#fr-单位" class="headerlink" title="fr 单位"></a>fr 单位</h5><figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima">.<span class="hljs-built_in">grid</span>-container &#123;<br>  <span class="hljs-built_in">display</span>: <span class="hljs-built_in">grid</span>;<br>  <span class="hljs-comment">/* 选择列的宽度 */</span><br>  <span class="hljs-built_in">grid</span>-template-<span class="hljs-built_in">columns</span>: 2fr 1fr <span class="hljs-comment">/* 则是占当前盒子宽度的 2/3宽度 1/3宽度 */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-22-at-5.42.53-PM.png"    width="300px" alt="grid-template-columns2"/>

<h5 id="repeat-方法"><a href="#repeat-方法" class="headerlink" title="repeat() 方法"></a>repeat() 方法</h5><figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima">.<span class="hljs-built_in">grid</span>-container &#123;<br>  <span class="hljs-built_in">display</span>: <span class="hljs-built_in">grid</span>;<br>  <span class="hljs-comment">/* 选择列的宽度 */</span><br>  <span class="hljs-built_in">grid</span>-template-<span class="hljs-built_in">columns</span>: repeat(<span class="hljs-number">4</span>, 1fr) <span class="hljs-comment">/* 表示有4列 且每列占当前盒子宽度的 1/4*/</span><br>&#125;<br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-22-at-5.43.25-PM.png" width="300px" alt="grid-template-columns3"/>

<h5 id="grid-template-rows"><a href="#grid-template-rows" class="headerlink" title="grid-template-rows"></a>grid-template-rows</h5><p>方法同上</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima">.<span class="hljs-built_in">grid</span>-container &#123;<br>  <span class="hljs-built_in">display</span>: <span class="hljs-built_in">grid</span>;<br>  <span class="hljs-built_in">grid</span>-template-<span class="hljs-built_in">columns</span>: 140px 280px;<br>  <span class="hljs-built_in">grid</span>-template-rows: 40px 80px;<br>&#125;<br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-22-at-5.43.59-PM.png" width="300px" alt="grid-template-rows1"/>

<h5 id="grid-auto-rows-grid-auto-coloums（二者道理相同）-但好像-grid-auto-coloums-不起效果"><a href="#grid-auto-rows-grid-auto-coloums（二者道理相同）-但好像-grid-auto-coloums-不起效果" class="headerlink" title="grid-auto-rows / grid-auto-coloums（二者道理相同） 但好像 grid-auto-coloums 不起效果"></a>grid-auto-rows / grid-auto-coloums（二者道理相同） 但好像 grid-auto-coloums 不起效果</h5><p>如果不知道有多少行 <code>row</code>，可以用 <code>auto</code> 来自动布局</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.grid-container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-number">140px</span>;<br>  grid-<span class="hljs-attribute">auto</span>-rows: <span class="hljs-number">40px</span> <span class="hljs-number">80px</span>; <span class="hljs-comment">/* 自动以 40px一行，80px一行 不断循环*/</span><br>&#125;<br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-22-at-5.47.20-PM.png" height="300px" alt="grid-template-rows2"/>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.grid-container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-number">140px</span>;<br>  grid-<span class="hljs-attribute">auto</span>-rows: <span class="hljs-number">40px</span>;<br>  grid-template-rows: <span class="hljs-number">80px</span>;   <span class="hljs-comment">/* 第一行是80px 但后续依旧以grid-auto-rows起效果 */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="minmax-方法"><a href="#minmax-方法" class="headerlink" title="minmax() 方法"></a>minmax() 方法</h5><p>起到最小最大值的限制</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;grid-container&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;grid-item&quot;</span>&gt; Grid Item <span class="hljs-number">1</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;grid-item&quot;</span>&gt; Grid Item <span class="hljs-number">2</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;grid-item&quot;</span>&gt; Grid Item <span class="hljs-number">3</span> <span class="hljs-comment">----------------------------&lt;/div&gt;</span><br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;grid-item&quot;</span>&gt; Grid Item <span class="hljs-number">4</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;grid-item&quot;</span>&gt; Grid Item <span class="hljs-number">5</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.grid-container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">2</span>, <span class="hljs-number">100px</span>);<br>  grid-<span class="hljs-attribute">auto</span>-rows: <span class="hljs-built_in">minmax</span>(<span class="hljs-number">40px</span>, auto)  /* 每行最小<span class="hljs-number">40px</span> 最大不限*/<br>&#125;<br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-22-at-5.57.13-PM.png" width="300px" alt="grid-template-rows3"/>

<h5 id="grid-row-gap-grid-column-gap-行和列的间隙"><a href="#grid-row-gap-grid-column-gap-行和列的间隙" class="headerlink" title="grid-row-gap/grid-column-gap 行和列的间隙"></a>grid-row-gap/grid-column-gap 行和列的间隙</h5><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.grid-container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">2</span>, <span class="hljs-number">100px</span>);<br>  grid-<span class="hljs-attribute">auto</span>-rows: <span class="hljs-built_in">minmax</span>(<span class="hljs-number">40px</span>, auto);<br>  grid-row-gap: <span class="hljs-number">10px</span>;<br>  grid-<span class="hljs-attribute">column-gap</span>: <span class="hljs-number">5px</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-22-at-6.01.36-PM.png" width="300px" alt="grid-row-gap"/>

<p>当然你也可以简写<code>gap</code></p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">grid</span>-gap: <span class="hljs-number">10</span>px;      /* 行间隙 和 列间隙 都是<span class="hljs-number">10</span>px*/<br><span class="hljs-attribute">grid</span>-gap: <span class="hljs-number">10</span>px <span class="hljs-number">5</span>px;  /* 行间隙 <span class="hljs-number">10</span>px 和 列间隙 <span class="hljs-number">5</span>px*/<br></code></pre></td></tr></table></figure>

<h4 id="grid-整体布局"><a href="#grid-整体布局" class="headerlink" title="grid 整体布局"></a>grid 整体布局</h4><p>整体布局(才展示了 <code>grid</code> 二维布局的魅力)</p>
<h5 id="grid-template-areas"><a href="#grid-template-areas" class="headerlink" title="grid-template-areas"></a>grid-template-areas</h5><figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.grid-container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  grid-template-<span class="hljs-attribute">columns</span>: repeat(<span class="hljs-number">2</span>, <span class="hljs-number">100px</span>);<br>  grid-<span class="hljs-attribute">auto</span>-rows: minmax(<span class="hljs-number">40px</span>, auto);<br>  grid-template-areas:<br>    <span class="hljs-string">&quot;header header&quot;</span><br>    <span class="hljs-string">&quot;sidebar content1&quot;</span><br>    <span class="hljs-string">&quot;sidebar content2&quot;</span><br>    <span class="hljs-string">&quot;footer footer&quot;</span>;<br>&#125;<br><br><span class="hljs-selector-class">.grid-item</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">1</span>) &#123;<br>  grid-area: header;<br>&#125;<br><span class="hljs-selector-class">.grid-item</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>) &#123;<br>  grid-area: sidebar;<br>&#125;<br><span class="hljs-selector-class">.grid-item</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">3</span>) &#123;<br>  grid-area: content1;<br>&#125;<br><span class="hljs-selector-class">.grid-item</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">4</span>) &#123;<br>  grid-area: content2;<br>&#125;<br><span class="hljs-selector-class">.grid-item</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">5</span>) &#123;<br>  grid-area: footer;<br>&#125;<br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-22-at-6.12.02-PM.png" width="300px" alt="grid-template-areas"/>

<h5 id="grid-column-start-grid-column-end"><a href="#grid-column-start-grid-column-end" class="headerlink" title="grid-column-start/grid-column-end"></a>grid-column-start/grid-column-end</h5><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><br><span class="hljs-selector-class">.grid-container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">2</span>, <span class="hljs-number">100px</span>);<br>  grid-<span class="hljs-attribute">auto</span>-rows: <span class="hljs-built_in">minmax</span>(<span class="hljs-number">40px</span>, auto);<br>&#125;<br><br><span class="hljs-selector-class">.grid-item</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">1</span>) &#123;<br>  grid-column-start: <span class="hljs-number">1</span>;<br>  grid-column-end: <span class="hljs-number">3</span>;    <span class="hljs-comment">/* 注意这里的数字有学问！ 1代表最左边 2代表最中间 3代表最右边 */</span><br>  <span class="hljs-comment">/* grid-column-end: -1; 负数直接表示最右边 */</span><br>  <span class="hljs-comment">/* 更加简化 start/end */</span><br>  <span class="hljs-comment">/* grid-column: 1/-1;  即 (start/end) */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima"><span class="hljs-comment">/* 版本一 */</span><br>.<span class="hljs-built_in">grid</span>-container &#123;<br>  <span class="hljs-built_in">display</span>: <span class="hljs-built_in">grid</span>;<br>  <span class="hljs-built_in">grid</span>-template-<span class="hljs-built_in">columns</span>: repeat(<span class="hljs-number">2</span>, 100px);<br>  <span class="hljs-built_in">grid</span>-auto-rows: minmax(40px, auto);<br>&#125;<br><br>.<span class="hljs-built_in">grid</span>-item:nth-child(<span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-built_in">grid</span>-column-start: <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">grid</span>-column-end: -<span class="hljs-number">1</span>;<br>&#125;<br><br>.<span class="hljs-built_in">grid</span>-item:nth-child(<span class="hljs-number">2</span>) &#123;<br>  <span class="hljs-built_in">grid</span>-<span class="hljs-built_in">row</span>-start: <span class="hljs-number">2</span>;<br>  <span class="hljs-built_in">grid</span>-<span class="hljs-built_in">row</span>-end: <span class="hljs-number">4</span>;<br>&#125;<br><br>.<span class="hljs-built_in">grid</span>-item:nth-child(<span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-built_in">grid</span>-<span class="hljs-built_in">row</span>-start: <span class="hljs-number">2</span>;<br>  <span class="hljs-built_in">grid</span>-<span class="hljs-built_in">row</span>-end: <span class="hljs-number">4</span>;<br>&#125;<br><br>.<span class="hljs-built_in">grid</span>-item:nth-child(<span class="hljs-number">4</span>) &#123;<br>  <span class="hljs-built_in">grid</span>-<span class="hljs-built_in">row</span>-start: <span class="hljs-number">4</span>;<br>  <span class="hljs-built_in">grid</span>-<span class="hljs-built_in">row</span>-end: <span class="hljs-number">6</span>;<br>&#125;<br>.<span class="hljs-built_in">grid</span>-item:nth-child(<span class="hljs-number">5</span>) &#123;<br>  <span class="hljs-built_in">grid</span>-<span class="hljs-built_in">row</span>-start: <span class="hljs-number">4</span>;<br>  <span class="hljs-built_in">grid</span>-<span class="hljs-built_in">row</span>-end: <span class="hljs-number">5</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-22-at-7.08.59-PM.png" width="300px" alt="start/end"/>

<p>其实对于<code>版本一</code>有<code>版本二</code>的写法能够有同样的效果</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima"><span class="hljs-comment">/* 版本二 */</span><br>.<span class="hljs-built_in">grid</span>-container &#123;<br>  <span class="hljs-built_in">display</span>: <span class="hljs-built_in">grid</span>;<br>  <span class="hljs-built_in">grid</span>-template-<span class="hljs-built_in">columns</span>: repeat(<span class="hljs-number">2</span>, 100px);<br>  <span class="hljs-built_in">grid</span>-auto-rows: minmax(40px, auto);<br>&#125;<br><br>.<span class="hljs-built_in">grid</span>-item:nth-child(<span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-built_in">grid</span>-column: span <span class="hljs-number">2</span><br>&#125;<br><br>.<span class="hljs-built_in">grid</span>-item:nth-child(<span class="hljs-number">2</span>) &#123;<br>  <span class="hljs-built_in">grid</span>-<span class="hljs-built_in">row</span>: span <span class="hljs-number">2</span><br>&#125;<br><br>.<span class="hljs-built_in">grid</span>-item:nth-child(<span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-built_in">grid</span>-<span class="hljs-built_in">row</span>: span <span class="hljs-number">2</span><br>&#125;<br><br>.<span class="hljs-built_in">grid</span>-item:nth-child(<span class="hljs-number">4</span>) &#123;<br>  <span class="hljs-built_in">grid</span>-<span class="hljs-built_in">row</span>: span <span class="hljs-number">2</span><br>&#125;<br>.<span class="hljs-built_in">grid</span>-item:nth-child(<span class="hljs-number">5</span>) &#123;<br>  <span class="hljs-built_in">grid</span>-<span class="hljs-built_in">row</span>: span <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="justify-content-center-align-content-center"><a href="#justify-content-center-align-content-center" class="headerlink" title="justify-content: center / align-content: center"></a>justify-content: center / align-content: center</h4><p>注意：这里的 <code>align-content</code> 和 <code>flex</code> 的 <code>align-content</code> 有一定的区别！！</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><br><span class="hljs-selector-class">.grid-container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">2</span>, <span class="hljs-number">100px</span>);<br>  grid-<span class="hljs-attribute">auto</span>-rows: <span class="hljs-number">80px</span>;<br>  <span class="hljs-attribute">justify-content</span>: center;  <span class="hljs-comment">/* 和flex的布局效果相似 这是对整个容器的位置布局 */</span><br>  <span class="hljs-attribute">align-content</span>: center;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-22-at-7.17.18-PM.png" width="300px" alt="整体位置"/>

<h4 id="justify-items-center-align-items-center"><a href="#justify-items-center-align-items-center" class="headerlink" title="justify-items: center / align-items: center"></a>justify-items: center / align-items: center</h4><p>(默认值是 stretch)</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.grid-container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">2</span>, <span class="hljs-number">100px</span>);<br>  grid-<span class="hljs-attribute">auto</span>-rows: <span class="hljs-number">80px</span>;<br>  <span class="hljs-comment">/* 这是对容器整体位置起效果*/</span><br>  <span class="hljs-attribute">justify-content</span>: center;<br>  <span class="hljs-attribute">align-content</span>: center;<br>  <span class="hljs-comment">/* 这是对容器里的子元素位置起效果 */</span><br>  justify-items: center;<br>  <span class="hljs-attribute">align-items</span>: center;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-22-at-7.24.55-PM.png" width="300px" alt="子元素位置1"/>

<h4 id="align-self-justify-self"><a href="#align-self-justify-self" class="headerlink" title="align-self/justify-self"></a>align-self/justify-self</h4><p>(默认值是 stretch)</p>
<p>会覆盖父容器的 justify-items align-items</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.grid-container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  grid-template-<span class="hljs-attribute">columns</span>: repeat(<span class="hljs-number">2</span>, <span class="hljs-number">100px</span>);<br>  grid-<span class="hljs-attribute">auto</span>-rows: <span class="hljs-number">80px</span>;<br>  <span class="hljs-attribute">justify-content</span>: center; <span class="hljs-comment">/* 和flex的布局效果相似 */</span><br>  <span class="hljs-attribute">align-content</span>: center;<br>  <span class="hljs-comment">/* 这是对容器里的子元素起效果 */</span><br>  justify-items: stretch;<br>  <span class="hljs-attribute">align-items</span>: stretch;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span>;<br>&#125;<br><br><span class="hljs-selector-class">.grid-item</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">4</span>) &#123;<br>  <span class="hljs-comment">/* 会覆盖上文的justify-items align-items */</span><br>  <span class="hljs-attribute">align-self</span>: flex-end;<br>  justify-self: flex-end;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-22-at-7.36.04-PM.png" width="300px" alt="子元素位置2"/>
]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/10/06/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>js-array-reduce</title>
    <url>/2021/12/08/js-array-reduce/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>localStorage cookie sessionStorage</title>
    <url>/2021/11/27/localStorage-cookie-sessionStorage/</url>
    <content><![CDATA[<blockquote>
<p>前言：<code>localStorage</code>、<code>cookie</code>、<code>sessionStorage</code> 用于将数据存储在用户的<strong>确切</strong>浏览器里。例如，你在你当前电脑的<code>Chrome</code>浏览器里使用上面 3 个方法来存储数据，你无法在<code>Safari</code>浏览器里获得存储的数据！</p>
</blockquote>
<h4 id="存储大小限制"><a href="#存储大小限制" class="headerlink" title="存储大小限制"></a>存储大小限制</h4><table>
<thead>
<tr>
<th>存储方法</th>
<th>存储最大容量</th>
</tr>
</thead>
<tbody><tr>
<td><strong>localStorage</strong></td>
<td><strong>10Mb</strong></td>
</tr>
<tr>
<td><strong>sessionStorage</strong></td>
<td><strong>5Mb</strong></td>
</tr>
<tr>
<td><strong>cookie</strong></td>
<td><strong>4kb</strong></td>
</tr>
</tbody></table>
<figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>Byte = <span class="hljs-number">8</span> Bits<br><span class="hljs-symbol">1 </span>Kilobyte (KB) = <span class="hljs-number">1024</span> Bytes<br><span class="hljs-symbol">1 </span>Megabyte (MB) = <span class="hljs-number">1024</span> KB<br></code></pre></td></tr></table></figure>

<p>事实上如果是仅存储数据，<code>localStorage</code>、<code>sessionStorage</code> 已经是非常非常大的了，所以几乎不用考虑存储容量大小问题！ <code>cookie</code>仅仅只有<code>4kb</code>的存储空间，但事实上，你用<code>cookie</code>存入的数据其实都是很关键的数据，所以，你也不必太关心<code>cookie</code>存储空间问题</p>
<h4 id="访问方式"><a href="#访问方式" class="headerlink" title="访问方式"></a>访问方式</h4><table>
<thead>
<tr>
<th>存储方法</th>
<th>访问方式</th>
</tr>
</thead>
<tbody><tr>
<td><strong>localStorage</strong></td>
<td>在用户使用同一个浏览器的基础上，打开多窗口上同一个网站(网址一致)，无论你打开多少个窗口，它们存储的数据是一致的</td>
</tr>
<tr>
<td><strong>session</strong></td>
<td>在用户使用同一个浏览器的基础上，打开多窗口上同一个网站(网址一致)，你在一个窗口存放的数据，另外的窗口是看不见的。你关闭了当前窗口，当前窗口的 <code>sessionStorage</code> 也会随之消失</td>
</tr>
<tr>
<td><strong>cookie</strong></td>
<td>在用户使用同一个浏览器的基础上，打开多窗口上同一个网站(网址一致)，无论你打开多少个窗口，它们存储的数据是一致的, 并且 <code>cookie</code> 还可以在服务器上访问。这是因为对于每个向后端服务器发出的请求，所有的 <code>cookie</code> 都会一起发送。这使得 <code>cookie</code> 非常适合于与身份验证相关的任务</td>
</tr>
</tbody></table>
<h4 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h4><table>
<thead>
<tr>
<th>存储方法</th>
<th>过期时间</th>
</tr>
</thead>
<tbody><tr>
<td><strong>localStorage</strong></td>
<td>无限期(除非人为删除)</td>
</tr>
<tr>
<td><strong>sessionStorage</strong></td>
<td>当前窗口关闭则数据过期，被删除</td>
</tr>
<tr>
<td><strong>cookie</strong></td>
<td>人为设定过期时间</td>
</tr>
</tbody></table>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><h5 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h5><p>(<code>localStorage</code> 和 <code>sessionStorage</code> 用法非常相似)</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 针对localStorage<br>localStorage.setItem(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;帅得乱七八糟&#x27;</span>)    <span class="hljs-regexp">//</span> 键值对方式： 且键和值都是字符串<br><span class="hljs-regexp">//</span> 针对sessionStorage<br>sessionStorage.setItem(<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;21&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-27-at-9.01.03-AM.png" alt="数据存储"><br>注意：我在<strong>chrome 浏览器</strong>打开了两个窗口(设为<strong>窗口 A</strong> <strong>窗口 B</strong>)并且都进入了<strong>B 站</strong><br>我在窗口 A 进行了<code>localStorage</code> 和 <code>sessionStorage</code>的数据存储，并且在该窗口的控制台看到了对应存储的数据。而当我打开窗口 B 在该窗口的控制台，我只能看到<code>localStorage</code>存储的数据，而<code>sessionStorage</code>里面空空如也…</p>
<p>对于<code>cookie</code>的数据存储如下：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">document.cookie</span> = <span class="hljs-string">&#x27;sex=male&#x27;</span><br></code></pre></td></tr></table></figure>

<p>控制台结果如下：<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-27-at-9.09.37-AM.png" alt="cookie1"><br>很遗憾，尽管我们设置了 <code>sex=male</code> 到 <code>cookie</code> 里去，但是该数据已过期！！</p>
<p>解决办法：手动给 <code>cookie</code> 数据设置到期时间，这里我采用 <code>UTC</code> 日期格式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.cookie =<span class="hljs-string">`friends=帅得歪瓜裂枣; expires=<span class="hljs-subst">$&#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">9999</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>).toUTCString()&#125;</span>`</span><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-27-at-9.13.55-AM.png" alt="cookie2"><br>这里的到期时间：9998 年，几乎算永恒时间</p>
<blockquote>
<p>tips: 如果你想储存多个数据,就重复使用上述方法即可！</p>
</blockquote>
<h5 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h5><p>(<code>localStorage</code> 和 <code>sessionStorage</code> 用法非常相似)</p>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">localStorage</span><span class="hljs-selector-class">.setItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;帅得乱七八糟&#x27;</span>)<br><span class="hljs-selector-tag">localStorage</span><span class="hljs-selector-class">.getItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>) <span class="hljs-comment">// &#x27;帅得乱七八糟&#x27;</span><br><br><span class="hljs-selector-tag">sessionStorage</span><span class="hljs-selector-class">.setItem</span>(<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;21&#x27;</span>)<br><span class="hljs-selector-tag">sessionStorage</span><span class="hljs-selector-class">.getItem</span>(<span class="hljs-string">&#x27;age&#x27;</span>) <span class="hljs-comment">// 21</span><br></code></pre></td></tr></table></figure>

<p><code>cookie</code> 获取方法：<code>document.cookie</code><br>只不过，这样会把所有的 <code>cookie</code> 数据获取出来(事实上应该不是所有，服务器端似乎可以限制)</p>
<h5 id="数据删除"><a href="#数据删除" class="headerlink" title="数据删除"></a>数据删除</h5><p>(<code>localStorage</code> 和 <code>sessionStorage</code> 用法非常相似)</p>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">localStorage</span><span class="hljs-selector-class">.removeItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>)<br><span class="hljs-selector-tag">sessionStorage</span><span class="hljs-selector-class">.removeItem</span>(<span class="hljs-string">&#x27;age&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p><code>cookie</code>删除方法：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">document.cookie = <span class="hljs-string">&quot;friends=; expires=Thu, 01 Jan 1970 00:00:00 GMT&quot;</span>  <span class="hljs-regexp">//</span> 把键值对中的值设置为空，且设置为已过期<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>mongoDB 基础知识</title>
    <url>/2021/11/24/mongoDB-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<blockquote>
<p>事实上，我现在完全用不着 MongoDB 技术，但是突然想学 😓，以此作为学习笔记<br>… 算了, 最近先不学这个</p>
</blockquote>
]]></content>
      <categories>
        <category>Node.JS篇</category>
      </categories>
      <tags>
        <tag>全栈</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs 基础学习</title>
    <url>/2021/11/24/nodejs-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>写 nodejs 代码 首先要下载 NodeJS: <a href="https://nodejs.org/en/">下载网页</a><br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-24-at-9.27.15-AM.png" alt="nodejs下载"></p>
<p>推荐下载<code>LTS(Long Time Support)</code>版本！因为更加稳定而<code>Current</code>版本太新了，可能出现问题！</p>
<h4 id="什么是-NodeJS-以及-NodeJS-的优势"><a href="#什么是-NodeJS-以及-NodeJS-的优势" class="headerlink" title="什么是 NodeJS 以及 NodeJS 的优势"></a>什么是 NodeJS 以及 NodeJS 的优势</h4><blockquote>
<p><strong>NodeJS</strong>: 一种 <code>javascript</code> 的运行环境，能够使得 <code>javascript</code> 脱离浏览器运行<br><strong>Node.js</strong> 在浏览器之外运行 <code>V8 JavaScript</code> 引擎（Google Chrome 的内核）。 这使得 <code>Node.js</code> 的性能非常好</p>
</blockquote>
<p>由于 <code>JavaScript</code> 发展的速度非常快，但是浏览器发展得慢一些，并且用户的升级速度也慢一些，因此有时在 web 上，不得不使用较旧的 <code>JavaScript / ECMAScript</code> 版本。可以使用 <code>Babel</code> 将代码转换为与 <code>ES5</code> 兼容的代码，再交付给浏览器，但是在 <code>Node.js</code> 中，则不需要这样做。<br>另一个区别是 <code>Node.js</code> 使用 <code>CommonJS</code> 模块系统，而在浏览器中，则还正在实现 <code>ES</code> 模块标准。<br>在实践中，这意味着在 <code>Node.js</code> 中使用 <code>require()</code>，而在浏览器中则使用 <code>import</code>。</p>
<h4 id="NodeJS-初级知识"><a href="#NodeJS-初级知识" class="headerlink" title="NodeJS 初级知识"></a>NodeJS 初级知识</h4><p>创建一个 <code>js</code> 文件并搭建初始的 <code>server</code> 端如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* app.js */</span><br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);      <span class="hljs-comment">// 引出http这个模块(这里的http是一个函数)</span><br><span class="hljs-keyword">const</span> port = <span class="hljs-number">3000</span>;                 <span class="hljs-comment">// 设置在3000端口(方便后续服务器放置在3000端口上进行监听)</span><br><br><span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>&#123;  <span class="hljs-comment">// 创建 HTTP 服务器</span><br>  <span class="hljs-comment">// 参数req --&gt; 代表 request    参数res --&gt; 代表 response</span><br>  <span class="hljs-comment">// 这里面放置的是该服务器将要进行的所用工作</span><br>&#125;)<br><br>server.listen(port, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>&#123;  <span class="hljs-comment">// 服务器被设置为在指定的 3000 端口上进行监听。 当服务器就绪时，则 listen 回调函数会被调用</span><br>  <span class="hljs-keyword">if</span> (error) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;有一些错误！&#x27;</span>, error);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Server 正在监听端口&#x27;</span> + port);<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>现在来看一看效果：</p>
<blockquote>
<p>利用 vscode 在终端输入 <code>node + 文件名</code></p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-24-at-10.46.35-AM.gif" alt="nodejs效果"></p>
<p>在浏览器(客户端)看见由 <code>server</code> 端发出的内容</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua">const http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br>const port = <span class="hljs-number">3000</span>;<br><br>const server = http.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res)</span></span>&#123;<br>  // res.<span class="hljs-built_in">write</span>(<span class="hljs-string">&#x27;在浏览器可以看见我哦~&#x27;</span>);   // 注意：不能写中文，不然会在浏览器里为乱码<br>  res.<span class="hljs-built_in">write</span>(<span class="hljs-string">&#x27;You can see me in the browser~&#x27;</span>)<br>  res.<span class="hljs-keyword">end</span>();<br>&#125;)<br><br>server.listen(port, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span></span> &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">error</span>) &#123;<br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;有一些错误！&#x27;</span>, <span class="hljs-built_in">error</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Server 正在监听端口&#x27;</span> + port);<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p><strong>注意：</strong> 每一次更改 <code>nodejs </code>文件内容，都需要重启 <code>node js</code> 才能看到效果：即<code>node app.js</code></p>
<p>可以安装<code>nodemon</code>避免上述问题。</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> init -y<br><span class="hljs-built_in">npm</span> i nodemon<br>把 package.json 文件的 <span class="hljs-string">&quot;scripts&quot;</span> 部分进行修改<br>  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;devStart&quot;</span>: <span class="hljs-string">&quot;nodemon app.js&quot;</span><br>  &#125;,<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-24-at-10.53.30-AM.gif" alt="nodemon"></p>
<p>这样，就不用再自己手动重启 <code>nodejs</code> 了</p>
<p>现在我通过 <code>server</code> 端来传递 <code>html</code>文件！</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* index.html */</span><br>  &lt;<span class="hljs-selector-tag">div</span>&gt;<br>    &lt;<span class="hljs-selector-tag">h1</span>&gt;你好世界！&lt;/<span class="hljs-selector-tag">h1</span>&gt;<br>    &lt;<span class="hljs-selector-tag">p</span>&gt;好吗？好的！&lt;/<span class="hljs-selector-tag">p</span>&gt;<br>  &lt;/<span class="hljs-selector-tag">div</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* app.js */</span><br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);   <span class="hljs-comment">// 用于文件处理的模块</span><br><span class="hljs-keyword">const</span> port = <span class="hljs-number">3000</span>;<br><br><span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>)</span>&#123;<br>  <span class="hljs-comment">// &#x27;Content-Type&#x27;:&#x27;text/html&#x27;格式支持html文件</span><br>  res.writeHead(<span class="hljs-number">200</span>, &#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>:<span class="hljs-string">&#x27;text/html&#x27;</span>&#125;)  <span class="hljs-comment">// 参数一：是http的状态码   参数二：告诉浏览器发送的数据类型</span><br>  fs.readFile(<span class="hljs-string">&#x27;index.html&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, data</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (error) &#123;<br>      res.writeHead(<span class="hljs-number">404</span>);<br>      res.write(<span class="hljs-string">&#x27;404 Not Found&#x27;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      res.write(data);   <span class="hljs-comment">// 这里的data 就是 index.html文件</span><br>    &#125;<br>  &#125;)<br>&#125;)<br><br>server.listen(port, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (error) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;有一些错误！&#x27;</span>, error);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Server 正在监听端口&#x27;</span> + port);<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-24-at-11.20.08-AM.png" alt="html在浏览器运行效果" width="300px">
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>全栈</tag>
      </tags>
  </entry>
  <entry>
    <title>post</title>
    <url>/2021/12/25/post/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>post请求和get请求的区别</title>
    <url>/2021/10/09/post%E8%AF%B7%E6%B1%82%E5%92%8Cget%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h4 id="1-有哪些请求方式？"><a href="#1-有哪些请求方式？" class="headerlink" title="1.有哪些请求方式？"></a>1.有哪些请求方式？</h4><ul>
<li>get</li>
<li>post</li>
<li>put</li>
<li>patch</li>
<li>delete<br>…</li>
</ul>
<h4 id="2-get-请求和-post-请求的区别"><a href="#2-get-请求和-post-请求的区别" class="headerlink" title="2.get 请求和 post 请求的区别"></a>2.get 请求和 post 请求的区别</h4><p><strong>get 请求</strong><br>1）一般用来从服务器获取数据 (有时候会在 url 里增添参数 表示获取有一定限制(筛选数据)的数据)<br>2）1 中提到可以在 url 里添加参数，但这样做的话，安全性，隐私性就比较差。并且参数的长度是有限制的(不然，如果无限长，url 的长度就无限长…非常恐怖…)<br>3）当 发送 get 请求时，刷新浏览器或回退页面是没有影响的(只要 url 没有发生变化，就不会影响 get 请求发送)<br>4）get 请求可以缓存 (这是什么东西？有待查询) (因为 get 请求的数据一般是公开的…大家都可以看的东西)<br>5）get 请求会保留在浏览器历史记录当中<br>6）get 请求可以被收藏为书签(因为直接收藏 url 就可以了 url 带上了参数)<br>7）get 请求只能进行 url 编码(‘Content-type’: ‘application/x-www-form-urlencoded’)<br>8）get 请求通常是通过 url 地址栏发送请求<br><strong>post 请求</strong><br>1）一般用于提交数据到后台 (比如登录、注册时的操作)<br>2）post 请求的参数放在 请求的 body 中。所以不会再 url 中展示，相对而言比 get 要更加的安全<br>3）发送 post 请求过程中，回退页面，请求重新发送(因为参数会发送变化)<br>4）post 请求不会被缓存 (post 的请求的数据一般来说都是比较私密的…)<br>5）post 不会保存在浏览器历史记录当中<br>6）post 请求不可以被收藏为书签(post 参数放在 body 里面的。书签无法找到对应的参数…)<br>7）post 请求支持多种编码方式(例如 url：’application/x-www-form-urlencoded’ 表单提交：’multipart/form-data’ …有待补充)<br>8）post 请求通常是表单发送请求</p>
<p><strong>get 和 post 请求比较深入的一些区别如下</strong></p>
<ul>
<li>post 请求和 get 请求都是 http 的请求方式。底层都是 tcp/ip 协议。get 产生一个 tcp 数据包。post 产生两个数据包(但是 firefox 只发送一个)<br>有个问题是，这个发送一个数据包或发送两个数据包的区别和意义是什么呢？<br>(在网络好的时候，发一次数据包和发两次数据包 其实效果都差不多。但是当网络条件很差的时候，发一次数据包的效果肯定比发两次数据包的速度要快！)</li>
<li>get 请求会把 http header 和 data 一起发送出去，服务端反应 200。post 请求先发送 header，等服务端响应了 100 再继续发送 data。服务端再响应 200</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>react中常犯的错误</title>
    <url>/2021/11/01/react%E4%B8%AD%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<h3 id="useState-篇"><a href="#useState-篇" class="headerlink" title="useState 篇"></a>useState 篇</h3><h4 id="使用-useState-的时候，打印出来的结果往往是上一次渲染的结果-例如"><a href="#使用-useState-的时候，打印出来的结果往往是上一次渲染的结果-例如" class="headerlink" title="使用 useState 的时候，打印出来的结果往往是上一次渲染的结果 例如"></a>使用 useState 的时候，打印出来的结果往往是上一次渲染的结果 例如</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">App.js<br><span class="hljs-keyword">import</span> &#123;useState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">decrement</span>(<span class="hljs-params"></span>) </span>&#123;<br>    setCount(count - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 打印出的内容总是比当前的要慢一拍...</span><br>    <span class="hljs-built_in">console</span>.log(count);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">increment</span>(<span class="hljs-params"></span>) </span>&#123;<br>    setCount(count + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">console</span>.log(count);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;decrement&#125;</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      &#123;count&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;increment&#125;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-02-at-8.31.55-AM.1dmn8iq4rlwg.gif" alt="总是打印上一次渲染的结果"></p>
<p>解决办法 1：<code>setState</code>里面放入函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">decrement</span>(<span class="hljs-params"></span>) </span>&#123;<br>    setCount(<span class="hljs-function"><span class="hljs-params">prevCount</span> =&gt;</span> &#123;<br>      <span class="hljs-comment">// 可以打印出当前值来...</span><br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;current&#x27;</span>, prevCount - <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">return</span> prevCount - <span class="hljs-number">1</span><br>    &#125;)<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">increment</span>(<span class="hljs-params"></span>) </span>&#123;<br>    setCount(<span class="hljs-function"><span class="hljs-params">prevCount</span> =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;current&#x27;</span>, prevCount + <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">return</span> prevCount + <span class="hljs-number">1</span>;<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;decrement&#125;</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      &#123;count&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;increment&#125;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-02-at-8.35.50-AM.1mr4db5n7sjk.gif" alt="展示解决问题后的效果"></p>
<p>解决办法 2： 利用 <code>useEffect</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">decrement</span>(<span class="hljs-params"></span>) </span>&#123;<br>    setCount(count - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;count&#x27;</span>, count);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">increment</span>(<span class="hljs-params"></span>) </span>&#123;<br>    setCount(count + <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-comment">// 注意一件事情：useEffect似乎总是在当次渲染最后的阶段才会执行</span><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(count);<br>  &#125;, [count])<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;decrement&#125;</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      &#123;count&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;increment&#125;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-02-at-8.52.02-AM.5p7kn57e3oc0.gif" alt="解决问题的效果"></p>
<h4 id="使用-useState-的时候，同一个地方多次使用-useState…但是最后只打印一次的结果"><a href="#使用-useState-的时候，同一个地方多次使用-useState…但是最后只打印一次的结果" class="headerlink" title="使用 useState 的时候，同一个地方多次使用 useState…但是最后只打印一次的结果"></a>使用 useState 的时候，同一个地方多次使用 useState…但是最后只打印一次的结果</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">App()</span> &#123;<br>  const <span class="hljs-literal">[<span class="hljs-identifier">count</span>, <span class="hljs-identifier">setCount</span>]</span> = use<span class="hljs-constructor">State(0)</span>;<br><br>  <span class="hljs-keyword">function</span> decrement<span class="hljs-literal">()</span> &#123;<br>    set<span class="hljs-constructor">Count(<span class="hljs-params">count</span> - 1)</span>;<br>    set<span class="hljs-constructor">Count(<span class="hljs-params">count</span> - 1)</span>;<br>    set<span class="hljs-constructor">Count(<span class="hljs-params">count</span> - 1)</span>;<br>    set<span class="hljs-constructor">Count(<span class="hljs-params">count</span> - 1)</span>;<br>    console.log(count);<br>  &#125;<br>  <span class="hljs-keyword">function</span> increment<span class="hljs-literal">()</span> &#123;<br>    set<span class="hljs-constructor">Count(<span class="hljs-params">count</span> + 1)</span>;<br>    set<span class="hljs-constructor">Count(<span class="hljs-params">count</span> + 1)</span>;<br>    set<span class="hljs-constructor">Count(<span class="hljs-params">count</span> + 1)</span>;<br>    set<span class="hljs-constructor">Count(<span class="hljs-params">count</span> + 1)</span>;<br>    console.log(count);<br>  &#125;<br><br>  return (<br>    &lt;&gt;<br>      &lt;button onClick=&#123;decrement&#125;&gt;-&lt;/button&gt;<br>      &#123;count&#125;<br>      &lt;button onClick=&#123;increment&#125;&gt;+&lt;/button&gt;<br>    &lt;/&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-02-at-8.38.52-AM.43efrxnf3uc0.gif" alt="效果如图"></p>
<p>解决办法： 还是在<code>setState</code>中放函数来解决</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">function</span></span> App() &#123;<br>  const [<span class="hljs-built_in">count</span>, setCount] = useState(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span></span> decrement() &#123;<br>    setCount(<span class="hljs-built_in">count</span> =&gt; <span class="hljs-built_in">count</span> - <span class="hljs-number">1</span>);<br>    setCount(<span class="hljs-built_in">count</span> =&gt; <span class="hljs-built_in">count</span> - <span class="hljs-number">1</span>);<br>    setCount(<span class="hljs-built_in">count</span> =&gt; <span class="hljs-built_in">count</span> - <span class="hljs-number">1</span>);<br>    setCount(<span class="hljs-built_in">count</span> =&gt; &#123;<br>      console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">count</span> - <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">count</span> - <span class="hljs-number">1</span><br>    &#125;);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span></span> increment() &#123;<br>    setCount(<span class="hljs-built_in">count</span> =&gt; <span class="hljs-built_in">count</span> + <span class="hljs-number">1</span>);<br>    setCount(<span class="hljs-built_in">count</span> =&gt; <span class="hljs-built_in">count</span> + <span class="hljs-number">1</span>);<br>    setCount(<span class="hljs-built_in">count</span> =&gt; <span class="hljs-built_in">count</span> + <span class="hljs-number">1</span>);<br>    setCount(<span class="hljs-built_in">count</span> =&gt; &#123;<br>      console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">count</span> + <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">count</span> + <span class="hljs-number">1</span><br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    &lt;&gt;<br>      &lt;button onClick=&#123;decrement&#125;&gt;-&lt;/button&gt;<br>      &#123;<span class="hljs-built_in">count</span>&#125;<br>      &lt;button onClick=&#123;increment&#125;&gt;+&lt;/button&gt;<br>    &lt;/&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-02-at-8.43.37-AM.a9jurgtg8ww.gif" alt="解决问题后的效果"></p>
<h3 id="useEffect-篇"><a href="#useEffect-篇" class="headerlink" title="useEffect 篇"></a>useEffect 篇</h3><h4 id="useEffect-执行不受控制-依赖项为对象"><a href="#useEffect-执行不受控制-依赖项为对象" class="headerlink" title="useEffect 执行不受控制(依赖项为对象)"></a>useEffect 执行不受控制(依赖项为对象)</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;useState, useEffect&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [name, setName] = useState(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <span class="hljs-keyword">const</span> [dark, setDark] = useState(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">const</span> age = <span class="hljs-number">24</span>;<br>  <span class="hljs-keyword">const</span> user = &#123;age, name&#125;;<br><br>  <span class="hljs-keyword">const</span> BtnStyle = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">padding</span>: <span class="hljs-string">&#x27;2px&#x27;</span>,<br>      <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;dark ? <span class="hljs-string">&#x27;black&#x27;</span> : <span class="hljs-string">&#x27;white&#x27;</span>&#125;</span>`</span>,<br>      <span class="hljs-attr">color</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;dark ? <span class="hljs-string">&#x27;white&#x27;</span> :  <span class="hljs-string">&#x27;black&#x27;</span> &#125;</span>`</span><br>    &#125;<br>  &#125;<br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;user&#x27;</span>, user);<br>  &#125;, [user])<br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      &#123;/* input 标签和onChange事件是绝配哦！ */&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;(e)</span> =&gt;</span> &#123;setName(e.target.value)&#125;&#125;/&gt;</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;setDark(dark =&gt; !dark)&#125;&#125;</span><br><span class="xml">        style=&#123;BtnStyle()&#125;</span><br><span class="xml">      &gt;Toggle Theme<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-02-at-10.04.01-AM.6po73dr6gz00.gif" alt="问题如图"></p>
<p>我点击<code>Toggle Theme</code>。按道理来说，不应该打印 user。但因为 user 是对象。前后两次渲染生成的 user 的地址不一样所以会导致 useEffect 的重新执行。</p>
<p>解决办法 <code>useMemo</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [name, setName] = useState(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <span class="hljs-keyword">const</span> [dark, setDark] = useState(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">const</span> age = <span class="hljs-number">24</span>;<br><br>  <span class="hljs-comment">// 只有age 或者 name 变化的时候，才会有新的user生成。</span><br>  <span class="hljs-comment">// 不然，重复的渲染也不会有新的user生成</span><br>  <span class="hljs-keyword">const</span> user = useMemo(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;age, name&#125;<br>  &#125;, [age, name])<br><br>  <span class="hljs-keyword">const</span> BtnStyle = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">padding</span>: <span class="hljs-string">&#x27;2px&#x27;</span>,<br>      <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;dark ? <span class="hljs-string">&#x27;black&#x27;</span> : <span class="hljs-string">&#x27;white&#x27;</span>&#125;</span>`</span>,<br>      <span class="hljs-attr">color</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;dark ? <span class="hljs-string">&#x27;white&#x27;</span> :  <span class="hljs-string">&#x27;black&#x27;</span> &#125;</span>`</span><br>    &#125;<br>  &#125;<br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;user&#x27;</span>, user);<br>  &#125;, [user])   <span class="hljs-comment">// 当然，依赖项改为user的内部属性即[name, age]也可以，但是不够灵活</span><br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      &#123;/* input 标签和onChange事件是绝配哦！ */&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;(e)</span> =&gt;</span> &#123;setName(e.target.value)&#125;&#125;/&gt;</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;setDark(dark =&gt; !dark)&#125;&#125;</span><br><span class="xml">        style=&#123;BtnStyle()&#125;</span><br><span class="xml">      &gt;Toggle Theme<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-02-at-10.12.54-AM.3hitoqy72fo0.gif" alt="解决问题后的效果图"></p>
]]></content>
      <categories>
        <category>React篇</category>
      </categories>
      <tags>
        <tag>高级</tag>
      </tags>
  </entry>
  <entry>
    <title>tailwindcss-注意项</title>
    <url>/2021/10/23/tailwindcss-%E6%B3%A8%E6%84%8F%E9%A1%B9/</url>
    <content><![CDATA[<blockquote>
<p>当前版本：<code>v2.2.15</code></p>
</blockquote>
<p>我 TM 发现，当前版本似乎是不支持<code>rotate3d</code>的。<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/3B9771F637F41E091B4FCE198208DFD9.76wwwpk22l40.png" alt="不支持y轴旋转"></p>
<p>不知道有什么解决办法没…???</p>
<p>有解决办法：自己去自定义功能</p>
<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-23-at-9.53.54-AM.5u636vtv5gk0.png" alt="自定义功能"></p>
<hr>
<blockquote>
<p>tailwindcss 新特性：<code>JIT</code></p>
</blockquote>
<p>按需加载~也是在性能层次上的升级…<br><a href="https://tailwindcss.com/docs/just-in-time-mode">文档</a></p>
<h4 id="tailwindcss-和-antd-结合在-react-项目中使用"><a href="#tailwindcss-和-antd-结合在-react-项目中使用" class="headerlink" title="tailwindcss 和 antd 结合在 react 项目中使用"></a>tailwindcss 和 antd 结合在 react 项目中使用</h4><p>注意：tailwindcss 和 antd 是能够良好的适配的。只不过最好 tailwindcss 开启 <code>!important</code><br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-26-at-8.23.00-PM.65an1pz1gzg0.png" alt="tailwindcss-antd"></p>
<h4 id="使用-tailwindcss-后的优先级是怎么样。与-antd-相比？与普通的-css-相比？与行内样式相比？"><a href="#使用-tailwindcss-后的优先级是怎么样。与-antd-相比？与普通的-css-相比？与行内样式相比？" class="headerlink" title="使用 tailwindcss 后的优先级是怎么样。与 antd 相比？与普通的 css 相比？与行内样式相比？"></a>使用 tailwindcss 后的优先级是怎么样。与 antd 相比？与普通的 css 相比？与行内样式相比？</h4>]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>高级</tag>
      </tags>
  </entry>
  <entry>
    <title>一些 JS 有趣且有用的函数</title>
    <url>/2021/12/02/%E4%B8%80%E4%BA%9B-JS-%E6%9C%89%E8%B6%A3%E4%B8%94%E6%9C%89%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p><strong>注意：在一个函数里，改变传入的对象本身，这种行为是不好的！ 你至少应该复制一个副本！(不是复制地址值哦)</strong></p>
<h4 id="清理对象的众多属性中只有键而没有值-值为-undefined、null-的情况-不包括-0-‘’-false-这些带有值的-！"><a href="#清理对象的众多属性中只有键而没有值-值为-undefined、null-的情况-不包括-0-‘’-false-这些带有值的-！" class="headerlink" title="清理对象的众多属性中只有键而没有值(值为 undefined、null)的情况(不包括 0, ‘’, false 这些带有值的)！"></a>清理对象的众多属性中只有键而没有值(值为 undefined、null)的情况(不包括 0, ‘’, false 这些带有值的)！</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> cleanObject = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">object</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> result = &#123;...object&#125;;   <span class="hljs-comment">// 不要修改传入的对象</span><br>  <span class="hljs-built_in">Object</span>.keys(result).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;  <span class="hljs-comment">// Object.keys 能够获取对象的所有键值对，并转化为数组</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">object</span>[key] ?? <span class="hljs-literal">true</span>) &#123;  <span class="hljs-comment">// 这个 ?? 是非常牛的！  我有篇博客专门有讲解！</span><br>      <span class="hljs-keyword">delete</span> result[key]<br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-string">&#x27;test1&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-string">&#x27;test2&#x27;</span>: <span class="hljs-literal">null</span>,        <span class="hljs-comment">// 被删</span><br>  <span class="hljs-string">&#x27;test3&#x27;</span>: <span class="hljs-literal">undefined</span>,   <span class="hljs-comment">// 被删</span><br>  <span class="hljs-string">&#x27;test4&#x27;</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-string">&#x27;test5&#x27;</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-string">&#x27;test6&#x27;</span>: <span class="hljs-string">&#x27;测试测试&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">const</span> newObj = cleanObject(obj)<br><span class="hljs-built_in">console</span>.log(newObj);<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-12-03-at-9.11.20-AM.png" alt="func1"></p>
<h4 id="封装-http-请求-针对-jwt"><a href="#封装-http-请求-针对-jwt" class="headerlink" title="封装 http 请求(针对 jwt)"></a>封装 http 请求(针对 jwt)</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> qs <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;qs&quot;</span>; <span class="hljs-comment">// 要安装qs</span><br><span class="hljs-comment">// 这里的RequestInit是针对的fetch的第二参数的类型</span><br><span class="hljs-keyword">interface</span> Config <span class="hljs-keyword">extends</span> RequestInit &#123;<br>  token?: <span class="hljs-built_in">string</span>;<br>  data?: <span class="hljs-built_in">object</span>;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> http = <span class="hljs-keyword">async</span> (<br>  endpoint: <span class="hljs-built_in">string</span>,<br>  &#123; data, token, headers, ...customConfig &#125;: Config<br>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> config = &#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-comment">// 默认是GET</span><br>    <span class="hljs-attr">headers</span>: &#123;<br>      <span class="hljs-attr">Authorization</span>: token ? <span class="hljs-string">`Bearer <span class="hljs-subst">$&#123;token&#125;</span>`</span> : <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// 针对token会用到的，发送请求，携带token</span><br>      <span class="hljs-string">&quot;Content-Type&quot;</span>: data ? <span class="hljs-string">&quot;application/json&quot;</span> : <span class="hljs-string">&quot;&quot;</span><br>    &#125;,<br>    ...customConfig <span class="hljs-comment">// 可以覆盖前面的属性，特别是method方法，轻易改变为 POST 或其他请求方式</span><br>  &#125;;<br><br>  <span class="hljs-keyword">if</span> (config.method.toUpperCase() === <span class="hljs-string">&quot;GET&quot;</span>) &#123;<br>    endpoint += <span class="hljs-string">`?<span class="hljs-subst">$&#123;qs.stringify(data)&#125;</span>`</span>; <span class="hljs-comment">// qs.stringify 将对象键值对转化为 xxx=xx&amp;xx=xxx格式</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    config.body = <span class="hljs-built_in">JSON</span>.stringify(data || &#123;&#125;); <span class="hljs-comment">// 哈哈，无形之中给config加上了body属性</span><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">window</span>.fetch(<span class="hljs-string">`.../<span class="hljs-subst">$&#123;endpoint&#125;</span>`</span>, config).then(<span class="hljs-keyword">async</span> (res) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (res.status === <span class="hljs-number">401</span>) &#123;<br>      <span class="hljs-comment">// 401 是未登录或token失效的意思</span><br>      <span class="hljs-comment">// 设置一个退出登录的操作(方法)</span><br>      <span class="hljs-built_in">window</span>.location.reload(); <span class="hljs-comment">// 页面重新刷新</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;请重新登录&quot;</span> &#125;);<br>    &#125;<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> res.json();<br>    <span class="hljs-keyword">if</span> (res.ok) &#123;<br>      <span class="hljs-keyword">return</span> data;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(data);<br>    &#125;<br>  &#125;);<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h4 id="返回首页"><a href="#返回首页" class="headerlink" title="返回首页"></a>返回首页</h4><figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">const resetRoute = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (<span class="hljs-built_in">window</span>.location.href = <span class="hljs-built_in">window</span>.location.origin);<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>奇淫技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>一些软件推荐以及特别的指令</title>
    <url>/2021/12/13/%E4%B8%80%E4%BA%9B%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90%E4%BB%A5%E5%8F%8A%E7%89%B9%E5%88%AB%E7%9A%84%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h4 id="vscode-单页面关键字搜索：-command-G"><a href="#vscode-单页面关键字搜索：-command-G" class="headerlink" title="vscode 单页面关键字搜索： command + G"></a>vscode 单页面关键字搜索： command + G</h4><h4 id="vscode-中-格式化-json-点击方法"><a href="#vscode-中-格式化-json-点击方法" class="headerlink" title="vscode 中 格式化 json 点击方法"></a>vscode 中 格式化 json <a href="https://zhuanlan.zhihu.com/p/349187161">点击方法</a></h4><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">简述方法：<br><span class="hljs-number">1.</span> 下载 <span class="hljs-type">JSON</span> TOOLS 插件<br><span class="hljs-number">2.</span> 在<span class="hljs-type">json</span>文件里输入 <span class="hljs-keyword">option</span> + command + M<br></code></pre></td></tr></table></figure>

<h4 id="不说了，牛爷爷-vscode-插件推荐"><a href="#不说了，牛爷爷-vscode-插件推荐" class="headerlink" title="不说了，牛爷爷 vscode 插件推荐"></a>不说了，牛爷爷 vscode 插件推荐</h4><p>vscode 插件：</p>
<ul>
<li>ES7 React/Redux/GraphQL/React-Native snippets</li>
<li>Tabnine AI</li>
</ul>
<h3 id="简历模板"><a href="#简历模板" class="headerlink" title="简历模板"></a>简历模板</h3><p><a href="https://github.com/Squares4/resume-zpc">https://github.com/Squares4/resume-zpc</a></p>
]]></content>
      <categories>
        <category>好用工具篇</category>
      </categories>
      <tags>
        <tag>奇淫技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇文章掌握性能优化大法之防抖和节流</title>
    <url>/2021/10/13/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%8E%8C%E6%8F%A1%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%A4%A7%E6%B3%95%E4%B9%8B%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<p>相信一提到前端性能优化，大家脑子里就会一下映射出许多内容。例如：懒加载、CDN 缓存、DOM 优化、图片优化、Webpack 的优化配置…但今天我想谈论的一个性能优化点是<strong>防抖</strong>和<strong>节流</strong>函数，因为它俩够“小巧”，但发挥的作用却不容小觑！</p>
<p>在实际写项目的时候，我们会发现，一些事件总是会被频繁触发。例如鼠标事件、键盘事件、scroll 事件…</p>
<p>举个小例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">let</span> input = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;[name=&quot;username&quot;]&#x27;</span>)</span><br><span class="javascript">  input.addEventListener(<span class="hljs-string">&#x27;keyup&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.value)</span><br><span class="javascript">  &#125;)</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e1b22b590194ef58b3cf9ce2853aaa0~tplv-k3u1fbpfcp-watermark.image" alt="debounce1.gif"></p>
<p>由上述非常简短的代码及效果图，我们就可以发现，频繁的触发回调是真的要命 😭😭😭,它不仅会造成大量的计算引发页面卡顿还会造成频繁的网络请求导致不必要的流量浪费以及极低的用户体验…为了规避这类情况，我们急需控制回调的触发频率，让回调函数被触发的次数恰到好处！因此，防抖函数和节流函数闪亮登场 ✨</p>
<hr>
<h3 id="防抖函数-debounce"><a href="#防抖函数-debounce" class="headerlink" title="防抖函数(debounce)"></a>防抖函数(debounce)</h3><h4 id="防抖函数核心逻辑"><a href="#防抖函数核心逻辑" class="headerlink" title="防抖函数核心逻辑"></a>防抖函数核心逻辑</h4><p>人为设定一段<strong>延迟时间</strong>，用于延迟执行<strong>回调函数 A</strong>。如果在延迟时间内，用户反复触发这个<strong>回调函数 A</strong>，则只会重复刷新延迟时间，而频繁被触发的<strong>回调函数 A</strong>中，<strong>仅最后一次触发的回调函数 A 是能被执行的</strong>。</p>
<h4 id="写防抖函数的五大要素"><a href="#写防抖函数的五大要素" class="headerlink" title="写防抖函数的五大要素"></a>写防抖函数的五大要素</h4><p>好了，上文已经讲解了防抖函数的核心逻辑，现在大家来熟悉一下写防抖函数的五大要素，从而方便理解下文真正的防抖函数 💪🏻</p>
<ul>
<li><ol>
<li>需要使用闭包</li>
</ol>
</li>
<li><ol start="2">
<li>需要 setTimeout、clearTimeout 的灵活运用</li>
</ol>
</li>
<li><ol start="3">
<li>防抖函数的第一个参数为需要被触发的回调函数</li>
</ol>
</li>
<li><ol start="4">
<li>防抖函数会返回一个函数</li>
</ol>
</li>
<li><ol start="5">
<li>回调函数的 this 指向需要和防抖函数返回的这个函数 this 指向保持一致</li>
</ol>
</li>
</ul>
<h4 id="手写防抖函数"><a href="#手写防抖函数" class="headerlink" title="手写防抖函数"></a>手写防抖函数</h4><p>请大家在看代码的同时注意我的注释！！！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// fnA 是要被触发的回调函数   delay是延迟时间</span><br><span class="hljs-keyword">let</span> debounce = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fnA, delay</span>) </span>&#123;<br>    <span class="hljs-comment">// timer是定时器，如果在延迟时间内频繁触发回调函数A，则会重复刷新延迟时间timer</span><br>    <span class="hljs-comment">// 注意：这里会运用到闭包！！(请不了解闭包基础知识的朋友先去看一下闭包基础知识后再继续看这篇博客)</span><br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">// 防抖函数会返回一个函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-comment">// 锁定当前this的指向，方便控制fnA的this指向和这个返回函数的this指向保持一致</span><br>        <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">this</span>;<br>        <span class="hljs-comment">// 保留调用防抖函数时传入的参数</span><br>        <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">arguments</span>;<br><br>        <span class="hljs-comment">// 如果在延迟时间内频繁触发回调函数A，则重复刷新延迟时间timer</span><br>        <span class="hljs-keyword">if</span> (timer) &#123;<br>            <span class="hljs-built_in">clearTimeout</span>(timer);<br>        &#125;<br>        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-comment">// 将fn的this指向和防抖函数返回的这个函数的this指向保持一致</span><br>            fnA.call(context, ...arguments)<br>        &#125;, delay)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>好啦，手写代码完成。接下来，我们试一试防抖函数</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">let</span> input = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;[name=&quot;username&quot;]&#x27;</span>)</span><br><span class="javascript">  <span class="hljs-comment">// 注意：addEventListener的this总是当前正在处理事件的那个DOM对象</span></span><br><span class="javascript">  input.addEventListener(<span class="hljs-string">&#x27;keyup&#x27;</span>, debounce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.value)</span><br><span class="javascript">  &#125;, <span class="hljs-number">2000</span>))</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71fab3e4f6044064b640a1fa5964349d~tplv-k3u1fbpfcp-watermark.image" alt="debounce2.gif"></p>
<p>快速输入 12345677 后，需再等待 2s 才会执行真正的回调函数。这就是防抖函数发挥的真正作用！消除了过多而不必要的回调函数。</p>
<p><strong>附赠一个化简版的<code>debounce</code></strong></p>
<p>这个版本的<code>debounce</code>使用了箭头函数，原理和上面的<code>debounce</code>是一样的。(关于此题的箭头函数使用，也许本篇博客的<strong>彩蛋 2</strong>能给你一个提示)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> debounce = <span class="hljs-function">(<span class="hljs-params">fn, delay</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...<span class="hljs-built_in">arguments</span></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;arguments&#x27;</span>, <span class="hljs-built_in">arguments</span>)<br>    <span class="hljs-keyword">if</span> (timer) &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timer);<br>    &#125;<br>    <span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;测试&#x27;</span><br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      fn.call(<span class="hljs-built_in">this</span>, ...arguments)<br>    &#125;, delay)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="节流函数-throttle"><a href="#节流函数-throttle" class="headerlink" title="节流函数(throttle)"></a>节流函数(throttle)</h3><h4 id="节流函数的核心逻辑"><a href="#节流函数的核心逻辑" class="headerlink" title="节流函数的核心逻辑"></a>节流函数的核心逻辑</h4><p>人为设定一段间隔时间，<strong>当第一次触发回调函数 A 时，回调函数 A 被立即执行并且开始计时</strong>。在这段间隔时间内，无论用户触发多少次<strong>回调函数 A</strong>，都不会被执行。</p>
<h4 id="写节流函数的五大要素"><a href="#写节流函数的五大要素" class="headerlink" title="写节流函数的五大要素"></a>写节流函数的五大要素</h4><p>事实上，节流的五大要素和防抖非常相似(只有第二点有区别)，所以当看懂防抖函数的代码后，在手写节流代码时就显得比较轻松了！</p>
<ul>
<li><ol>
<li>需要使用闭包</li>
</ol>
</li>
<li><ol start="2">
<li>结合时间戳来判断时间间隔</li>
</ol>
</li>
<li><ol start="3">
<li>节流函数的第一个参数为需要被触发的回调函数</li>
</ol>
</li>
<li><ol start="4">
<li>节流函数会返回一个函数</li>
</ol>
</li>
<li><ol start="5">
<li>回调函数的 this 指向需要和节流函数返回的这个函数 this 指向保持一致</li>
</ol>
</li>
</ul>
<h4 id="手写节流函数"><a href="#手写节流函数" class="headerlink" title="手写节流函数"></a>手写节流函数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"> <span class="hljs-comment">// fnA 表示回调函数A， interval表示间隔时间</span><br> <span class="hljs-keyword">let</span> throttle = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fnA, interval</span>) </span>&#123;<br>  <span class="hljs-comment">// last 运用闭包知识</span><br>  <span class="hljs-comment">// last 为上一次触发回调的时间, 初始化为0 方便第一次触发事件就能运行回调函数</span><br>  <span class="hljs-keyword">let</span> last = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 返回一个函数</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 记录当前的时间戳</span><br>    <span class="hljs-keyword">let</span> now = <span class="hljs-built_in">Date</span>.now();<br>    <span class="hljs-comment">// 保留调用节流函数时传入的参数</span><br>    <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">arguments</span>;<br>    <span class="hljs-comment">// 回调函数的this指向需要和节流函数返回的这个函数this指向保持一致</span><br>    <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-comment">// 通过时间差来判断再一次触发的回调函数是否还在这段时间间隔内</span><br>    <span class="hljs-keyword">if</span> (now - last &gt;= interval) &#123;<br>      last = now;<br>      fnA.call(context, ...args)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>代码效果：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd4d3d0f930b4882b09c4a52ff1d071c~tplv-k3u1fbpfcp-watermark.image" alt="throttle1.gif"></p>
<p>事实上，防抖和节流函数的相似度是非常高的, 相信大家在理解完我手写防抖和节流函数时所提及的 5 大要素以及我的代码注释后，能够对防抖和节流函数感到更加亲切！剩下的就是靠你自己手写一下代码，让代码真正变成你自己拥有的。</p>
<p>本篇文章可能会有作者笔误或理解错误的地方，请大家多多指出！ 如果这篇文章对你有帮助的话，还请给这篇文章点一个赞吧 💕</p>
<hr>
<p>下面的三个彩蛋实则是我在写这篇博客时突然想到的三个关于 this 和作用域比较有意思的点，如果大家有兴趣，不妨看一看！</p>
<h5 id="彩蛋-1"><a href="#彩蛋-1" class="headerlink" title="彩蛋 1"></a>彩蛋 1</h5><p>在上述防抖函数中，我使用到了 setTimeout。而事实上对于<code>setTimeout</code>的<code>this</code>指向，其实也是有一些学问在里面的。<br>给大家送福利！在下述三种情况，this 会 100%指向 window</p>
<ul>
<li>立即执行函数(IIFE)</li>
<li>setTimeout 中传入的函数(非箭头函数)</li>
<li>setInterval 中传入的函数(非箭头函数)</li>
</ul>
<h5 id="彩蛋-2"><a href="#彩蛋-2" class="headerlink" title="彩蛋 2"></a>彩蛋 2</h5><p>对于 setTimeout 的箭头函数的思考</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;帅得乱七八糟&#x27;</span><br><br><span class="hljs-keyword">var</span> me = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;帅得歪瓜裂枣&#x27;</span>,<br>  <span class="hljs-attr">hello1</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 箭头函数中的 this，和你如何调用它无关，由你书写它的位置决定</span><br>  <span class="hljs-comment">// 这里的this的作用域是hello1函数作用域。所以，谁调用hello1，这里的this就指向谁</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-comment">// 指向me</span><br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`你好，我是<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>`</span>)<br>    &#125;)<br>  &#125;,<br>  <span class="hljs-attr">hello2</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;   <span class="hljs-comment">// 指向window(彩蛋1里有提到)</span><br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`你好，我是<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>`</span>)<br>    &#125;)<br>  &#125;<br>&#125;<br><br>me.hello1();   <span class="hljs-comment">// 你好，我是帅得歪瓜裂枣</span><br>me.hello2();   <span class="hljs-comment">// 你好，我是帅得乱七八糟</span><br><br></code></pre></td></tr></table></figure>

<h5 id="彩蛋-3"><a href="#彩蛋-3" class="headerlink" title="彩蛋 3"></a>彩蛋 3</h5><p>关于回调函数的参数问题</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">let func = <span class="hljs-function"><span class="hljs-params">(fn)</span> =&gt;</span> &#123;<br>    fn();<br>&#125;<br>let callback = <span class="hljs-function"><span class="hljs-params">(param)</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(param)<br>&#125;<br>let fn = function() &#123;<br>    let param = <span class="hljs-number">123</span>;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(param);   <span class="hljs-regexp">//</span> <span class="hljs-number">1</span>s后打印： <span class="hljs-number">123</span><br>    &#125;, <span class="hljs-number">1000</span>)<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">(param)</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(param);   <span class="hljs-regexp">//</span> <span class="hljs-number">1</span>s后打印： <span class="hljs-literal">undefined</span><br>    &#125;, <span class="hljs-number">3000</span>)<br><br>    func(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> callback(param))      <span class="hljs-regexp">//</span> <span class="hljs-number">123</span><br>    func(<span class="hljs-function"><span class="hljs-params">(param)</span> =&gt;</span> callback(param)) <span class="hljs-regexp">//</span> <span class="hljs-literal">undefined</span><br>&#125;<br>fn();<br></code></pre></td></tr></table></figure>

<p>为何我给回调的参数加上<code>param</code>，则打印变为<code>undefined</code>？ 这其实是函数作用域在作怪！如果在回调的参数上加<code>param</code>，则该回调内的所有<code>param</code>(包括回调的参数<code>param</code>)都是属于该回调函数的作用域内。而很明显，回调里的<code>param</code>没有赋上任何值，所以是<code>undefined</code>。如果参数没有 param，则回调内的<code>param</code>就会向上一层作用域内寻找<code>param</code>，恰好 fn 里有定义<code>param</code> 且值为 123。</p>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>高级</tag>
      </tags>
  </entry>
  <entry>
    <title>全栈之路</title>
    <url>/2021/10/27/%E5%85%A8%E6%A0%88%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="85e0cfa87bb3f35db14416837591c699feb2ee106448a3b81e300fe5ef05eb1b">227b2a181666066aebdadda3a2b5e6f50d6e05fc6d451d3d21073ae436e46d1569c5a0a427d8db9a6ecb5f7716f78486174e1c589784f095fa5400ad938788f1047c72422d851cf8b6e2d288070ce94b1172db78ec3c84590d2233c4d1e6fab7f38ea6c064de4e926c766fad56a6459acca247ae8492f3c81d056b2886e0c93cc5ba5310063d42b00eb392f52e9d8f55f543fe95a3687b27ad03b87c21a900bdeeed80c861537c63d4ba4c3e75333677e7e9f5f3499b9665a0ee9d752e59599bdaf8481cce5b6e8537ce467e52a59afdb8345e3d913601208115465dd8e7ed1e10d8c3832dc4fdb39d898f0885e903df85dbd8c3846e90824dea9b218df0aab637c50e3db0fd08fad4b39a382d4d1f1620ef0a2f5e911cd5c89e6c8d92bdeada0159c6d761af0cc818e8e4a0a0f6bb063a31ee419f2bea407a16d250d558eb1f742cb3a9f42aa6d96575639ffec0384fdc80a87fae77d54c3d90ea8f864b5de30633fa533cbf4dc73e16efd66d15aa4d9843e0a8fb1db0b140d2dbbe32648fd1f573acaa3c855b21eb1ab1b10d9702f32bdb194f35853641c219a594620695fba3e9fe1fdaae5bc80891143664125d43e9b01e91e5e610e26681997d57b80edb9ef1f46e4a0712b110b5c2add5f5dc7c9421f5c8327380eb819a0251dd3517e9f925155996008a2b822e4d76a5adbdcd196aedc7fc243b09489336219abdddba876e594ce2b46757ea2335e0eea787e9dbf47d90b1cfa9da0db4af8cd7924bf4ed57bd2524dd3773b97112bc2f9b06b3078c64f271d300cdc3d24cf69a3e65d7e787ada6f1452a6787cd5b89baacd227b09969a08019248d0bf4ad19244bc5961ea984d784fda1d3cc1a338b37ff04d4fa3565f21f021566c5005da47b0362980715c0211582c9562d4c7f1c199830e2c4bd2bf87b61a5c2cf47cf5a2c70b58310ee7168f2970128429b9aea566f6cdc2995ed7eb0e2811b9825062a7d8d666533cb372cc77c1fb47b7f0d5fa86d6320d5378baf5d8e5b83ea61b6774a89e295633bde737ace9318dbab66770e8d87a6b2b9bc95544018af819f2204a7f956595773f2e4e147f01f0a6aea23c0e3aad0614808fcb9221d60bd4239b23bc1ab13334ecd6804e43c2078462b0585f93b96fb868b3645c8bf2a5ba10fcbb5c8c3ab9b50c37248d2b07c5525192cfa92560b49284e62818a083251e965ca5192c838e937d5f390d2f3a30afd66b3a9e4bd5ac7983f867dfda9eddef7bd04042e09464216cfef37d516d775d6cd545094275c31945fd3e81b93b9e40f76f78178959834e0045144b8c515ff6785edb004cc989f086ce7b5222d72c36e6ecaa8a02ef9c7ffcfdf1b62031ca69c8ca55b282f64abc34a6c1a9b824ccca6541759c613f26011276064acf32c7907003c40a227365c25c33d7e9825ce9ef78cae5fe33ba4751db44f337a9cedb21567f42332129a368043313f4266d2f0c0ddf452c3ccdc4a8440791e7205ccd1346c663c00dae42f99052dc2e56769fcb970ec1f632f37f3a9ac87fdf1c60fa574fe8f9550b50f177972c5301e5ef70dd7a7bb0f6ba975d208023751c338afb359fa864a32a25404ef5073be78da44dc22594436c15588cdc258586f6d5efcc4c37cd4b884e8bf0962e412deb2ff05137b4a88ec82cb6c6754f37070cce201935cd99151da75811416860d8f80b24ceee7040dac4fc2df7829474eaa61668c5183284d576bbba84d6ade5261e7fb8ef55f60a316a31f7f0591430f386fdbae00046cbd4a6a75e9cbb8f4277afc5e63b7d3e33f026734fe299d4b15b6ab0a81b65fcccb20d050cc61425fed11c9aa64c3a0b3ddf2f1c92cb5fb959c7e998babf5f5c8b47cca7c444c3ae87e5125b18150808c7d0839c4c5a36edd45d778f64d6138ea106d81ed90efe713a1b0fbc4f51f68959b87c430b3fc181f6a7a0af0310701bdd6b278434121f4ef31ae1f49d552631d66ef3683c1d2f67e76499efb04d04f411d916c034cfb581de45baddf3c35e811b2846b7b13f6f6de97df94a5331a9dddcccb27d7a1c29e0fc7f3bdc9d7f7d9f39e8d2a9e13e277dab81f9866388286127cfbd89b1d617d8b6de3d9860691908316dbdac443e19566ada7675407331e0df59ed3162e63d5963edf38f9e10ba07709a9f4fb67586f31cab37fd03adaf323aa0a97def4034ce7ab4be917ad94db82af25961f7cd338faa3ebfd14f15cbbbc0c82e09eff47e487328881bad1066e640adb6ff2c307edb76e21b3335ee2119316ff8c155240e952cad2a7e4662bdb95f5cccac9bd65841888113461218a9c68f601367e3d63a18eae774aadf2c3e41da85c4eab390de854b33dd26c83546dd76eb826b1461d1bb51b19d5dc97e376c62f0810906fb243c8560aa90a937425baad3ce0fb1bdb8c4357fc412f464cda5d3096524c5f3dc205c9cd060923ccaba131779ec47cb6595621abef280a2f3b1c1f8e0f90d339cb5217b760697335eb6da68e97409bac62d7e7fb1b7426e5457616f23e02a53cf6bc8b09d7f63c1353331f929c256f317e0450110c935b1ab72cf5bf2f19d0c328045c2e60e6dbcd234365ca50e80ceeb3133fa3fa1072994eb77deb1506029c2f81246b450d7221815cdf28542327284eb6ab595fb13327d890adc7b38547dbfa177e3dd5fcf2cd857c74d0419ca913d25adaf82aee1277c8ab6738a83210e918ae0606690254c2bfe778ef7f7387ab95e46977b0b5e361f23e0abaaa8fd19d5a39c8832748cca20ae37be14a760bb7e68b8df0028345353a2e5201958b134fec90fbbf0162d9fd1efea395327382c1fae6b93204d4076d0bfa2421106c7b22a5f4ddf0b308a2303212eb61a01f6ff178a9a3850b88c0ac034fb60f189cf1742706d8e28bf46638e961537c14b64f881abf3a838fb9a214e7ce27a12704e3b9023f9f985c257d4f64acaa87993d7892a1cf6bca42f3cc2fc636bd36232856f2419356b2fda3f93c03e247fe26243d1b31a3e7508c90a0ee216240fe517cf41865382b151c0e5dabda1131ca350dc5148a67b6141d0292591c7b62085f06fb5f52ae70b3b07b7eeae70be66f5b75ecd718626e92cd3edd09197cf624d75bfff9227708051ed1ed30096be81e5c1de9577dca8b5ad0b1c08bbb0ad6cc6d0873286e640f9f4c6593f19a4dd0c3b59d9b8c3c5680a7cc6fcbe6b57c1a869809e83b4bbbb7ef25b38f96ff83dc41ff73ef2d45b9971cca575cb170df6854fb092ddf173ce0e10f8472b0099606a581a70c93d08ef29f53abce24da09056cdf4b89668967ec1e398e50c1230fa22150bf980e73e557e9caf24254e84905e12fbd8bb78f9cab4bbdd8254981b127a69ef229e5488815e2fef45864bb73b99cece1760d2da51ccc43267b4ad1eecc5d7b8f84eea5cbf3893bb26f99a52eee85f90f1879aa1dc42b9f23ebc9fbb25ff4cb50ccaa2944a14228baab894d856e861b4c49bd8771c35faff622bda325385c34ab0b2af194fb8174886106609be4d1abae4af6286958849096715da3f5576d0897ee8554201bf6b30ebc5060a0839194feba0c98fb136e1800936b678b29ec4a87cb8c9a471f227bb3f9811461d6f879b3cd318738afad29a601f6a7df21776d2e0a2de0c9eda390053179df173ea8f3975ff340f89f5c2e84c2afea496a6a4d689e326122a8f2b5805605cce71dcbf08b02d79e1b0ddbef30bc4378cef81e2628bce8f650d796320694b9bb4861fc7d901f3b1f23fa78af642851a81b9b5441a9cafc12bebff4ae38515e1b24b56a95ec88f95e4714478116514ccbbc1ef0ef63a7e4065ad3b8437d66b1db9d4db535c2123bfc8ce809a74b5fba6f65a78a2b19fbcc4d2b8c008ce7be3e5a5fffd77775cccaa90c79b9abc943776ff21656fb7aacc0e75a35cf2d6c33ee37c8bd1bfc866146db38c4cd33386934ddd41bab16d58bed63a06ad4f38e3df62e51fc13b0c4292cca3c00615fdbbd56f51fac1fbbb7cbbc65d9d56aad527f2ab61f8a16b6ae17780d64382677f8d84fe4f72197eb320b728a45155c41cdf804ad63569320338efbcb3ac65fc286237b6eded903a30c98289f45f98d58c1bc2353a7682657646cb051f905aa47f1c8af3c54ffecad2715360ff11417c05e244abafe0ab192dfe6ec34febf5f219c0f9ed27ca3ae43fe0f64991368722fa40d1f1ab5278499cf9bdc6a6ad70b81a793efe262ca7b86c8d4e82a4764bec98e49c44f646f84aa10819b15cc8031b38d68b6db03cdf16703f2cc35aeb2ea33377f682f0438db1912f3152411549092b8868e1d369235e9c1ebe5a12233ab0194420a04d5bb42bd3d292903f04a95ee23adbe7067c0852a8f4502e37b97b0d38c7c3a6e866b0456c84084c2fdd263d0388fd57090da1e48cd3b941091a3bdc1d78a21ab89533191dad9fdeafdf7b32cae8349366fb93519e9618ac98168e8c744f8db2472e941b7aec5a3c4992770640b7d051467a891451175a7a5de8ed88efaf1d67f934eef4d5d350151fa00126532a522901faccf639cf4d9229ffab9966ab5acea4b3776d7bbb0aaffa8b8fcee0db52dfc9fce367577856da133efd34a8b00080c338089406ee9a22fc0d202d0208061c98ef378e45679646225fa8219689fa86197da593aae18040fed007bc620e3679f222cfeb2ea2a31d5d0e8e7deb3f86e60e5f1bb47b61ef776328e133e8155bf2dd6af9195c0af096b48f6d7e25d6658844d687a903b3604f47d939e288353ad13c5e76d8b561c70c5ebd8f9dba244e1263c47e1c30458a9bcf998b7cacb1c5dea3e329f0758e37023ad334a5721661119cd82111e5c03ae50dd13d4dad0432cf176d1bf681b96a04ba23b27879c7daca4f982a99f580a8a9c073b5160dab1fe5b8911fbb092be1fde7323c7f8e762a687fe5cfd7ba5bef961aa60bcd9d2fcb094e3fbee4e625c8751d71f43e062a0ae7d3a684e2d23e3512cebe052726d90ab9365a95a6e4f06903745f01e261c549bb5334e1e5a3c44e9c26c6ffcdceaf129e304697f12b5adf25a1a00ae20c930042a4f794015ca4017775e48e42c559a91313d76311bde0fdad586db39ff9ad5033b8e4fb40d08b222f6ea8185ee8af4826675e8dee6fbbf47dc181c8406815022afcba14fa3a497108a8df110de310df7bcb559c7c037efdbebc1f1e9b1909408afdccbf214147d14184aac38f0495c3897a8725241154675d5ebf90f33fc32614e492334e8a0b077f2de19a39fe859842aa1a5ceff0fd6c8104983fecefe25b494900d55a2d69273cd5a4e4aee334782734b68ae7ba272da8e5d1d908f2521dcb87d32669435f466ec6357fadd8bf316b46c1cf093998b9d1a62784485bbc9e3a2d9adc790aa9543d1651d97f789fa74aa1cba437249fdebaf5389374eb9ebb19ec0d9755cdc7448d07d09915c33c5cc2fb2514ec1306fb61b0f68d6def00ec7933e25e7b22c673801cacd8277141e6c583ec3a2ef247d77bf07e8a1f36785535e2ef7c2728c944c93cffd70ac5a8bab837f4fef8487eaf0b5cc452d2cf6c1c84984c34f5ac933f4edfa928a3edab1ad1bd71f8f002b79c401d54d7dec8547579d718b4bdc951f4fb8b08bd813f9f88ff1937e243c543ed9dcb62e15b8a48297be9ff7eb0ab9aa48549e277f3e740be5cb75b553cda23c92da65eda4d78c9222aa2a57abaea2d4f6dd468ed5b8f613998b787c5bad121bc1c0ac37a68cfb3a7b7361c587027ea1077847ad5dd19e6581d30c9e138da8e84a95d8701f296ff8a35d185bb93aed4e7bd3ef5388cb88fee0ff34fe12b7c85a84a94c2928b2ec952435150fb02160b7ea908f9fc74082673de1b21325c8ab834294e176beb2e1c5f3ec45aa136f2e53bb46e879fd1ee778ca207a07c7963e66a0c9fa2b955e77092a172b23b0ce8e609e27e663563e15e9312f00ffdd4e726652524e7a7865d2ad9bd7b5d4299e787ece5bdfaf17e58f499f593557dfa7a175d27076b9516b7bebed29307468b457686ed0a73122ee40a3dcb9818c5da146851743d7dd7eed04c4059fcf4659c584899e7cc18430f4c5a9439555c3d4b82a22c43ff8d6df6df13c86b5f088f041b83c017864c73d84ab3a34c800890cbe88ffb2c8406f16b747e1de748babf72ce04fcfb23e0e6261af921720785e343a19bfbd7d85f7be20af8c0cd1f967f45674c94831dd336b83e6d7eb997fd42818a6646e9d07a80001c619f79dd0d67591b7cee223120cd5e1687fd7fb6f9e7e47731b0a921d0c598b70f2ad2228324f7d6bbd3438deea06fc1f784bb07474af0c4af2a26d509c6afd990f07318a387d88694134f104e3e89ea372b42d30f3ff4b2c12a8875de5a458ff438756d0c62207baef2b95cb70a273354d3dc70ccb2f9580cc1e9c4851d27d8676fb56c4cec18662b539c5079535a4f12264fb71be081909b62102b910d223985b056c6df129d60a1de1c97f978439dbad14022895c079550efad007bb6b49a1bb5c0728af71f55ba6b52d9dc8b0f27d6824efbf09e1f753bc5a039a95514f687582e78bf17d9b3c29cf043ea7402c1f68d7dbf86853d253e9f7506d83bf76daa1c65bbd86db53cb0f8248832abdab550b415a66a4cc5f559b585be35368b45e1d3d89bfe3fcfda3a957f5990e8b15b3e0cf11aae09a787b8f31be129ec34441028495504386ea844eace1944a6836a38539878c78f93d278fa542e469e7650be3d3f0e712c41406bbb7e87caa3ed79656d9046eadc3c4e581e2177fc3ba86218f0e8deafc56cc577c5e3f96249d209cc0ba4b0f871c2da4be36c86e5dd3f94833e89db0439ac0982b25aadb2294cb7bcdd29bd4c8c5ab7084df903b79bc087ceb604febcf0a723d8462bdd236628e28fca5d34d2f2c5ef034d40f1f90b6554f402d58c2600b4fe6c9c5530176f909b5e9cce279040e0bbaca3b034a0c7ec48fc363d74f942f7014e9bfb53aa486ccd440de80cb040983f0fcf1355718d0891cab64865ca6dbc6182bdda9efb4346d41d039193ddca04ad7685e78166b8012fe1554770864c4db2b30d1d0b24d97ad98394f31b057d5630878760d34ad3bc88691e3117db81f31d5fd6641481a4637dea79b25cf0512a64fdbe6dde5510a59eb3bbbb1715ada183fa7a843051ddf106b8961a656454ca81c939bf8bb2c37422c2b80afa064af65decae438a4995feea3016e2b215586c05f47e2c68c3151411be1032ef6d0734effa7c8c657a89c4b3cc27e2760e8f43c4d2d97f1b1a2bd07912644bda2a5196d0e3bcc1b83d0b55ecba7ee0940bd5be13928f7885f59b03bf116e8e40c72113ee9f6819c29ab6fa4c8a19010afa52a55e355d7c17121e3bb3fefae26baa01957a2e400b2e747a44b1e66c5cb651d036ed88ae6ff5c0be7782e8bd3c05d521e533b736fc5def328f568310c2e99bd46237512a734cf58d261d9720c0c80ecb6cb274a8ec8d9b5bc79b25f5f00d80dd5987f9541caf938ef7f3828da5724d99c1d3315fc2217c7e4440e3c918858f9f1c86c15bc8e0db65492c1febbda72d6435fa67fe4be9873a16b882fa243cea007110ddd415e94ae60aee940eae2f4717896142c842d0e062cd18433e249bc26f13ced65613f5a4f493128172c979742212a32a31d3d2022c409ff94ef8bd7464e174d4a04ba0928fa586e70f07ce7d8a5659ccf0c492e5920baf0b9fba698b6ade96c0b3a2ee3f2cd5b9de409159233b9a0ec5bed12337b707107e26f95b9d9c63d9bca9bcac82198a113718baf0469e1b3ef9cd8db24cf23bb87c110fda75f795328461fc741d427b97f941437c6aaa56093b86a30ffec3a023ec2ff444b7aaf6d7898829fc0bda6a991846f5bcd3517d3e60c1a75836963f80714f991e302a9d56ec2113daeca14ece99f11acbffa8f6871e4711932a5e69b2d8e8f9aff0d94815396dfc7e1d612e8f4f631e872fc81c484b9b87df5fcab9fbfffeb07d6b553d76de6c2445ea80674e8408c3cbe58d27f867e1cb7b076213bc894c4015abda4535b31bc94db5acf08bb16f8cddf51116a113763029ca68ba2aea734375b87c8bc4f80fc6f6546f584fa98f0824e3c5ca963de27ccf2ab52b9b1bec9a0fbb7b2d94652fcf8584c98127459086557a8fb70a7568f77388e5bba0300ba318bf54f4dea0d03f67395b8f1b005b21328a6746cb71872882ffab17ef7ff03e82f9f189dd1e2ca26221ac3b47a5b9ad968083c89a6a68b64537cdc79d556ca60ee0d9d814f0e6e29ed4a183486fe9b0888f203332e1c9fdd7114bebca7ecfd284b5d16618cc04b169903a60eaee8a476c871cd57432af524c46e97fed210a5bf71acdcda0867742cd93f8053339bbfc2498265d5af39725da08268def27cd1c3305507b10bc98aecf4b0189a872fb044736520ace454e7bacace8815657cef038519951f7e687472236bda0a1cb226ee506921ee60d49383b89f22116b2f32016e88eb85926a3b5900ad7559bf6a8d4959ae02b021c29c4f875c09d733adba08f2b1301ad2c8478821638558ceaf69be92b9caf877a51a7e10a66eb73bcc9c6093202a1d7ab8a1662335ee82c66cc70764b556041a1db76bad627818de542286f7e78c1524694c2255485f0edbe1b11865e8ceae2adf9dd35deff0a3288c0883d33eb3e63042922aa090fcc18b288acc1df736503a13723218097fd2e19edc0d22cb0a7b42ea2ba5ea814232a26ad379d9df4bb2bdd747d042cbc0e80fae5364855f7c586fc010e6ea16acf0e4c62f96b88eb3c20328c73d25df2c7cbffc19487552b1068914e4f77c54b1c55ca05cb91685986dffeb451ce781ae0e5c8a576c6a6e9e11c84f885522d770659e4cdc9261720eb0190de049bd3deb8ec2efd82f1fa6aa1dcb1448b490642309a21f20fa6206fcf841d4fa030d8373d14bdcdca8d28963fe165ceb82061cccc1e1deb3bcd042a3449efde5a356d95dd7bc3404870e8e352f41ba310f543fe795dbfe1df6618685384fb2990b0b404c87bf5bfd30aba6e8ae86e12f446b3fec00b321178eb72ccaacc3df8d9c63d4d3fe80da3a2ada574edbb693614c2f9c6e2fa9e2447af70e54a9cc3ddab41735818ac236d4cc5658cc4813b986aa4b786f3cb0d422abebaad291b7943643de8779a0ab98083253a69e12dd31a3d456bbdf5ae9341372aaf0e1dd92071dbac7a849f6bf16802069cc659c2aec9c2c8bc723acee935a7ffc48fc43a87e6aa746ddb188304fa10a6bed2e1f8f79db3a4a4f28bb08c65fa4a05381667b95c545304530b9a4d4155218bc36b6be245fb64abe7b5f75503490f94c937ae3f3ec069e4f023a74b52e1a18f4e720d44744fd52c7092d21cb244feef66a704af23af00f6c8232cf61d4d6bdb10748afefde93b53db29155ab3a2a3d5649e2f9a71517dd7776616268a00ff6173d345a47dfe19768ff2c4cda48c283eb4e00003e7ae19ae48a84269c74a0eac74db9efa3e98d7df8839509a44b8272229e7c6965d7682b828e6cbfee0b8d34a1db1509b90eccbe324294587b0a9b986499e0f96be735829d0b2578d972e94ceb627cc690671f07b2f9c830ca724eee1d036c6e6151eb319bef0b1f1f1cca71692fd46157e65e8314130f33808f40995f954ec545d138851456f15c945234fb00c749a5d80431e685a2efeb24495e756c3ae836832f6ac9110da6ba5a66f5c7006841072a9e49a1c07c8e9ede3874a62eb87b9a71cac2cd22ae92da72f1f83332c5f0b67bdf1d63a108b475a36d9649e6bd0574c8f2a956c7bbe1afe5e9315b0f5e6c2e588c44031c64462f1cdf9c68625b22db87e00215a80e8c45cc004890283c30a5b784bb8b369b1d21cbee5347ed77de5fb49c7976efe811370f1be78cabafca3043a5ad321f9662a43c44e7db0f5ffd85f8c2574acdb8b604bc2987662bc8f71d989a514c7df83a74c9a96b2c18f13251eda45ae6a6fa40e7819aae3430914ad23469648985dcc5295f18a44f57d0662570d35895d30bdc9cf5632e632e7f17792ddf523efd9f891f744f9941b395aa822c94f7da520a8b90ea1423445ed2781f1846fd737176aa6ae9728357c15b8f5e475c7039792d869da6f4957aaecd14bf70a15fdcb2aed411d50a1e8b012eea9be3aaf8b322df68129472a1c4712deb6e4cd47e6ceaa52c2b5beec216e752bcc4069b9240a474ff977a9f784003ad6ea6bb670ecc838f04794a7ebfa5c8f0ded37f8bf1892f080cd4663eb299ee45c39617b174bbd3c5af851bb058d0dd33178c8ed68d3f22bfd203830a90713d1d4eec22fb9383a70afaf7e37f25a94c89ee1d5a07f286babb8bfc8d8bc92ff50ad8bf1b691c3502955033fecaeeb48fb37ee5837f8404fe7b35c7f2d9133f4e87b756e45f6a6ffc80e19d122d3204a68745cde84bdfd3a1f8eaa49254bfd7ec2251ed36d692df2a57e355403b53ac0e90c7255fb858ada5aae41e375ea9f54012625011342351f1ba2cc7828c5b1b152bb0cb8af7958d668f561e4f97c2e93459efc250ac4fea8bb987194ced9477dfcb269f56abf0974427a4ff0ca66c116b812a9d766c1b6059265728c97113c5add5a40a12c1e56c10d6e448a8aaac076ab50c5cf6753028fec06c666b514b5c6bda3606ca79275e14734cff69152d11ae01378534abe6e044a6c027b40afcb150c61b768bf00dc1f19450bdad6b10b16aa84b9a278a08f2a3370128096a0c52d2533da886bd06c1eb159a5e46fe2ff2b4c06e5daa43294b5f6f3e525d8a39a5450b95c286d2082ecb569d7d8e02c359bafc1ffe4ef483cdd42f852c39a0df539bbf97e08c434675ea32d278225987e60e0f8042c7b91a0663c38fe4aa867579520388eccb0bf02448eeb4efe9b42bcd711948081d52e97d77849e769446c517fa764a5715b1f8e375c6caae6fa9ff0f73345f030af12ea1f5bfb8810bd64347ae1c8d724e3a8983cf42562e4e27e1672821eaf4fe2edd3535ce385b2bc24b4d564ba51f99b588989ba04591b00b9cc44005903b29f9b9eb4ec418094fdbceac09b1797953</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Node.JS篇</category>
      </categories>
      <tags>
        <tag>全栈</tag>
      </tags>
  </entry>
  <entry>
    <title>创建自己的npm包</title>
    <url>/2021/12/06/%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84npm%E5%8C%85/</url>
    <content><![CDATA[<p>首先创建一个文件夹，然后有以下目录：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">Hy-npm<br>  <span class="hljs-string">|-package</span><br>  <span class="hljs-string">|-test-folder</span><br></code></pre></td></tr></table></figure>

<p><code>package</code> 文件夹里放置我要发布的 npm 包的所有内容<br><code>test-folder</code> 文件夹用于测试我要发布的内容</p>
<p>首先，进入终端进入 package 文件夹内。 利用 github 创建一个新的库。然后把下面的这些内容复制进控制台里去<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/%E6%88%AA%E5%B1%8F2021-12-06-%E4%B8%8B%E5%8D%8810.41.57.png" alt="github"></p>
<p>算了！自己弄一个 react npm 包 现在就不弄了…目前来弄太麻烦</p>
]]></content>
      <categories>
        <category>程序员素养篇</category>
      </categories>
      <tags>
        <tag>奇淫技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>前端技术-随笔</title>
    <url>/2021/10/21/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF-%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="8b19cdf59439dd5b9890efb32fd23cbabfc73591ff0c14d5775ccdc0ca3b9094">227b2a181666066aebdadda3a2b5e6f50d6e05fc6d451d3d21073ae436e46d159686d77bbb604d04e40d05b2217adb9ba18e8a5ebc5f3699ec1b74cab7d8b43a6774ee75925fd14e809b453ee1f530018c907ba0e46121f51acb23a7caf6b1657f865a7786e2cb2e01678afdb1962fb3a9748fdc6583a12d0be32187b6e820835eaf05fc300ae7bbd7886e5677065ffe3bd3507c30d2a5b3954c592d5d2a436d23b896e7138ab44bd82905f5df59fa5b991d666ff8b3a11afd0df0e00097dd0fa0ebe49572301d27e96f43fdf04d7afba5782fac5f3962dd5166adb4fffc2bdea5629d016a353a6ae9f85317dbc80e39036b619d5fe6aef44907d5794ce110a5f48a83cf02b03fb608faa0afc66a34a0c2ca0b2984f3f2ce537251b9f55fa8206c67083c6de62a8c1c7f75301410def6ca999bd54afe42ae6f367177dd555fd628f56edee01aa0df3406ac51c64d08f5a42972f0b5501865a0b37941c3d256f23582be3a7e1ff1d33f8f52f9ef473402a21b0efd3dfef996e9b7d92a94bcaa1e638d6756353ad7b62eeb6f3f03556bce1f90aaad8f07e8c395e91135fc4ec9fb35da818acd4716be32e1cb1c14b4d3bedce2a594604de44f5d9fc3afd7fd3f76c7cf6297207a01eb5a1b113ee5fc61cae246d36965fae83852b051ddce285efb04573477f3a5e21996e1b54c61dcae5a0c141f4cfb31d9c656924c76eaad0f73f7d4f8d3aeb6b7b80339a71496f5816566da93da975dcc8aa7396d2798932e2f1ac0c072910f4274e3c28989f71e00bef7f9d200b96f495496198b3ade9bfda143aaec3a6b7f6219ed91fec49b42005cd9ba94ca09b5c0fd5e47659f34e3c899c64e7cc32cde272a340799c3265a89d525d2ee89ae1996231a0305e65536f6c74dec74cfa2b48a61b8421be641da4d5be35cf985355f408e244df609a7662388496002f51665c02d17b073d4b5bef7470c607f0b96fe3412f805d8ad57ef3ba1e7dbd6ae06d6fab2cb8a8530a4bc4517a573f2cd53c7fd6b754620ac9fff1d5f6bab43692dfd97ca61b20e6097da4124ce6c09780a311f3ceae4333f09db0306e579fac251bff2d654644c356116461bbd7098657fe128ba7791cdce733c23631c51a8a0d9c02fe9f7bd2e1eab98c94834f5ac9e841e9d441c4c5da9a24cdab5e7ae5702d5547e1d6ce866c6eea344ed12d337f57eb4201eb36221b56279da33f1f76aa8efe95ffc914721c9d4b172c8a161b85ae1588c22bbf610017e93389e08491ef2dd025fbb708a2d47d67bd52ba97dd66fb8d4c4c6cb432da6b5bf8293a875a88b9e9e23e415ffe8b3ce3c2216b39432370487d724a842a47a6f641ca3bd570997e3386a26a6b85011cfdcaadf5aaf7cff9d10fed535c8cb3c960db963c0f418f57f50fc795208f2e8240a0f9f050495e16aa8d569623c7b675a7c5e2f3c8c78835e2225c74d3970aeaa778c48574346f6f44b84507dc43fa5be4604ca99d3bcee595bec88cfd35ee68ba5d3af</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>程序员素养篇</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试之道-CSS</title>
    <url>/2021/12/16/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93-CSS/</url>
    <content><![CDATA[<h3 id="CSS-的优先级"><a href="#CSS-的优先级" class="headerlink" title="CSS 的优先级"></a>CSS 的优先级</h3><p>优先级从高到低如下：</p>
<ol>
<li>!important</li>
<li>匹配优先级计算，详情见下文</li>
<li>若以上规则都无法解决，后来者优先级高</li>
<li>user agent stylesheet</li>
</ol>
<p>其中的<strong>匹配优先级</strong>计算如下：</p>
<p>首先有 A、B、C、D 四个值：</p>
<ol>
<li>如果本样式是内联样式，那么 A = 1，否则 A = 0;</li>
</ol>
<p>样式 1:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<span class="hljs-attribute">color</span>: red;&#125;<br></code></pre></td></tr></table></figure>

<p>样式 2：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: blue;&quot;</span>&gt;</span>hello world<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>样式 1 不是内联样式，而样式 2 是内联样式，所以样式 1 的 A 值为 0，样式 2 的 A 值为 1；</p>
<ol start="2">
<li>B 的值等于 ID 选择器 出现的次数;</li>
</ol>
<p>样式 1:</p>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-selector-id">#list</span> <span class="hljs-selector-id">#item</span> &#123; <span class="hljs-attribute">color</span>: red; &#125;<br></code></pre></td></tr></table></figure>

<p>样式 2:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#list</span> &#123;<span class="hljs-attribute">color</span>: blue;&#125;<br></code></pre></td></tr></table></figure>

<p>样式 1 的 B 值为 2，样式 2 B 值为 1</p>
<ol start="3">
<li><p>C 的值等于 类选择器 和 属性选择器 和 <strong>伪类</strong> 出现的总次数;</p>
</li>
<li><p>D 的值等于 标签选择器 和 <strong>伪元素</strong> 出现的总次数</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">    <span class="hljs-selector-id">#parent</span> <span class="hljs-selector-class">.children</span> &#123;   // 样式得分 <span class="hljs-number">0110</span></span><br><span class="css">      <span class="hljs-attribute">color</span>: red</span><br><span class="css">    &#125;</span><br><span class="css"></span><br><span class="css">    <span class="hljs-selector-class">.parent</span> <span class="hljs-selector-tag">p</span> &#123;     // 样式得分 <span class="hljs-number">0011</span></span><br><span class="css">      <span class="hljs-attribute">color</span>: blue;</span><br><span class="css">    &#125;</span><br><span class="css"></span><br><span class="css">    <span class="hljs-selector-class">.parent</span> <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.children</span> &#123; // 样式得分<span class="hljs-number">0021</span></span><br><span class="css">      <span class="hljs-attribute">color</span>: yellow;</span><br><span class="css">    &#125;</span><br><span class="css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;parent&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;children&quot;</span>&gt;</span><br>    hello world<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>三个样式的得分分别为：0110、0011、0021，所以最终第一个样式胜利，文字颜色为红色</p>
<p>user agent stylesheet 是指一些浏览器给某些元素默认的样式表，虽然各个浏览器的 user agent stylesheet 有些许差异，但是大同小异：head 标签（<code>&lt;h1&gt;</code>到<code>&lt;h6&gt;</code>标签）和<code>&lt;p&gt;</code>标签有 top 和 bottom-margin 属性, ol 和 ul 有 left-padding, link 有默认颜色，页面有默认字体大小。</p>
<p><strong>伪类和伪元素的区别如下：</strong><br>伪类用担保号:来表示，用来根据用户不同的行为添加不同的样式<br>伪元素用双冒号::来表示，用来创建一些文档中不存在的 CSS 元素</p>
<h4 id="尽量避免使用-important"><a href="#尽量避免使用-important" class="headerlink" title="尽量避免使用!important"></a>尽量避免使用!important</h4><p>只要有一个地方使用<code>!important</code>，在所有其他地方都要再用<code>!important</code> 覆盖它。特别是在 npm 包里更不应该用<code>!important</code>。也不应该用内联样式，不然别人就只能用<code>!important</code> 来覆盖了</p>
<p>这道题考察了候选人在写代码时是否注意最佳实践。在被 CSS 搞得受不了的时候，使用!important 是一件充满诱惑的事情，因为它可以瞬间解决你手上的问题。但是接受你的代码的人就惨了，特别是给别人贡献代码时更要小心，一定要给用户留出来选择权</p>
]]></content>
  </entry>
  <entry>
    <title>前端面试之道-DOM</title>
    <url>/2021/12/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93-DOM/</url>
    <content><![CDATA[<h3 id="DOM-概念"><a href="#DOM-概念" class="headerlink" title="DOM 概念"></a>DOM 概念</h3><p>文档对象模型 (DOM) 是 HTML 和 XML 文档的编程接口。它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容。DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。简言之，它会将 web 页面和脚本或程序语言连接起来</p>
<p>DOM 的概念看似抽象，实则只是把 HTML 中各个标签定义出的元素以对象的形式包装起来。这样做的目的，就是确保开发者可以通过 JS 脚本来操作 HTML</p>
<p><strong>DOM 不仅是一套接口，更是一套规范</strong><br>DOM 作为 W3C 规范的一部分，约束了浏览器中 JS 与 HTML 间交互的方式。多亏有了 DOM，我们现在在任何一个浏览器上都可以用同一套 API 去操作 HTML，而不必关系浏览器底层的实现差异</p>
<h3 id="DOM-树"><a href="#DOM-树" class="headerlink" title="DOM 树"></a>DOM 树</h3><p>DOM 结构以树的形态存在(树中的最小单位 – 结点)</p>
<p>在 DOM 中，每个元素都是一个节点，节点类型细数起来可以有很多种，我们这里强调以下 4 种：</p>
<ul>
<li>Document: Document 就是指这份文件，也就是这份 HTML 档的开端。当浏览器载入 HTML 文档, 它就会成为 Document 对象</li>
<li>Element: Element 就是指 HTML 文件内的各个标签，像是<code>&lt;div&gt;、&lt;span&gt;</code>这样的各种 HTML 标签定义的元素都属于 Element 类型</li>
<li>Text: Text 就是指被各个标签包起来的文字，举个例子：<code>&lt;span&gt;哈哈哈&lt;/span&gt;</code></li>
<li>Attribute: Attribute 类型表示元素的特性。从技术角度讲，这里的特性就是说各个标签里的属性</li>
</ul>
<p>现在来解析一颗简单的 DOM 树：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>DEMO<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>我是标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>在这个 DEMO 里，整个文件可以被看做是一个 document，根节点就是 HTML 这个 element</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml">          <span class="hljs-string">Document</span><br>             <span class="hljs-string">|</span><br><span class="hljs-string">             V</span><br><span class="hljs-string"></span>       <span class="hljs-attr">Element:</span> <span class="hljs-string">html</span><br>             <span class="hljs-string">|</span><br><span class="hljs-string">    /                \</span><br><span class="hljs-string"></span><span class="hljs-attr">Element: head   Element:</span> <span class="hljs-string">body</span><br>   <span class="hljs-string">|</span>                   <span class="hljs-string">|</span><br><span class="hljs-string">   V                   V</span><br><span class="hljs-string"></span><span class="hljs-attr">Element: title    Element:</span> <span class="hljs-string">h1</span> <span class="hljs-string">--&gt;</span> <span class="hljs-attr">Attribute:</span> <span class="hljs-string">class</span><br>   <span class="hljs-string">|</span>                   <span class="hljs-string">|</span><br><span class="hljs-string">   v                   V</span><br><span class="hljs-string"></span><span class="hljs-attr">Text: DEMO        Text:</span> <span class="hljs-string">我是标题</span><br></code></pre></td></tr></table></figure>

<h3 id="DOM-节点间关系"><a href="#DOM-节点间关系" class="headerlink" title="DOM 节点间关系"></a>DOM 节点间关系</h3><p>在树状结构的 DOM 里，节点间关系可以划分为以下两类</p>
<ul>
<li>父子节点</li>
<li>兄弟结点</li>
</ul>
<h3 id="DOM-节点操作"><a href="#DOM-节点操作" class="headerlink" title="DOM 节点操作"></a>DOM 节点操作</h3><h4 id="DOM-节点的获取"><a href="#DOM-节点的获取" class="headerlink" title="DOM 节点的获取"></a>DOM 节点的获取</h4><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">getElementById       <span class="hljs-regexp">//</span> 按照 id 查询<br>getElementByTagName  <span class="hljs-regexp">//</span> 按照标签名查询<br>getElementsByClassName <span class="hljs-regexp">//</span> 按照类名查询<br>querySelectorAll <span class="hljs-regexp">//</span> 按照 css 选择器查询<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> imooc = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;imooc&#x27;</span>);  <span class="hljs-comment">// 查询到 id 为 imooc 的元素</span><br><br><span class="hljs-comment">// 按照标签名查询</span><br><span class="hljs-keyword">var</span> pList = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;p&#x27;</span>)  <span class="hljs-comment">// 查询到标签为 p 的集合</span><br><span class="hljs-built_in">console</span>.log(divList.length)<br><span class="hljs-built_in">console</span>.log(divList[<span class="hljs-number">0</span>])<br><br><span class="hljs-comment">// 按照类名查询</span><br><span class="hljs-keyword">var</span> moocList = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">&#x27;mooc&#x27;</span>) <span class="hljs-comment">// 查询到类名为 mooc 的集合</span><br><br><span class="hljs-comment">// 按照 css 选择器查询</span><br><span class="hljs-keyword">var</span> pList = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;.mooc&#x27;</span>) <span class="hljs-comment">// 查询到类名为 mooc 的集合</span><br></code></pre></td></tr></table></figure>

<h3 id="DOM-节点的创建"><a href="#DOM-节点的创建" class="headerlink" title="DOM 节点的创建"></a>DOM 节点的创建</h3><p><strong>真题：请你创建一个新节点，并把它添加到指定节点的后面</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>DEMO<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>我是标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 首先获取父节点<br>var container = document.getElementById(<span class="hljs-string">&quot;container&quot;</span>);<br><br><span class="hljs-regexp">//</span> 创建新节点<br>var targetSpan = document.createElement(<span class="hljs-string">&#x27;span&#x27;</span>);<br><span class="hljs-regexp">//</span> 设置 span 节点的内容<br>targetSpan.innerHTML = <span class="hljs-string">&#x27;hello world&#x27;</span>;<br><br><span class="hljs-regexp">//</span> 把新创建的元素塞进父节点里去<br>container.appendChildl(targetSpan);<br></code></pre></td></tr></table></figure>

<h3 id="DOM-节点的删除"><a href="#DOM-节点的删除" class="headerlink" title="DOM 节点的删除"></a>DOM 节点的删除</h3><p><strong>真题节选：删除指定的 DOM 节点</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>DEMO<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>我是标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 获取目标元素的父元素</span><br><span class="hljs-selector-tag">var</span> container = document<span class="hljs-selector-class">.getElementById</span>(<span class="hljs-string">&#x27;container&#x27;</span>)<br><span class="hljs-comment">// 获取目标元素</span><br><span class="hljs-selector-tag">var</span> targetNode = document<span class="hljs-selector-class">.getElementById</span>(<span class="hljs-string">&#x27;title&#x27;</span>)<br><span class="hljs-comment">// 删除目标元素</span><br>container<span class="hljs-selector-class">.removeChild</span>(targetNode)<br></code></pre></td></tr></table></figure>

<h3 id="DOM-结点的修改"><a href="#DOM-结点的修改" class="headerlink" title="DOM 结点的修改"></a>DOM 结点的修改</h3><p>移动 DOM 元素的位置，修改 DOM 元素的属性等</p>
<p>真题: 将指定的两个 DOM 元素交换位置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>DEMO<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>我是标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>我是内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 获取父元素</span><br><span class="hljs-keyword">var</span> container = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;container&#x27;</span>)<br><br><span class="hljs-comment">// 获取两个需要被交换的元素</span><br><span class="hljs-keyword">var</span> title = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;title&#x27;</span>)<br><span class="hljs-keyword">var</span> content = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;content&#x27;</span>)<br><br><span class="hljs-comment">// 交换两个元素，把 content 置于 title 前面</span><br>container.insertBefore(content, title)<br></code></pre></td></tr></table></figure>

<h3 id="DOM-元素属性的获取和修改"><a href="#DOM-元素属性的获取和修改" class="headerlink" title="DOM 元素属性的获取和修改"></a>DOM 元素属性的获取和修改</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> title = document<span class="hljs-selector-class">.getElementById</span>(<span class="hljs-string">&#x27;title&#x27;</span>)<br><span class="hljs-comment">// 获取 id 属性</span><br><span class="hljs-selector-tag">var</span> titleId = title<span class="hljs-selector-class">.getAttribute</span>(<span class="hljs-string">&#x27;id&#x27;</span>)<br><span class="hljs-comment">// 修改 id 属性</span><br>title<span class="hljs-selector-class">.setAttribute</span>(<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;anothorTitle&#x27;</span>)<br></code></pre></td></tr></table></figure>

<h2 id="DOM-事件"><a href="#DOM-事件" class="headerlink" title="DOM 事件"></a>DOM 事件</h2><ul>
<li>DOM 事件流</li>
<li>事件对象</li>
<li>事件代理</li>
<li>自定义事件 —&gt; 重要哦</li>
</ul>
<h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><ol>
<li>事件流： 它描述的是事件在页面中传播的顺序</li>
<li>事件：它描述的是发生在浏览器里的动作，这个动作可以是用户触发的，也可以是浏览器触发的。像点击（click）、鼠标悬停（mouseover）、鼠标移走（mousemove）这些都是事件。</li>
<li>事件监听函数：事件发生后，浏览器如何响应——用来应答事件的函数，就是事件监听函数，也叫事件处理程序</li>
</ol>
<p><strong>W3C</strong> 标准约定了一个事件的传播过程要经过以下三个阶段</p>
<ol>
<li>事件捕获阶段</li>
<li>目标阶段</li>
<li>事件冒泡阶段</li>
</ol>
<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><h3 id="事件委托-—-gt-必会！"><a href="#事件委托-—-gt-必会！" class="headerlink" title="事件委托 —&gt; 必会！"></a>事件委托 —&gt; 必会！</h3><h3 id="事件的防抖和节流"><a href="#事件的防抖和节流" class="headerlink" title="事件的防抖和节流"></a>事件的防抖和节流</h3>]]></content>
  </entry>
  <entry>
    <title>前端面试之道 ES-Next</title>
    <url>/2021/12/14/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93-ES-Next/</url>
    <content><![CDATA[<h4 id="变量提升和暂时性死区"><a href="#变量提升和暂时性死区" class="headerlink" title="变量提升和暂时性死区"></a>变量提升和暂时性死区</h4><p><strong>变量提升</strong><br>对于 var 例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(b);   <span class="hljs-comment">// 打印的是undefined  --&gt; 这里是变量提升 本质是执行上下文的生命周期的不同阶段造成的</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<p><strong>暂时性死区</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(b);  <span class="hljs-comment">// 报错，但是JS引擎知道这里的变量是b，只是因为暂时性死区的缘故。无法获取值</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> f = () =&gt; d; <span class="hljs-keyword">const</span> d = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 这里是不会报错的。尽管d的位置被提前放置，但是并未被使用，所以不会报错</span><br><br><span class="hljs-keyword">const</span> f = () =&gt; d; d(); <span class="hljs-keyword">const</span> d = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 这里在定义b之前运行了b，则报错</span><br></code></pre></td></tr></table></figure>

<h3 id="一系列字符串方法"><a href="#一系列字符串方法" class="headerlink" title="一系列字符串方法"></a>一系列字符串方法</h3><ul>
<li><p>存在性判断</p>
<ul>
<li>includes: 判断字符串与子串的包含关系</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> son = <span class="hljs-string">&#x27;haha&#x27;</span>;<br><span class="hljs-keyword">const</span> father = <span class="hljs-string">&#x27;xixi haha hehe&#x27;</span>;<br><br>father.includes(son) <span class="hljs-comment">// true;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>startsWith: 判断字符串是否以某个/某串字符开头</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">const father = <span class="hljs-string">&#x27;xixi haha hehe&#x27;</span>;<br>father.startsWith(<span class="hljs-string">&#x27;haha&#x27;</span>);   <span class="hljs-regexp">//</span> false;<br>father.startsWith(<span class="hljs-string">&#x27;xixi&#x27;</span>);   <span class="hljs-regexp">//</span> true;<br></code></pre></td></tr></table></figure>

<ul>
<li>endsWith: 判断字符串是否以某个/某串字符结尾</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> father = <span class="hljs-string">&#x27;xixi haha hehe&#x27;</span>;<br>father.endsWith(<span class="hljs-string">&#x27;hehe&#x27;</span>);  <span class="hljs-comment">// true;</span><br></code></pre></td></tr></table></figure></li>
<li><p>自动重复</p>
</li>
</ul>
<figure class="highlight monkey"><table><tr><td class="code"><pre><code class="hljs monkey"><span class="hljs-keyword">const</span> sourceCode = <span class="hljs-comment">&#x27;repeat &#x27;</span><br><span class="hljs-keyword">const</span> repeated = sourceCode.<span class="hljs-keyword">repeat</span>(<span class="hljs-number">3</span>)<br><br>console.<span class="hljs-built_in">log</span>(repeated) // <span class="hljs-keyword">repeat</span> <span class="hljs-keyword">repeat</span> <span class="hljs-keyword">repeat</span><br></code></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>前端面试之道 V8引擎</title>
    <url>/2022/01/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93-V8%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="7d443e553323348ba4d845ac122d6da97bef97d7efae61d6dfce5bfc878ec7de">227b2a181666066aebdadda3a2b5e6f500cff926b131b1402dd8fbc0aa9886ab3f520959740f9b53540da0d905bc434d22b698ff2cc4c059468fcd19d9a3c32236df525bb11f074da765dd73b58119070ab4cefb74051b6c6d0a768a162b21a6c1b03dfb82807b1ba2a452afbf89710813f4995bef5e33425a641c033bf1b97e816276248c91d4ae5793d5331e0bab81cb7f28a1a72d60475fae916b6998c5badd8a1cf24212ab017f099c975171cb24001948c2e918b9678eb85bdbd285ff8ace356c1497731e5fe57269067b0e029d88bf9c9f773189462504d8a7f762dfef366d9ee4b4f1488029c47fb6ae45a3c93f3b3a01abe25a7b5be773ded075a651aa690afced2a7f59093d26d3a3004cf4bc5ed46c362b91ca81268ee28fe0783d72f2b20b05700def177119e8408e50b121831fa1c874913cc21625fd49069b4a58eb7f40c752292dc04a9912da5970c73e60d3da75bc4cc5f4d0ce3c71d792002168c36d6e476115d39a75c5b5ffb7d22db7360b479e3760a074b6e746595af8ec2169fe88cbab92240076eacb46890abf25de3cad5ec5c5a217a1350f25d4eba296d8da75a3191934dead68038d47db6c94d29c8317bccb885ce87e5992c9b73b9afc8273f97f552ed288c6e8fb6b247f7cf0f80d2e621e1ca5db209e85552b9825dfbef6e2f213b1faa7dc0b25d6b60336b2dfbf3c61768f288d0a9f75b603d4eb6fefd85161f61853dc78dff88bd3f7654bdca4b654a6ae0b5ca701c4cfb386dde987fb180e5b683a8d194a54b63efa78f9d404f015feafc4948c1edfb6de0d3ef5d0ae3fbe17e24ce72b6d22e20760bee681ece6bd4a58c7bedc8742269d51342d1ff79a994cda417d225aff6806a5e788414e69106d5e38e0c2fa5ceca264f58caca31643975796a7adf72e601cdc28b2bc98a72e6299c8b42cb5623c8a1d23b3a9ef9af9823ab89939e2f6d2a4bd8839a2001175b86def189815fded89873dc861a3649193c416066749da28f67c803630e3cc111395a4377db6d86f933ea2e589310ed2f3345f0d8d809283fb8c84033fa3fee15233680e00888c72fc1cf775a8470268b71a4dadab2996b86ef1a41f879133d1372d0c64d5f184e401fe3edce19e0d663f182e4aea672ccee02778ab919b213b1d13e6f933f47a876d7b6c2bd76fd5eba409e03b6a17a5bc879ed13265dbf77bf3c028994a640e8fe5b1756d35606ca29ded3b259df1448016c5fdf2cc9a5544e46e0842ae225a44d21fe6c724a8abf277165c97b1ce81bd913cbf91a9d0a00651027bbd02d2a76c59647bd1027fc4f324e7992eaf55ee40a256a5ce737112f858c005afc0cf69c8967ebe612f49815a8e6f9473afbc80865b2f579bf8cd5d50b3ac111e3600c305e9c153493f057e9e627b5255745b2f2ba3c1a8430c23de7795bc8813374e1c51c3fc83cf0e1e3f7f6bc081f60afb3449ab7cc5aa53aec0b5dbd734392a99eeb3e29d0be74088a1810257934afc4b51632786590bc90471fe7722b46344fc568788c1f0d91c6407a094d62cbfd7daf644eb0e332d58fc8bdc49175896e2f614dc41896cd3dff165458aed9469759b09a6fdeb9ee5c9490bb5d011f5e1e198e49afba4b348d059f46a28c99587973a323103ac902e6e73f5c8e9cfba5ccc70b4f4ff75d9cf6b740ea149032530bd0f2e6bb4caa3801c9bb6fb54e4711ec845372dc4b637dc7daebeee97d0e42cef8d09423a1ab106bcbb5945a0872078873bcd9a080e843d17ca4e640dae9296ec7467ad01cd7aa4ec8982f27a70a7f5690377b7d1bdb734b8f394f8043bc3e7b8e960842a50dce04b22e04d1af9125760a10f1a2fadace221f622623f8cc979be93af0a015f82bb53910aa9c8b89d760298b9662da3bf3bf1a89327f47c0d5b57bec19c14144c794e83923130350a1987209bdcc9b37cfeaa03f1f1fd0928621fa062bac1953c11b6aa1e53a9445ef79e228caaf663c7d0a0c64c44e374f34c8592a73a799c6653c1cf80ff7a86774ea9967c8d59b65076fa0fbfd1db27dd913f0d28e4931f474c3b3ac7494a0c575157993249cab2c3f8129b83e54930d7fdf12cbba64e1ee2ef18ed52996a1126781f4844bb97a53d0bac95b3034f5cbfd8e9804a28d814fa237896de1550b124108fa6548183d8dd71f22f5c01a40bbb47371d2e3169d66df371b88aacf40b74b7752f0c06d36b3e8d2709afd382565999b8e78d1218b5dc51a23899d7a8d84db1d7c2ce2f187aa8119d3248e0298abcb5e3a3bce602d8aa4bb9c11505ff465e79f27dbf049618d874895a9fe1b6f898fbf5a27261aed07d850facd6edb14586b9bb72e268eeff8f5d049c23e21b0a32039149e2fb6ce7321f143c681073ac3bd7bcc3b20381755cbb9142a5ab76733c02fbc87883758110f5415771818a4435a56be3a11289e68c955f704b62125daf54e01a8aefd3ccf932364292d270e22f1adeb2fbf62afdcc28f512b7779e089c805da3de988b3f4322d231df0d8680dd763d511eaab362ccc3121f74831bf4e869be0ff77be2d8dec60ee1eaf5a7ba506654fc0b87cd8ff90d7a95f7f2f1d0d2cc289db1e8445291a9d3f02221d48df672803b5df15fe548a0e47309b7f58b8fde20c09ecc683fc691ef34becb94d0142f5a336396c29b92ccb4507a3d05bfe92e55dc110bea72cf201b10fa90a7507bfa3204327ed7f718f6639c29a6a664ebd140767c9099a60cdd52b2e0ced8c6ff4cf876900d8a1508204b5ebea6fca06dba5bfe68f24e534abe0ba5d5239caa89eccf276406e7b9c1942924c3d0a3151a03a5f0993355d8d98af95537ec3645d2f52b0d4e231c6534b4a1abc2a87eac8c79f8ceb8181857731897a6be4d85a1299ac598d4c36f10e8e6d4b7a338f2062c7120ac241b73d5c59e9e1e038838f639b1677559718684fd2b646dbc337e0b6776a35f03ec577daf1e4e6ae66614346f5adedebe97fd912adf193964614652adb413b9d635978958f92d60ecb7fd2f06180518801fe8b7bcf6c00192b0c4fd9ed63861eca06b7ab1b042f245227fa3b001f5fe26030a46586542e05b82caa0fd7ebd69aaed2217c3a4832fdcc47a6262c0c855ff5c4b94a035782284e99ce7e301076efac87754115d69432c779fccd05f5adfa44ca93d87695435b6d53fa1c25f46f9c9bf39a7e36eae514a56a61d7bdca09d1dbb3fce36a5f1e97b0ad1dab0581d3a4bf39669573a1aa29ba21fcc50f5992983b11c78dc33f38e733e279abcd20dbe950adefc1cc0e7afeda3ab76217240dcd7fae37cd6259040d8ac6e42394bb4f1f58ce2e1e37cbb5d32a6a3f2067ee2dc32c6faa8cce6cac5bc7985e795ae0407b861b39f53c5deefbb050cbae4b68d265e2e068611c4854addf1ddc1ed23404d61b8c7343fd076f5a18da70ea7156ad00d363dc4bd76d1adc7bedf74bfd0112456d660962ec53b4ef32ad30e5cb077347bf3d6f91aebdfcf0e0d504a1a275858fbadc474062d9bd588ecf3f4a19fbf4508cb59af799b5c37aa018eedf6e32cd5b5cdbe325db68ab28d1f23999736694334b60fe4579b24da34c899ba4ae7684eca80287cafbfdd3580203b06e3478a46ccb9b411f7da346aacb4d026cc32f767f0b24e4853c37b6aba0d04e2aa445d925e651951b5cb5bb6a5a523db45fce6a4edad70348c814bdfd04c767303f92363f672888fd2128679fff3eb387acbe7f140c389a9ad5e2be78efd38860b54c6c11933e19913ed8a5871d2120a94d539638abe26dffae1f9e44eb253de3e40733776617a170c5986b323c80c6a56c825fee0665018ae3266751385e5409f08563420b8e4b490d9f7c50dddd531dc6bf8b5661aed57ad0dcfb7590dcaf5f21cf2a8e2ad7106a58f15b876bb452aee406bc32d44f15c0b69e6bc1be653b32a4fc3e6ea4ae5234f9f030371048387c5cd87551b8fb008008c60a05e3bcdd6835cfbd2dd5c349fe79cc1d4e60c5970ae7d984faea264244c0e753044a207dcb7159fb6c773b43588083855d17a09e58a564869d2d21daaf92458707cdb1ee6fc24ce0fd07f16c9d496d40ad7c7174b1e939c93d2432cb9cda61df399d837afdd1e75e3a38a167df03aaacc9b9b08afd7a04d080732e7a5beff40cbfdf6f9e3bf37a4c6c4a60503c45c620f5567619a1fedd18a22342905b79535c06e041f08269e249df7031450905c2590a2fdd8bf68fcdc5975310a40724c3ff9ceb8680a1df531275f00df5c36c38cb58918c84ab76ecf666e824e6db4e4f5295eff5549657b539d42541f0476e5aa0601766bd47d813ea07e713b06c02ce0cf197946564ceea5b3e1640222136704b447cf5a8290c7deef8994592f5edd3f0604a949d77af1bc7b2426c90a094fcf9ab67f5484aeb2ee140cae6e4b0bec5be189fbd7ccf6383114274b5427cd31c443aa5e16ad860ed231bb8bbeb18027ba87a4424681c2e02a0a09c8bcbda8c7c2e35fc228b3421a990840a5a319d41c1b1a0a6b72450eaa9c712a461d7f115848da479bd28c1e57e2c3478c937f1bbbed91751339d58988595efd2e614b75e35251b04818579a50635477404f3d72e87765030edef5686d11341a71d57a41ae1b3a4e09d70e09759a3c1bc5368f11cbb58419a60c06d76a43eb0b00dc2e8612fc777a5b4097f749c2db95ddc4b4ddc29eb0525afd62b295fe7093ab492aa4990edcfd83a7178f0bceee254cd642715ab9fb344f36f7e70c5d351756618a87b140abeecc3469030990a8b262adf138c3e481edf58425b63e2fe71c9d77473068ee30e9452b138e1f4558d323f6a8eaa29917d8a28ceff08b612ba09df55be801832deaaf18d8d08a6474b4dc69bf7ec564ea932a5243f9afb53191346bb6c8731e2f893b374f8a9e2c5a9b019792579cf447861478062ecc6947fc3d3043ce676ae154194e38a4fd38cc6141a3a5ae2e710a41015c3f0d43d0c48caf8cb9a43b5b82f56307e624e153c2599f289ec33b26c4d01632764a1a22e9976e258fcd8b2a77e9f38e2ecf8c8e74fab7455bd02300883e2a012d9664d654213d9c92ca90dfc0d646d35acc84f07d741429f17cf4438c287ba6e6e44708d75d7797817f4559d2c4e8b6fa6879ddeed1a03fd73a728e0ba6fffd30fae1ff83e740fd2000ca30118cef31556c404f6d2e91728f2963e76bf6dee9816391d87727c01e834d4edab855c6fd319fb156391d778964d425000a0d21741a879cae529d093ae54f9de91ee794fba0d7c837d9ad3d63a27aecc18d057b576cf5d0c0b68d67f7b5e2c8cd834c43d2a3e9b7f0eb7b4e4b6af17412a23adab0e3fb22dce775d4fc486ca37570c973b9ab4575e576e06216aa8dcdf0f4cc540c7e73c758c06ee0ccf7fbab640ccebf6e2e905e6671ff9ce57a5df4194be28d8bd35f33719f3e51a79f73ca37e5c8492dec5cf41e7fbff4b0862a9691c55d8305a6a8bebbd963e5c725939f6cda370c67915505a0c3e5f438ff4e20d22ec12db2156025e50bf76dccdda09851968d5941495b4de6e106d975a56f8285d3e4007b4967a3b67d2e0cd063b009606a4d0ab4e15c228f9c09573a5c81d7ad40994c4e032ac1a8210099ac2cbb14e7244cf22a27fea529a2e765af6f962660f751c695d51b63abaeddf2d1b48883e0678fe6bdb56357fb5b899f9b4f8ab4d859c6b48a8c8c4f074c665d5d25742966ea3f28f5bf26d98a7a2ab75305a43ca9b4b7170a3f3f3f146e9a617098fb053f90b89b477578bb039071de9bb95467e59b0108dc754b55fb7d5af1880d7be4a5ec1814bd47b7ad475a0cda7827d7b6a9c17df18dbe4d8cff7cfe8f05be3dbc667f5948fb4195b7ca468538a8a984b7219e6a97eee16818d67f7fa45a46d11057ac4937d219b8d5ea7da615bebe6f9c7bbbc44929b2eb4843b37d44f38b32aeee0bbda5c531cc62af2307d7c41850f9ab8af30b6e47d5cdc8f2ade81f6b457cf5f7c813404f8538eb176d9fb1d092f9f9d87644f65da35bb25b89f29cc0a84596c9300d65f98a9abbcc1acb2b9fcb7cd63a1b1cc9f62fca4b591d1b3fe8713b6f69ebf47ae60cb0aed8ea94727ce2c510138c48048caa4352574735c5ef87d6b96fa0055f99051a3467475552f15b624d2f3b872992713dddeac1b536182b718ab9f7724714e691676c7270e9bd71f443b6571b50f7017db8f3f83f0b185003009d9237405431667e3ef8b70b2b093bc8027a004c0cf4d221518f637852907c0d0c6ce0e82cdd5c5e0ddaa6c4d95b41961d8a9be2193c8958ca0ab9ce8a95260f73b48dee569d19ce00d36313dd51a846cf2ac96916b4934e16137d77b78bc4b14357d0cac28cc1a988b82f5577998aaabda11e5d027cbda88cf848b26698d700cd18cb7677bbe0f112c1e1d32c7452a39c67d75fdcf0499404eb59cb2fdc3becdd04ab5f7304adccca4553d3e75653f2c6cd6e94a43f65cf64e76bcc67cf7960d6e8c77746d3c2f617e50f224d23e9aa2c80bb98a7b4a6a4b6f85ebe7fd662baf563cb21ee696e3035ed5bd28769fc38d835bca0099cbb60f39ac90d119646600f0d733207701d3a23ba341214b7b6400629b1331464652f88d673720da9211ac51d1c32337d5176f8b8ffd7aca49d6c8ba42691c25de8a027d7aacb0c1379952abc27a4e060ea9b31657397bc692b0442e8c13ce165fdd6b5ad360f223b44d00d5759238ae0a226b4cc568c5e3fb620064d0aa0d73369d56f789e5521b59b823d6d3cf0c52eba86721a74ee994d5dda4172c39c939991d49ffaf60581f01fb5f372137784623eebe0117dca26351a41f87868a40eec64335318f0fe3a592d6e452e17f891e52746e513e01ccd7463c1f26d13d178d235fc5cd395606a92e56add956cf8a5cf9b30525ecef2af574e5ab184b7cb11bf5a04b91e28108d6e950e398cbd407f537080292e05b275970388ba68d6fb755ef17f55793f76bc6688228a8e5d0ebb5029f5b6adb9255153402b7de0b052485500db08cf1957e66e18276052f8f72cd6bd0f0ea95adc80967b68bafdc49d9938868366e2381f537f67eb380985bf88718c3e986c627c36fbeae43f3bdc03e7586829a487160a3a576dff5a612643c68d5f3f8a756f665474b51744d0dbaa63a99851d94f7ef03bfd29bfbd9bd68dab5ddc8822a96e645854a0dbdfcc02d1cc7b4104a1c045fadf127d9b8e458ee176556e6812ccf258b7c5f0164318dfc4604910ac7a583d2df0976cc4a2ec0be3dbf62c5632d5350577329e898f7013b45c5089365cde2feb3d5c2e26ed717a65e90bd72217ddf86df7811a8c72169147f497e4b80670683f234e9d6f875d91e0bcc5da627db671153ddf478180f39a7b5ba67f8486573f7e42ef1295f48179fd2df40b1b0e8bbb4abd5feae3e43e9929b31a28e8ef2e13858da614b166e9b162c2dba690f346ae60bcafeb00004d8c048ae5e3d6e2c0bd630871bd9ee5c616c52c62954536b632ba87a748ac8b0a74667fdfaa65224763dafaeb6cc8c0e30877eb9247d8509b873472e579bb1f862c13b2070a0a0a668f7d55e0611b343de1f406e976286b1ec74c8e51f5be5708041035cc29fd3f4d70660fe6c46ee397a8a87c9547ff923dacff07bcb0b792e403fef1c5deb86bc084e56374f3ef6ce4081d441851134f8887f63103466fd5496a7e12dc4565c19bd686287e26fb36b1d2673536c9206886c117284c48cc1dec47470babc1de377c9554c7fb3a9bf861c8f8e5204777e97b7e8f7cbb5d983ec55f3512833abe2783893461b66bdc31c540004c135ff71bfbd8e2e6289860c86aa34743a30a32288556002ac805c38492a77d919db13f85e7b95fa550c13a29d93ee1851a0f5f065f4c213684adb02dfd36e0970e202300c686ea324679c541dd438b4ced902fb401a1df52ef9395021363fa94ec82f3b87cb979a7f9eb3ecc4d7f9223a04da38283896a843381829260245025df7ad54dd6bd8db6703c5becd56f08d594ecaed2da93a50fc1dc684a5499685454d76e239f1b5394e8c5e36c0f58bc28ea0f5112f0d218e6cff056fd9215b64f2266e19c5497990507078b554d3be7a2d962a9645e70e7f4cf8afa51ed33b18efafc82ff800d9a0499612efa938d0c0feecf0a8ec2a976d705751077cf52b469747d4b18a6496be7adb9ce966bee6d20edb8ac6b6090331977a9477a61990c35fc9e1366456fcd834280ece4a0bbf66b5de606f41aa0fcac92c06919046dce41d69c0be10a75fabe9eef9c661b0e3434e0f93bbd195db41ec88bca54e6f6c0d8558e052cff6f2b6479bdd9c3a3a848c1f7ac2ff8a9fbc39dff428f78af68fb67c581bed01636bab7c339b5879322d2feb5ba0acc7fe4419641d0904e2ed87cfa3cbe663acad530559db6428a9b064990b5a9cf32e10590ae6194663ba9b5014034f81f7b810a91d8779ad7269bc5b620d6105ededcd9254dd05195e85c51dbc98eb5086c366902020c79e998169ba1525350e273de849a241b4aed613044298cef2126446d79ca41907ec5eb0eb4eca11727edc1eaa2348db51ec7db063239ddcb5d440c7a2a2ed6a4d2d5d94deb645039f92f9a63360d7fdec90320e7caa3b4cb35607a57457b8a2ab89cd29cdf6c2cc107fb6e67af5d9c1258624c03f90928ee7ecf26b2f1caaf381676c453cb4b95866b6d0d6d290fd5fe04d9f5e7af84b8bf39b401a30f19debb604039f3411b86ce3b72cc998b4a34e0b005ea16dd6acf4749b80096240296496d71080e160fd382b525011f3173d016116a4fd8a5f3e248cdb9634e8d20090002d637d9e2c210c22a39bc8788b75e698f3db86d10ea2ef4554d1370a12926d2dcef8f60f729d4bf9fbcf87cd664dbd8cb9838194f68f0a2131f0ed4e115d1ee701e392158b50e7c58b3e0fd70d36b9787f1ffe6e5116d22704bd37630972a52887c8a2be0d283e7349f143cd2e1fe86295e7f335f6c196a3d84de138e377b8dd1825e5daa41733b46dc3a8c7516c7ced98215bc6e1abac3008f51a541cfdb0c632884bf611ecdebe910029c2db047cf6c18fb0be35a62419947d443ee1d0577f516ee01adcff33b221c06d826c07fbcca7635a5b9e2e76ff044bf05deff640d4f1e1e1cc2e19723bc11abed2ec01054793ca63d9c54532f5a7e43868466bd611f6273a09cb800fb2ea3f2b2ae8e98d110b51f91b5accdd02ae628b6dd3220bc33ce54d6d9659409dd438e3fdf9c5c920f68418b75e11bc715b8d1a600220d2ef4a3b263a5bc400acea63142803e55aaacfa192af142f5fe3405e3034fb8fe033cbd74e25128f78e7e94806f4daad5a5dcb4ad38eea732176764bef90399a9e9526a91f16d2ccb5c1bc184c5551198bc55d9c598390a5423fba7f44b7a9323f80f0e76815b410c3e5c166fa5776f</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>前端面试之道-异步</title>
    <url>/2021/12/13/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93-%E5%BC%82%E6%AD%A5/</url>
    <content><![CDATA[<p>JS 语言的<strong>任务执行模式</strong>就分为<strong>同步</strong>和<strong>异步</strong><br><strong>同步</strong>：就是说后一个任务必须严格等待前一个任务执行完再执行，任务的执行顺序和排列顺序是<strong>高度一致的</strong><br><strong>异步</strong>：任务的执行顺序不必遵循排列顺序。比如说前一个任务就算没执行完，也没关系，先执行下一个任务就好</p>
<p>主线程里，充斥着<strong>用户事件</strong>、<strong>ajax 任务</strong>等高耗时的操作，这种情况下还不采用异步方案，页面的卡顿甚至卡死将是不可避免的。</p>
<h3 id="异步方案"><a href="#异步方案" class="headerlink" title="异步方案"></a>异步方案</h3><p>回调函数 —&gt; Promise —&gt; Generator —&gt; async/await</p>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>事件监听：任务的执行顺序与代码的编写顺序无关，只与点击事件有没有被触发有关<br>发布订阅：…(一种相当经典的设计模式)<br>回调函数：回调函数用的最多的地方其实是在 <strong>Node 环境</strong>下，我们难免需要和引擎外部的环境有一些交流：比如说我要利用<strong>网络模块</strong>发起请求、或者要对<strong>外部文件进行读写</strong>等等</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// -- 异步读取文件</span><br>fs.read<span class="hljs-constructor">File(<span class="hljs-params">filePath</span>,&#x27;<span class="hljs-params">utf8</span>&#x27;,<span class="hljs-params">function</span>(<span class="hljs-params">err</span>,<span class="hljs-params">data</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(err) &#123;<br>      throw err;<br>    &#125;<br>    console.log(data);<span class="hljs-comment">// 输出文件内容</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">const https = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;https&#x27;</span>);<br><br><span class="hljs-regexp">//</span> 发起网络请求<br>https.get(<span class="hljs-string">&#x27;目标接口&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(res)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(data)<br><br>&#125;).<span class="hljs-literal">on</span>(<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-function"><span class="hljs-params">(err)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Error: &quot;</span> + err.message);<br>&#125;);<br><br></code></pre></td></tr></table></figure>

<blockquote>
<p>回调函数嵌套-&gt;回调地狱-&gt;让代码的可读性、可维护性被破坏</p>
</blockquote>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>核心考点</p>
<ul>
<li>考察 Promise 特性（问答题）</li>
<li>给出一段 Promise 代码，问输出结果（这类题的关键在于搞清楚 Promise 中不同任务的执行时机）</li>
<li>深度考察 Promise 原理（终极版本就是让你手写一个 Promise）</li>
</ul>
<h4 id="Promise-特性"><a href="#Promise-特性" class="headerlink" title="Promise 特性"></a>Promise 特性</h4><p>代理对象、三个状态、状态切换机制 这三个是 Promise 的核心内容</p>
<p><strong>代理对象</strong><br>Promise 对象是一个<strong>代理对象(啥是代理对象)<strong>。它接受你传入的 executor（执行器）作为入参，允许你把</strong>异步任务</strong>的成功和失败<strong>分别绑定</strong>到对应的处理方法上去</p>
<p><strong>三个状态</strong></p>
<ul>
<li><code>pending</code> 状态，表示进行中。这是 Promise 实例创建后的一个初始态；</li>
<li><code>fulfilled</code> 状态，表示成功完成。这是我们在执行器中调用 resolve 后，达成的状态；</li>
<li><code>rejected</code> 状态，表示操作失败、被拒绝。这是我们在执行器中调用 reject 后，达成的状态；</li>
</ul>
<p><strong>状态切换进制</strong><br>Promise 实例的状态是可以改变的，但它只允许被改变一次。当我们的实例状态从 pending 切换为 rejected 后，就无法再扭转为 fulfilled，反之同理。当 Promise 的状态为 resolved 时，会触发其对应的 then 方法入参里的 onfulfilled 函数；当 Promise 的状态为 rejected 时，会触发其对应的 then 方法入参里的 onrejected 函数。</p>
<h4 id="Promise-的常用方法"><a href="#Promise-的常用方法" class="headerlink" title="Promise 的常用方法"></a>Promise 的常用方法</h4><figure class="highlight vhdl"><table><tr><td class="code"><pre><code class="hljs vhdl"><span class="hljs-keyword">all</span>、race、<span class="hljs-keyword">reject</span> 和 resolve<br></code></pre></td></tr></table></figure>

<h5 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h5><p>这个方法返回一个新的 promise 对象，该 promise 对象在 iterable 参数对象里所有的 promise 对象<strong>都成功</strong>的时候才会触发成功，一旦有任何一个 iterable 里面的 promise 对象失败则立即触发该 promise 对象的失败</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> p1 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">&#x27;1号选手&#x27;</span>);  <span class="hljs-comment">// 成功操作</span><br><span class="hljs-keyword">var</span> p2 = <span class="hljs-string">&#x27;2号选手&#x27;</span>;   <span class="hljs-comment">// 成功操作</span><br><span class="hljs-keyword">var</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;3号选手&#x27;</span>);<br>&#125;)<br><span class="hljs-built_in">Promise</span>.all([p1, p2, p3]).then(<span class="hljs-function"><span class="hljs-params">values</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(values);   <span class="hljs-comment">// [&#x27;1号选手&#x27;, &#x27;2号选手&#x27;, &#x27;3号选手&#x27;]</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<h5 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h5><p>当 iterable 参数里的任意一个子 promise 被成功或失败后，父 promise 马上也会用子 promise 的成功返回值或失败详情作为参数调用父 promise 绑定的相应处理函数，并返回该 promise 对象</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">var p1 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Promise(<span class="hljs-params">function</span>(<span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span> &#123;<br>    set<span class="hljs-constructor">Timeout(<span class="hljs-params">resolve</span>, 100, <span class="hljs-string">&quot;1号选手&quot;</span>)</span>;<br>&#125;);<br>var p2 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Promise(<span class="hljs-params">function</span>(<span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span> &#123;<br>    set<span class="hljs-constructor">Timeout(<span class="hljs-params">resolve</span>, 50, <span class="hljs-string">&quot;2号选手&quot;</span>)</span>;<br>&#125;);<br><br><span class="hljs-comment">// 这里因为 2 号选手返回得更早，所以返回值以 2号选手为准</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promise</span>.</span></span>race(<span class="hljs-literal">[<span class="hljs-identifier">p1</span>, <span class="hljs-identifier">p2</span>]</span>).<span class="hljs-keyword">then</span>(<span class="hljs-keyword">function</span>(value) &#123;<br>  console.log(value); <span class="hljs-comment">//  &quot;2号选手&quot;</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<p>**Promise.reject(reason)**： 返回一个状态为失败的 Promise 对象，并将给定的失败信息传递给对应的处理方法<br>**Promise.resolve(value)**：它返回一个 Promise 对象，但是这个对象的状态由你传入的 value 决定，情形分以下两种：<br>如果传入的是一个带有 then 方法的对象（我们称为 thenable 对象），返回的 Promise 对象的最终状态由 then 方法执行决定<br>否则的话，返回的 Promise 对象状态为 fulfilled，同时这里的 value 会作为 then 方法中指定的 onfulfilled 的入参</p>
<h4 id="看代码说答案"><a href="#看代码说答案" class="headerlink" title="看代码说答案"></a>看代码说答案</h4><figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">const promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>    resolve();<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br>&#125;);<br><br>promise.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);<br>&#125;);<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>);<br><br>---------------------------------<br>答案如下：<br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">const promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>  resolve(<span class="hljs-string">&#x27;第 1 次 resolve&#x27;</span>)<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;resolve后的普通逻辑&#x27;</span>)<br>  reject(<span class="hljs-string">&#x27;error&#x27;</span>)<br>  resolve(<span class="hljs-string">&#x27;第 2 次 resolve&#x27;</span>)<br>&#125;)<br><br>promise<br>.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(res)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;then: &#x27;</span>, res)<br>&#125;)<br>.<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">(err)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;catch: &#x27;</span>, err)<br>&#125;)<br><br>---------------------------------<br>答案如下：<br>resolve后的普通逻辑  then: 第 <span class="hljs-number">1</span> 次 resolve<br></code></pre></td></tr></table></figure>

<p>此题易错…<br><strong>考点：Promise 值穿透问题</strong></p>
<figure class="highlight sas"><table><tr><td class="code"><pre><code class="hljs sas">Promise<span class="hljs-meta">.resolve(</span>1)<br>  .th<span class="hljs-meta">en(</span>Promise<span class="hljs-meta">.resolve(</span>2))<br>  .th<span class="hljs-meta">en(</span>3)<br>  .th<span class="hljs-meta">en(</span>)<br>  .th<span class="hljs-meta">en(</span>console.log)<br><br>---------------------------------<br>答案如下：<br>1<br><br>解析：你可以两者都传，也可以只传前者或者后者。但是无论如何，<span class="hljs-meta">then</span> 方法的入参只能是函数。万一你想塞给它一些乱七八糟的东西，它就会“翻脸不认人”。<br>第一个 <span class="hljs-meta">then</span> 方法中传入的是一个 Promise 对象，<span class="hljs-meta">then</span> 说：”我不认识“；第二个 <span class="hljs-meta">then</span> 中传入的是一个数字， <span class="hljs-meta">then</span> 继续说”我不认识“；第四个干脆啥也没穿，<span class="hljs-meta">then</span> 说”入参undefined了，拜拜“；直到第五个入参，一个函数被传了进来，<span class="hljs-meta">then</span> 哭了：”终于等到一个我能处理的！“，于是只有最后一个入参生效了<br></code></pre></td></tr></table></figure>

<p>在这个过程中，我们最初 resolve 出来那个值，穿越了一个又一个无效的 then 调用，就好像是这些 then 调用都是透明的、不存在的一样，因此这种情形我们也形象地称它是 Promise 的“值穿透”</p>
<h3 id="Promise-底层原理：手写-Promise"><a href="#Promise-底层原理：手写-Promise" class="headerlink" title="Promise 底层原理：手写 Promise"></a>Promise 底层原理：手写 Promise</h3><h4 id="执行器-amp-具备-pending、resolved-和-rejected-这三种状态"><a href="#执行器-amp-具备-pending、resolved-和-rejected-这三种状态" class="headerlink" title="执行器 &amp; 具备 pending、resolved 和 rejected 这三种状态"></a>执行器 &amp; 具备 pending、resolved 和 rejected 这三种状态</h4><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// executor 就是执行器</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CutePromise</span>(<span class="hljs-params">executor</span>) </span>&#123;<br>  <span class="hljs-comment">// 注意：Promise是一个代理对象。是一个对象！！ 我所以要在这里写Promise构造函数</span><br>  <span class="hljs-comment">// value 用于记录异步任务成功的执行结果</span><br>  this.value = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// reason 用于记录异步任务失败的原因</span><br>  this.reason = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// status 用于记录当前状态，初始化是 pending (pending、resolved、rejected三种状态)</span><br>  this.status = <span class="hljs-string">&#x27;pending&#x27;</span>;<br><br>  <span class="hljs-comment">// 把this记录下来，这里的this 会指向生成的promise实例</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-built_in">self</span> = this;<br><br>  <span class="hljs-comment">// 定义 resolve 函数</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-built_in">self</span>.value = value;<br>    <span class="hljs-built_in">self</span>.status = <span class="hljs-string">&#x27;resolved&#x27;</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 定义 reject 函数</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">reason</span>) </span>&#123;<br>    <span class="hljs-built_in">self</span>.reason = reason;<br>    <span class="hljs-built_in">self</span>.status = <span class="hljs-string">&#x27;rejected&#x27;</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 把 resolve 和 reject 能力赋予执行器</span><br>  executor(resolve, reject);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="then-方法"><a href="#then-方法" class="headerlink" title="then 方法"></a>then 方法</h4><p>每一个 promise 实例一定有个 then 方法，由此我们不难想到，then 方法应该装在 Promise 构造函数的原型对象上</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// 注意这里的参数名 其实很有讲究  resolve  resolved  onResolved</span><br>CutePromise.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onResolved, onRejected</span>) </span>&#123;<br>  <span class="hljs-comment">// 注意，onResolved 和 onRejected必须是函数！！不然，则是透传(穿透问题)</span><br>  <span class="hljs-keyword">if</span> (typeof onResolved !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    onResolved = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>&#123; <span class="hljs-keyword">return</span> x &#125;;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (typeof onRejected !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    onRejected = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>&#123; <span class="hljs-keyword">return</span> x &#125;;<br>  &#125;<br><br><br>  <span class="hljs-comment">// 依然是保存 this  --&gt; 这里的this 是 调用 then方法的对象，即promise实例</span><br>  <span class="hljs-keyword">var</span> <span class="hljs-built_in">self</span> = this;<br>  <span class="hljs-comment">// 判断是否是 resolved 状态</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">self</span>.status === <span class="hljs-string">&#x27;resolved&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 如果是，则执行对应的处理方法</span><br>    onResolved(<span class="hljs-built_in">self</span>.value);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">self</span>.status === <span class="hljs-string">&#x27;rejected&#x27;</span>) &#123;<br>    onRejected(<span class="hljs-built_in">self</span>.reason);<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h4><p>在 Promise 中，then 方法和 catch 方法都是可以通过链式调用这种形式无限调用下去的。这里先给大家透个底儿：Promise/A+ 规范里，其实压根儿没提 catch 的事儿，它只强调了 then 的存在、约束了 then 的行为。所以咱们此处，就是要实现 then 的链式调用</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CutePromise</span>(<span class="hljs-params">executor</span>) </span>&#123;<br>  this.value = <span class="hljs-literal">null</span>;<br>  this.reason = <span class="hljs-literal">null</span>;<br>  this.status = <span class="hljs-string">&#x27;pending&#x27;</span>;<br><br>  this.onResolvedQueue = [];<br>  this.onRejectedQueue = [];<br><br>  <span class="hljs-keyword">var</span> <span class="hljs-built_in">self</span> = this;   <span class="hljs-comment">// this指向Promise的实例</span><br><br>  <span class="hljs-comment">// 定义resolve函数</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">self</span>.status !== <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">self</span>.value = value;<br>    <span class="hljs-built_in">self</span>.status = <span class="hljs-string">&#x27;resolved&#x27;</span>;<br>    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">self</span>.onResolvedQueue.<span class="hljs-keyword">forEach</span>(resolved =&gt; resolved(<span class="hljs-built_in">self</span>.value))<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">reason</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">self</span>.status !== <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">self</span>.reason = reason;<br>    <span class="hljs-built_in">self</span>.status = <span class="hljs-string">&#x27;rejected&#x27;</span>;<br>    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-comment">// 为什么要用forEach来遍历所有rejected函数呢？</span><br>      <span class="hljs-built_in">self</span>.onRejectedQueue.<span class="hljs-keyword">forEach</span>(rejected =&gt; rejected(<span class="hljs-built_in">self</span>.reason))<br>    &#125;)<br>  &#125;<br><br>  executor(resolve, reject)<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua">CutePromise.prototype.<span class="hljs-keyword">then</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(onResolved, onRejected)</span></span> &#123;<br>  <span class="hljs-keyword">if</span> (typeof onResolved !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    onResolved = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span></span> &#123;<span class="hljs-keyword">return</span> x&#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (typeof onResolved !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    onResolved = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span></span> &#123; <span class="hljs-keyword">return</span> x &#125;<br>  &#125;<br><br>  var <span class="hljs-built_in">self</span> = this;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">self</span>.<span class="hljs-built_in">status</span> === <span class="hljs-string">&#x27;resolved&#x27;</span>) &#123;<br>    onResolved(<span class="hljs-built_in">self</span>.value);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">self</span>.<span class="hljs-built_in">status</span> === <span class="hljs-string">&#x27;rejected&#x27;</span>) &#123;<br>    onRejected(<span class="hljs-built_in">self</span>.value);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">self</span>.<span class="hljs-built_in">status</span> === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>    <span class="hljs-built_in">self</span>.onResolvedQueue.push(onResolved);<br>    <span class="hljs-built_in">self</span>.onRejectedQueue.push(onRejected);<br>  &#125;<br>  <span class="hljs-keyword">return</span> this;   //这里不该返回<span class="hljs-built_in">self</span> ？<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> cutePromise = <span class="hljs-keyword">new</span> CutePromise(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>    resolve(<span class="hljs-string">&#x27;成了！&#x27;</span>);<br>&#125;);<br>cutePromise.then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(value)<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我是第 1 个任务&#x27;</span>)<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我是第 2 个任务&#x27;</span>)<br>&#125;);<br><br></code></pre></td></tr></table></figure>

<h4 id="升级-then-—-gt-决议程序"><a href="#升级-then-—-gt-决议程序" class="headerlink" title="升级 then —&gt; 决议程序"></a>升级 then —&gt; 决议程序</h4><p><strong>决议程序</strong>处理是以一个 promise 和一个 value 为输入的抽象操作，我们把它表示为<br>[[Resolve]](promise, x)</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-comment">/* 构造函数 */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CutePromise</span>(<span class="hljs-params">executor</span>) </span>&#123;<br>  <span class="hljs-comment">// value 记录异步任务成功的执行结果</span><br>  this.value = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// reason 记录异步任务失败的原因</span><br>  this.reason = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// status 记录当前状态，初始化是 pending</span><br>  this.status = <span class="hljs-string">&#x27;pending&#x27;</span>;<br><br>  <span class="hljs-comment">// 缓存两个队列，维护resolved 和 rejected 各自对应的处理函数</span><br>  this.onResolvedQueue = [];<br>  this.onRejectedQueue = [];<br><br>  <span class="hljs-comment">// 把this缓存，后面会用到</span><br>  <span class="hljs-keyword">var</span> <span class="hljs-built_in">self</span> = this;<br><br>  <span class="hljs-comment">// 定义 resolve 函数</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-comment">// 如果不是 pending 状态，直接返回</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">self</span>.status !== <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 异步任务成功，把结果赋值给 value</span><br>    <span class="hljs-built_in">self</span>.value = value;<br>    <span class="hljs-comment">// 当前状态切换为 resolved</span><br>    <span class="hljs-built_in">self</span>.status = <span class="hljs-string">&#x27;resolved&#x27;</span>;<br>    <span class="hljs-comment">// 批量执行 resolved 队列里的任务</span><br>    <span class="hljs-built_in">self</span>.onResolvedQueue.<span class="hljs-keyword">forEach</span>(resolved =&gt; resolved(<span class="hljs-built_in">self</span>.value));<br>  &#125;<br><br>  <span class="hljs-comment">// 定义 reject 函数</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">reason</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">self</span>.status !== <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 异步任务失败，把失败原因赋值给 reason;</span><br>    <span class="hljs-built_in">self</span>.reason = reason;<br>    <span class="hljs-comment">// 当前状态切换为 rejected</span><br>    <span class="hljs-built_in">self</span>.status = <span class="hljs-string">&#x27;rejected&#x27;</span>;<br>    <span class="hljs-comment">// 批量执行 resolved 队列里的任务</span><br>    <span class="hljs-built_in">self</span>.onRejectedQueue.<span class="hljs-keyword">forEach</span>(rejected =&gt; rejected(<span class="hljs-built_in">self</span>.reason));<br>  &#125;<br><br>  executor(resolve, reject)<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* 决议程序 */</span><br><span class="hljs-comment">// 好奇这个x代表的是什么？</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolutionProcedure</span>(<span class="hljs-params">promise2, x, resolve, reject</span>) </span>&#123;<br>  <span class="hljs-comment">// 这里 hasCalled 这个标识，是为了确保 resolve, reject 不能被重复执行</span><br>  <span class="hljs-keyword">let</span> hasCalled;<br>  <span class="hljs-keyword">if</span> (x === promise2) &#123;<br>    <span class="hljs-comment">// 决议程序规范：如果 resolve 结果和 promise2相同则reject，这是为了避免死循环</span><br>    <span class="hljs-keyword">return</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;为了避免死循环，这里直接抛错&#x27;</span>))<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x !== <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;function&#x27;</span>)) &#123;<br>    <span class="hljs-comment">// 决议程序规范：如果x是一个对象或者函数，则需要额外处理下</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 首先是看它有没有 then 方法（是不是 thenable 对象）</span><br>      <span class="hljs-keyword">let</span> then = x.then;<br>      <span class="hljs-comment">// 如果是 thenable 对象，则将promise的then方法指向x.then</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        then.call(x, <span class="hljs-function"><span class="hljs-params">y</span> =&gt;</span> &#123;<br>          <span class="hljs-comment">// 如果已经被 resolve/reject 过了，那么直接 return</span><br>          <span class="hljs-keyword">if</span> (hasCalled) <span class="hljs-keyword">return</span><br>          hasCalled = <span class="hljs-literal">true</span>;<br>          <span class="hljs-comment">// 进入决议程序(递归调用自身)</span><br>          resolutionProcedure(promise2, y, resolve, reject);<br>        &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>          <span class="hljs-comment">// 效果如上</span><br>          <span class="hljs-keyword">if</span> (hasCalled) <span class="hljs-keyword">return</span>;<br>        &#125;)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果 then 不是 function, 用x为参数执行promise</span><br>        resolve(x)<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>      <span class="hljs-keyword">if</span> (hasCalled) <span class="hljs-keyword">return</span>;<br>      hasCalled = <span class="hljs-literal">true</span>;<br>      reject(e);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 如果x不是一个object或者function，用x为参数执行promise</span><br>    resolve(x)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/* then方法实现 */</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">CutePromise</span>.</span></span>prototype.<span class="hljs-keyword">then</span> = <span class="hljs-keyword">function</span>(onResolved, onRejected) &#123;<br>  <span class="hljs-comment">// 注意，onResolved 和 onRejected必须是函数；如果不是，我们此处用一个透传来兜底</span><br>  <span class="hljs-keyword">if</span> (typeof onResolved !== &#x27;<span class="hljs-keyword">function</span>&#x27;) &#123;<br>    onResolved = <span class="hljs-keyword">function</span>(x) &#123; return x &#125;;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (typeof onRejected !== &#x27;<span class="hljs-keyword">function</span>&#x27;) &#123;<br>    onRejected = <span class="hljs-keyword">function</span>(x) &#123; return x &#125;;<br>  &#125;<br><br>  <span class="hljs-comment">// 依然是保存 this</span><br>  var self = this;<br>  <span class="hljs-comment">// 这个变量用来存返回值 x</span><br>  <span class="hljs-keyword">let</span> x;<br><br>  <span class="hljs-comment">// resolve 态的处理函数</span><br>  <span class="hljs-keyword">function</span> resolve<span class="hljs-constructor">ByStatus(<span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span> &#123;<br>    <span class="hljs-comment">// 包装成异步任务，确保决议程序在 then 后执行</span><br>    set<span class="hljs-constructor">Timeout(<span class="hljs-params">function</span>()</span> &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 返回值赋值给 x</span><br>        x = on<span class="hljs-constructor">Resolved(<span class="hljs-params">self</span>.<span class="hljs-params">value</span>)</span>;  <span class="hljs-comment">// x 代表 then里面的回调执行的结果</span><br>        <span class="hljs-comment">// 进入决议程序</span><br>        resolution<span class="hljs-constructor">Procedure(<span class="hljs-params">promise2</span>, <span class="hljs-params">x</span>, <span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span>;  <span class="hljs-comment">// promise2从哪里来的？</span><br>      &#125; catch(e) &#123;<br>        reject(e);<br>      &#125;<br>    &#125;)<br>  &#125;<br>  <span class="hljs-comment">// reject态的处理函数</span><br>  <span class="hljs-keyword">function</span> reject<span class="hljs-constructor">ByStatus(<span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span> &#123;<br>    <span class="hljs-comment">// 包装成异步任务，确保决议程序在 then 后执行</span><br>    set<span class="hljs-constructor">Timeout(<span class="hljs-params">function</span>()</span> &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 返回值赋值给 x</span><br>        x = on<span class="hljs-constructor">Rejected(<span class="hljs-params">self</span>.<span class="hljs-params">reason</span>)</span>;<br>          <span class="hljs-comment">// 进入决议程序</span><br>            resolution<span class="hljs-constructor">Procedure(<span class="hljs-params">promise2</span>, <span class="hljs-params">x</span>, <span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span>;<br>      &#125; catch (e) &#123;<br>          reject(e);<br>      &#125;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">// return 一个符合规范的 Promise 对象</span><br>  var promise2 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">CutePromise(<span class="hljs-params">function</span>(<span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (self.status<span class="hljs-operator"> === </span>&#x27;resolved&#x27;) &#123;<br>      <span class="hljs-comment">// resolve 处理函数</span><br>      resolve<span class="hljs-constructor">ByStatus(<span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (self.status<span class="hljs-operator"> === </span>&#x27;rejected&#x27;) &#123;<br>      <span class="hljs-comment">// reject 处理函数</span><br>      resolve<span class="hljs-constructor">ByStatus(<span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (self.status<span class="hljs-operator"> === </span>&#x27;pending&#x27;) &#123;<br>      <span class="hljs-comment">// 若是 pending ，则将任务推入对应队列</span><br>      self.onResolvedQueue.push(<span class="hljs-keyword">function</span><span class="hljs-literal">()</span> &#123;<br>        resolve<span class="hljs-constructor">ByStatus(<span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span>;<br>      &#125;);<br>      self.onRejectedQueue.push(<span class="hljs-keyword">function</span><span class="hljs-literal">()</span> &#123;<br>        reject<span class="hljs-constructor">ByStatus(<span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span>;<br>      &#125;);<br>    &#125;<br>  &#125;)<br><br>  <span class="hljs-comment">// then返回的是一个封装好的promise对象</span><br>  return promise2<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>前端面试之道-浏览器渲染原理</title>
    <url>/2021/12/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="9a8caae2b122dfbfef52fe36136b379099b8b8baced30eae0eafe9273d06ecfd">227b2a181666066aebdadda3a2b5e6f5ea2a8a3a236d171731e102205dd466ed52dabad676352595c7f037721ef9c47e0b0cc78143e5fe889fb042b78c3b885705c92d05cd963b1d36e5a23940789b74bbf14843272e71708cbb09ca76531e697e4b5b52f71b2516caba769b4a9f7d0c7045ab3e016b3bc069b518db5bc7938ea18c3f739418766ac3bcee55ff49bd1b0a207c5cdf58e40ba5708aa41c46285165da6a9de1cd86b063ae97883ac1e466bcd0276d3e8c8919db2e2e60b1df4872e83110861ecad6f2abcebacf42853886d338543bb7b1124731f85aedfd5097ebee064dda7e07c3a0723fbe214eda1589c5c280ce8ab5f89ab4c1aaa7cb9e40fded3c18727109f1424c1ae818d15eb3eafc5b2103a0082516ea6860211eb11154e67334bed82982295ba3aa6aa607c224c1462f3de585426289aeb388af863ba1ad161b8a83c2cb14766a56de72004a03e5f4b827767194692613f8d2caf2adaf3488bd2a66019c60b1c7446ef16360220a11cfd75700aacf4fe6270d5b68be5a0a49e0356ec5dcf074f52e4246e3c73489740ec4c4874f49ac98effac3ccd78a2f2927acc8a320cb1d40e5f61dd9655ed327c188819953d2da2c8238d071b6d029bee5008d1eed310fa153674b5cb163ba8d063f9142e53b3f7f2334fe268144911cd86f1161e099b5bce27349282a9c9cdfac54fd6ccab75a73713c8f295741141d8c76158b15db76050d8ccd01fc0bfa08100431027df44d346aadd42bc380c1a1eb816016e55da0d4f3e5cc6e98c25337655c530a5f2be27fc9537f42b262eb11dc04606ba09b928838f2a2679ac693f2bb901ccf4e198402cd16ef7901b10d723754c53ff0338d770bfc3350252f19e81910fcfd0291c5a30f5567d9f5db5f7e6011029467e2cc92791db570a61a359f0adb727b2a6d375ef0500776dcc4bab98fa6348609e584e4cc6a354fa14c40f8135b7c33c808f0915e4c934def2f6c492aa9517994acc36269a34ab62c48abcf562a87e94a5f6165c2b23de4a3a92c6b95dcaa7d1d7197bdcfdfb22927ecb2ccf2ca8362175215823355be3c080098ed8b7437a0f66100a8ffec7543311ae931fe2c64de7612d0c7151a81a8594f13b99e9ca56cc5e2e65eab5dce67f0dc28e8b60bc5abbbaae9a8495d9dbcbc0708ebc39b25e943a98b4b5291d98c446da0ff3322001b0469849bfb1ff035d72c272421512c3ecd4442530b1a72c38081283933d5409ab7548be685ac37fe24117cbd0c061e7ad402d2fa47cbfda56f1be89b2a9e003fc946eba8d60d7ea641fd1c7fe6000ecadba782826ee1ca66ed793208d58871acdf749ba5dd15f53ffe0f19e21e228e54810190a23361c2f146ec87c8628b361cc02c67cf1388cd56cf574eac327477c7f1d3b2e76832e6929ae357c9949cf5c87baae2b0ace3e15423a635b91c3d5cc752d2fec7a0898daf0957441660f2162b52b869d1c8e3dc4f9f7c5c283e13672f46bd435e4a04508248041dec5a91a7c6cde8282c941538027096866401492214040aa2c475176a1949211a8f395ae5742b66ccd07b3515bf33417a9fb8a51d94f8ea28c1ca2dd1735567ad13cb633eb6a335c7965b13fd180b228321b940a319808315dcadd9d182c3f9db3db4b944000ac0eafacbba8b1c1bc07c7dccb2eee8eafe5406314aa11f1ff18ee68245fd9cb963168c646fb620d61185308b77918713b29a0f82da2592a94da9cfafbceb4be37fac1a494859f467efdb7492215f8d51d5c360339741f25fdde5cf8197385bdd04f50361e270347eb00d65dcd0e793d155c2ff8a792d3e77381ed444485868f1da5d5229371cd0de9b2c4be9d6a6b5800b1293d9be5841af36449e3b1431594298303fb2a1034c5ce8cf7792a612e415e4ebb4c46ab5fd8b80b8d4187161c89204ca5ee2b80bec384d4deaa2dff69d75ae032968e78d2040beecd2610ea8bdf645fb7cef82fe2f30d2548c5b3916e909731013bc98cf97765d4561524b8e0a8e1ed8070e34ce41914680df5863eb8d9ce3b713637c903d18e9ba0e656dd3e899f1097b0558fcdf7bee678a011802956f696a231fa25741d70a5f0582e8f708ecedcfd941d71ed2f5c3bcb045c9514a06b2433a3e5666017afd927f948493c71858a6f28194f9feffeb53e836de674ec81817991d4c0f2103be1c3470d572d9e47c3eae979c1d3d0395fd85edca1f83febc3850548205ad6d5a0cd855975ea5467156ac1f4f16b88ee77c5bb3f93a2935cdfa5b30dcc1c7a27ba4ba42990561d37be5446aa1893108145fa5e3f0ebefb9e3b9f5bc876ae06c29634a051f0f88f7cf9a3dcb0e3b99cac9e9dfed2642e51bb328f2a935646e651e79ae43e50136a1bd711a6063cd458ccbb26be10798b372b6d43629df51de87ad37f55ae113ce3460f1b08e164456156c6c4d63e6a5d7a845a37e2f71d5fae0b1ce4e70ce9cb2b84213567e8eaf822e2ef06d76d5e92faa0d7a573732a83951bd9ddaed9f9416512f1dd5aa36fabb6ed1d81a6e2e9ba2d51f6eab3dcff42fa2427817350eeaf295932d1d3aeb8fd68c9c705556e1a6d209a71700b7dc4c158d93a327230d0c14edaf22b3f2dba5c0d34ae17e0a23d70343f188061f5deaefb1d4511196df63b5afac5b3c4de8b35be3ec83d29c8c6085f1d7b48ef7a97b158314c9b40fec325ddd6140ef26aa51b527fcf173f0e4c34d3dc81c843d6e2e4d25dc653fab9cee0c323617274b121647ee692cb61719eb15e25022ba2c824c1448f48c95121ba43ac3dba6e8b3f09077e2e1b589a5585a30230640868694560e9df38ae4d5e4ec1aa9c9a33a1e6a5971a4905fff1ad3c0e3d62dd354e4464d2d1f044dc26fd23fd8bf4e0f75fe40d4cacc4850d41ee330c24fcf379138d3bcf81d95012a8e5286cce0c1479c8f2b07238d53c2bb749baea05194e9f09b1d3068b13bcef762f4126dd323f1400f78f6f7586f5684ba0f039c447944a835e3c0b462c317d25943581999c692bc2e1c2081a047e243188834b5c1dc1884f2d0b8202ed5f607f84b08612cfe30c42987d123716b61120535acaf16a471995c551a06a74476eb4f818abbbf1c4897ffe4ebed13e6d9e09523ca7df7b9f827cb7648947a71f4c169f778d059b544a203707473ff408e225a362492987be5020177476d549da2f0bcc666a057c8a31d77289f498615748bdf70aac469fb5f506aaa458e3094ab1d8e783a173c1a8bfaf17255e1cb1635886ab7b75f25217cdfa70e03055c290862ce09622653ac483c7141dadab6aa0fc0b15e8dc74b47cc9f26b803b09811af7a6e6d8d6c8670d21fd18c86af928c4f9c520bcfc04be9b05e3e5a6e29a9d64387798924c5f496a2b972f1e5ed757489f06c8e3826c48ed17d41dadc628b4fafeaff75e703fb1796577f0ac80d1385e27d5189a018e94c9f7bd21d457953e4cdc4fc37cda26bf32e4aae594ae57a4b7dd25ec91909c9dd75cde13d314d529e268f818f2da7a6e3bc0506f74c17d476e62012f1849e555f424d1a24a8172285844f729c7ebaf42c95e8ac95c6883831e2081c28eba4338e7c1b8a80509b0b2f0bea67d98aa43971649769b63ef1831af9d3df119bc271e0164e52ff926a5c8e6db02080a9f4b6418e7c1abcfc3c36342f59f757a21986f16e64c05a24dcd76f419608eb4c8f098d6e2e1338303a3350c1b9e6bdafc1f2e788734e0ac96d9ad0d4b8463979e3c6986e23f3ddb952cfa44df12a26d7583ddb8f4e2a5628951c8045ca31f097bc3ff7e82824caf2d5b7745e50958825787a3d1384bf5948f7bdafdb2bdbd66958be76f035bd74d990abb095446181e299272bf48e14157b17033c1f2cf1e8ecf0e0082b9ed6ee0ce902a5bb5104230ec2098f8807972c572c3227fa15c425c529f0716b0dd427fc0e04e2bb63beba736547ddd56b4ae97f85ad4970c94896f00dc4f4cc056affbb5a2d45066fc809f7ea70c428045a11ad55bf9ec14415a9d31c9d294d0f12a3d3227b1d664948417607c08e93e1d272f730f956a476cbd715e80c07e9cfaa62bbc95449eaa75eac7963f370f97e6b49d9afd4bf7fd9e7a504522c9d2fda65410869cf2daef56f3af528a6d959c3089ebbb073b18a7b6e2f6148056ad8653bb364b447a30046f94c9949a89d28330eb343df3aa1e330060e2e75b67d32afefaae9a6bd6de729d09412bb185e7734197f5afab97019368cfd24ec1e50f217d405ca35a8e34643f497e9b182bdd191eef5870d896e3cb07940258b5916baa26167978ffcc66caf97159ecb404ce8f0db53feaa4ecf8e91901d88d472e4274ff4a7fb056dcc7b92aef997f40b07f24e1355e0263c0559180c3c123220ed29b5e8548d9c53ff599bd692e5b2a34f6d440e3b893318bdab7253e8eff3cffd3762b85758ba96f5e190e43f1ed7d232efabbf80ff29dae7f03d494ec32971aaa9e01e052539babe2cd16d7a825eb88bdca8c9b5cd66b19a0fa78a21ea6700ec5717864e6b425b35b0379f1b559ee885b8224d88147af604a64b503c835e30c6c6a879ea829861708629705f25a52c15e76053a18a47ea15a2d8c07ea676172ca6363890ed596dd18d8d5928591df62ba76f450bf7525a1f4d0fe1efae036891c61c868f9fad8acd8a667b3a384d6319b43a3a6f9ab14599d4726d119b5a49b78fa45d38e22dec95ccc3c3733ae2c41760bf6998e7ec79f650f3ab8f21396f6eeecc80d2507f79fad07ba80eb2e342ceaa717982e8525188578c4eaea58b72c026404330039bb72f19da97a3c35db55d74292086f060a046fa71c65499e89b935aa54b9cb96b19e66f99e1ca1efdceee94bfe0702e426c05b9931e2d36bc5cbe3dd9c3a80b96ebdb044c46f94eefc50a5b543151d265a29303976f008bb4433df5d2fbccd89378db0e97b723e8f047e333972c7245ea63b7e14617490ae5639ac9407e6dd5cf198f54bbbc7ff968880ef85d4df6cee73c2fc46f2b361ac2795f6ea81226b05ed5e07f9b57a642c55bc1daa311a3b6cd458eeb6ee90af52f7d3a4dc7898da7d188362e4bf64dd36b11076878cfc254ed7a5079eff39c6e1f650419638ba4665ead1ab9830b5fdc7783d1f14f3a09195ece114835568631f8b4339fbf139ffee2faae1bfbd6654799d3da702715e210b97be5cd189174b93ec1664c0b562a2725d89c01e868c9acbf3a5ea2d4539dba43160463c91b1b363cbc90a5dcc0ee480a5e880b80c742cb22d76e610d2cc8a9cdf0040a82d6f13e12383333d14a0adcdbcca1855184c4c5540eb52575153d74f0e37113f4311793d11abd62cc75c7767bc785024eb56a8692c94f28b3cb7bcc6dd61346d00356ff33b29a030e177119e6256205d1e77fd88210375a1785c5db4b7bc476dc6c85d35aedab47cffc2893bc1f2fccbf8b485cd6b9c22753d9568e5f9016e0ad07b0240f01c0ba3f3f43a0898c133b27a265ad329e3a1ce8a2b569b431df7c890499372da5d9b2cd46dcd83c325a83449441987470157c5a3355144b4f5f7164d3954ca0ca1ba42bf10e04333908db81de5d9ac3072286793fc5697b166de7fdfaf0fc73ad5c25ec728fd255fa4aa9f8d5e61c03c5a47b3866e425759dc5c2eb0cf6ea8d8fbfb19e800d723ea12d7e639d5e3596f7933dc3dcb1b6c9c343bbb3eac583cc6722a46c5e4f5f51bcc7bee42ced6227b5ac33e546b658df87b8f0a952cf6423b97ca2d68d7e1bec7d63ef3f1547b561c3b3bbd1637af83e1f5ac6d2bd4238eb06fdf1bfb0af12720d40dfe6b354f8af6fd894e1e65ec4b400b81b4def76b685822f5940a4c668debdc21105ccb25e52a3529962307aca4af3f55e6f1ff1e86d53fff62f116b428c6baff27cbbc9fa7cbbde53f28b68f624165e00c62da6b17f1d88316f72c2ec0b4b690ad1ce54c7491632f04af395f7b9e766d996aa56c2388e357a73a25863348f9dd190fe5536accec1b4545942dfb8b9780c9f915d3741537cb2682f998e8ca167</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>前端面试之道-琐碎题</title>
    <url>/2021/12/16/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93-%E7%90%90%E7%A2%8E%E9%A2%98/</url>
    <content><![CDATA[<h4 id="一个页面的脚本如下，请问会打印出什么内容？为什么？"><a href="#一个页面的脚本如下，请问会打印出什么内容？为什么？" class="headerlink" title="一个页面的脚本如下，请问会打印出什么内容？为什么？"></a>一个页面的脚本如下，请问会打印出什么内容？为什么？</h4><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">const</span> sum = <span class="hljs-number">0</span>.<span class="hljs-number">1</span> + <span class="hljs-number">0</span>.<span class="hljs-number">2</span>;<br><span class="hljs-attribute">console</span>.log(sum === <span class="hljs-number">0</span>.<span class="hljs-number">3</span>);    // false<br></code></pre></td></tr></table></figure>

<p>因为 0.1 和 0.2 被转成二进制后<strong>会无限循环</strong>，由于 JS 中位数的限制多余的位数会被截掉，就出现了<strong>精度损失</strong>。</p>
<p>一般来说在 JavaScript 中进行运算一定要小心，应该尽量把复杂的算术运算交给服务端，或者使用 <code>mathjs</code> 等库来进行计算</p>
<h4 id="为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组"><a href="#为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组" class="headerlink" title="为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?"></a>为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?</h4><p>因为 <code>arguments</code> 是一个对象，它的属性是从 0 开始依次递增的数字，还有 <code>callee</code> 和 <code>length</code> 等属性，与数组非常相似；但是它们却没有数组常见的方法属性，如 <code>forEach</code>, <code>reduce</code> 等，所以我们叫它们类数组</p>
<p>遍历类数组需要先把类数组变成数组。3 种方法： slice、Array.from()、…</p>
<h4 id="一个页面的脚本如下，请问会打印出什么内容？"><a href="#一个页面的脚本如下，请问会打印出什么内容？" class="headerlink" title="一个页面的脚本如下，请问会打印出什么内容？"></a>一个页面的脚本如下，请问会打印出什么内容？</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">const arr = <span class="hljs-selector-attr">[]</span><br>arr<span class="hljs-selector-attr">[5]</span> = <span class="hljs-string">&#x27;5&#x27;</span><br>arr<span class="hljs-selector-attr">[10]</span> = undefined<br>console<span class="hljs-selector-class">.log</span>(arr.length)  <span class="hljs-comment">// 11</span><br></code></pre></td></tr></table></figure>

<p>数组的下标只不过是数组对象的一个属性而已，当赋值的下标超出数组的长度时，数组会根据下标自动更新 length 属性的值。<br>重点在于记住 JavaScript 中数组的 length 属性只是一个会自动更新的属性，它不会管你设置的下标是不是超过了数组长度，它的任务就是根据这个下标自动更新自己的值</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">const</span> arr = []<br>console.<span class="hljs-built_in">log</span>(arr.<span class="hljs-built_in">length</span>)    <span class="hljs-comment">// 0</span><br>console.<span class="hljs-built_in">log</span>(arr.<span class="hljs-built_in">length</span>())  <span class="hljs-comment">// 报错</span><br><br></code></pre></td></tr></table></figure>

<p><strong>注意：数组的 length 属性只是一个值，并不是一个方法</strong></p>
<h4 id="谈谈你对-generator-函数的理解"><a href="#谈谈你对-generator-函数的理解" class="headerlink" title="谈谈你对 generator 函数的理解"></a>谈谈你对 generator 函数的理解</h4><p>一个 generator 是一个特殊的函数，它不像普通的函数只能返回一次返回值，generator 可以产生一系列的值，且不是一次性返回，而是由用户控制一个一个地返回。一个典型的 generator 是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">NameGenerator</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;John&#x27;</span>;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;David&#x27;</span>;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;Li&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> name <span class="hljs-keyword">of</span> NameGenerator()) &#123;<br>  <span class="hljs-built_in">console</span>.log(name)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>generator 的使用场景是：使用特定的规则，生成数据。比如生成 ID，生成编号等等</p>
<h4 id="escape、encodeURI、encodeURIComponent-有什么区别？"><a href="#escape、encodeURI、encodeURIComponent-有什么区别？" class="headerlink" title="escape、encodeURI、encodeURIComponent 有什么区别？"></a>escape、encodeURI、encodeURIComponent 有什么区别？</h4><p>escape 方法已经被废弃，不应该再被使用。<code>encodeURI</code> 和 <code>encodeURIComponent</code> 都是用来操作 URI 的。</p>
<p>encodeURI 用来处理整个 URI，所以它不会转义&amp;, ?, /, =等完整 URI 必备字符，而 <code>encodeURIComponent</code> 会转义那些特殊字符，所以通常只用它来转义 URI 的参数。比如手工拼 <code>URI</code> 时对键值对使用 <code>encodeURIComponent</code> 进行转义<br><code>encodeURI</code> 和 <code>encodeURIComponent</code> 的区别从字面意思上就能看出来，前者用来转义整个 <code>URI</code>，后者只用来转义 <code>URI</code> 的一部分。</p>
<p>一个常见的的误解是：由于 <code>encodeURI</code> 可以转义整个 <code>URI</code>，所以它的转移范围更广。</p>
<p>有意思的是，其实正相反，由于前者可以安全转义整个 <code>URI</code>，所以它的转义范围反而不如 <code>encodeURIComponent</code> 的广。这个一定不要搞混了。</p>
]]></content>
  </entry>
  <entry>
    <title>前端面试之道-计算机网络</title>
    <url>/2021/12/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="77c9b5f238536a1c9918979975999dd5bfce1fb3270254f48174e259baf3a3c5">227b2a181666066aebdadda3a2b5e6f57e600d46621b1569b80f830bc7e39b9e2183e3015ea2a55874439bd48acce8efcf862d577546bb5a9d5302c0659387085e4d089805aacc819f3b489a6bcc745c7c605c26c2a370a86588d9eb171a86d39662b4bb7b7cce57513c30c6e913f4b153ce068abec04771e6470d61737380eb6d38bb3238f206da3b58328d89d5c432d12d22730f2e044cbe45f9900311e772c9874d133f0fc4173bc2587335eb6c5198ae21c267d38478c6a52d3a4d7190552c2ffd1b5149e1a0589d4919cb15068e4afdeb4ab2189a4120d672ac5e2e30b4c81c4fc7705d6ff1b65e51448ea1c7ab74c0712950a30838940d626562f2c472a757f2336b43b3946fb436e4e28612a1f6f90d27adbbe4d475c06cbeb5f0633c686066121b38c66eff65b96fba3002efcca99874efdb5e4821afb5010390688715b39d64f0b601e45fed125a4fea814b5f712ccf47cb7c5560a87b3e6e64f84633190be76d2324e1cc87508bd831c763a086fc86480401ce688fe80168dd512e58908e3cd769b7d8c898188f8d709115e93fcae770b82841e06d55927325a508a8480c99db38ac924a772aaa2ca10da4bea04fef18e6cfd96adb61c5615a37ea31e6402ad6532af2174da8b8b7a91f9945990dcebde92bc50ae0e3a2faef50e256beca339a12668e9a5ae9b2c429d117e8b903bb06831efd605ce553379b3a2d42b37d98ee0b5a57e4f777a21461b84743bd93b2fdbaebead4bcd1085f671ae4489c818768e1d76a68f6aeb4fd874488c059e1753ef53ae92b2a97fc6c1f63576e1f6047af6d8b99043c74d6b9d164607b6289430bed6f53ed01981db8fe458e018dfd37d6f8c89efdd501b3801d73c9e1d71174c32454c11862c95ccd598f15a4f223ac828239fde53c77d21c053c2aaaeaf2f81afc21bc786623b130589063978c239c94d9d1d3dd26837a701ca77a7c7b37518f5d85818c50579f5ad99faa7dda28f0e2cda7db88061199f330fd2e8aac65b2966ea8f72e4cdb9fb97264526c4acf807afecc6324792e7f77c2dace394c09a684ef30c278a3b3cb2a8ec9792cda279457dfc65480a64c61d391ecf5a5afdb77a182efb069b0a789a7aa860e448e56e9e27b4dc8888d59ae0b0dcfe6761ea8d334d9ff9dfa39a016fb405390059cdea25a7e4757722bf97192a977207da8e0294c8cbf7114e34673b4fff5059368488096a8b5b3c79dba1249c90763f8fcd8801ea59299987f94d7c0e8e1342dc2df762af89d8a78812fea3303e75333ed73a36482e671178c4b42d387c7e156b28f4f4d7bbb026336d4ea66a3a461c72280f13303f3b435b6bfe1adc67408cdad54736d900b11854d389537afd11cfbcc71e9e40b02410e3e2ab48f314026b82731bbfa90b04e20b81cf6b57ec9531de0398668dcacf937d38857efc4d9a7828b9cdabaaeb6818fd6e439fdc11745f8549c48e7bb2267c44399a0f048850078c24d11edf4a1908d4828cf5e77db8a8bf559d23b6b51e3d016715cbafe45721b0734cb64d6a738b18c09a63dc5c59b251610f724a853557124cf2f907953c26f3310e54ad469eac7469bd73afbb9d45b723a2ee33df9f31a88a3345489291bdb20bf3ebae97792419a2da812fcc98d160a784f94b166c9d46d937ab6ed0305ebb811fa1de3630b153f02bd5596c6a0650a166c8626ca0e6bd5f6841121bf4d805ac9825264d886bf259b33b58be2457c4f70e06b66f5f17f38548505b4a62dc2f05b53362b8e2f12b278b870d34ce2f9eca841540b1bcfe9ea6d8f3a78180dc68e151a1709e95bdf4012786667fc466cf4b4f2d8a7944f8e4af082b718c54657188017384f41230a86c1fa715bc0516af2e1bfda9338d36d98ecd3664cdfc4cfed09b1ad1d595e2c6f283f382f1ef914852ed2b2ace7725536a4af488b5a529c029f76a88360e0e856d49cab74e9e8961f1ad11c274351eb4f1b4d1bc996d63540251f8de1af5ad6869cb4d747d7e7138d8341bcf6e0d4e8dd61aeb167f0e70fa86ed447fff8f8117971f7c79998bde493eb16c1811cba9fbb58458507d753c6ba3526d5024410345afeaf0e26f690d378f38bff2f33fd3165ee84fd05b4e833e32af8d5ca137a899975aed893d3763fab4d7a619a8cc5fe0345c0bdf1e6237d99c0423f43fdd14b2f598716b207758554610c68e134b284858d09b8f8ef1a941522d6f4b358cfa988379ae232997ce5de190a68b0c3a6f9ed2860787d1362b1b158dc55f978d5be96cbc4898bf94fad863d3edf16ba191a6dc7a6a091c2ba0f3b5325ddc3e212a63179a07fb389d3f1dd8b78c364b4044a7441d6dccbd88b7c1e49c89d442bd929f31ff32ad32c9733a475595936a201eb0de8b8cfed79f5977ff620f8b7447fab3f97fcebf54ceb18f7665665679f49d0febcf4238b7c3cd6755d269700bb8f172513cfe59f61950b9350ae9d010ba39d7dd0ca633299dcbede9006a34c0716972a03dad075f4928235a83b764b484306f3ad28249f6bea54dface5df087e8d85c7c5c5eab555ea5618a1465f0265ac7ca2821db0f85a1ce1a3bbfd5f505008a0f964c2c6a2bbc7ea5ead6134c1029f68a4bf4a36e3f1fb4b60ac7e3b3389270ec49d01c37efc849894f891af188586e411782ac055c01103390c963df9f2c7f7b2712c08c53868d94377e806f1f567d8b8a5948e51c5a9ff4eefa844f646acb23f301c8791ada60ada97fec27eb3a9e5e3d5a68118047083b16120b0eb29715d868c8ae0c24ec4daa6415d996864474ec0ce0b9c532ca4d2b3b6c94021810020f97d06c3638a990236724ff0b7de2ee1abba4dfe545f9bcb7be93d0d6bab2397e174e3ae124f47148ce9f43190a1129421895cec9ce6b95335f17fefc83862049cb5978836bcf34b9170c8782ecfebad5da6a2e5aaad0afa9ce00d5cd05952871c41e10094c91906b145c77389afc924a720989c910d021dd8f5e0bd062e7eca60ebbaae35ec97a5387e89c51b732329908e4df1f98524aaf93742662939fde57e89fe2c799da7d9abf1c297ba98b804b4f6b4c43eb63c0a3725b359adc13295e76dab4ac5c5dd92efa49d405d8ce8ed5e751b07e2f9ef7f40b78975be205fca7509e3ce316053205e5ca24bf684b62f7c0f866a9d38375bba0f025460c185dfda2524226ef6057295cb119001b9dfd3cafc8fc112a2c036d20f1f8201ca64c898da9d52c195aa5c4102bb3793cdce95de80902bd529ff2dd80987ad96e31b05c78946c4c122c7aea0969bc5c7675cad263cc685766b644084402c58f41df94f0cbc641361b5006d758e7d607b44c0eb463c9040c136a8978d8cd87bc1eb5b04f4f7471d5ac456734fa6d11e08ae6e352186df01f43aa5f8d0d20892d819a0c21820383db3609c039023884df6d3d6ddd563ebb81f1b37391c66e2a15f7b0feda095397754921230cd11d5b23451c07889266b4309ab408c4e44cb11b9aea2736f6fa823ca7bfe1d3b79a3fe079680180fa319eafc688825df0b319d8741da3a3578622ace0aa27c3cefdc1e6a952551d5a2c123e20a2e08145494ade071a78a6df4955f8ee36e8d4913b84583bd0cb7f135b942d707876407c41ee300f2138900ec4d471da0803e6097acd83888328e4d2fbf599ef99bb65c0ef5fa1ce1ccd63b664d5305b0a38416063e95268a28d6dda2b7b671e2d80a3e1dbbbccdae70047cd5007fe30c9604ac0caa1e286538b5016a3ddaa1360837934cd0cc48795de811b50aae076b56442938e6d6d7fe6e390bfba9d7fc077a316b04f2dfe8c41fd4bec11802c7954cc3b094f1361fe7b3dce04232dbf58ab2f3a3e091ab98b8e6b63a2d14867b078edbca70b0c9e57082d62ee3dd7ad70560cb758ac0732b46ee7443f5f66290fc63f3d42194149234e87aa9dafe8adad802fcaacef8ce566f233c28c06e2d1ed70c611f9d0d9d4a94d8fde9f0a05e6c35ff27d34330a76b5dbbf0bf40ec8361c39b76d43b6a1e0731f4109845c7d82efe2993d6cb291cea687944d536e4de6fc7a40bd080bc6fc36fb7bcc4ec5e4b6f3445a1160c75af1596034fb7ed55f9122b762df813aba15f55654ce8afb3c47ab93765d70210ea677f5f5c729f3ba11fd15024a6d6084fb3e9ea7632905308324358b99880bfb16c38b7b692a34b2ccbaf3a6da736745917db96d62f7fee1977c1e6d8884665ea172d6558be30090619069f8aa7d74b2b84e5443de0fc0d228fc349d53cd5a7050d4f1450f4d902672bacc6f50bac93354428ff00f81be2681cc1ff37d56b006f1a835fc4ca81ea10405911999e795b534fc261f022fb61c21d7eed5707730b43bc4d7a1d31f924d83625432157ce9651144ae8bea278db61736316828835f4d2b43a192f5b444acc8cc75040d04da7ce487008edab587edb59469e8103b9a2e5538954a58d86df4d390b3654214c67ac17e1b0fd0515d86041ba7934c28e722f4ba91528f1123958e9a59253c4ecafecbfe87209165aba6f878f92cc52cef06075436efb02c8326cd5b12612f07c983fd848010eae7d35ba85b48c3658e7501aecacb2d32db115b12585d1f8a28e9ca97700e891c9d99eb7f236b9c7dab03a70f94e6e64f0517a69874168dce90fc7ffdf337cb99687abd45f73607235b28b0747a1be52e4c1a4cf0d99bfd947d4caa850fa1aa090cc4fa0a4aafbddee597afcc29440c1215cc731d7c5cff21528663974d95b8de0b44fb384c88087016b3769b1f89acddcd1d83fc6322442de9d9b0b7302c23fdf1734e0d57d2f29704e8ff5609bd8af5e3090d20c59e9dddff78c833f3975d1b607005a4bf47033734b8e15561c72270a01aead4238aead966b3c991dc168815927a629c4c1191c12b503eeb234974de8e2bcde69f6414ab17bbff4b1a9b694992c80523ebd0ce063b03a48e6b1c1beda63d03fdec5691f7a5098081e45e6b697e39a97170cc98aeaa2f376db06a3f5893d7119f028fc591dd53aea03985c27a18e3233f05863457fa09c750b0cbc3680b0a978aa3dbcfc97cd94cff92c7026656e2a9a12ff6936a5f784fd20704544d057c8a4b58a16a90b54413638b90cc9494c5f13605748d17e6145b691e346ffecdc7b399963b34d1c15046b44824da0d953ab4324c525659bf53c82f7e2f9f504335924f38c98d6f1401963430eee9b08732330f63ab57a4c8878421e5844171420f3ef45577d7b3714e1531b56ef35a6488c60ba47739fac4bf6133942e7d563c41f35118651131774d32d67ddd5bb3be82955a9e554b6d70dab7518d439577d591168a9b2c49966708b8caf51e9e10eaa88157a2af08a7f1ff2564a5084ba8e600ba6538232ee787214214b8c7ebb20e56e1db4354d03af196f0bb6ab33b49bb9ccbf59a58717bbb237b58ec219ddbaeef09f0721607409cd4de679eb52ade064fe45fc4a6f3aef0218795f4fa3d2c1f5821394ca7a84d3a988761c77329d0db968ea33403e2271bb301c179b99e13af8b480c2341d0b4afcfdda36303c27ecb83f6880f5e90df1d6dd437b53b71f8271d7d983b52a6ac265fe0ffdc2bb5e3d3867eaf0eff4701c84ba812d1151741ef4370e799b2b33cefe0c9d43a689949797c0a15f5745b0e686331ec3aac001137e3ac0edd8102266e20344985e6953305874f63b2a6ff8eb9a01a8cbeddd4fd0d3082d43c1fdaf4dafac5d893f068231790e8320f746376ab1248c595056e89e6055d861794e1ef3ec9a82c88264014db76d9dab1769d272e52a46e56fd3b07c0bd06b4791aa33564de640f3e89a59a36d072c45bc6b37d4df79cfd7a0c5a0eb933c2b05356b79aa3dbf2d1ee88547161ce75bdea650baf1395e2c12eeb1bfe576a63b363f5eb1b7d852c870a8bb9d463520443920c2b599514340732f7813c72b29409780aefff22d2466953c634d0891890e22c46bdc11e1147686689381a94ad0307e1911d0e55ac9afe5b21ff67ea078f7660ab91d85e2dea90d4cf7d7272d8c689aebfc4c733a81551b76dc67416e49f44a814a18391d70dba131483325c8a97d4cf180466a67ef86e2d63d0b15d06ebd9ed8097c14e6d215cecc0c975c883718e1acdd0af4101fb6fb12b483de19d48b341e60ee5af0660895074dc77d62e9e76c959ed824de6a1045762b60e05e21c05a7b7da0783180f2dce5f524886d64c59b493418292c595810a1a127819deb3dd2b36f14f8a0c5e72e031a94ec87b37e906e8b97baf63b27ae8004df8a39befc728c328e5bc6750d0b30aeb93cb8a4034f0641879ea45bb3e4f7b3d5a5a73704140484d7bc164641d256387de656356f9a9f98e9f17d0879331796378ea801504036b92cc8a6d834aa96853f2d4dc22b2c3f2296351692d9e9d1282c4d8b68f5284774a2baf12f212b8595c32a07d37c2fb6b54830a3a007fe31cf8649d2e6e543b4bae9d406cfae59ed35fe7976c56f7410963472de002cef6e592e7d198d6e8955a0a49c8c9b95ef8fadb0f8f29f3fa1392b5e0bde607c88a3ea1ab12c19d399d1e68f495f2c3d60e1a76b689a6616fe36b72cf6edffe9f783e6f77aeced4015c1f2d2c78234469ff8993130b4f5cb4a4b849898c28ddfb9b387bb67b4ba460f6761e39d067747da65007a0437a8c1ccd4701dea6e11ad7996629d70198fa30ccfb6e352f5d103e83c5996474b8de0a65d0ae5291566221c9252e047096cff21b5b4d67e45b9b93ca6dd75014447a808bd7f2c20727175b4b418d2c44ced9b9a6ab9d46146e1b4faff5d2e5712d0a0ce242e1242e439c416db661b13b385ff082cd4c4b5847f756242fdae13821d5a1bcec770b74e7d9a992a7ebe03aba9d9317e84b203399de34815b09cfd0bf486dd2ce97b9162c492ea36fd912b281d0b586733bf55cffa16b75bc049a017701b8c6eb6a35477ac2095fd4f4c49e94455e4f2400fed16ef99cedccb7c72cc218200e8102b328ff5c5159250219e977ba5eb0e49ed46c3608741502c05d6f990807be102832c89b9ce81c6e839b27d87ae4b8f9ae05d3d14e7b744138b0f50e1fe70c89b17b76a2fae2d9904042bdcd9af281a5a9bc75f5734d0064517da20147e921af8c48710c623863623537a0ea97caef9d3f543e5cd7693dce35c2bfa5e1b89d65b4dfe3baf9530d065587cf892c31b54c98a56b0a73e92c9daea73235791f965e8e15d6366180e77069464451adcc5216c1f7d664069272c1f716f7775fe98d29f311e495e23631c2d5356e86869fa23c2c0f407dbeee1643ffd0cc735d925968698bec40c6f2e57e39ec52cf4da7b1d2f0901199f736687c26dffdb3ac0fd92d03e5798e43f98afd2b1159a8beace2051d2864487e9c8058abf5e41f4793afa18a12fd82da88e2d1da1e64a614f5bbd0b96cb6f74d994a61a5d5dc50991216e48393f7b9c5bc252a60b93c4ceb6064f48242155c0e5a3404213422ba3decea04da02810469b73808c60d5808fb84188cd7531f81a6f8a3c3fd945c958352b9f09e1b1dcbbb0850d48efd0ae92b3783884029e7f8f39093855b2b99a7e6e35208a5b41f49bab184f28be2ab5d8762b6bdf0960121580febdd927970d61112a391cfbd3ac5ec0effad5991008aee36baaece5952749cca15a623872c95922c897ccf7c6fb4239d8031da152e2309b4534eff39b4cbd07f1243b6359233d226f34caa433fbf7bf198df2d670702b540cb71ce490fdc9525a443d3f7138e926f8079324c5fd8edf0d626ed1e1c5317ba9f336c64ce5551f5dcb084bbffc6f29f3be292e858df1f58ab3450737271f3691c6c22eda65d16696e4802c1fcb59efb5ef028ec1d7eea162e662297e3ded15434202c9e238c6f522a3ede28629b1f304a0ddfa0096ff2d3e2140f92f2b87d937b14db4ccff71119a08c22eb8aadc57445c0de5d6f25cc0e5565afcc034ecdf7a067ed36cf7de973d8360ffe4ac0a774dc0639e10512cc1fa2b9d6b8b3dc3044e829d6dfecf266df657a34b5644ae2c0b4d5a2923e34ad390535a73cab0f404b4e507e63ba1bc730223077166638cf66d6abd48335a69b6ebc16e0aa421a266c2a7ceed6dd1b614531ffcf48ba7e9a0c654a62bb7c16b54fe46fb07e2c87e0043ea0d69277602fde3d3abefc51c56b35d73967a5842c3dedeee4476716deb7f2b12f26a8f8d0567850a258db4cb1f4727756fe271b4d696febcf28da7fb38c64efd1c27ff46bfe34b69944ceeff300d8ac9731feaa9416bfd614678f84a85e234fb7b0649fd05db0276ab8ea14e8544f4d87466da191cd4387844a3c390105e22ed1acdbfb208ff8a5a89460b44ed5f0e96ae0c8c6f9f5fb61883ac472cf1528ebcfceec007bf3ca47357f3d00b0452bdf5c6ccc874f10a4793003fc7b088ad8f08dbe426ef7d4500c12b06e7aa2a21bfeb610fb3814f508293910d246af9452a6f7f188f6c011874fd03f895305b0ebd8d665b2cb7c805538121bcd646daf1db6c709ae68f4370eacf7e69635f40fd6470cc99867f2297d7e879a87b7cd1bac92d2f4facb225a58117e67872341a6ec7ecf90d1a597a9692b0727822dd678a57c51c40c6f47dc61fa99584ac95e36d0e98b54f5266d7dc940b680cbffdef0efe0916a07d45f32e3649143f11a45d48629d7a3f4c2304af48e03b3799be5e8308dd6ddd637608d04e3ab964dd1c18256e2c37bae416bda0eb448b789e35b27e294bba5220a22ce72289d98636a5679aaaa02e145dcf6df65120fc870f5f91ec3aabef8bbaa1172a9016c5380dfc4592d263d5d47cc1c7be6687f3988ac64adbd93197eaa99be10f8c1e8b9b0fc49b47ef23db6c54fac47089dce689d82ae0ee60e4ee700261b3cb4ea19e38754730ce1dfd3900df2a1171f27235ccefe01c8e3d53d979ca5ff9fd879c6027f26bb24bf12d1027e6d654d73fa6bef9073a539bf766a429a766570fc58647bece2b6bd7f1fa26658eda3bf870e2c68725741940e87cdab842da5749a0bb3d8e9000efc2500f8752497a2dafefbd680c68eab2702d371caca7c749542b919d829a7ef18de340144ad18bad222c64a78ec75ce6e29334a7452da1e94f3168821240478fa56fca81116159681748f7e31e18a4d14af3cbcd377cf652ce973db1fbb713eb7d8a161ac9c9cc5969e96632373c9e045f5b2bb5cd33fd0179abe4972958f39e584548b8eac9e11f423476dade1332962fc8749be06e056e80285069d3c0a3258bbf2a7b18d29e0e407e53593c596af09a55eb61e6763569d5ddf9167789b4129903d2e412835222802352fdf000c84bf69f62ae8e20c702b417c4a5a27ac1174bea8f43dadce3a650b0fe40a0e87070f64b6621e11d58a85711af15b1d85dfbe39fc1606842727065f287dc9d4efce9c191791964d6432d0466f510b6390eccc51d63b8c99c204208420656f16ee74046acf4f1e9cb48fe861942c35706cd7acb80d7f57167d75a548a909e9395db5eb435f8882d3be54c296a342b628913d885dafbe45509b37a25b17eaf493443053f3c7a265f87b7218652a1fbde1d2d963b70f027bcc446419e9a88b3427fe8e1725bc034bf34b307f23a59eb45e243918fe15deec6f0c996d2aa2b87ee229b287376b8b65c557d69f2c3191cab682662ba43fdc156e76aa66d5b1a21cff8bbf00310fd93e0317f784386d260a72162cc3cab10056e0c101647268b519024a72b2b8f7d34dc0af7acac9f3a32e38998fcdc6442c86516f5d25e07310fde138086a32e74c1908689a73f9d4938aab94f98d640116a49774cd17c43f78f6ec1e28bea724630df7deec0f222dfe9e85efc4a46d945ac8bfd9fd56ecda00787720b44e82d75446e1c78402ca37be9af891c9afc76921e8515774e3a7292694530bedb76a3aad66da2ec424ee4e94745574e3e0fb14c732aface24b04eff38afc7da3832e2ed0db1fd05019fe4ec2eb0889e07a36a8b8589283f40fae83e7eb3ccd7d42ed943a76f95bdfa4e34cfa5b2e2adf0ed0949a0cd225e905d6d2dad2c237a4cf1e28e6dae4974007d608084fd37c0e52855c62ba97ec593f9baa5e855de570664eae6997fa7f31013c42ccc6917eee077146eaf09f055439ebae0c5ea4da6a1a8f8373040d7ae68b09641d62439897e8a345500e4de2d2799e6dba8f306420e52596bb80256fa811612991c061aca9b5f195ecb8b6bf66b7ab667e56ea0df0625f68484f6493cc3d94ae5f4ae52a76f97de896aa0c9104f963e1fc920a6ff64c61bd3ae33af6fe3fa285cbcf3dd23f3971769ff66ec18f654d18a7f6d3b9ad99c697e1e11af4c3fc2b6415c47825164552dde98280b49267345e54796556d3e4efc232426328d2c538e34bb3b6dc56dc14e0fcf20c2808437fca6ab31e441d3993dcffc43a97a0c7f9170a944b0d72f412cd4823f8db32d44a92797ee3a637b384e4f376cd5adc3d1a17f9d91563a76a9fff307cd3a83df5c21566f7932062adecc575c5d1f310ff581b18d9083653d7af1cf47f96951ef02b3fda56390e0a402a0b6cc6a8806a1c8543b7ad0f400de0e6e56a19edad73edc433713c865adb916c195d174a92dfa2ed6349ae64c5e6616e00b338c797a49084281d9a280e765a3df30f827ee0cd83744e7719bd01293e331ad013c403cbc7909f8b198a66bfc5154245fb491cb531eab055179a67972425145bef8de13f387aaf34b44fd6455c25cb78d109c4c56df37d2e5559855dff91953bc1fcbb15b5201082427c7853a608d8db4f7e5cf0c55b326cb2ccd332e74067c4a0c7383aecb66ef64f6489cc60c68ec1f50b14d9bf083483d203e4cab6f54a1910008e9066b0909424ddf951a59a6f75f35d481cb11067e6d6102c70458a116dbcadfc382ed0ff0132968dcfaa3e7566d8a44e99926cb8b26a8fc2b2ca9741232e1e90cdec4fdfa482311b0964c60ad873dfd407cff133544ceb60688d773e9f4b930df7ebbd649c279a222cca02a3d1be251200853b429401c37f2c69b6cc2aa545eed4a1aa7dc713797af386c8f85ae45f01b6867815f7e902aa0ed774a28de00090f11e613518a7faba22df98781fb49bfe73135d042595ce907df802a86ce0f5ab34724746c8b3219f459ea96eb6b04385a97bc43ecf9659dc1e0abb8cca742612653bfbb1acdc18b663776e5264d2ae42af9487497fd00598b58cc493dca41a872dfc7a4ff50fceab458240257c25b3b6b97bbe09c745d49d0bff35d97e46577f11bac98619188fe694bc023cab4813401a88035bb5943727471976fbc200ab2e6cb4014b0886aec509649560c976a6030e50d380803769e7cdc332e20cbc00ba64fceb7bddc2d22a314aaf7153e6e08592e9ae3637ba5a6a0a3741d5a1135096e01b63af770a5c9f2ca0516e114a845f3b3841015cbc82bf658437c81b2b539b0d27ba87ab73e22cfc710828801876ce650aa0468d9abb9019a07b8ca111f4620ffc39c2c3b124dd889d16d9d8c658ede5d63d9d68239b7fc1c05300a5966d6d0035afbeabe9c5ce2c6b6e2b1e30782c51dedff2e184eedef0f79968e8868dad8a4a242bff08a7ef78af4ce71774769277c3ebce576b43704617aa9f39015fa151db55431894751c7394e459ce76d495fa36eb872881bc627e20e5410b5a991b618c9459b24b360a88a3efc385711a69fd7fc4478008321b0652d0b0f7221025591e49d48db31249eba70b7a93507ba9b7f1ebea0fb2e5815421918d2c58829d4ef6e56d85effbbf5f94e80adcb734cbf0c54178a43b5bcc600eb489d9c2d5a3faf66ae29c1ba086c9e532c5881bccc12df6565343a09700c01f247145614fbe02aaffc40aab7bceadec9e75683f44dcf7058477f8d785e16d5907509c90a1cac623a4b3321755f1e9ae73509655d1f1f7fe75e8afce1f8dfb20461dae5e276f72d13869fee303ba13e5a8a7275b1cfadbfe4031a4e4c3bac73673d7b878aa6d730fcd505360f1a40ba150449e44a4114a6948e9d63a7e2f1a09c9da4129f51ef96265758b2a737d7fb4b99dc1e5bab4d4117c719b093e955546dfaacff376e9087f91f3ecf72ae8033654bf3e872a39ab446eee7f12239c4c88a8c1ecdb364075b3aa03449df10ecc2b77a7c25ed57beffe579d9a2b4a46cfece2caa2a8dec1d7170c9b6ce90017f67bb320bfab0c48a2c3e5467d70409607421aabdcaf9f0ea5eb666d7aad16c1ebea4ab8ec8a7d53ac5ef287290ab350765dde587241508b2c794472427898f3926df7ae335aec0196938f07cdc300a9404f924a02293829a83ce9c4840660910491cca62bbcedc400d4f4445ef4827ccc88952b770b681475131f49c0592129f22860de553eb2cedcf16ffef28b2f07e4761c1d6985af9317c44808b393276b03d817528da200f4974315843905005938e7241af0fb3f8ef207506c7590945116af5b2543f211cf7bb28837d263e612bd5739f3e548e4c8624b41ad4dcc77016623b1f2811835209f4936a9b9d9dfa6c9341cb42ff63900ff9bd93ebe344ee1e27c2503069a05fddbb14c0cacd38873adcf20f415965c7208d36dbbdff18693da57384cf34bb1ed3437833b170bc1ec5a6bc1b2b1a2e3ab939587ee8f80a18e2d86b92a19037c424dbb32db06c81d8c0f67207bd7d9c092145adf24af450b4f1bf487238f65731f2260f023f788335d83f2b8b9e7c9a09990f60192566e2425cd748d2584431b603f14be0fb56a42a8eaf0d216e33a6f2b33d332b4fe4da9e2499c8d6bd6e7b359503e1ceb38f4081c192b4ab659419e4e374cf09add3de5bb1f38614316c5aebb395a1f4d310b223b70166edbd8b94cce92ef0a3effec975ea54f4367e8a88fc4afd56bcbef1dc35d6c68944ec51d6a7bd2bc803e0c43baab3f0cb0ec5c8f322041d5e6804ea3c3b06bf337be57c9469a6cae013e5e99a8d4fdf0a41b90fa5271b4a3270b798e2b17027d2d74a716439d5eb94e7e64e0e71d20d5ea4571a5da2373cf7778d4e0ff462141a6da9e9938996222a9ee5ff12ba60737587f9d0d0c519ec5e7b8c2c5d08877bc9896ea6e11e1ca828600d55f1f06863715f88a6506f22808edf0a5391f69dc1a316f34d5cc2747cbcdb0cee915522c171636556c3105bc49fba9f77bcd7a18f626aaecb945fa85e390f3e0340fab56eddf88840e8256593527e3d06cc520ac4fe9660170722c41bbc6f640300894ff4b11c465d10bd4636d4afc64e2b6671dad71505b847d1741cb13104105a6257fb2fac55094ffe95650fe8eb07e10d34971514f935706026d40c0f3963f33639730aa75269bbfb2ac110768cea4a892ca8841a651091612bc45e00a57cf72d9ccc9bdacbddb89f072e2abcec4d103f583e4a4c8bf6fc1f4e5bf6d685503dffeff2c8a2768d9bcab633076c77515ce4a120df93062715ea9ff23f6e5b3190eafdc61692a969a377e67d86ef407cf428f8ba2e797a90a140031bc10e1f144762d72b921c7fba3f5897cdfd57b3d26b9fa1cd812f7b5dea4b5dc6e17cad3c70175e5b02da992fecf0b98833f0bb3c44af3e09989f82784044a013518ba6478650fb5e93e6beb0f2a4838c798d9b13296d834a9f271ef3d8f1a7e2383cb144fb088db0f166e93a8bd4faded067c8a895e706dc2b60f16434e6bdcd8c47ae423baa3a647fc907f5d99584001d2b7b95120fb3fa26998b07c81c14288eefa9556f592a519dc10f5fd97096ec51a2634d1bc1e0cbe053ed0e6918b25c58befe5cf21153f0081ee17b9757de226311f3eeec7b54880ad4447800b79b8136f07d4d94e04c1b4882ba8f626826ec71547bbf24d2f5e4841195332abdb65cc981befc0951957907bd1827586ecd9d86eaba38715b5be1682ba15fc33f7b85aba198bdea82ecdd8306391399cf548043ea4958c6cbe9aa6b4de7d0f5e3e062e41771b128cfd1f275be726fdf9514b74ebd04a9e944e1c27a21dc6a16dd87cb1b172f4001f88b20772e1a65d5cbb82bc4866ffc85dfaf92a798840bf6a85b4d7695d7ae5134f50be243f3195ea299e49443b61ab2f2c922f1c4daef6c292d86b130b84bb7f319f0644a18a32f6424284a1246173c2d80c869f732352ce05fea2488592d1d43392eabc3a604b9cf40a1d77d9b57dd98bbb7a1e1bae0f7fb35870d3f9facc8d4633191c3f488f43f178a3d12a94671b9fd50c44ffbc2ccba2cd3aad352ba814e1ac6932f0bdf92564a082451ee9c99a8a3373a528d305c5ae59cf8d05c1f463a79e7b123bbc20f90be9d347a5cfabbf0a6f20e5b13f46fe892ac7678c8a410f328a5b7a4af16c81b595b8843ca33d46805aa55791528db8318745f044145364431e02f1eeb3d890debd00ca9d97ba0bd5048861889a66dac527a25fe73e40e97e01e8fbbc30f75b907370820b7d1860b0301bbf4188df6dd393aa81812121f33cf8f8bce3b69cc3ec4d06b403115751b52e5575d50e383912434d71055a95759dd2e095bdf813323a154caa58222d6455929e58981e4355a9cd91304f6e9ada1ed6048c9b36f8324015f1e50daf0b98a1a34d8c312b4be31e650e61f7030973e9899d6c3ed08db095008a795e9a00411c108f53717c1f9b0d8604afb84f4bcd72e51d96a28a023c08b24858e2e7a22021b237eb0248637b5d75b9f7726827b5567347d1fde55f6f459dafc266f356fbb1a052879f34ec381a1aecf8847e2fce46a064c5d65e198c043712714ae1edd6b8bb9fde979b2b150901cfcb066a79173f1333296e7c857ce429a68c873828773edaedd24718c0c8e7c1b29bd548062b38642bb9a6ffea92fe030f55b5eb101bae14998b5496628140ca765de0f614070019743b030e99a1452b844e49fa257fed4b65bbe009cde8ce913dfbea26a0e28755a15ed5e4f91005aae9fdb39f8de4cef427c4d427207ce24175669d2c7017da3ada01af475416ec80970fa28abc5d38616160030c947aacf4bff9b0ba86e53287eb8fe0fd5fd7497787f9174189e6598b2a03af3f5fb91fbdcbab457e4b97947d595881a6620f85fd9de6f413a3ac6077550bc4be2487cedcd013ad186cfb0a873dde9cd6d5a09f8c0ce3c12274d5db36b6ff73e8962fd5d60ae54eda33d9aab8462b38fc0e6e1af4c9bf87f52204b41b6d3cd19f86d50b2b738e304f61df1eaaddd7839c25004baf4ad504e14f10615a92734bcfda33664d40e9d06cc740684a0e049c78fb89e3587f94e3862e6e783a35c224e727a7661266f8bd648601ecc5e1b2740246db87b160a3990c5b289f6a2da7703e35210b5f27437a20338e942bd0225536e56e0051808c9e5b7c570e0b11e83a4b3ce6899c12508b4635915f5e5746beb6b56c5b6be6cdfe05bdfa952b5ba6cd184a36fb87dff3b8cc4dba3a1df68b3b57e24e34b25d412bc8bc86dff666223e008a5873d65ea3b386bc4174ae84d872dd73106125e34da1e87001cb75237c6f7295df7f3d7d662c7bea7f7b91473b46c8232f0e82d1cc0115ddd1dc9666af13a2d0cced34d35bedc66ffbd1347020a1921323f3a6001f95968f9a9abd0be7b38a1c20139821c560839fa1c66d8f03ab666280eedb7923a5534d762f1c9f6fefc17f36f9fd780260308d95cfbe2d291e269b752e7f7427f90730e0f098fde86e9e3a88a40c8eb2791d81a1ad00a36828eab1929fc3bb6ca8c431fbf0069d6c9d871b75b2a6fac297e453d9d67802df477b3a4445c97d0b375e4133b04b1f7b13272209fdf36b3ad0d21535931e8917266687b2fba971a21ee481495acfae2c52c9902ef4aebc247c0e8f286962313b837e9fe48bdd97ebb94f3a59e98abdce216a0e13049f432ca6fd738b0e6169d37f0f6294dcdabda56f1331ae529c5766179c515d4a13b510abafd236993608d7b50f2cd1f31861441992b20ba2523cdbd729a71850ead927b60c1f353a980ec3ef5cf84656c1ee69e75fb1f8ea9afb5240268533a9a93bd7ca197b5d56053f4f5a90812a30f56800c41ecd02f71ccdbde70cb410dd9c66718167c8aed6f51d9c1211153fc70f125cdd4e9514ae1a3b264ff523082a3c0aad90e7ddf741a39d5337afb4644a42e2370c41727a71cc9d5364dd3938860549da2b6c7ff1f10f8f865cf359633afb99648cbc198b21a0590e9b8805434a035b7d7394ccfc908b2387c492c8b80ae369e49827b6315194f211e6981ec8bc93eda1634982bebfc433ca4f41f43ba30b700ebc67c11d9b6074d9729a28133ad0250ece7c97132c2116c3a0a7e6ee5ffa61149a35fcadc293aa20d4f7580e49c1714e4bbe8908429f8bc0a435e6b57d327f9b31ff71159e2cd5f55d7b999bb8215018f5f4d9fea5ec0e1bf7ca2c0c34ac481915c741b63036e361896d374c65bc3addf763249ac70e806749349adaa393943cfaafa8afe6ae463c743efdcab271baa48e1f8cd6988e00f151296c3dad4f395fa364b97832480e81a85d6d46d88130201da748febc9905f99c12293f87627fef21f7c9daebb2385b71e2294ecaaa0737f63cfceb2e81bf0a8aaa3a0ac201d5fa512611295786a2c51526922ac9b7152fc84759d46da9d847f6719b823a0ae4f87f45c0ca3f17e25023350cd87f3d69dfbe8bca39626cfdf007521c4a91d5cb2b175abe20708fb1a5703cfaed365b548a5dfa90082fd7a90a69566761b4c52ffb104fb0b1d8cc62510643764d2b78b6b950b90aba475ddcbadb78fab775e137bb2815ff9ec30cd061d97db62de620efe4e9077b7fc12db66a8cff125e91fcf0321d3d0bc763dea8676384b87953d53a75e359f035a97f886bf66ef0220499a963ab8fa76bb044a3b1e1f70e4c8ed5cfe58e02068d85f78d9776a7fb522ee8e4ff4fd503ce25f63d12fe802427c0292f66bb4b9b309a05b03c9ff4daa055cab13944b54e75c1710bef7cd20b69573bd1b4558a67345d51be6f497bed86577a0da0882590e20ce77bacd455810585f35abedd55d411622971bea6d764db4a8797bd1ccb45a73da8ca1242503d434dc381757b418805a30316dd752c849b8ae08ad547c949e32caadb8458f3c3c49f0186b19f6af3b09b9273c78ab1126d623e317948b23f444da1ad0be783a626a1288450cdbf99fae7e1d7b661b549a19796f2d2c0bc948a1e40d67e3d4bac1f9b1742e77af6d52390dbc4c16506578b4bf0bcdf394beb5419d39800c340c0a995f508088ea74fdcebfb2750936fd09f8c3759cd9e4d8f8ac3c2b3ded77b6bd9582e6ab08af1387f7cf14e6a7dec92bd834ef8c0e216e81022590d2157a4923ca85d6001a7db781ef9a54e4913b81ddc01af96070e2eb76de1bf58db322779232dc05c68675d670aaec0a5e556d549f2b36d13a9bbab27f0a7418fe421b569b1a0af2bf3cfa7c33f097b1a59dfa5561e35dc27617f207ed895eedfd9cb1eef55a659c99b0d4b56ddfcc571b796e44d243012dae7eb27a1547e1d78fc825687ac1932e422660f278ee835fc4562fcaa5f167f0903df18cc012ae809500761ef96a9c336101c2cdd3f26f02922d9c0a014e8bc1b36589f94a331c2d28e8c6c7391d2cbae8f023e56314c3b3e59d66b96072505677883d8de0cf2a05637dca5c066610a313555590bf9c8ab3c2f11901a2ecb2a8a558ff046357780cfa78b013282a81d776d94839c3e1703bcda35edec6841232bcfdc58de517c442fe3d2ac7adc900a900bf6cc0a0a2e4b795b6f7d55569128a612e946b04f069bdc3926daf6d49a19d68aa52c642528589cebbb808ce20bbccc10bbc69b27d96a7f2ce9cf98e09bf8ab9b9e05e3799d31729d9c00da64e0a62dc27bdf83747ab8651c08d4b1fe359f6978f4f4503f27a3f97dd99cda5e1babf1a822ab0e876b433eef733f8d7ecc625113c0f8475ffb04004a2f9d8f2af36a24f346d20e09d25585d29a15c081a7ea98bc5cbf9d7d462710e842e39abc209fc7d714f2ac404817b05b3e53bdcf09d7e510a3e7cc63e6001de7fa3113f3256839fb390fb5e50f3454b02dca0386f3dc3372c9d23beea6bb4bbfeeb221321aca7e1ca1cfc3b1fb39f93e64c0b6f4af8749c743d6b98ac1137c71d84db481a7fd26da733d6062e40428a01cd46012b3f06778f893bbb995c4dfa6f1c4a4fef518db78be2102aa95195f1a98887b56320e54bc013bbd1ccd1c379670ddf2c0db6f58508a77c59fa9bbdfebdc5cadd5f58f90f485cb6d04b264564ccf3ebafff212e1672fe6153275f27b4ec085808d0ca04a752f94d3737f196701f69a831afd86c88c5ddddcd661070a29ed45d5bca54efb48ddd4033e91131b6720f80d2945ee93e0f54e27b4504bdbf1743c64d10abf25412a1eee2ae220b17faaa29c973d2c70626a6f0b9d1af7a2a7817d632fa44eb29139cf99a6abb157b0f2e7765ab7dd3c443d1436b767d87ea2ac34891e4c86a0224320bbdf5d5b93d89d846bc56c155ea8036dccfcba26049fce2eaecc418091cd7ff06364f8f6ceaa53196201d6d5cdf0b56cb08b263ad648b97ff1f42645098fce091b74deb9281b9377af83f63f37acf39fff67fe37d2087b8c243f80f7d02d0cbc8be0fa27f0c3af1d395f9f55f6926160dce07e2ab59ad5331369d76f02ab4c959f60baa97a672da36e767805d34e011734b204f52a1b6ce02da85ef7e011224220318bbd012d2ec6bfe7741f8a572e3126918b8584471d63369d3fbc91aa30130bc8fcf1adbbbf04568e69982b65557557bf9a05aa4432cfad1f4ce4c876ddf318c8b4308d67b5cd85f3097fac8333460c95d5617ac8f44d9e3cd6d47ddfefe6705a04555f49040f28132c625c426c61cf99dcb9b5d92b22eeadc5095801b75a0361addaf7ae0dadf82f768696b411d44ec716c0e00faa41bf3f5f9007e08018304b231bf14d8e618801444fc2feef254aeaf501e34b2df5bd46f6cc4847a843f14a03d41659f9afbbc2a716dfbcd690f1112f749611a9b6d9ecc44021bf8c3a6343338f07f5eca151497ea913ba8b942afda785287e675caf51abdd93fc448b752b44d455e70178007fe06748a1c29c6990c940c5fc0842baf05cf60e63ceea6507aa95f24d27607a6f715e39f73cbea48709f02ee3b4b098538b197f0936088a118c8796194529ab30c64184f846d081c602a4d6d8ea330599473ea025206dded33872f5e7c585b3c71c3f414aa9c4d2ffc4de8853502f55814dbf8f9975fd655f81200e2e992cbc0eaf954b64949cf46a8db9c681a404599c7bd1ff5e68ffd58cd3a67cfd6dc441787c9d250abb2e48a35f03ddd286d3d0c6e9bd6cb8db5164dccd9f30d1a543f5d4a74b3aab851b0f0242684464cf949c3a5e3d0bf61796ad6e081e6d0c7c773ba222c722e88cd79c323a416a940a9a2a593994eee348d9331b8adae96bae38fa9c98d0b2920ff4e29ba4bbc59682275aecd95a2745f37a323f735cf999297de01f877007f02075c8f3ba68a4dd0eed36b4591ab557309a9645a064214d68cf0fdbc078c268bc1245c99cac2b06b6b69268f378b9981015c573972e8e8b6e0b3ba24f8dec61c483bdbd9ebf74272e156c12225a57d43e6bd468b071998eb2cccad670f85daba34f0316f06a63889849fe06d5908d0090230e58fee6aa4281701ba0bfd4032b4a13c9cc0f648f005eea12ae8b92079def43d68f80ea28e2a0564b7c8bc5ff3f00b06c2911e46efef311b535fa767f39ba1aafc81872cb5a9f06f036783f6bd0d29a6cce0f2c872cc1ffc17031e68b153d8bb2157621f474f977e38e4ef6df528ab8e860e518ffc9dd1434a3ed7dbce98ba09c09d65b8cf4785e65d3a3bc42a3ae05914130b895dcfea870f69c456bfb9888b91bc7b4a219fc8a5c52062f7dcba3b2e0959a7582f499f183b9c2f3ebf39dba00d7cbb4b6b1764aa4bd77f861c4bdb149241e57fd38ea74a45d73821a769ae3044455537d97714f3af0f5bbbc040511289df239f6f19b429288cf0c67ea81caa91bff1894b07b7f8a08ec1d08b1140e352d101ec66a82d53de934ab14f601455ccfc76e764d0642bbbdf77f0fac117e8d7b3c68d197b2584cbae277bb7eae166d8abc29e036e9829441510cea79ee178b7f723c597cee887504aa8408269d10ae33d0bb898864f1e0c8110e6b99c2230db289bdb3713cee6d257c6af2ce00a32be94d4fa77d73213984903ee52f26577437e94416f912e6e28b81042a63bb4325b9d36159fa007ec0a665f618599d7222b06db61d2e57cc421da4ede22d044361722c23d2768116540db610d29bf7889f5153deb04571454896eb7b1685e25cd43037e1f2ba4bda0b7e01fba5664cafbbaa06c3ff500a7dc</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>面试篇</category>
        <category>基本功</category>
      </categories>
      <tags>
        <tag>面试之道</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试之道-设计模式</title>
    <url>/2021/12/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="5f1b6e9c86bf80b7b92c296e613f8f9dd79609e29f27415903b18d116942817b">227b2a181666066aebdadda3a2b5e6f5b1a3e3f3bd459b0158117c6d08d90c8e5c2d57f4cf69816d7f9f12f8e92fb163fab1be13f1307730dc63d9ff67193d5ef563cd1c3d9e1c5f85f6e80d1d6c135c412f9648967f3df9f6483e4fea385f558b1b5dad141651b37e579456ff05a583d9eab3b6bec4272eabd5cf3734d9d9225f5723cc2e7e49c16bff2b6fb472a2f7a06ccd894051c0994de481522c83f5ac162ab19f9ac37549a24ab65d19f0a240d8627ab86356224af9b08100a975f76119f293b45c6699b4e9b02dbe3717d3307b6edb2d1eacc0cb3beb4b6ce1b31c2c88fe6a55453ae6daf62674c394977fb165597691748a7504a4e365c8910158a1e2951359b276767306faa7da8fcee5fea789865906af8c73618238eafb7407842a18a8038133648a1d5f48988e8f26d4170a4e6259b29e174a0d959387616d8a8d1005287498e6e4504fd55df245173d23cadbff189bf776e98f3d145297268e9f8acca144d2e1e03c2fe60b357cbb0982c3d03606630c0862361a5e8b83b3532b54499a9aafbe83869d8bf0f7cf197a157c81eb80eb6a0e467d93847099829700e7d7654111161de8345c463d15c68527c94aa44eb23f25d735905422020324df54cf0451af276f5dc2fe140c426914d92aa5bb56418702365287269b5cfcafce60bef40a9c227e32eec5a15501f99852e8c6378631943b90619b879bd118127d112ec4d5e49bb04b6720b13ac5a97b8416d0db28993743ac098a2f2a9ce293c833a37ca278d4b9e8dca4a408b506d82b39d7a030b4941df4d86a2eb6d591451c31d2b94d4324621ec8e73a757c805d9134c776ddb33e420a7439f9a8436be6881b678f8284253c38f461036325308f04c8b7a7184b83c07da26fa135780ce44a13aa96b5aa028242da8e3aa6df008e2cfcc2f52d4465848d4268a4e3028b044a30f53d602629ea630d8bbffaadd3cd613b2869aac8e8cf702953707b85af7a20f3d55a5c520cef7a0db2644aa0ca712acbb99f1537f86001119409b81375ec62c11e6a02d8e71210b1d16d51a16dc5e282fe30542799dfa4825c51559a136dbc1f05d3a4fa2ddcf3fdbf48b767326bb2d624fe824d1e63d389dbe37ecebc1977654bdf9c392aee1c6ed13213a2d678171a354dc6fcff15d4badcc476a19633a74c437e2576e35ed536cd08510c69bd11ce9f866a25dbe4b41f2d392659c9924c5b4087547a8acf1a2d22609ddd6e6f</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>面试篇</category>
        <category>基本功</category>
      </categories>
      <tags>
        <tag>面试之道</tag>
      </tags>
  </entry>
  <entry>
    <title>各种第三方库和有用的网站</title>
    <url>/2021/10/26/%E5%90%84%E7%A7%8D%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/</url>
    <content><![CDATA[<ul>
<li><p>神奇的插件 tabnine (ai 之功效)</p>
</li>
<li><p>创建各种随机的 id: <a href="https://www.npmjs.com/package/uuid">uuid</a></p>
</li>
<li><p>临时 email(temporary email): <a href="https://temp-mail.org/en?__cf_chl_captcha_tk__=pmd_3sqozgesOjiYQawAofglAq5i.BE_BIbQ82jvwb2nUWE-1635683915-0-gqNtZGzNAyWjcnBszQdR">temp-mail</a><br>(方便测试邮箱登录、修改密码等功能)</p>
</li>
<li><p>免费实现用户认证 firebase：<a href="https://console.firebase.google.com/">firebase</a></p>
</li>
<li><p>在 react 中使用方便的 icon：<a href="https://fontawesome.com/v5.15/how-to-use/on-the-web/using-with/react">fontawesome</a> (当然，antd 里也提供了一些 icon)</p>
</li>
<li><p>提供假的数据<a href="https://reqres.in/api/users">fake Api</a></p>
</li>
<li><p>方便接口的 <code>url</code> 传入参数： <a href="https://www.cnblogs.com/jin-zhe/p/10049876.html">qs</a></p>
</li>
<li><p>字体下载网站： <a href="https://www.fonts.net.cn/fonts-zh-1.html">fonts</a></p>
</li>
</ul>
<figure class="highlight openscad"><table><tr><td class="code"><pre><code class="hljs openscad">例如：<br><span class="hljs-built_in">import</span> qs from <span class="hljs-string">&quot;qs&quot;</span>;<br><span class="hljs-built_in">let</span> obj = &#123;<br>  name: <span class="hljs-string">&quot;shuai&quot;</span>,<br>  age: <span class="hljs-string">&quot;21&quot;</span>,<br>  sex: <span class="hljs-string">&quot;man&quot;</span><br>&#125;;<br><br><span class="hljs-built_in">let</span> <span class="hljs-built_in">str</span> = qs.stringify(obj);<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;str&quot;</span>, <span class="hljs-built_in">str</span>);   <span class="hljs-comment">// name=shuai&amp;age=21&amp;sex=man</span><br><br></code></pre></td></tr></table></figure>

<ul>
<li><p>处理时间格式的库：<a href="https://www.npmjs.com/package/dayjs">dayjs</a></p>
</li>
<li><p>react 错误边界库：<a href="https://github.com/bvaughn/react-error-boundary">react-error-boundary</a></p>
</li>
<li><p>react 头部标题控制：<a href="https://github.com/nfl/react-helmet">react-helmet</a></p>
</li>
<li><p>查找 react 中无限渲染的原因的库：<a href="https://github.com/welldone-software/why-did-you-render">why-did-you-render</a></p>
</li>
<li><p>获取免费的图片: <a href="https://unsplash.com/">unsplash</a></p>
</li>
<li><p>获取 icon 的网站: <a href="https://fontawesome.com/">font awesome</a> (这个网站有免费的 icon，然后下载它放在自己项目文件里就可以直接使用了…)</p>
</li>
<li><p>实现语言国际化 <a href="https://react.i18next.com/">i18n</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>好用工具篇</category>
      </categories>
      <tags>
        <tag>奇淫技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在html文件里快速加载js代码</title>
    <url>/2021/11/09/%E5%A6%82%E4%BD%95%E5%9C%A8html%E6%96%87%E4%BB%B6%E9%87%8C%E5%BF%AB%E9%80%9F%E5%8A%A0%E8%BD%BDjs%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="0fd9f2c5a8b64e092d4421864a8c8e40b859630a8945587d2cad58af0fb84c91">227b2a181666066aebdadda3a2b5e6f533f8a07cd85867ca602e77f179370000a6001093222e5810201ed20d3d24666fef8a7f0200220fadd819e291028a7aa316f404676651ab690fc1e8cfddf54cef1742f698a0099ab4a682000e38dedbf9dc4bbeb6db6eece38c38c7869c81b631e677c3d39eb80b2acc71a8ba9b6ee408c53932e4465078ad3bfe99ba34f3c723e0e0bde33b8d18677369e4c2655febe59dbba14c180127b14e34cc7bd33936ffc613f7c70964afd8d8849f0c9835c96cde8e7984c52f4a1d60b2b118a4f4a47b18f15de5c2213b8b0e286e6a5427644f61a270e15fe5cf2830ae729efe140cacf4f7e3f7e00cd2f705ec3f4cdf4b53cba2104e4db18b5c2662c30636e7156761592f686786916b0ab2507d33b02fd5922bb866f5196f2969811791bda5985bd58cc101bd47f8f187fa80b5bd37cd8881d9b1fe3188af8ae935b255eeb1e2a2a1e02ff50c32b85b2641452f954fcee4fa8b49e3f66aa3bfb0ec85be864859db90a7a37217f7260cb4007e3e164e122f1bc8a9654ef5dc7a0cc99e8781d7934f41b4773d00673e2665451f0a2c191ae14d307a76472dab7604e3c01740bc82fe8421c9c3041bc5d351a4db0669f467ae55a5e1d527b7e8ac48bda4bdb3433420bdeb5fce634cb9eda1b35a553f8fb8016fef26e56f9d3d8fdd7b89eaca73f6ea7c7339030cd1a88dd0b16fe36b6aa713e0794ff19a490a85807545bf45c5015183aebaf836e3ee3b2db88452a6e4c1e4bb8304906fe011bbc9699cedd6edd54c1d1ad49dd726c1d23db8f2fd410474dc5428d5fce3110bc5914fef72dcc652def233148538a4f3ed7c8f0ce416eb7145ccde7fafd821b3cfd156bdd510ffa9664f94ae2dcae17cc66cc4d2509e50c3232b5c0ea8d05b20363a35010815cc17054dabf11922ad2a8cc3ff098739908ea8b2b90556abc589409d2072b92e002ec8ca497cc4a985a62c14246d42e7ff14e7ba42253187ed35fa7db7b55eb225d2b702bbf77111a44a57a639371568dde6bf720b1c16dd993cdaa05fb7dd59a10c1d753f4965749c518f82a8f6346449ef1be6d41e3c45cdacfb1d4589c20240c253d69b67fb8e8996a090529d2d50dc900e16da4bb7afaf14d0864ad443013a675bb5fcc2f947d8a04d4b2bc6b82c35fe9d263288e022c13ffe97b1694c406e8b91bdac8fdc9c600bb3a6f17ff5fa6fcf60171c48e8ea845fed74c957e8cfe69a95f4afdd08e81148b9fb10e3fc2183246675f015258fd163c528723c734ef83d45490857ffeee242ca9df46adc66f0ded805be82ab1723cea871dba1ab176af79d3087224f6b0195d3c3d049d430cb3b184aee1c702f271910275ed52c85a88d98ad2aea6e8a37188f0822a1d5406a35cdfde79d4734fd7ded7caab99e726f00e0eb3fc59695fc91d0e00ea118242827af0add3fb45427ea3b05ba743579fcc579e40e52848f704103496692879b1eac8f4782c3826b6e5cdabf8d561e2187e5f7fa3768f960ec75a83528885c89aa505c99a78f6f237ad2b4313a78297bb7f554a704843fdc18f217ad598005613c80ab29fb92dfafceec7c4aad379435a63795eb08c156c537c8b89ed6b92f49de86b3af62bef42f74bb0967725e502f9e6ef49f03e5a0c5969cb2a991d4218af00098bcaba9a9f21f87bf3290238c22c9c70f0c3f038f65571d3bf45e4043baf21509bfaa26b2976b88778f32299ba461baa6aaa816b0e17ee996e11e8aa34c1252845b6b07f8cbe9527c7ed4e3e0f35e38488d4448fc4c7edb74193a87c9aa41f5ac2c0cc8c720332a73cf7188068158cf0527a019b158a83e35f2a9f5108931d0b4c7a50ca896c087b598007cbfb26453cc34b009ed80b10a06fa70ef750c3c9a9b1f4bbd39b7c0cbbd910668fcc01820aa9141ce225c6b7bb30c5a54394268aa7ad2c27d8ab8e1bafa8709de4f56e1efc4afb1e4bda2649602b7bc72e8ec97d75a90780e9395e4558226035ad03707a63c51209db52bf840dec8b9ccc94503f343054d46b4ad678d4e77d99fcfb320a0b17ce06e69ce19f16c60e713a76d1576fd5e797b23156abe8361a1b144e0515ea0a5e00fed5e5f01f1ab5236ba5c0bd7d63a52c9d3847b625edc9e59889a727fd533edad18a886c8657492ca52e6d1928c141cca5ec8cc65d4110f29ccc8a951f05722e1a728ed04ce3f806e715ae94a7d82977cb8bc899b20bca61be3a6fe8950b9ec7dc943410cb425dc26e548c0bf7aaa69f4619524ca0da9b54ac7192f6b609f5cd3cb8f7f6a4376ac7f46b4ce00d18eef374a9a55cbf6d2e6f31e72ed0b9ee77ae1d444c244a29d99d6e789ba7bd4670136c976ff1dea2f5d0449943b81ec1f23a95dc393e512a094001fe96bf672283eb05544846a5caf308f11e03d3629e381d4c7a2154390932128f849f2cbc30c2aea3bf81c32fbfc63d2bdf9b6c93830a7ed6e5076f1e7621652f7a60ff2fd734cea738dc2d9aedabce59d2d9de69843de28f488fefadfe5dc15a5f5a9611a7a74b9b8c86fd4171110bb604474f0b5526aefd464bb4ded6617406018d5b580cc7f3d5457409eb92d12bc3503f99f194c510039fff92ecb37cb91a12623c06554df8cb3b61e5b72d15853c42acc47b531ae3258fa9f436ed19804212cbcbbf7a5d00ea8cfb73f6d79240eff71be1a04c3416f9f5dde08127dffd08f5177d440adf84d9276a5ece1cacff366fa72e85a0a153b4362ab3b11c43ded378d7786671adf4c99e2f65e967b0cf61c3ac0c908325bf57c53d3b4749f9ef79cebdf64fa59f3e7d198624b3a884c4686bfd11e989ab46d6a3a8f996ecfc34fcc73bb47a35c7bc1c8a4206071a3a540f497c1ed3b8f256b5f26f9982f0eed5cd321f0488f6e7526a8a89cef5c5a8ffc9f0f95e1c9146b9f8fb380a6ba1a5aef974f55e73e73dbcb31b8fc284e615fbf1d0710a6594120efee14dbc95428687b1af71a3eb06df12d0165a5f826a842043aea2842b4e3145ec47c5b65c6476fc20937beed08ffa90f55f4fd1f65a17fa5d2f8e31119da3ce715fcd1356fd480754e62ef61a564221a7bb59bf6025f32ad7545ae7a9c4df0466a610f4fb56046d4ae3a7bb4445be4d15bd417948d2c34ec3a93bd75c04a84eafb9ad0fb5de2814351a22eaba93dd645239c9754c85e1ca4e31f34e71b4bb2342e6835656f705920aad5dc6de9e1e5ce229d7e88be6a498467f4f6ce8fa01fee98fcca7838dc907cd3d615ca51a25d6d6f9103b0525130148017eadda84547f3510687ca199c3ac085ed85d735cfdeae194baa1eba03a0393cc7ddb1e5dbe59b5b0529d95b5117c80dff22b3eeca84190236ec9f2c4950fa8a9e4afd754558845266e35c5cdea314ad72ec5dd40222471d468a4b947dac55119b5da7ac99f77361db72b9622297359feb04de8ca5e81438248988191fca4fd122e73be73c59ce517ecd1a5c4be16dc71d4186676b47830ad7f826e43677a63ba9e1d075eeb8d7e84afa8b8bc99d7b0ee60277c61d70eb5584c7b9548fc45212158b0a148092c58a5f9d50336c8d1a944d36b2980628a365543d7172703e2797ad9b9e7226f88a377f2baad277c95ac4518b2d8b7d6d8e11887eec12893ba65b9a3cd4376b5b2ee7feeba29afb574efe574a2d4af849a8520f9da2101e15ee7a2518125eb6a91dffd0fab918f324d2553efe475533368552c6e761df4ef488422ef0d8717298579ec9b240ca19ba6522a00b21baf047c8e5af2fd9343ab73d9af7b7a2fe3ad2482def84737bbae5b31e2c7afe282916ce1fb122f9defd20f9c3004864734577885438321aa2e5c245fa9976d8f2eaedd3db647a564b2149c920d191fac40c3e6cbfbdb957be7025486a0fbfd5dd84fd3bf13490b7d4b1b639339aba6956bc7672e11adeb46269557e4129d8e76b870ad69da4057782f8ed2702ac969189962cbb9a5aaa44b8a8b4bf8b316e21b3932a3702641c1fcc908df0fd674ac1ba091bb71b52af576e2a093021038fa261e57e9d0d6e714a836826ec2e6fb4fea132090a055e2771baa93cd2f6e03611274ecbb09d936766effaa3c85acb39e47a5e7849985980d4349df6405449278a1b6798c9db8a7d780ecbc89c55592690c68e90b193e29b0677b5bb6c0be1dee58725344a2ef48b8a952bcf1d74a64c72ce74c7db2aef81e8858b8c555638dc061ea9300ef53abb6fe9a5520893175b4ba1294419d0b7dd91565cfc4f63b35acd26cd3d527d3c021b526167639a1b7c3113a07390cfe981d1e8c83c523d1e0fe5eaff051f6f2603b211f61476ee2ba0df080da33afc6e1c158c4f31fddea9a45c73a7c31978034e8dae631b005baee54ae574a4c264c4e0f832bc4e5dffd4f00f3bee75a9f05469252cea398afce8e29e7b8d3ea00499df27e166d3ce30d0ad04fbfe5bc0949b0dffb61c058d213e915d526c717b37deb0ca0278f38917c816179a91ec9a532f33560c7ac4265d653825b33d2ced76ad05e4658fdb12042b06d2a2ca234e40b83e43a50857cf1c807f548b7daa8da05110fd293858d00c801b49a5f6b924ed9c57982bcd1d32212905b55253e771c18f941db6dd21ca47e8ca140d68da2f8a9b23ee16b306859a845e17b6e8a462cdb2e3f1f92fa535336cb9e7fed88bad2084947269beade2755cf6f8ca837b954247b8c45f685ed581713b85dcccd7458dd284d3b927eb423fa4f4599078c1065107b740a7c86a14ada9922ad32954b7657044aab96d2709a472f6b673929009d5e6b14799f9d4adefd466d63a8537d59f48f30e1e4e5c139b8aa3884a2780ca381dca48105914f19da724c75e127d591f7d259cbc604579a7e3a923458d177d270ab0499c7f74b774db64b6da86d79e619c27bbbe6291ec58e502d1e19f22fbc2faa3c45cd056e422cbd46dfa756a7aeadb46b18d46cee73696b4a24eb75d8d21d024db2d86c6051f1c133498d98766b4b2069564bbf26c41b381ac02db09a7f5e9cd438bb7ebb7074e2d5743155b322cdb3e7220ecdc71ceb76b5d350eac7f92657a45a3e40e65d0d8c5912678c97cf6238471ab2baf948181241103f05e1c3e365c38eb9fe816e8188decdeda1095e6b867b3822ddf7b0d64b5a7a3ea56ce50760bb719f8f1dbf46dec9f0f97bfd139523593cbc17eb5d03f67b4dcd31bfed15ae965ca076a35660342558221ce0cb05635482a3e9a5227607f601e7cb46af1e987fc3f083f89a265e9a1430bff9880d3040cfcb6ff6baf8edc23067dc5a22b68dd325678f67c6beada038d7b8ace7cda60aca9fdba89e6bc4065f72a6c9aad770a5ffb988bf9ba089a3f4ae6d1d3a9664f560b06163abc6f65604655e340df00043eca8ced5dd00e3bf329a14e415c08e299f7aa2a455cc7528b2d59aed108c20c4526a3c7f9a27ee0335325dfefbf551ee79ac43b906a0844c729dafbc1c287f67020c97972c4196a6b1688360e3e8ee18ac749db42c4367d99e2a93b7a071e4bcc28cdb0afe2b8e7ecd01424b7c2f253d1a894cf018401dbca140e0c42caec9ccf30193035baa34d897a5cec52eb6126d62eecfecddb7b49562538cbf7193a0af4a65759ae6ff950aa56a769834f9cd0281d595d31757fcef1bffc001d859cf794fe31420da110887c1b2eb3c316462545f0beca2fc1329bfc777232b845693f3d44eab487b1ffdb622d357a820537ec422e78b742bd50a0b97595eb8b98b406650f466835c61cd319f6d25b13ed8651ed289b3306456c1ee0aad2117f1447012c5cfd82ac7bc56138b86e5ce180c2377ca72b3eba9264596084b90bbaf8848eabc6a7e537e2d10df5e1b291c4fac1ebed615405bcb5d720d8c7c53cd440e3448f045664349ef9c91ce735cc5b7d0b8416a340b10262a8c4b595ec197fb28eb1975404920b119bce6636f6a7694112e888c8513a8610524d03b2cc354b5e09c584d00a6f412f6309e453d2412898d6e91ade709ac3ff6055d8bb85f77950778a4bd5ac2b2d1d80bd0b1cc68d5d26a7f8bdf913e1c30ccc72d97f377376ca0393d3f86c8aa27bab906a3de6b16d1fbe6a39c9f63ed7ab8464fdd1b6755c4293fa825b486ba4ac25ebd9097751a4d76149eb6217752b3e7d611af9fa5de79f815a2415b5de6221dd8c90a65675b67daeeb730859dd15c531fdb892b69852d5babc57862eb48d5ad3e6cf91da31163ac6a2f10a260d63ee6cd3f053db70a29c7155b9e28b594501105db1a3b23ec3efeab98b7e76a2254d478c9c17c504c8d6d0d592a0c2a5e856d9fa2ab222ec8a105f5fb315df6e06532a933c5f6c697a4339146a2d697d4f8afb103216cba5636734992df6362df3162351b18e127692f7731a8721dbf19c8a7b47dcda18d4297758e29a3a6cfc2de3ddedb08bdea0c82520d296e32afdad8187cf4ef79f0163973f59c6de1d36858315cdeccb5f5cd79eb1959887f9350a4b11efe35c3d7f28743506d4f61c8d52987b5bd2c077345c70321763e57136393704df391b6e6fcfa4842e3a15cd3b40819043182b08f27c5319d5fe476666b46b7ce4d3adb572a0aaf01752b7c082f3c689c327d0e4c084077dfcdea43f402ff401edf805f5fcb7bc1c74666e401e6751b074590f6db5e4e592f2aa72431a43d26c7dca4a9f46e094dbb66cb96152fb750fc14ab26ab65d86b100bf7ac5ee467f803956f5cab23ba8d9d1adab49317b747e9b50cb671e9ad449c368bb43a31b940310f1b92c78195ded64f0e3a2be85f47514f186dcbfbb4d6a9e7064fbf8dc5890fdcbe35a25cb8035d8dc44548c51209b6c34583bf3edd41aee766317d056e300e12ca66cac907e62c912b5364022c7def4efef139e3cd7bb75d3dc89baf779dcb84288a3c7f150729129191e4be7568c969d811e868b93fbad075753b4222c364f2f03fd78dad3f7d1fec8cc4413a165ef642280f7c07bea47b3382ab177b98eebd50dfa293a47e86ba496786e60897a47249570eb822629c8922d17554578c3ff369aa54d72c711d0ceb7a0269f25ae4b10d4c6dab1064d8066c0d3a1e43dc905787c63c9d8f82f8cb4bb2daee498f7a5273b261c2246411fce27209ced84778592f3bcfbede78faccf591132ad7dde75a198114cc91e3639c92a016adecf79eaf2756defbc9ce244294cfad83dca93e010b806d5fee486d57b73cdbccd7285275d299e40a28f23e2601d800ae45ea91ec17bfecd5249801843398f71c0ff67ec38256ff1283c6d28b24d8f75270128e84d2d681a39ca5e81548c663f255aeeee2367cc67d7bcb04d9115d12b51a6318441ca680632b7b16eb22425afcd79b40bd72e0ef110e85eb902235100c4dcbc28ea0814c109238a65d15a63dff6ca418cb6ee745150deeba302dcca0d9698cfec16818f9cd36d814fbf64b8412925ec1858f82a216c303442091ef9bd5a2ec20cd259f2c345f2250cc2bf889229135fc55ab2aa7df084aa7e616cf24f2c87f4ea090c74baa7546fa71a1a93cb07aad079c8e091bef76795486d49d016a698ea46f187b43cad9e21861176b2c46e249951c98a721fd4bfbeaaf8b2b469b60c8c6a0a5fb5e3ab0b2a0b7e9561d24f5acb77a40f055ced4c1c00a08414eb0edf93539f5f45ccf14f965717f2de1a79b5d89fbc611b16e098adfbe795713eda8c2e93db4146bd3ed6f9acb4330d9c1a462bc076af588db1513f69b068c595ec1dfdb58eb488879963b6b80cf64b7a1c292aa5082c838d8b3a2fd84299b5987c78e1bb56b3c72d8d5c02bfd2363ba463ec36f24c3e2d7cfa94d515818f6844dcc24dbc8877f6d7f28858d4255332486366023b85550d86a1c95ba5f6c49db4256d1f6ad6f4ef9e677bbc50e8cb595861b8c185a02e3674b9cb16fe9035ec31d1f5de98587e9f4996fe46a663bb3f37e903851cf788e3dfa6010a4d09438c1a2a693c2c91fb19b4ef6ec4cfe44fa49b1bb17f74d0dfb75680e6767d07ecca70d5a7c2bb278f5fa0f5eb247fbfe4079818a84651db7071583e0aa3d8817b66752a003ac70a23e123f323d9a459fe0f610f7d43565e9ead0646e0c7039bcb12ff7667697d8c0a23cc0796b43c95e27faa3ff132cd73ec67e265cee012d03278f2965a692479f020a6817c9a29ca44603f41b44e9e9ecdaf5cdcb9e3c80abd5dd497ad62b75805d4b9e747078e1e1b413bca7f16eb34fc196829eb9ffe24e5dd748f583f2578a5ffdcb7eea43a4ac19d3426b50fde2783e701f5c45ef067ec742eb7adc84fa9dc19bb14ba3028baab28ac421c1ea1d11463afad954d678aa2b5555e8130aee11a39f3ef455085df07ebe7831cc0a156fc63fe86a0ebe1209e15e65d08f21839081e79fd963e626668a0eafee70db686850f777623a2772c8a230a01211d3fcf298bc0fb84baf4f110ee7b0c55564d6d7eb1421f525b78473bbb745068de7b1dda422e49e6cf4a4ab755d63b4a605ffe1c589bfbe08d513f5899865e08155425c79dbcc190246d1a0b510830ff53e1461a5ef7dc1740aab6d50df63ac1318da68d68fc673d293c32dd4cbf2462c7eef200ad8f479bf0bad9b1fb276bc0563ff4fb036d0809530dd99ed67ca29e55bc0e1f866fc58f79735dd56e8b50cf5526ed99a8c0e8235a8e50e3f73044f29a958408e15c78f8c1c0370db017a9ca070529325bdfc98bbd06e6c783b840830049b86cca400df7fffe92bca290cd08e8806c656e65887c8d4f611849eb9108dbac68b2d04c8334d81e46f0a79243f951f43d89ecdb53fb6b3b775fe43e6f64ad85d019b8167d2b8668b78851fd5d854922e7c48ff45d15dc68e01ca4f4ae5a1a0da34b174d40409b10db3ea1b91a16b36b6758efa389bbfce5ac0b6688eea119f261c4659a126ca3c8e1afaf81227a8808df7f1402d4e9c363984e8e555de43efed1af00bb1137f57f1ffaad4992a03d23f44476e6fbe915c5d024a63ddfd34932bf853596c35e0bd24b45d8fba95e7b57e5453692d71cd792da692bae74987b3c60beb40232f705bcc8201d4ad9fca2f6935e5114f7c66510b3fa29feddaa414937db9bc57f44aaaf7d40568ca5deff551688c04ad8f2f19c5743c929338a4e4e967fee0a71cdf243efb6053dae2479ebcda796e1c7598aa564af45b8602d841b18e77005f82512a6832a7f87adbfda5e191335f4c470244c63ac27c70c43d961392e983b3f0fda8469225f58e0c4095841ac493409a1822dcc1a797854671d9942ec40bef7d50bad1f4e0d278324583fdb6fd71449857951b479bcf0518fccdb5add4b940299944898513ab395367acca511a362aefeb80e243bc3420495061c127d8a86e72428bb4bbba1da25c67ede249501a6fa4024a7327d28081d96235aae4a2174820039a7a080ebdd9e445444c7b5277ac0ee6becbb78e5a012463e94700029a4c12b0ad39a9f6c0d94dc0174e931821b81a5efc6a08095527c834c7eafe40e8f40e2ce281ed2564c459a6d80def276afd71d0a8593cf5d2df8df9c33063f9561ec5d6985b05fa94d7f2a63a3eec8c5f2437e0600a40292fe9a8e804314041f2affecfd7c21908314f50358ba06a3e2451e99d1aaddb852ab6468e86da02568935c661c7d7fbcf3d1a8fb8f7544e8e1a5615776339e84c3adc3c5195b0c4da3de9eeb83bcc2fb4721f464be2737f45c3a68b9ff8205060431365cc0b3d73f06d16239527de078e6f2df984561a5663a0d9be1d6c635315e29d9653bce7f53a636357f94d20a954d05d4ceb936652b9f7941bda7e231ae3c299c3fde38c52e4e083167523cd38ef1dc28d7d5014fd9031215f3fc7f47c9096497feaa0217a8ab361f8e6f2ade730f75dea41bfdd40c55966307ec1a4417949921f94174498643e8f9a4dfb8e682e2fb2e93fe745b63ea09567ae7ce4db1ae581aa72cdd06cfbec95184f56b23f256e0a024c898b6e0503d7e9336b7b52e20d9168333677d8e50cc82001be12a7cb90f2810c06ec23beb4693ee4a1243f3aadec04bc25732c988b778a48d08ef8234025c1858decd8837e8e802282d4138d9af239ffa7367217373a615a924ff56f6c2322163ed5c6874218bcb119b128a3469b9a66dc4fc95b71c3f405bd02d21ee2e117b18fc5bf4401cf2efbd7ca984355fa0fbc794d3487914c2b78e2677631e38ec460163279831b77b524cc7efd007f0147e8589c5d779357b1f0685ebb45a3b210b30549cef5ecc0d816c5008654ee83ea99ba8bd27ff1724d4bb99a32150059f5f33c921ffaca78e44220cad4f60f03270d692fbd6b627e7f1c72572c765b7436d82fd46428f3fa24ced768d7dca06a3af9f21def9fe5199f902636376ec95d4651fe9b6b5b40dfac2c64279264728aaacbbecbe9b79ea259e227847d07153c3978559df70b9eb384a6171267d385f1017d9a4424af23a64c7ad8ec1963a22286c68025f4e78f75c725addfa05f7ada097e470629ebce7e84e0ce92398878e97f14e9dbed07cb84053789cc9e0f9764866e74ec7377c07439789639c24b4e3915935edaa830de06c83aa3a36d25d36047c74d887ed08f0d62cbca1a169d35becc176b9307b7fa82ea4ef0ad402b6e4d63c86fea2ad6ef6d098c43b7188e44be24a8ba05dd5b5462e81525c45a94a2a02748e4e07bc9d756b07910d979a9d6f6a1d3a7bce88046930100b5b9eddb4c9a21819f0237c286934f74a7fa019d5e74e5a28fd5b944d1e822584101a4cdc6fade5e39b0f664711016538bf96da3e654d189eb84529b782ce1cdadfc6133f58ff1389ce0120ed9cc126c7e296d7f4b77bf9ddbd0bb45bcd3b9a617a2ff05580a1936bd8baf69549338c0b91cedbf1720373c3e890c92279500d617878495f270f1f39f941315e2a22956de0a10c6119ca30775e6ce4c3956c40719c6ce7d733b9a77214cd85cc1a195e71035339c8522a2cfeaa6259524281485214474f023183419a74e776eb9601191c73a9264ae2db92316d0766cd0c17dd08e6ce10a6351c2ceb8b28beb8f4b015ab7bc2c2da97bafe0d2c2b30eb7c5b4df736f2ec49e695247a13476e60e5c6257d60c6f7c41ebbba4f7c4ab1f39d01ba3da83b4fbccb794df0ea58a5e92637e134ea385cc1568c039e9a63ad4b7c5fefdcce1eb6a141f5e0ad042da4174afcfb75f4af1c729617506e5f9ab1371d61417393cefedd1aaee3b115b3b36c3a5af447ca08ccc44c256fcf0d2f01f2dc5b9a2e543642bb8e78dcd36870b0ec089b96ec1351486fb5049cee355e78ee13ee49a57ad92b5591d30b08da2d1f41a080030807d1569750e79447dd5825285535ad46eaa395c1467bc753e22d2e56594a9903d9f1a03d738b70b558c2f900a2fdd9bb289ceafae03185a5cc46d5c37840798a5f6f0a4dc45891133ae8f3a3b76b638049b337c47766e95d56191567f8fc2429966ef5f536c4f3478f8c9308168bb02fd74174475b73fc20aa3431d88082d38aef92ff6a59fe8354bee0be40840b1c4748d76596121b3a5ebeb6644ec1c8d36412826b6de77daca17c804d8a0635811d1d7c8268ad23512a5ab3d3ef7845b4709ab581f6ddde4094e8ddf1ec90ca673e4cc006e6f5f49301c8b018b4cb009a89fac3c955fc75a74caa2e392b250f5e5af5a4ffe5b076c637525d4fdaadef5340b94b195e4f17ef84e913f5b0870665b5b8da187817686489aa2e6e3ad2a70b5754aeab54d1a63e9906a920da4fb97f89c7dc0eabc73569b13f3e0c7d0034c399a2dcd5ff45a2b0ff23561ee0f75034bb00d5833bf815ff6466796b278f62bf2acff5ac0cbc106c77caf9ae1ada4b6152b85f16837b17f89e5ef59920b4cb9ce2cc297e9629e213df240d2cffce19403095e44d7d6ef04cefcec3d85b4503cb7331f28f9b18a705c183f9f517e44eb1b57ee7e03662e9aa172a7655573c08c62246c443219e90509b246a060fd9ebad6d71c7b8f272a8e4e3301bacfc0e25f40f48d69727d5983dd8d189b1f6fdb2c98a3350110a75d34e2b13ef3ed00a0d413f636575947506cf0d98874be37b566b33793a431f7f7c2b558d118b1878e02ecb13a6b87f1d15c5fc5ea9cda36a9f0040d7b9a76af747336099d1d69bf3b630f1fef6dc0fe4e92b3240396d37b6d484d4093df243707dd7c5c739a856679453fa6d7b04af2811830e73061ce860dcd4ebe46585f0365efd2f284caf0120087eb145481e447b4443dedf9cb4f71ab7d8958ee659b0f33a6214e54aed75b44712942ec5b2dff13bc3db6adb1c55c02bb4a50dd4bc8c997d8e6a80e8034bbefe9eb408094f4ed57bddd51e124614b02119bed311a05b4688378365e297686b2699bd6872a60271bed5a646990132759ec9ab8e1b723d7d4abc80543a81de06f65343d4a2ead6dbb22088680f9ea24d31665c5c6e35fbc51db4c3208b96fc3765ea37f9773e31ba140645f9b92651cd2739467461bfb4cce41ca871cbb6bc2540d68af6cc2ff0aa83fb195490a2ed1dd3931f52b9d01ffb4ff5d770c42e04fd42d65e5f811d750fed80bbf7fe52cc78a80fc2b23f68fb3c6ba93426679aa345231af8ce2c6349d1438d770132d4cdab8702f4bfd657d876ffce11412b83d307a1544099b95df43dc84003dd0d0d0c9fb22e2c5d153103c68687f1df9351a83d78cde9030d0d26ca3ad9af7cebbdeb89b562c65e46a61a4dbc79be2e411c2b1bd36004bedbd681d368d020264e4e80f0d0e0cb63e1c45c54e8b98f17d3bf83d7f1e8a0b8bf978c1bb0a54ab2cc0111f629466573beb3df1da0b83fbdfe1a46585dcfccae36a1199abc3cae5b6a14251b1abf89343e38eb1d54da87356ec4c913e8bd043dcddcdefd8a6dec074bc8c7a0d2d0bac6f70b86e50556da06d8ef591cc930693d92ca27fdb78349005dfb3a505efb851e89da6c2ee5d7b8fedade34e355bf4a17a76003bc94a70d17ce8a674dd41906a6c3d6900cff5594b554eea9e2a47fdad0ff18dbead2ae9b8ad629d68418e41c330365ffbc044d36cfc700967dc697103a9c503c7d3083ce44a1121f72f0b569d4eb126178d082dabcfdc78e2096f0b0808bcc7ba0560ad1e2339f2e85abcd91da2e9ed40b6f7ed651d55a9d4880b9212fdab5a358e3a2a2f4421ef329feed719e79fd65b067d04a99fe13c0b041b717cc2b2d2eaf4602e616c15cdb3448c59329eb43214d70f5050e8cf9c53e3b6afd1c85c2134e9b0aae47ac0d586c1a7502a62fed66c351a6273747ed42c3551e4594dd4926aadb04b597b21a7a85d8a94cea810154ad9c7430e7ee941fbbbc99a4673ddf2b88b6014be6363f471f61cb8c81cc3771f588484ac669e3e905fcce3084a7d5ce666fed5c6ac2d01f59c22c2cb0ca3c613ab32548a6a9084f074fb40992fcd94994bd4be389c5d944fbaba5fcb076d623d554b3d2f28148bbddcb2794cfbd202c7dcabcabf71b68f8f5b6b6e73c764ddd3d887aacf2d603e0ad10389182f089493d35faec3b217f42ee73c59c04598812a75d6adb352ad702a83d70aa8ece7d063d0f1a1a9808d7f03138c82521f331ab393b8ebe1bda140e6deb499e5337b27ce9519e575d5fe2ee0eea0431cbe09aacc35af378b8cf3d19de0b84f5e881e5ae22d85dc63b8acf341843b23af1ccffcd5eeca8ab847489ef1d8c1639f9809ca06e60de41ff0412a312814a02832fa99052cfbc1b245bf2a4358c2f6a16cc023229fa37aeaa8078cd483b266b3f272124054164db249fc221bacd88d2accfca305ebfcc84b4db08634cbc0a0125b372151ed2d9edb1094db04416360ce32adedc78dfcae605259607cea7795c8921a44a11d51ca24109f5938e3f0fd902ea3fbcd31c2da9bc7859accb7ca27383106dd189f2b3f15e2109c2c66227da2e18222bd133eb6e8fc56dd59810cf1e8d7e1429c73885c96f43f9ad0c419ccefa264997e0b6f902bb8fcafa55a939015735cd55935b76ec521631d8ffa47fcf08777576f1970ccd2126ffa42d403c6a00893b7d4ae16d73af5c2158513bca60c52a583f475424b4779d069c76075c8cc5e994f74d99a9400f1e3615b91ae5ecf016d43ff1b2bf8d1ad73cbfc50ac5465a54462b0e2d25e9e1b66b9584c0be3ed367b01d8a29a00e7e58d6ec5cfcaa9e7f63ba4ad461fe925b4cedd66d6f9d6304c4f50504cf8aec6a50cf073d31b8781412cb7900969074077af03cdd3fb368b675f2eb52dda4ab9618b8aacbf3ebe8812fec1ffcf7df5a019d18be8d7533cea73a889271124cad8ca25cf182d457baae7130ccb244496a5585ad57b0f6b4801cb523303a60bb9ef05334f08d0a4ad431a2876d79daa3fe61b6571a5f94b166672e18095235d10d454946b1d9fd494ad24406aa9f9e43415a44a979a3ba95e3719250c952d67b58328b68cd3966dc835fda21c1d3c85d323d0eb1da3e5f1428a17118274af862f1e43736275806d0cac42e7a1ee190cea7e690dd35a491656fdc87884fb62820e418bb101241e78ed2e9ceb806b849407cbf0cf44b19aa9faf4f405d3d9e6c9dd5f6625ca10d3d295dc772c627e68f9539838dcc0d606d5a3d7c4fa65430bfdb98e53fc18b6ef31f51080d9837cc5f245dff1de5e9861c3946a080ae98a7b450275db76f38898f1109abc505fdec42c8dfd3a21d5593273c79ebf897d174e9946143919d415d30379ff4ae7beac3e3fab0a6d4108ba9c8324478108b0ec3a148dee5ba6fb2dc10660e152d6f4225a91fb97dcb9314a014af455afc39e4aa5afee8bf861a3dbfd9a116f8912bad6961c10963420b1952939bda8b177b1b0ddcc881d4d6ee9c611386bb5198e2d53d839bed396260bab0e3d880446ba7b6ac8e964eaab8ab80d74a358a72235fc7d2d192db5f44040b58889d46dac79c3e77cb6bc1e7c708af81a7926f5474588594dc21244fd4e35ab7d66b457a2ff626ba1c6be64ee9e899b62e3323015b20b93c448d05bd25b76cb273a544507599ea4c452919f5b5e70643bfca8dc584757c89b839fc63202e6598f1ba8bec6ae95dfa76beab9028a3f916e96519d9f479179c7d818b9e600c0d4aa329f7e9a8a67f965b5e034ac9fd70985d2910e9cd05707a262e9e217da02b2f30363cc0ace3d0d7601cb71c8e9f439c3edef1133d45b99d35d9c3c6710ba2699e10ae76191ebfa5a37824d5fd6e7b80404c8d8caa989064e9debce7e26df97928ddc3e8da6dfa230a4369829c9cdf2933ab50d9886926d02ac11d9e8ce8e785d818802fab5c0772f4e2c42b893058b53ef0ec26664f2c4218504525c02f6c0a7c4adeb8c133f57fa2fded8bda030838fca9c073e1dfd86d95045765d6ad0f4b9a5c9ff979f63e25bee72c80ca55838a0ea1fa7abfa7268c6228335ba5e491f79c8a7bcf8e664cac65731b41335951a6ba518a1168c0471f8fc0625dc69bccaabc8c058774576f7bc64af443d836f22b424fd3969f4db97219eb804f1b93778e0ec8c2ad95ed2ad557cf20d3afda645be945457730b199f0ae52d9f906177ee32fcfa9382c03fc6886b550702d2cb5525a1f828b6bf74e9f8786e5a89c323737338f7db3d7e068823a4cbcba3e56cf79fa2cd93ad93f1ad0495cf8cfacf1e5b40c407b373bbec81b65d63176c57e236ebd340b504adad4bec917fb28393a953fd93e9f8173849b0034f974fb280173dcdc6f08fddf92f236a32bd95a5faf73a0a9639e860f185d6b00a6662525900bc4364117ab011fb4dd90f1a2101c3bce0f4bf34ab6e7163849c3677a309d3d895fd44cf34ae538849aa464e56f2c85f06a25ed71fb0d75c25c56f538118cebbe9ee3f977d05a3faf8eadae96e2736d991215846a8e8fce564246ecd825ed4767f89e0977205b6fd52ee7b9445936f048b8c0c7eb2302689b99641b97c3341e35bf194466f21cbd398248ec3cc51f0fe57c2068893b62dc01ac1f339f208d4901595592af68d043e01654f90153891898ab3c76c05f7a7469eb551ebe84efd6463ebe453c16378ab3ebf4e39111b818267a8bd943033cc8e8f015618cf11861e9608083abbb978965db86e9f52e69d737748d15121318162d114667ee7fe0de96ad86d0077ea2a68da98e2f1dd30204e11a451f96730bcc5bba827930f769fec87c12e85e7c84e2ddf6ef765ce7034041b6ac854a01459ff99df6e8b790c87a3930d3fa9cfd36c1d3750960711fbd8417eacec911780b7ae69ed43205b282843d9ac6173d3cb2a24647d69ee5fab3b406664eab97e4b87fbe0e799ccfe52d02de2c1012491388f3eb4612d857247937529d428a26ac625375215a9f6139a7dc4a910cd266baf44a17f0d8a9523282fd6348a2253010d106e88f35e0595660acb8fab601cd5a4816ac121a2d059c51d3c52d4c07eaadd45fbd93026c81728bc77d88d8e4300061e0646ac57213e3ae537a9461493c3d0c3d059dd4074944563f41dae085e38b5206bff86819be12bd34abe34196353c76068b817a40fd7d871eebb28b0405c4b89814353a7133fb6bc3c8ba8813eaa6f83ce5eee01200fc7764764d3904268ec947f96bae04166d736612</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>小技巧/小知识</title>
    <url>/2021/12/02/%E5%B0%8F%E6%8A%80%E5%B7%A7-%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h4 id="对于-URI-中参数的转义和反转义"><a href="#对于-URI-中参数的转义和反转义" class="headerlink" title="对于 URI 中参数的转义和反转义"></a>对于 URI 中参数的转义和反转义</h4><p>反转义：<code>decodeURIComponent()</code><br>转义：<code>encodeURIComponent()</code></p>
<p>转义整个 URI:<code>encodeURI</code></p>
<h4 id="window-location-reload"><a href="#window-location-reload" class="headerlink" title="window.location.reload()"></a>window.location.reload()</h4><p>这一招能让页面重新刷新</p>
<h4 id="window-location-‘xxx’-这一招直接跳转到指定路径-xxx"><a href="#window-location-‘xxx’-这一招直接跳转到指定路径-xxx" class="headerlink" title="window.location = ‘xxx’ 这一招直接跳转到指定路径 xxx"></a>window.location = ‘xxx’ 这一招直接跳转到指定路径 xxx</h4><h4 id="移除-url-上-后面的内容：-window-history-pushState-null-‘-‘-—-gt-这招可谓牛爷爷"><a href="#移除-url-上-后面的内容：-window-history-pushState-null-‘-‘-—-gt-这招可谓牛爷爷" class="headerlink" title="移除 url 上?后面的内容： window.history.pushState({}, null, ‘/‘) —&gt; 这招可谓牛爷爷"></a>移除 url 上?后面的内容： window.history.pushState({}, null, ‘/‘) —&gt; 这招可谓牛爷爷</h4><h4 id="window-location-href-window-location-origin-回到根路由"><a href="#window-location-href-window-location-origin-回到根路由" class="headerlink" title="window.location.href = window.location.origin // 回到根路由"></a>window.location.href = window.location.origin // 回到根路由</h4><p><code>window.location.origin</code> 显示网页的根路由<br><code>window.location.href = &#39;xxx&#39;;</code> 跳转到 xxx 网址(如果是原本的网址，则重新刷新一次页面)</p>
<h4 id="用-if-xxx-then-能够判断变量-xxx-是不是-promise"><a href="#用-if-xxx-then-能够判断变量-xxx-是不是-promise" class="headerlink" title="用 if (!xxx.then) 能够判断变量 xxx 是不是 promise"></a>用 if (!xxx.then) 能够判断变量 xxx 是不是 promise</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">async</span> () =&gt; &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>&#125;;<br><br><span class="hljs-keyword">if</span> (!a().then) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a不是promise&#x27;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a是promise&#x27;</span>);   <span class="hljs-comment">// 显示这个</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">let a = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>&#125;;<br><br><span class="hljs-keyword">if</span> (!a().<span class="hljs-keyword">then</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a不是promise&#x27;</span>);  <span class="hljs-regexp">//</span> 显示这个<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a是promise&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="throw-new-Error-能够打断后面一切的进程-不过要看是异步还是同步，打断的后面的内容会不一样"><a href="#throw-new-Error-能够打断后面一切的进程-不过要看是异步还是同步，打断的后面的内容会不一样" class="headerlink" title="throw new Error 能够打断后面一切的进程(不过要看是异步还是同步，打断的后面的内容会不一样)"></a>throw new Error 能够打断后面一切的进程(不过要看是异步还是同步，打断的后面的内容会不一样)</h4><figure class="highlight livescript"><table><tr><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;打断施法&#x27;</span>)<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2&#x27;</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3&#x27;</span>);<br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;开始异步操作&#x27;</span>);<br>promise();<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;4&#x27;</span>);<br></code></pre></td></tr></table></figure>

<figure class="highlight gauss"><table><tr><td class="code"><pre><code class="hljs gauss">打印结果：<br>开始异步操作<br><span class="hljs-number">1</span><br><span class="hljs-number">4</span><br><span class="hljs-built_in">Uncaught</span> (in promise) <span class="hljs-built_in">Error</span>: 打断施法<br></code></pre></td></tr></table></figure>

<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">let promise = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;   <span class="hljs-regexp">//</span> 非promise<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;打断施法&#x27;</span>)<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2&#x27;</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3&#x27;</span>);<br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;开始同步操作&#x27;</span>);<br>promise();<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;4&#x27;</span>);<br></code></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">打印结果：<br>开始同步操作<br><span class="hljs-number">1</span>    <span class="hljs-regexp">//</span> 这里<span class="hljs-number">1</span> 后面不是<span class="hljs-number">4</span><br>Uncaught (<span class="hljs-keyword">in</span> promise) Error: 打断施法<br></code></pre></td></tr></table></figure>

<h4 id="跨模块的函数传递"><a href="#跨模块的函数传递" class="headerlink" title="跨模块的函数传递"></a>跨模块的函数传递</h4><p>(更多的是在 react 中使用)<br>即一个模块里定义了一个函数，并且这个函数中使用了该函数所在模块的特有数据。 将该函数在其他模块上使用，则可以使用该模块里的内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* demo1.js */</span><br><br><span class="hljs-keyword">const</span> a = <span class="hljs-string">&#x27;这是demo1的数据&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> func = <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> a + str;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* demo2.js */</span><br>import &#123;<span class="hljs-keyword">func</span>&#125; from <span class="hljs-string">&#x27;./demo1.js&#x27;</span>;<br><br>console.log(<span class="hljs-keyword">func</span>(<span class="hljs-string">&#x27; 这是demo2的数据&#x27;</span>))  <span class="hljs-regexp">//</span> 这是demo1的数据 这是demo2的数据<br></code></pre></td></tr></table></figure>

<h4 id="使用-lt-svg-标签-gt-代替-lt-img-src-39-xxx-svg-39-gt"><a href="#使用-lt-svg-标签-gt-代替-lt-img-src-39-xxx-svg-39-gt" class="headerlink" title="使用&lt;svg 标签&gt; 代替 &lt;img src=&#39;xxx.svg&#39;/&gt;"></a>使用<code>&lt;svg 标签&gt;</code> 代替 <code>&lt;img src=&#39;xxx.svg&#39;/&gt;</code></h4><figure class="highlight subunit"><table><tr><td class="code"><pre><code class="hljs subunit">&lt;svg viewBox=&quot;0 0 448 512&quot; width=&quot;100&quot; title=&quot;bell&quot;&gt;<br>    &lt;path d=&quot;M224 512c35.32 0 63.97<span class="hljs-string">-28</span>.65 63.97<span class="hljs-string">-64</span>H160.03c0 35.35 28.65 64 63.97 64zm215.39<span class="hljs-string">-149</span>.71c<span class="hljs-string">-19</span>.32<span class="hljs-string">-20</span>.76<span class="hljs-string">-55</span>.47<span class="hljs-string">-51</span>.99<span class="hljs-string">-55</span>.47<span class="hljs-string">-154</span>.29 0<span class="hljs-string">-77</span>.7<span class="hljs-string">-54</span>.48<span class="hljs-string">-139</span>.9<span class="hljs-string">-127</span>.94<span class="hljs-string">-155</span>.16V32c0<span class="hljs-string">-17</span>.67<span class="hljs-string">-14</span>.32<span class="hljs-string">-32</span><span class="hljs-string">-31</span>.98<span class="hljs-string">-32</span>s<span class="hljs-string">-31</span>.98 14.33<span class="hljs-string">-31</span>.98 32v20.84C118.56 68.1 64.08 130.3 64.08 208c0 102.3<span class="hljs-string">-36</span>.15 133.53<span class="hljs-string">-55</span>.47 154.29<span class="hljs-string">-6</span> 6.45<span class="hljs-string">-8</span>.66 14.16<span class="hljs-string">-8</span>.61 21.71.11 16.4 12.98 32 32.1 32h383.8c19.12 0 32<span class="hljs-string">-15</span>.6 32.1<span class="hljs-string">-32</span> .05<span class="hljs-string">-7</span>.55<span class="hljs-string">-2</span>.61<span class="hljs-string">-15</span>.27<span class="hljs-string">-8</span>.61<span class="hljs-string">-21</span>.71z&quot; /&gt;<br>&lt;/svg&gt;<br></code></pre></td></tr></table></figure>

<p><code>svg 标签</code>才能够展示 <code>svg 图片</code> 的真正威力</p>
<h4 id="react-项目中：-lt-a-onclick-e-gt-e-preventDefault-gt-lt-a-gt-防止点击时页面重新刷新"><a href="#react-项目中：-lt-a-onclick-e-gt-e-preventDefault-gt-lt-a-gt-防止点击时页面重新刷新" class="headerlink" title="react 项目中：&lt;a onclick={e =&gt; e.preventDefault()}&gt;&lt;/a&gt; // 防止点击时页面重新刷新"></a>react 项目中：<code>&lt;a onclick=&#123;e =&gt; e.preventDefault()&#125;&gt;&lt;/a&gt;</code> // 防止点击时页面重新刷新</h4><h4 id="链式调用-return-this"><a href="#链式调用-return-this" class="headerlink" title="链式调用:return this"></a>链式调用:return this</h4><p>this 指向了含有这些方法的对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">lazyMan = &#123;<br>    <span class="hljs-function"><span class="hljs-title">sleep</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;sleep&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span><br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;eat&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span><br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">study</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;eat&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span><br>    &#125;<br>&#125;<br><br>lazyMan.sleep().eat().study()<br><br>看成这样：<br><span class="hljs-keyword">let</span> temp<br>temp = lazyMan.sleep() <span class="hljs-comment">// return this  所以 temp 指向了lazyMan</span><br>temp = temp.eat() <span class="hljs-comment">// return this  所以 temp 指向了lazyMan</span><br>temp = temp.study() <span class="hljs-comment">// return this  所以 temp 指向了lazyMan</span><br></code></pre></td></tr></table></figure>

<p>这里让链式的方法都指向了同一个对象</p>
<h4 id="BigInt-的作用是提供了一种方法来表示大于-253-1-的整数"><a href="#BigInt-的作用是提供了一种方法来表示大于-253-1-的整数" class="headerlink" title="BigInt 的作用是提供了一种方法来表示大于 253 - 1 的整数"></a>BigInt 的作用是提供了一种方法来表示大于 253 - 1 的整数</h4><h4 id="react-项目中，后端返回的是-html-格式的数据。如何呈现在页面上"><a href="#react-项目中，后端返回的是-html-格式的数据。如何呈现在页面上" class="headerlink" title="react 项目中，后端返回的是 html 格式的数据。如何呈现在页面上"></a>react 项目中，后端返回的是 html 格式的数据。如何呈现在页面上</h4><p>dangerouslySetInnerHTML 属性<br><code>&lt;div dangerouslySetInnerHTML=&#123;&#123;__html: ...&#125;&#125;&gt;&lt;/div&gt;</code></p>
]]></content>
      <tags>
        <tag>奇淫技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>开发个人博客反思和总结</title>
    <url>/2021/10/09/%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%8F%8D%E6%80%9D%E5%92%8C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="开发过程"><a href="#开发过程" class="headerlink" title="开发过程"></a>开发过程</h4><ol>
<li>购买域名 Namecheap —&gt; 算了，最后还是去的阿里云买的…国外的 支付方式有点困难<br>.com 和 .net 有什么区别呢？</li>
</ol>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-title">.com （商业机构）；</span><br><span class="hljs-title">.net （从事互联网服务的机构）；</span><br></code></pre></td></tr></table></figure>

<p>买的域名对于所在区域有什么影响没？</p>
<ol start="2">
<li>设定 DNS 将域名停泊到 Cloudflare，因为它有免费的 SSL 以及全球 CND 加速等服务(采用免费方案)，然后设定 DNS， 加入两个 A 记录<br>(<a href="https://zhuanlan.zhihu.com/p/86961133">https://zhuanlan.zhihu.com/p/86961133</a>)</li>
</ol>
<h2 id="cloudflare-的优势是什么-cnd-是什么东东？"><a href="#cloudflare-的优势是什么-cnd-是什么东东？" class="headerlink" title="cloudflare 的优势是什么 cnd 是什么东东？"></a>cloudflare 的优势是什么 cnd 是什么东东？</h2><p><a href="https://cloud.tencent.com/developer/article/1137135">cloudflare 相关知识</a><br>SEO –&gt;<br>建站需要什么东西</p>
<ol>
<li>域名</li>
<li>空间(主机) —&gt; 存储网站的地方</li>
<li>程序(目前已经有开源程序了)</li>
</ol>
<p><strong>域名</strong>:heyang.xyz (域名是租的…) 具有唯一性<br>注意：<br>不要购买中文域名(如果有 seo)<br>买常用的后缀<br>容易记忆的</p>
<p><strong>什么是网站空间？</strong><br>服务器(专业电脑，更强大) —&gt; 目前干脆就用自己的电脑当一个服务器算了…(不行，电脑要一直开机才行…但事实上不可能一直开机)<br>空间(服务器里的文件夹)<br>上述的这个文件夹可以和域名链接在一起(所以访问网站，其实就是通过域名打开服务器里的文件夹)</p>
<p>空间所以我们采用租的方式…</p>
<p><strong>建站程序</strong><br>事实上大多数都是用的建站程序来写的…<br>WordPress<br>织梦</p>
<hr>
<p>HEXO<br>安装 nodejs –&gt; nodejs 让 js 成为了与 php、py、perl、ruby 等服务端你语言平起平坐的脚本语言</p>
<blockquote>
<p>hexo 安装：npm intall hexo-cli -g</p>
</blockquote>
<p>利用 github 的仓库作为 hexo 的服务器来搭建个人网站</p>
<p>个人博客的话，用 hexo 完全不需要去另外购买空间，可以托管到个 ithub、coding 等托管平台，免费提供的空间完全足够了，毕竟一篇文章顶天不过十几 kb</p>
<hr>
<p><a href="https://pages.github.com/">https://pages.github.com</a></p>
<p>采用 github page + hexo</p>
<p><a href="https://hexo.io/">hexo 网站</a><br><a href="https://hexo.io/plugins/">hexo 插件</a></p>
<p>.github.io 是一个二级域名… 二级域名有什么不同之处吗？</p>
<p><a href="https://hexo.io/themes/">hexo 主题</a></p>
<p>我喜欢的主题：<a href="https://github.com/blleng/hexo-theme-lx">hexo-theme-lx</a><br><a href="https://github.com/zhaoo/hexo-theme-zhaoo">推荐 hexo 主题</a></p>
<p><a href="https://github.com/fluid-dev/hexo-theme-fluid">最牛逼最适合我的 hexo 主题</a><br>fluid 这个主题文档相当的详尽不错！</p>
<blockquote>
<p>hexo 清理缓存，重新部署:<br>hexo clean &amp;&amp; hexo g -d<br>—&gt; 当我使用了这个命令后，我所更新的东西就会自动放在<a href="https://bruce-shuai.github.io/%E9%87%8C%E4%BA%86%E3%80%82%E8%80%8C%E4%B8%8D%E6%98%AF%E7%94%A8git">https://bruce-shuai.github.io/里了。而不是用git</a> add . git commit -m …这些操作…</p>
</blockquote>
<h4 id="为博客绑定自己的域名…"><a href="#为博客绑定自己的域名…" class="headerlink" title="为博客绑定自己的域名…"></a>为博客绑定自己的域名…</h4><p>资料<br><a href="https://cloud.tencent.com/developer/article/1435908">dns 解析</a></p>
<p><a href="https://www.bilibili.com/video/BV1rb411n79N?from=search&seid=2760737936132922743&spm_id_from=333.337.0.0">该域名的教程</a></p>
<hr>
<p><a href="https://blog.justlovesmile.top/">看这位大佬的 hexo 笔记能学到很多</a><br><a href="http://blog.itchenliang.club/posts/22350780-f32d-11ea-bb4a-d3e1cbe3d59d/">魔改 hexo</a><br><a href="https://pxxyyz.com/categories/">fluid 大佬博客</a><br><a href="https://i.vince.pub/p/fluid-doc-pr/#%E4%B8%80%E8%A8%80">fluid 又一个大佬博客</a><br><a href="https://papiboy.gitee.io/2021/03/25/hexo%E7%BE%8E%E5%8C%96%E9%A1%B5%E9%9D%A2/">再一位 fluid 大佬</a><br><a href="https://www.itrhx.com/2018/08/27/A04-Hexo-blog-topic-personalization/">再来一篇 fluid 美化的博客</a><br><a href="https://blog.jalenchuh.cn/posts/hexo-fluid/">这位大佬的 fluid 的美化教程很不错</a><br><a href="https://emoryhuang.cn/blog/1729600336.html">再一位大佬</a><br><a href="https://blog.justlovesmile.top/posts/c8972b63.html">hexo 的使用</a></p>
<p><a href="https://segmentfault.com/a/1190000012805627">更换 hexo 主题</a></p>
<p><a href="https://waline.js.org/guide/get-started.html#leancloud-%E8%AE%BE%E7%BD%AE-%E6%95%B0%E6%8D%AE%E5%BA%93">hexo 评论区 Waline 插件</a></p>
<p><a href="https://www.pexels.com/zh-cn/">免费图片网站</a><br><a href="https://undraw.co/search">免费 svg 图片网站</a></p>
<hr>
<p><strong>博客性能优化：</strong></p>
<hr>
<p><strong>cdn</strong><br>GitHub+jsDelivr+PicGo 搭建免费图床<br>相关博客：<br><a href="https://blog.justlovesmile.top/posts/c8972b63.html">https://blog.justlovesmile.top/posts/c8972b63.html</a><br><a href="https://segmentfault.com/a/1190000020240864">https://segmentfault.com/a/1190000020240864</a></p>
<p><strong>–&gt; 无需下载软件的方法：<a href="picx.xpoet.cn">PicX</a></strong><br>用 cdn 外链的好处是什么？</p>
<hr>
<h2 id="Artitalk"><a href="#Artitalk" class="headerlink" title="Artitalk"></a><strong>Artitalk</strong></h2><p>发布说说<br>官网：<a href="https://artitalk.js.org/">https://artitalk.js.org/</a></p>
<hr>
<p>SEO</p>
<hr>
<p>留言板</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><code class="hljs llvm">一言： https://developer.hitokoto.cn/sentence/#<span class="hljs-variable">%E6</span><span class="hljs-variable">%8</span>E<span class="hljs-variable">%A5</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%8</span>F<span class="hljs-variable">%A3</span><span class="hljs-variable">%E8</span><span class="hljs-variable">%AF</span><span class="hljs-variable">%B4</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%98</span><span class="hljs-variable">%8</span>E  // 这个网站的api有点骚~<br></code></pre></td></tr></table></figure>

<hr>
<p>loading 动画：<br><a href="https://www.zyoushuo.cn/post/69e.html">1</a></p>
<hr>
<p>创建一个新文章<br>(是在 blog 目录下进行下面的操作!)<br>hexo new post “Title Name”</p>
<p>更改的内容效果先在 hexo server –debug 上观看(一般来说有大的改动，需重启 hexo server –debug)<br>如果感觉更改的不错(依次输入下面三个语句 上传到 heyang.xyz 里)：<br>(是在 blog 目录下进行下面的操作!)<br>hexo generate<br>hexo deploy<br>hexo clean</p>
<hr>
<h4 id="性能检测："><a href="#性能检测：" class="headerlink" title="性能检测："></a>性能检测：</h4><p>不多赘述，这篇文章讲得非常好！<a href="https://juejin.cn/book/6844733750048210957/section/6844733750123692046">修言-Performance、LightHouse 与性能 API</a></p>
<p>解决国内 github+hexo 打开页面慢的方法：<br>由于国内访问 github 的速度较慢，因此可以通过双部署同时部署到 Coding<a href="https://coding.net/">https://coding.net/</a><br><a href="https://zhuanlan.zhihu.com/p/100926319">一篇不错的文章</a><br>更多 Coading 绑定部署操作需要进一步看</p>
<h4 id="博客加密"><a href="#博客加密" class="headerlink" title="博客加密"></a>博客加密</h4><p><a href="https://ednovas.xyz/2021/05/03/hexoencrypt/#%E5%AE%9E%E7%8E%B0">借鉴此博客</a></p>
]]></content>
  </entry>
  <entry>
    <title>开始我的个人博客之旅啦</title>
    <url>/2021/10/07/%E5%BC%80%E5%A7%8B%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85%E5%95%A6/</url>
    <content><![CDATA[<p>这篇博客只是用来测试一下网站 哈哈哈<br>祝福看见这篇博客的你 永远快乐哦!</p>
<head>
  ..
  <script src="//cdn.jsdelivr.net/npm/@waline/client"></script>
  ...
</head>
<body>
  ...
  <div id="waline"></div>
  <script>
    Waline({
      el: '#waline',
      serverURL: 'https://blog-api-9sizcti78-bruce-shuai.vercel.app/',
    });
  </script>
</body>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>数据模拟(mock)方案</title>
    <url>/2021/12/02/%E6%95%B0%E6%8D%AE%E6%A8%A1%E6%8B%9F-mock-%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h3 id="方案一：代码侵入-直接在代码中写死-Mock-数据，或者请求本地的-JSON-文件"><a href="#方案一：代码侵入-直接在代码中写死-Mock-数据，或者请求本地的-JSON-文件" class="headerlink" title="方案一：代码侵入(直接在代码中写死 Mock 数据，或者请求本地的 JSON 文件)"></a><strong>方案一</strong>：代码侵入(直接在代码中写死 <code>Mock</code> 数据，或者请求本地的 <code>JSON</code> 文件)</h3><p>这种一般都是在文件中用 数组的方式 或者用 json 的方式来写一些比较简单的数据用来测试</p>
<p>优点：如果只是小的数据且代码逻辑不复杂的情况下，用这种方法，比较方便且节约时间<br>缺点：与真实 Server 端环境的切换是比较麻烦的！一切需要侵入代码切换环境的行为都是不好的</p>
<h3 id="方案二：请求拦截-例如：Mock-js"><a href="#方案二：请求拦截-例如：Mock-js" class="headerlink" title="方案二：请求拦截(例如：Mock.js)"></a><strong>方案二</strong>：请求拦截(例如：<a href="http://mockjs.com/">Mock.js</a>)</h3><p>帮我们生成随机数据<br>优点:</p>
<ol>
<li>(相对于代码侵入而言)与前端代码分离</li>
<li>可生成随机数据</li>
</ol>
<p>缺点:</p>
<ol>
<li>数据都是动态生成的假数据，无法真实模拟增删改查的情况</li>
<li>只支持 ajax,不支持 fetch</li>
</ol>
<h3 id="方案三：接口管理工具"><a href="#方案三：接口管理工具" class="headerlink" title="方案三：接口管理工具"></a><strong>方案三</strong>：接口管理工具</h3><p>代表: rap、swagger, moco, yapi(大公司才有)</p>
<p>优点：</p>
<ol>
<li>配置功能强大，接口管理与 Mock 一体，后端修改接口 mock 也跟着更改，可靠(比 Mock.js 更灵活)</li>
</ol>
<p>缺点：</p>
<ol>
<li>配置复杂，<strong>依赖后端</strong>，可能会出现后端不愿意出手(看后端人的脸色…)，或者等配置完了，接口也开发出来了的情况。</li>
<li>一般作为大团队的基础建设而存在，没有这个条件的话慎重考虑</li>
</ol>
<h3 id="方案四：本地-node-服务器"><a href="#方案四：本地-node-服务器" class="headerlink" title="方案四：本地 node 服务器"></a><strong>方案四</strong>：本地 node 服务器</h3><p>代表：<a href="https://github.com/typicode/json-server">json-server</a></p>
<p>优点：</p>
<ol>
<li>配置简单，<code>json-server</code> 甚至可以 0 代码，30 秒就启动一个 REST api Server(又是 rest api)</li>
<li>自定义程度高，一切尽在掌握中</li>
<li>增删改查真实模拟</li>
<li>接口管理工具相比，无法随着后端 api 的修改而自动修改(这个自己也用不着)</li>
</ol>
<p>缺点：似乎只能局限于 <code>rest api</code>(所以对于登录等功能的 api 实现就比较麻烦…)</p>
<p>利用<code>json-server</code>模拟自定义 api<br>需要 <a href="https://coding.imooc.com/lesson/482.html#mid=41285">自己写 middleware</a></p>
]]></content>
      <categories>
        <category>面试篇</category>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目之道</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法-大厂面试题实战</title>
    <url>/2021/12/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h3 id="最长回文子串问题-力扣-5"><a href="#最长回文子串问题-力扣-5" class="headerlink" title="最长回文子串问题(力扣 5)"></a>最长回文子串问题(力扣 5)</h3><blockquote>
<p>题目描述：给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000</p>
</blockquote>
<p><strong>找关键词：字符串， 最长</strong> –&gt; 动态规划问题<br>—&gt; 这个动态规划问题 尽量学学人家代码随想录的思维</p>
<h3 id="根据一棵树的前序遍历与中序遍历构造二叉树"><a href="#根据一棵树的前序遍历与中序遍历构造二叉树" class="headerlink" title="根据一棵树的前序遍历与中序遍历构造二叉树"></a>根据一棵树的前序遍历与中序遍历构造二叉树</h3><p>(二叉树类题目中的重复逻辑，90% 都是用递归来完成)<br>两个核心规律：</p>
<ul>
<li>前序序列头部的元素 p1 一定是<strong>当前</strong>二叉树的根结点</li>
<li>中序遍历序列中，以<strong>当前</strong>二叉树的根结点为界划分出的两个子序列，分别对应着二叉树的左子树和二叉树的右子树</li>
</ul>
<h3 id="复制带随机指针的链表"><a href="#复制带随机指针的链表" class="headerlink" title="复制带随机指针的链表"></a>复制带随机指针的链表</h3><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure>

<h3 id="岛屿数量问题"><a href="#岛屿数量问题" class="headerlink" title="岛屿数量问题"></a>岛屿数量问题</h3><blockquote>
<p>看到“所有” 必须想到“枚举”！看到“枚举”，必须回忆起 DFS 和 BFS</p>
</blockquote>
<h3 id="机器人扫地"><a href="#机器人扫地" class="headerlink" title="机器人扫地"></a>机器人扫地</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> cleanRoom = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">robot</span>) </span>&#123;<br>  <span class="hljs-comment">// 初始化一个 set 结构来存储清扫过的坐标 set(无序、不重复)</span><br>  <span class="hljs-keyword">const</span> boxSet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br>  <span class="hljs-comment">// 初始化机器人的朝向</span><br>  <span class="hljs-keyword">let</span> dir = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 遍历 递归 dfs</span><br>  dfs(robot, boxSet, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">robot, boxSet, i, j, dir</span>) </span>&#123;<br>    <span class="hljs-comment">// 记录当前格子的坐标</span><br>    <span class="hljs-keyword">let</span> box = i + <span class="hljs-string">&#x27;+&#x27;</span> + j;<br>    <span class="hljs-comment">// 如果已经打扫过，则跳过</span><br>    <span class="hljs-keyword">if</span> (boxSet.has(box)) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 打扫当前这个格子</span><br>    robot.clean();<br>    <span class="hljs-comment">// 记住这个格子</span><br>    boxSet.add(box);<br><br>    <span class="hljs-comment">// 四个方向试探</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) &#123;<br>      <span class="hljs-keyword">if</span> (robot.move()) &#123;<br>        <span class="hljs-keyword">let</span> x = i;<br>        <span class="hljs-keyword">let</span> y = j;<br><br>        <span class="hljs-comment">// 打扫方向</span><br>        <span class="hljs-keyword">switch</span>(dir) &#123;<br>          <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            x = i - <span class="hljs-number">1</span>;   <span class="hljs-comment">// 向左</span><br>            <span class="hljs-keyword">break</span>;<br>          <span class="hljs-keyword">case</span> <span class="hljs-number">90</span>:<br>            y = j + <span class="hljs-number">1</span>;   <span class="hljs-comment">// 向上</span><br>            <span class="hljs-keyword">break</span>;<br>          <span class="hljs-keyword">case</span> <span class="hljs-number">180</span>:<br>            x = i + <span class="hljs-number">1</span>;   <span class="hljs-comment">// 向右</span><br>            <span class="hljs-keyword">break</span>;<br>          <span class="hljs-keyword">case</span> <span class="hljs-number">270</span>:<br>            y = j - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 向下</span><br>          <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        dfs(robot, boxSet, x, y, dir);<br>        <span class="hljs-comment">// 这时说明撞到墙了</span><br>        ...<br>      &#125;<br><br>      <span class="hljs-comment">// 转向</span><br>      robot.turnRight();<br>      dir += <span class="hljs-number">90</span>;<br>      dir %= <span class="hljs-number">360</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>数据结构与算法之二叉树</title>
    <url>/2021/12/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h3><p>树的层次计算规则：根结点所在的那一层记为第一层，其子结点所在的就是第二层，以此类推<br>结点和树的“高度”计算规则：叶子结点高度记为 1，每向上一层高度就加 1，逐层向上累加至目标结点时，所得到的的值就是目标结点的高度。树中结点的最大高度，称为“树的高度”。<br>度”的概念：一个结点开叉出去多少个子树，被记为结点的“度”<br>“叶子结点”：叶子结点就是度为 0 的结点</p>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><ul>
<li>它可以没有根结点，作为一棵空树存在</li>
<li>如果它不是空树，那么必须由根结点、左子树和右子树组成，且左右子树都是二叉树。</li>
</ul>
<p><strong>注意，二叉树不能被简单定义为每个结点的度都是 2 的树。普通的树并不会区分左子树和右子树，但在二叉树中，左右子树的位置是严格约定、不能交换的</strong></p>
<h4 id="二叉树的编码实现"><a href="#二叉树的编码实现" class="headerlink" title="二叉树的编码实现"></a>二叉树的编码实现</h4><p>在 JS 中，二叉树使用对象来定义。它的结构分为三块：</p>
<ul>
<li>数据域</li>
<li>左侧子结点 (左子树根结点) 的引用</li>
<li>右侧子结点 (右子树根结点) 的引用</li>
</ul>
<p>在定义二叉树<strong>构造函数</strong>时，我们需要把左侧子结点和右侧子结点都预置为空：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 二叉树结点的构造函数</span><br>function TreeNode(<span class="hljs-keyword">val</span>) &#123;<br>  <span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>;<br>  <span class="hljs-keyword">this</span>.left = <span class="hljs-keyword">this</span>.right =  <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="二叉树遍历-递归"><a href="#二叉树遍历-递归" class="headerlink" title="二叉树遍历(递归)"></a>二叉树遍历(递归)</h3><p><strong>对于二叉树的遍历 —&gt; 必须要达到当场直接默写的境界才行！！</strong></p>
<p>遍历：</p>
<ul>
<li>递归遍历(先、中、后序遍历)</li>
<li>迭代遍历(层次遍历)</li>
</ul>
<p>二叉树遍历： 左子树一定要优先于右子树遍历</p>
<p>根结点 -&gt; 左子树 -&gt; 右子树 前序<br>左子树 -&gt; 根结点 -&gt; 右子树 中序<br>左子树 -&gt; 右子树 -&gt; 根结点 后序</p>
<p><strong>编写一个递归函数之前，首先要明确两样东西</strong></p>
<ul>
<li>递归式</li>
<li>递归边界</li>
</ul>
<h4 id="前序-先序-遍历"><a href="#前序-先序-遍历" class="headerlink" title="前序(先序)遍历"></a>前序(先序)遍历</h4><figure class="highlight xquery"><table><tr><td class="code"><pre><code class="hljs xquery">var preorderTraversal = <span class="hljs-keyword">function</span><span class="hljs-built_in">(root</span>) &#123;<br>    const nums = [];   // 这里应该有闭包  这里最好不要放在preorderTraversal外面，力扣机器识别不了。。。<br>    <span class="hljs-keyword">function</span> pre<span class="hljs-built_in">(root</span>) &#123;<br>        // 先要排除空节点<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">!root</span>) <span class="hljs-keyword">return</span> nums;<br>        nums.push<span class="hljs-built_in">(root</span>.val)<br>        pre<span class="hljs-built_in">(root</span>.left);<br>        pre<span class="hljs-built_in">(root</span>.right);<br>    &#125;<br>    pre<span class="hljs-built_in">(root</span>)<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><figure class="highlight xquery"><table><tr><td class="code"><pre><code class="hljs xquery">var inorderTraversal = <span class="hljs-keyword">function</span><span class="hljs-built_in">(root</span>) &#123;<br>    // 前 中 后 都是一个套路<br>    const nums = [];<br><br>    <span class="hljs-keyword">function</span> inorder<span class="hljs-built_in">(root</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">!root</span>) <span class="hljs-keyword">return</span> nums;<br>        inorder<span class="hljs-built_in">(root</span>.left);<br>        nums.push<span class="hljs-built_in">(root</span>.val);<br>        inorder<span class="hljs-built_in">(root</span>.right);<br>    &#125;<br><br>    inorder<span class="hljs-built_in">(root</span>)<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><figure class="highlight xquery"><table><tr><td class="code"><pre><code class="hljs xquery">var postorderTraversal = <span class="hljs-keyword">function</span><span class="hljs-built_in">(root</span>) &#123;<br>    // 前 中 后都是一个套路<br>    const nums = [];<br><br>    <span class="hljs-keyword">function</span> postorder<span class="hljs-built_in">(root</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">!root</span>) <span class="hljs-keyword">return</span> nums;<br><br>        postorder<span class="hljs-built_in">(root</span>.left);<br>        postorder<span class="hljs-built_in">(root</span>.right);<br>        nums.push<span class="hljs-built_in">(root</span>.val);<br>    &#125;<br>    postorder<span class="hljs-built_in">(root</span>);<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="二叉树遍历-迭代"><a href="#二叉树遍历-迭代" class="headerlink" title="二叉树遍历(迭代)"></a>二叉树遍历(迭代)</h3><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><blockquote>
<p>题目：给定一个二叉树，返回它的前序（先序）遍历序列</p>
</blockquote>
<p>做这道题的一个根本思路，就是通过合理地安排入栈和出栈的时机、使栈的出栈序列符合二叉树的前序遍历规则</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">var</span> preorderTraversal = function(root) &#123;<br>    <span class="hljs-keyword">const</span> nums = [];<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">stack</span> = [];<br><br>    <span class="hljs-keyword">if</span> (!root) &#123;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>    <span class="hljs-keyword">stack</span>.push(root);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">stack</span>.length) &#123;<br>        <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">stack</span>.pop();<br>        nums.push(node.val);<br>        <span class="hljs-comment">// 注意 入栈和出栈的逻辑</span><br>        <span class="hljs-keyword">if</span> (node.right) &#123;<br>            <span class="hljs-keyword">stack</span>.push(node.right);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (node.left) &#123;<br>            <span class="hljs-keyword">stack</span>.push(node.left);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h4><!-- 中序有点坑... -->

<h4 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h4><h4 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h4><blockquote>
<p>题目(力扣：226)：翻转一棵二叉树。</p>
</blockquote>
<h3 id="二叉搜索树-BST"><a href="#二叉搜索树-BST" class="headerlink" title="二叉搜索树(BST)"></a>二叉搜索树(BST)</h3><p>左孩子的值 &lt;= 根结点的值 &lt;= 右孩子的值</p>
<h4 id="查找数据域为某一特定值的结点"><a href="#查找数据域为某一特定值的结点" class="headerlink" title="查找数据域为某一特定值的结点"></a>查找数据域为某一特定值的结点</h4><figure class="highlight xquery"><table><tr><td class="code"><pre><code class="hljs xquery">还是递归<br><br><span class="hljs-keyword">function</span> search<span class="hljs-built_in">(root</span>, n) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">!root</span>) <span class="hljs-keyword">return</span> null;<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">(root</span>.val &lt; n) &#123;<br>        const left = search<span class="hljs-built_in">(root</span>.right, n);<br>    &#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">(root</span>.val &gt; n) &#123;<br>        const right = search<span class="hljs-built_in">(root</span>.left, n)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        console.log(<span class="hljs-string">&#x27;目标结点是：&#x27;</span>,<span class="hljs-built_in"> root</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="插入新结点"><a href="#插入新结点" class="headerlink" title="插入新结点"></a>插入新结点</h4><p>力扣 701：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 这里的插入结点是往空结点上插入，而不是破坏原来的二叉搜索树</span><br><span class="hljs-comment">// 插入的值如果是二叉树中本身就有的 该怎么办？  --&gt; 这里就不用考虑这个问题</span><br>var insertIntoBST = <span class="hljs-keyword">function</span>(root, <span class="hljs-keyword">val</span>) &#123;<br>    <span class="hljs-comment">// 递归边界</span><br>    <span class="hljs-keyword">if</span> (!root) &#123;<br>        const node = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode()</span>;<br>        node.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>;<br>        return node;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">val</span> &gt; root.<span class="hljs-keyword">val</span>) &#123;<br>        root.right = insert<span class="hljs-constructor">IntoBST(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>, <span class="hljs-params">val</span>)</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">val</span> &lt; root.<span class="hljs-keyword">val</span>) &#123;<br>        root.left = insert<span class="hljs-constructor">IntoBST(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>, <span class="hljs-params">val</span>)</span>;<br>    &#125;<br><br>    return root;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h4><p>力扣 450<br>这里还需再理解理解…</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><code class="hljs xquery">//  这一个相对要难一点...<br>// 还是要递归...<br>// 结点的消除 该怎么做？<br>var deleteNode = <span class="hljs-keyword">function</span><span class="hljs-built_in">(root</span>,<span class="hljs-built_in"> key</span>) &#123;<br>    // 递归边界<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">!root</span>) <span class="hljs-keyword">return</span> null;<br><br>    // 已经找到结点<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">(key</span> ===<span class="hljs-built_in"> root</span>.val) &#123;<br>        // 如果结点就是叶子结点<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">!root</span>.left &amp;&amp; <span class="hljs-built_in">!root</span>.right) &#123;<br>           <span class="hljs-built_in"> root</span> = null;<br>        &#125;<br>        // 如果结点还有左结点,但没有右节点<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">(root</span>.left &amp;&amp; <span class="hljs-built_in">!root</span>.right) &#123;<br>           <span class="hljs-built_in"> root</span> =<span class="hljs-built_in"> root</span>.left<br>        &#125;<br>        // 如果结点还有右节点，但没有左节点<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">(root</span>.right &amp;&amp; <span class="hljs-built_in">!root</span>.left) &#123;<br>           <span class="hljs-built_in"> root</span> =<span class="hljs-built_in"> root</span>.right;<br>        &#125;<br>        // 如果结点既有右节点，又有左节点<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">(root</span>.right &amp;&amp;<span class="hljs-built_in"> root</span>.left) &#123;<br>            <span class="hljs-keyword">let</span> left;  // 申请一个指针<br>            left =<span class="hljs-built_in"> root</span>.left;  // 记录这个指针<br>           <span class="hljs-built_in"> root</span> =<span class="hljs-built_in"> root</span>.right;<br>            const<span class="hljs-built_in"> min</span> = findMinNode<span class="hljs-built_in">(root</span>);<br>           <span class="hljs-built_in"> min</span>.left = left;<br>        &#125;<br>        <span class="hljs-keyword">return</span><span class="hljs-built_in"> root</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">(key</span> &gt;<span class="hljs-built_in"> root</span>.val) &#123;<br>       <span class="hljs-built_in"> root</span>.right = deleteNode<span class="hljs-built_in">(root</span>.right,<span class="hljs-built_in"> key</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">(key</span> &lt;<span class="hljs-built_in"> root</span>.val) &#123;<br>       <span class="hljs-built_in"> root</span>.left = deleteNode<span class="hljs-built_in">(root</span>.left,<span class="hljs-built_in"> key</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span><span class="hljs-built_in"> root</span>;<br>&#125;;<br><br>// 寻找当前结点的最小结点<br>var findMinNode = <span class="hljs-keyword">function</span><span class="hljs-built_in">(root</span>) &#123;<br>    while<span class="hljs-built_in">(root</span>.left) &#123;<br>       <span class="hljs-built_in"> root</span> =<span class="hljs-built_in"> root</span>.left;<br>    &#125;<br>    <span class="hljs-keyword">return</span><span class="hljs-built_in"> root</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>关于二叉搜索树的特性，有且仅有一条是需要大家背诵默写的：<br>二叉搜索树的中序遍历序列是有序的！</strong></p>
<h4 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h4><p>题目(力扣 98)：给定一个二叉树，判断其是否是一个有效的二叉搜索树</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><code class="hljs xquery">// 要有最大值和最小值来限制 范围<br>var isValidBST = <span class="hljs-keyword">function</span><span class="hljs-built_in">(root</span>) &#123;<br>    <span class="hljs-keyword">let</span> flag =<span class="hljs-built_in"> true</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">!root</span>) <span class="hljs-keyword">return</span> flag;   // 空树，也符合二叉搜索树的定义<br>    // 进行dfs的操作...<br>    const dfs = <span class="hljs-keyword">function</span><span class="hljs-built_in">(root</span>, minValue, maxValue) &#123;<br>        <span class="hljs-keyword">if</span> (minValue &gt;=<span class="hljs-built_in"> root</span>.val) &#123;<br>            flag =<span class="hljs-built_in"> false</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">(root</span>.left)&#123;<br>            // 既然进入左子树，则最大值会一直受到限制<br>            dfs<span class="hljs-built_in">(root</span>.left, minValue,<span class="hljs-built_in"> root</span>.val);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (maxValue &lt;=<span class="hljs-built_in"> root</span>.val) &#123;<br>            flag =<span class="hljs-built_in"> false</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">(root</span>.right) &#123;<br>            // 既然进入右子树，则最小值会一直受到限制<br>            dfs<span class="hljs-built_in">(root</span>.right,<span class="hljs-built_in"> root</span>.val, maxValue)<br>        &#125;<br><br>    &#125;<br>    dfs<span class="hljs-built_in">(root</span>, -Infinity, Infinity);<br>    <span class="hljs-keyword">return</span> flag;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="将排序数组转化为二叉搜索树"><a href="#将排序数组转化为二叉搜索树" class="headerlink" title="将排序数组转化为二叉搜索树"></a>将排序数组转化为二叉搜索树</h4><p>题目（力扣：108）：将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。<br><strong>关于二叉搜索树的特性，有且仅有一条是需要大家背诵默写的：<br>二叉搜索树的中序遍历序列是有序的！</strong></p>
<p>所以，此题可以利用中序遍历来反解出来…</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 注意这里的 高度平衡...</span><br>const sortedArrayToBST = <span class="hljs-keyword">function</span>(nums) &#123;<br>    <span class="hljs-comment">// 处理边界条件</span><br>    <span class="hljs-keyword">if</span>(!nums.length) &#123;<br>        return null<br>    &#125;<br><br>    <span class="hljs-comment">// root 结点是递归“提”起数组的结果</span><br>    const root = build<span class="hljs-constructor">BST(0, <span class="hljs-params">nums</span>.<span class="hljs-params">length</span>-1)</span><br><br>    <span class="hljs-comment">// 定义二叉树构建函数，入参是子序列的索引范围</span><br>    <span class="hljs-keyword">function</span> build<span class="hljs-constructor">BST(<span class="hljs-params">low</span>, <span class="hljs-params">high</span>)</span> &#123;<br>        <span class="hljs-comment">// 当 low &gt; high 时，意味着当前范围的数字已经被递归处理完全了</span><br>        <span class="hljs-keyword">if</span>(low &gt; high) &#123;<br>            return null<br>        &#125;<br>        <span class="hljs-comment">// 二分一下，取出当前子序列的中间元素</span><br>        const mid = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>floor(low + (high - low)/<span class="hljs-number">2</span>)<br>        <span class="hljs-comment">// 将中间元素的值作为当前子树的根结点值</span><br>        const cur = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(<span class="hljs-params">nums</span>[<span class="hljs-params">mid</span>])</span><br>        <span class="hljs-comment">// 递归构建左子树，范围二分为[low,mid)</span><br>        cur.left = build<span class="hljs-constructor">BST(<span class="hljs-params">low</span>,<span class="hljs-params">mid</span>-1)</span><br>        <span class="hljs-comment">// 递归构建左子树，范围二分为为(mid,high]</span><br>        cur.right = build<span class="hljs-constructor">BST(<span class="hljs-params">mid</span>+1, <span class="hljs-params">high</span>)</span><br>        <span class="hljs-comment">// 返回当前结点</span><br>        return cur<br>    &#125;<br>    <span class="hljs-comment">// 返回根结点</span><br>    return root<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="平衡二叉树-AVL-Tree"><a href="#平衡二叉树-AVL-Tree" class="headerlink" title="平衡二叉树(AVL Tree)"></a>平衡二叉树(AVL Tree)</h3><p>指的是任意结点的左右子树高度差绝对值都不大于 1 的二叉搜索树<br>对于同一个遍历序列来说，平衡二叉树比非平衡二叉树的查找效率更高</p>
<h4 id="判断是否为平衡二叉树"><a href="#判断是否为平衡二叉树" class="headerlink" title="判断是否为平衡二叉树"></a>判断是否为平衡二叉树</h4><blockquote>
<p>题目(力扣 110)给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
</blockquote>
<p><strong>平衡二叉树是任意结点的左右子树高度差绝对值都不大于 1 的二叉搜索树</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> isBalanced = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// 又是递归... 毕竟在遍历...</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">root</span>) </span>&#123;<br>        <span class="hljs-comment">// 返回的是高度，最底层是 0</span><br>        <span class="hljs-keyword">if</span> (!root || !flag) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">const</span> left = dfs(root.left);<br>        <span class="hljs-keyword">const</span> right = dfs(root.right);<br><br>        <span class="hljs-comment">// 同层相减</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.abs(left - right) &gt; <span class="hljs-number">1</span>) &#123;<br>            flag = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(left, right) + <span class="hljs-number">1</span>;<br>    &#125;<br>    dfs(root);<br>    <span class="hljs-keyword">return</span> flag;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="堆结构"><a href="#堆结构" class="headerlink" title="堆结构"></a>堆结构</h3>]]></content>
      <categories>
        <category>面试篇</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>面试之道</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法之动态规划</title>
    <url>/2021/12/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p><strong>动态规划是一种思想</strong><br>动态规划中每一个状态一定是由上一个状态推导出来的</p>
<p><strong>总结一点规律：</strong></p>
<ol>
<li>一般稍微麻烦点的动态规划就是 <code>dp[i][j]</code> 这种二维数组</li>
<li><code>dp[i]</code> 或者 <code>dp[i][j]</code> 就是最后要返回的结果</li>
<li>动态规划 for 循环 来遍历</li>
<li>一般要找的就是dp的递推公式</li>
</ol>
<p>一般求最值问题 就少不了用方法： <code>Math.max</code> 进行比较</p>
<p>注意：动态规划很多时候需要使用二维数组 <code>dp[i][j]</code> 来解决问题<br>一般<code>dp[i]</code> 或 <code>dp[i][j]</code>就是题目的结果</p>
<p>动态规划五部曲</p>
<ol>
<li>确定dp数组 (dp table) 以及下标的含义</li>
<li>确定递推公式(即状态转移公式)</li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ol>
<h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h3><p>这道题目有两个关键的特征：</p>
<ul>
<li>要求你给出达成某个目的的<strong>解法个数</strong></li>
<li>不要求你给出每一种解法对应的具体路径<br>这样的问题，往往可以用动态规划进行求解</li>
</ul>
<p><strong>做动态规划题</strong></p>
<ol>
<li>先倒着分析问题。</li>
</ol>
<ul>
<li>定位到问题的终点</li>
<li>站在终点这个视角，思考后退的可能性</li>
</ul>
<ol start="2">
<li>记忆化搜索来提效</li>
</ol>
<ul>
<li>用空间换时间，也就是想办法记住之前已经求解过的结果</li>
<li>在递归的过程中，不断保存已经计算出的结果，从而避免重复计算的手法，叫做<strong>记忆化搜索</strong></li>
</ul>
<ol start="3">
<li>记忆化搜索转化为动态规划</li>
</ol>
<ul>
<li>记忆化搜索可以理解为优化过后的递归。是一个自定向下的方法；动态规划，是一个<strong>自底向上</strong>的过程。它要求我们站在已知的角度，通过定位已知和未知之间的关系，一步一步向前推导，进而求解出未知的值</li>
</ul>
<p>和分治不同，动态规划划分出的子问题，往往是相互依赖、相互影响的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> climbStairs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-comment">// 初始化状态数组</span><br>  <span class="hljs-keyword">const</span> f = [];<br>  <span class="hljs-comment">// 初始化已知值</span><br>  f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>  f[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>  <span class="hljs-comment">// 动态更新每一层楼梯对应的结果</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">3</span>;i &lt;= n;i++)&#123;<br>      f[i] = f[i-<span class="hljs-number">2</span>] + f[i-<span class="hljs-number">1</span>];<br>  &#125;<br>  <span class="hljs-comment">// 返回目标值</span><br>  <span class="hljs-keyword">return</span> f[n];<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>什么样的题应该用动态规划来做？我们要抓以下两个关键特征：</p>
<ul>
<li>最优子结构:它指的是问题的最优解包含着子问题的最优解——不管前面的决策如何，此后的状态必须是基于当前状态（由上次决策产生）的最优决策</li>
<li>重叠子问题: 它指的是在递归的过程中，出现了反复计算的情况</li>
</ul>
<p><strong>树形思维模型将帮助我们更迅速地定位到状态转移关系，边界条件往往对应的就是已知子问题的解</strong></p>
<p>递归思想明确树形思维模型：找到问题终点，思考倒退的姿势，往往可以帮助你更快速地明确状态间的关系<br>结合记忆化搜索，明确状态转移方程<br>递归代码转化为迭代表达（这一步不一定是必要的，1、2 本身为思维路径，而并非代码实现。若你成长为熟手，2 中分析出来的状态转移方程可以直接往循环里塞，根本不需要转换</p>
<h3 id="如何优雅地找硬币"><a href="#如何优雅地找硬币" class="headerlink" title="如何优雅地找硬币"></a>如何优雅地找硬币</h3><p><strong>提示：最值问题是动态规划的常见对口题型，见到最值问题，应该想到动态规划</strong></p>
<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><h4 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0-1 背包问题"></a>0-1 背包问题</h4><p>最值问题–&gt;要想到动态规划…</p>
<p>先倒推，找状态转移关系</p>
<p>找自变量和因变量 –&gt; 自变量是物品的索引 因变量是总价值</p>
<h4 id="最长上升子序列模型"><a href="#最长上升子序列模型" class="headerlink" title="最长上升子序列模型"></a>最长上升子序列模型</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 因为只求长度，而不求具体有哪些元素。还是最值问题，故直接考虑动态规划问题</span><br><span class="hljs-keyword">var</span> lengthOfLIS = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> len = nums.length;<br>    <span class="hljs-keyword">const</span> db = <span class="hljs-built_in">Array</span>(len).fill(<span class="hljs-number">1</span>);<br>    result = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] &lt; nums[i]) db[i] = <span class="hljs-built_in">Math</span>.max(db[j] + <span class="hljs-number">1</span>, db[i])<br>        &#125;<br>        result = <span class="hljs-built_in">Math</span>.max(result, db[i])<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>数据结构与算法之排序</title>
    <url>/2021/12/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p><strong>基础排序算法：</strong></p>
<ul>
<li>冒泡排序</li>
<li>插入排序</li>
<li>选择排序<br><strong>进阶排序算法</strong></li>
<li>归并排序</li>
<li>快速排序</li>
</ul>
<blockquote>
<p>注意：考虑到排序类题目在未经特别声明的情况下，都默认以“从小到大排列”为有序标准。因此下文中所有”有序“的描述指代的都是“从小到大排列”。</p>
</blockquote>
<h2 id="基础排序算法"><a href="#基础排序算法" class="headerlink" title="基础排序算法"></a>基础排序算法</h2><p>这个基础排序算法要求不高，直接能够默写下来就可以了</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>这套逻辑到底要执行多少次，是完全由数组中元素的个数来决定的：每一次从头到尾的遍历都只能定位到一个元素的位置，因此元素有多少个，总的循环就要执行多少轮</p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序的关键字是“最小值”：循环遍历数组，每次都找出当前范围内的最小值，把它放在当前范围的头部；然后缩小排序范围，继续重复以上操作，直至数组完全有序为止</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[5, 3, 2, 4, 1]</span><br>function selectSort(arr) &#123;<br>  for (let i = 0; i &lt; arr.length; i++) &#123;<br>    let minIndex = i;<br>    for (let j = i + 1; j &lt; arr.length; j++) &#123;<br>      if (arr<span class="hljs-comment">[minIndex]</span> &gt; arr<span class="hljs-comment">[j]</span>) &#123;<br>        minIndex = j;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">[arr<span class="hljs-comment">[i]</span>, arr<span class="hljs-comment">[minIndex]</span>]</span> = <span class="hljs-comment">[arr<span class="hljs-comment">[minIndex]</span>, arr<span class="hljs-comment">[i]</span>]</span><br>  &#125;<br>  return arr;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序的核心思想是“找到元素在它前面那个序列中的正确位置”。<br>具体来说，插入排序所有的操作都基于一个这样的前提：当前元素前面的序列是有序的。基于这个前提，从后往前去寻找当前元素在前面那个序列里的正确位置。</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm">[<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>]<br><br>function <span class="hljs-keyword">insertSort(arr) </span>&#123;<br><br>  for (let i = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; arr.length; i++) &#123;</span><br>    let temp = arr[i];<br>    let <span class="hljs-keyword">j </span>= i;<br>    while (<span class="hljs-keyword">j </span>&gt; <span class="hljs-number">0</span> &amp;&amp; temp &lt; arr[<span class="hljs-keyword">j </span>- <span class="hljs-number">1</span>]) &#123;<br>      arr[<span class="hljs-keyword">j] </span>= arr[<span class="hljs-keyword">j </span>- <span class="hljs-number">1</span>];<br>      <span class="hljs-keyword">j--;</span><br><span class="hljs-keyword"></span>    &#125;<br>    arr[<span class="hljs-keyword">j] </span>= temp;<br>  &#125;<br>  return arr;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="进阶排序算法"><a href="#进阶排序算法" class="headerlink" title="进阶排序算法"></a>进阶排序算法</h2><p>归并算法和快速排序算法 <strong>“分治”，分而治之。其思想就是将一个大问题分解为若干个子问题，针对子问题分别求解后，再将子问题的解整合为大问题的解</strong></p>
<h3 id="归并排序：归并排序在实现上依托的就是递归思想"><a href="#归并排序：归并排序在实现上依托的就是递归思想" class="headerlink" title="归并排序：归并排序在实现上依托的就是递归思想"></a>归并排序：归并排序在实现上依托的就是<strong>递归</strong>思想</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> merge<span class="hljs-constructor">Sort(<span class="hljs-params">arr</span>)</span> &#123;<br>  <span class="hljs-keyword">let</span> len = arr.length;<br>  <span class="hljs-comment">// 错误边界</span><br>  <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">1</span>) &#123;<br>    return arr;<br>  &#125;<br><br>  <span class="hljs-comment">// 进行分治</span><br>  <span class="hljs-keyword">let</span> mid = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>floor(len<span class="hljs-operator"> / </span><span class="hljs-number">2</span>);<br><br>  <span class="hljs-keyword">let</span> arr1 = arr.slice(<span class="hljs-number">0</span>, mid);<br>  <span class="hljs-keyword">let</span> arr2 = arr.slice(mid, len)<br>  <span class="hljs-keyword">let</span> left = merge<span class="hljs-constructor">Sort(<span class="hljs-params">arr1</span>)</span>;<br>  <span class="hljs-keyword">let</span> right = merge<span class="hljs-constructor">Sort(<span class="hljs-params">arr2</span>)</span>;<br><br>  return merge<span class="hljs-constructor">Arr(<span class="hljs-params">left</span>, <span class="hljs-params">right</span>)</span>;<br>&#125;<br><br><span class="hljs-comment">// 用于合并数组的函数</span><br><span class="hljs-keyword">function</span> merge<span class="hljs-constructor">Arr(<span class="hljs-params">arr1</span>, <span class="hljs-params">arr2</span>)</span> &#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-literal">[]</span>;<br>  <span class="hljs-keyword">let</span> index_1 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> index_2 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> len1 = arr1.length;   <span class="hljs-comment">// 这里要弄一个数组长度缓存。因为后面的调试中数组长度可能会有变化</span><br>  <span class="hljs-keyword">let</span> len2 = arr2.length;<br><br>  <span class="hljs-keyword">while</span>(index_1 &lt; len1<span class="hljs-operator"> &amp;&amp; </span>index_2 &lt; len2) &#123;<br>    <span class="hljs-keyword">if</span> (arr1<span class="hljs-literal">[<span class="hljs-identifier">index_1</span>]</span> &lt;= arr2<span class="hljs-literal">[<span class="hljs-identifier">index_2</span>]</span>) &#123;<br>      res.push(arr1<span class="hljs-literal">[<span class="hljs-identifier">index_1</span>]</span>);<br>      index_1++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      res.push(arr2<span class="hljs-literal">[<span class="hljs-identifier">index_2</span>]</span>);<br>      index_2++;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 把剩余的arr1或者arr2的尾巴接住</span><br>  <span class="hljs-keyword">if</span> (index_1 &lt; len1) &#123;<br>    res = <span class="hljs-literal">[<span class="hljs-operator">...</span><span class="hljs-identifier">res</span>, <span class="hljs-operator">...</span><span class="hljs-identifier">arr1</span>.<span class="hljs-identifier">slice</span>(<span class="hljs-identifier">index_1</span>, <span class="hljs-identifier">len1</span>)]</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    res = <span class="hljs-literal">[<span class="hljs-operator">...</span><span class="hljs-identifier">res</span>, <span class="hljs-operator">...</span><span class="hljs-identifier">arr2</span>.<span class="hljs-identifier">slice</span>(<span class="hljs-identifier">index_2</span>, <span class="hljs-identifier">len2</span>)]</span><br>  &#125;<br> return res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序在基本思想上和归并排序是一致的，仍然坚持“分而治之”的原则不动摇。区别在于，快速排序并不会把真的数组分割开来再合并到一个新数组中去，而是直接在原有的数组内部进行排序。</p>
<p>投降了…</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 快排入口 (下面的这个参数默认值使用挺厉害的...)</span><br><span class="hljs-keyword">function</span> quick<span class="hljs-constructor">Sort(<span class="hljs-params">arr</span>, <span class="hljs-params">left</span> = 0; <span class="hljs-params">right</span> = <span class="hljs-params">arr</span>.<span class="hljs-params">length</span> - 1)</span> &#123;<br><span class="hljs-comment">// 定义递归边界，若数组只有一个元素，则没有排序必要</span><br>  <span class="hljs-keyword">if</span>(arr.length &gt; <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-comment">// lineIndex表示下一次划分左右子数组的索引位</span><br>      const lineIndex = partition(arr, left, right)<br>      <span class="hljs-comment">// 如果左边子数组的长度不小于1，则递归快排这个子数组</span><br>      <span class="hljs-keyword">if</span>(left &lt; lineIndex-<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 左子数组以 lineIndex-1 为右边界</span><br>        quick<span class="hljs-constructor">Sort(<span class="hljs-params">arr</span>, <span class="hljs-params">left</span>, <span class="hljs-params">lineIndex</span>-1)</span><br>      &#125;<br>      <span class="hljs-comment">// 如果右边子数组的长度不小于1，则递归快排这个子数组</span><br>      <span class="hljs-keyword">if</span>(lineIndex&lt;right) &#123;<br>        <span class="hljs-comment">// 右子数组以 lineIndex 为左边界</span><br>        quick<span class="hljs-constructor">Sort(<span class="hljs-params">arr</span>, <span class="hljs-params">lineIndex</span>, <span class="hljs-params">right</span>)</span><br>      &#125;<br>  &#125;<br>  return arr<br>&#125;<br><br><span class="hljs-comment">// 以基准值为轴心，划分左右子数组的过程</span><br><span class="hljs-keyword">function</span> partition(arr, left, right) &#123;<br>  <span class="hljs-comment">// 基准值默认取中间位置的元素</span><br>  <span class="hljs-keyword">let</span> pivotValue = arr<span class="hljs-literal">[M<span class="hljs-identifier">ath</span>.<span class="hljs-identifier">floor</span>(<span class="hljs-identifier">left</span> + (<span class="hljs-identifier">right</span>-<span class="hljs-identifier">left</span>)<span class="hljs-operator">/</span><span class="hljs-number">2</span>)]</span><br>  <span class="hljs-comment">// 初始化左右指针</span><br>  <span class="hljs-keyword">let</span> i = left<br>  <span class="hljs-keyword">let</span> j = right<br>  <span class="hljs-comment">// 当左右指针不越界时，循环执行以下逻辑</span><br>  <span class="hljs-keyword">while</span>(i&lt;=j) &#123;<br>      <span class="hljs-comment">// 左指针所指元素若小于基准值，则右移左指针</span><br>      <span class="hljs-keyword">while</span>(arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> &lt; pivotValue) &#123;<br>          i++<br>      &#125;<br>      <span class="hljs-comment">// 右指针所指元素大于基准值，则左移右指针</span><br>      <span class="hljs-keyword">while</span>(arr<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> &gt; pivotValue) &#123;<br>          j--<br>      &#125;<br><br>      <span class="hljs-comment">// 若i&lt;=j，则意味着基准值左边存在较大元素或右边存在较小元素，交换两个元素确保左右两侧有序</span><br>      <span class="hljs-keyword">if</span>(i&lt;=j) &#123;<br>          swap(arr, i, j)<br>          i++<br>          j--<br>      &#125;<br><br>  &#125;<br>  <span class="hljs-comment">// 返回左指针索引作为下一次划分左右子数组的依据</span><br>  return i<br>&#125;<br><br><span class="hljs-comment">// 快速排序中使用 swap 的地方比较多，我们提取成一个独立的函数</span><br><span class="hljs-keyword">function</span> swap(arr, i, j) &#123;<br>  <span class="hljs-literal">[<span class="hljs-identifier">arr</span>[<span class="hljs-identifier">i</span>]</span>, arr<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>] = <span class="hljs-literal">[<span class="hljs-identifier">arr</span>[<span class="hljs-identifier">j</span>]</span>, arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>]<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面试篇</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>面试之道</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法之深度与广度遍历</title>
    <url>/2021/12/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%B7%B1%E5%BA%A6%E4%B8%8E%E5%B9%BF%E5%BA%A6%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h3 id="深度优先遍历-不撞南墙不回头的“迷宫游戏”-DFS"><a href="#深度优先遍历-不撞南墙不回头的“迷宫游戏”-DFS" class="headerlink" title="深度优先遍历 (不撞南墙不回头的“迷宫游戏”) DFS"></a>深度优先遍历 (不撞南墙不回头的“迷宫游戏”) DFS</h3><p><strong>“不撞南墙不回头”的原则：只要没有碰壁，就决不选择其它的道路，而是坚持向当前道路的深处挖掘——像这样将“深度”作为前进的第一要素的搜索方法，就是所谓的“深度优先搜索”</strong></p>
<p><strong>深度优先搜索的核心思想，是试图穷举所有的完整路径</strong></p>
<p><strong>深度优先搜索的本质 — 栈结构</strong></p>
<p>二叉树的<strong>先序遍历</strong>正是深度优先搜索思想的递归实现。可以说深度优先搜索过程就类似于树的先序遍历、是树的先序遍历的推广</p>
<h3 id="广度优先搜索思想-BFS"><a href="#广度优先搜索思想-BFS" class="headerlink" title="广度优先搜索思想 BFS"></a>广度优先搜索思想 BFS</h3><p><strong>BFS 算法的实现过程，和队列有着密不可分的关系</strong><br><strong>广度优先和层序遍历是密不可分的</strong></p>
<h4 id="二叉树的层序遍历-力扣-102"><a href="#二叉树的层序遍历-力扣-102" class="headerlink" title="二叉树的层序遍历 (力扣 102)"></a>二叉树的层序遍历 (力扣 102)</h4><p><strong>看到“层次”关键字，大家应该立刻想到“扫描”；想到“扫描”，就应该立刻想到 BFS</strong></p>
<p>这招是自创的，命名逻辑正确(且只用一次循环)，但是力扣不给过…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 给结点设置新属性的方法 */</span><br>var levelOrder = <span class="hljs-built_in">function</span>(root) &#123;<br>    <span class="hljs-comment">// 层序遍历： 队列 和 while 的搭配</span><br>    <span class="hljs-keyword">const</span> queue = [];  <span class="hljs-comment">// queue 存放的是结点</span><br>    <span class="hljs-keyword">const</span> nums = [];<br><br>    <span class="hljs-comment">// 我给结点开辟个新的属性 表示层级</span><br>    root.level = <span class="hljs-number">0</span>;<br>    queue.<span class="hljs-built_in">push</span>(root);<br><br>    <span class="hljs-keyword">while</span>(queue.length) &#123;<br>        <span class="hljs-keyword">const</span> top = queue[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (top.left) &#123;<br>            top.left.level = top.level + <span class="hljs-number">1</span>;<br>            queue.<span class="hljs-built_in">push</span>(top.left);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (top.right) &#123;<br>            top.right.level = top.level + <span class="hljs-number">1</span>;<br>            queue.<span class="hljs-built_in">push</span>(top.right);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!nums[queue[<span class="hljs-number">0</span>].level]) &#123;<br>            nums[queue[<span class="hljs-number">0</span>].level] = []<br>        &#125;<br>        nums[queue[<span class="hljs-number">0</span>].level].<span class="hljs-built_in">push</span>(queue[<span class="hljs-number">0</span>].val);<br>        queue.<span class="hljs-built_in">shift</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> nums;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>传统解法… 感觉时间复杂度还要高很多…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">var levelOrder = <span class="hljs-built_in">function</span>(root) &#123;<br>    <span class="hljs-comment">// 层序遍历： 队列 和 while 的搭配</span><br>    <span class="hljs-keyword">const</span> nums = [];<br>    <span class="hljs-keyword">if</span> (!root) &#123;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>    <span class="hljs-keyword">const</span> queue = [];  <span class="hljs-comment">// queue 存放的是结点</span><br>    queue.<span class="hljs-built_in">push</span>(root);<br><br>    <span class="hljs-keyword">while</span> (queue.length) &#123;<br>        <span class="hljs-keyword">const</span> temp = [];    <span class="hljs-comment">// 来一个临时数组</span><br>        let len = queue.length;<br>        <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">const</span> node = queue[<span class="hljs-number">0</span>]<br>            temp.<span class="hljs-built_in">push</span>(node.val);<br>            <span class="hljs-keyword">if</span> (node.left) queue.<span class="hljs-built_in">push</span>(node.left);<br>            <span class="hljs-keyword">if</span> (node.right) queue.<span class="hljs-built_in">push</span>(node.right);<br>            queue.<span class="hljs-built_in">shift</span>();<br>        &#125;<br>        nums.<span class="hljs-built_in">push</span>(temp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面试篇</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>面试之道</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法之栈与队列</title>
    <url>/2021/12/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<blockquote>
<p>前言：很多时候相关题目中压根不会出现“栈”、“队列”这样的关键字，但只要你深入到真题里去、对栈和队列的应用场景建立起正确的感知，那么很多线索都会在分析的过程中被你轻松地挖掘出来。</p>
</blockquote>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="有效括号"><a href="#有效括号" class="headerlink" title="有效括号"></a>有效括号</h3><blockquote>
<p>题目(力扣 155)：给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效</p>
</blockquote>
<p>此题利用栈，来验证是否括号有对称性</p>
<p><strong>记一个规律： 题目中若涉及括号问题，则很有可能和栈相关</strong></p>
<p>注意：此题看似简单，但特别容易考虑不周，导致出错…</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">var isValid = <span class="hljs-built_in">function</span>(s) &#123;<br>    <span class="hljs-keyword">const</span> bracket = &#123;<br>        <span class="hljs-string">&quot;(&quot;</span>:<span class="hljs-string">&quot;)&quot;</span>,<br>        <span class="hljs-string">&quot;&#123;&quot;</span>:<span class="hljs-string">&quot;&#125;&quot;</span>,<br>        <span class="hljs-string">&quot;[&quot;</span>:<span class="hljs-string">&quot;]&quot;</span><br>    &#125;<br>    let stack = [];  <span class="hljs-comment">// 设置一个栈！ 能有资格进入栈的，只有原来开口向右的</span><br>    <span class="hljs-keyword">for</span>(let i = <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] === <span class="hljs-string">&#x27;(&#x27;</span> || s[i] === <span class="hljs-string">&#x27;&#123;&#x27;</span> || s[i] === <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>            stack.<span class="hljs-built_in">push</span>(bracket[s[i]]);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] === stack[stack.length - <span class="hljs-number">1</span>]) &#123;<br>            stack.<span class="hljs-built_in">pop</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 如果上面两种情况都不满足，则就不可能有对称性了，直接报错！</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 这种方式有点out！</span><br>    <span class="hljs-comment">// if (stack.length === 0) return true;</span><br>    <span class="hljs-comment">// return false;</span><br><br>    <span class="hljs-keyword">return</span> stack.length === <span class="hljs-number">0</span>;   <span class="hljs-comment">// 这种方式才简洁</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="每日温度问题"><a href="#每日温度问题" class="headerlink" title="每日温度问题"></a>每日温度问题</h3><p>(此题理解我还不是特别深刻)</p>
<blockquote>
<p>题目(739):根据每日气温列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。</p>
</blockquote>
<blockquote>
<p>例子:给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p>
</blockquote>
<p><strong>栈结构可以帮助我们避免多余事情</strong></p>
<p><strong>避免重复操作的秘诀就是及时地将不必要的数据出栈，避免它对我们后续的遍历产生干扰</strong><br>有趣的理念：<strong>递减栈</strong></p>
<p>此题核心点：最小栈里放置的不是温度，而是温度的下标(便于记录温度的时间点)</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">var</span> dailyTemperatures = function(temperatures) &#123;<br>    <span class="hljs-built_in">let</span> res = <span class="hljs-built_in">new</span> Array(temperatures.<span class="hljs-built_in">length</span>).fill(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">let</span> min_stack = [];  // 递减栈！核心点：最小栈里放置的不是温度，而是温度的下标(便于记录温度的时间点)<br><br>    // 递减栈发挥的作用是什么呢？<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> i = <span class="hljs-number">0</span>; i &lt; temperatures.<span class="hljs-built_in">length</span>; i++) &#123;<br>        // 检查温度是否大于递减栈的某个位置的温度, 如果温度大于，则把递减栈中小的剔除<br>        <span class="hljs-keyword">while</span> (min_stack.<span class="hljs-built_in">length</span> &amp;&amp; temperatures[i] &gt; temperatures[min_stack[min_stack.<span class="hljs-built_in">length</span> - <span class="hljs-number">1</span>]]) &#123;<br>            res[min_stack[min_stack.<span class="hljs-built_in">length</span> - <span class="hljs-number">1</span>]] = i - min_stack[min_stack.<span class="hljs-built_in">length</span> - <span class="hljs-number">1</span>]<br>            min_stack.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        // 将当前温度的天记录在递减栈中<br>        min_stack.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>    <span class="hljs-built_in">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="“最小栈”问题"><a href="#“最小栈”问题" class="headerlink" title="“最小栈”问题"></a>“最小栈”问题</h3><p>题目(力扣 155):设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈</p>
<p>核心：配置一个辅助栈！</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-keyword">var</span> MinStack = function() &#123;   <span class="hljs-comment">// 这是一个构造函数</span><br>    <span class="hljs-keyword">this</span>.stack = [];        <span class="hljs-comment">// 尴尬，有点忘记this的一些操作了...</span><br>    <span class="hljs-keyword">this</span>.assist_stack = []; <span class="hljs-comment">// 辅助栈(同样是一个递减栈)</span><br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;number&#125; val</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;void&#125;</span><br><span class="hljs-comment"> */</span><br>MinStack.prototype.push = function(<span class="hljs-keyword">val</span>) &#123;<br>    <span class="hljs-keyword">this</span>.stack.push(<span class="hljs-keyword">val</span>);   <span class="hljs-comment">// 借用js数组本身就自带的push功能</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.assist_stack.length || <span class="hljs-keyword">val</span> &lt;= <span class="hljs-keyword">this</span>.assist_stack[<span class="hljs-keyword">this</span>.assist_stack.length - <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-comment">// 注意：这里是 &lt;= 符号</span><br>        <span class="hljs-keyword">this</span>.assist_stack.push(<span class="hljs-keyword">val</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;void&#125;</span><br><span class="hljs-comment"> */</span><br>MinStack.prototype.pop = function() &#123;<br>    let <span class="hljs-keyword">val</span> = <span class="hljs-keyword">this</span>.stack.pop();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">val</span> === <span class="hljs-keyword">this</span>.assist_stack[<span class="hljs-keyword">this</span>.assist_stack.length - <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">this</span>.assist_stack.pop();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;number&#125;</span><br><span class="hljs-comment"> */</span><br>MinStack.prototype.top = function() &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.stack.length) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 边界值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stack[<span class="hljs-keyword">this</span>.stack.length - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 注意！这里说的是栈顶元素(不要想成stack[0]了)</span><br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;number&#125;</span><br><span class="hljs-comment"> */</span><br>MinStack.prototype.getMin = function() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.assist_stack[<span class="hljs-keyword">this</span>.assist_stack.length - <span class="hljs-number">1</span>];<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>关于队列，在算法面试中大家需要掌握以下重点：</p>
<ul>
<li>栈向队列的转化</li>
<li>双端队列</li>
<li>优先队列</li>
</ul>
<h3 id="如何用栈实现一个队列"><a href="#如何用栈实现一个队列" class="headerlink" title="如何用栈实现一个队列"></a>如何用栈实现一个队列</h3><blockquote>
<p>题目(力扣 232): 使用栈实现队列的下列操作<br>push(x) – 将一个元素放入队列的尾部。<br>pop() – 从队列首部移除元素。<br>peek() – 返回队列首部的元素。<br>empty() – 返回队列是否为空</p>
</blockquote>
<blockquote>
<p>示例：<br>MyQueue queue = new MyQueue();<br>queue.push(1);<br>queue.push(2);<br>queue.peek(); // 返回 1<br>queue.pop(); // 返回 1<br>queue.empty(); // 返回 false</p>
</blockquote>
<p>核心点：栈转队列 需要两个栈!</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-keyword">var</span> MyQueue = function() &#123;<br>    <span class="hljs-keyword">this</span>.stack1 = [];   <span class="hljs-comment">// 入队操作依赖 stack1</span><br>    <span class="hljs-keyword">this</span>.stack2 = [];   <span class="hljs-comment">// 出队操作依赖 stack2</span><br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;number&#125; x</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;void&#125;</span><br><span class="hljs-comment"> */</span><br>MyQueue.prototype.push = function(x) &#123;<br>    <span class="hljs-keyword">this</span>.stack1.push(x);<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;number&#125;</span><br><span class="hljs-comment"> */</span><br>MyQueue.prototype.pop = function() &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stack2.length === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">this</span>.stack1.length) &#123;<br>            <span class="hljs-keyword">this</span>.stack2.push(<span class="hljs-keyword">this</span>.stack1.pop());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stack2.pop()<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;number&#125;</span><br><span class="hljs-comment"> */</span><br>MyQueue.prototype.peek = function() &#123;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.stack2.length) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stack1[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stack2[<span class="hljs-keyword">this</span>.stack2.length - <span class="hljs-number">1</span>];<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;boolean&#125;</span><br><span class="hljs-comment"> */</span><br>MyQueue.prototype.empty = function() &#123;<br>    <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>.stack1.length &amp;&amp; !<span class="hljs-keyword">this</span>.stack2.length;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p><strong>双端队列就是允许在队列的两端进行插入和删除的队列。</strong></p>
<h4 id="滑动窗口问题"><a href="#滑动窗口问题" class="headerlink" title="滑动窗口问题"></a>滑动窗口问题</h4><blockquote>
<p>题目(力扣 239)：给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值</p>
</blockquote>
<blockquote>
<p>示例：输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 输出: [3,3,5,5,6,7]</p>
</blockquote>
<blockquote>
<p>核心是<strong>递减队列</strong> 区别之前做过的 <strong>递减栈</strong></p>
</blockquote>
<p>此题要注意一下细节，因为非常容易出错…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//  使用双端队列来解决问题</span><br>var maxSlidingWindow = <span class="hljs-built_in">function</span>(nums, k) &#123;<br>    let res = [];<br>    let queue = [];    <span class="hljs-comment">// 这是一个递减队列  元素应该是记的下标 而非 nums的元素值</span><br><br>    <span class="hljs-comment">// 有空的时候，看看能不能把这两个for 循环合并在一起</span><br>    <span class="hljs-keyword">for</span>(let i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!queue.length || nums[queue[queue.length - <span class="hljs-number">1</span>]] &gt;= nums[i]) &#123;<br>            queue.<span class="hljs-built_in">push</span>(i)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span>(nums[queue[queue.length - <span class="hljs-number">1</span>]] &lt; nums[i]) &#123;<br>                queue.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            queue.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>    &#125;<br>    res.<span class="hljs-built_in">push</span>(nums[queue[<span class="hljs-number">0</span>]]);   <span class="hljs-comment">// 第一个窗口的最大值已经有了！</span><br><br>    <span class="hljs-keyword">for</span> (let i = k; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (queue[<span class="hljs-number">0</span>] &lt; i - k + <span class="hljs-number">1</span>) queue.<span class="hljs-built_in">shift</span>();<br>        <span class="hljs-keyword">while</span>(nums[queue[queue.length - <span class="hljs-number">1</span>]] &lt; nums[i]) &#123;<br>            queue.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        queue.<span class="hljs-built_in">push</span>(i);<br>        res.<span class="hljs-built_in">push</span>(nums[queue[<span class="hljs-number">0</span>]])<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面试篇</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>面试之道</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法之递归与回溯思想</title>
    <url>/2021/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF%E6%80%9D%E6%83%B3/</url>
    <content><![CDATA[<h3 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h3><blockquote>
<p>题目：给定一个没有重复数字的序列，返回其所有可能的全排列<br>示例：<br>[<br>[1,2,3],<br>[1,3,2],<br>[2,1,3],<br>[2,3,1],<br>[3,1,2],<br>[3,2,1]<br>]</p>
</blockquote>
<p>思路：重复 ===&gt; 递归 ===&gt; DFS 思想<br><strong>当我们感到变化难以把握时，不如尝试先从不变的东西入手</strong><br>有空这个还要再做做…</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> permute = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> result = [];<br>    <span class="hljs-keyword">let</span> cur = [];  <span class="hljs-comment">// 当前的排列</span><br>    <span class="hljs-keyword">let</span> len = nums.length;<br>    <span class="hljs-keyword">let</span> visited = &#123;&#125;;   <span class="hljs-comment">// 做标记</span><br><br>    <span class="hljs-comment">// 其实这里就是在穷举</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">index</span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (index === len) &#123;<br>            <span class="hljs-comment">// 这里的slice是有学问的！避免仅仅只是地址的传递</span><br>            result.push(cur.slice());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">if</span> (visited[nums[i]]) &#123;   <span class="hljs-comment">// 如果这个坑位被占了，就换下一个</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            visited[nums[i]] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 表明这个值已经用过</span><br>            cur.push(nums[i]);<br>            dfs(index + <span class="hljs-number">1</span>);<br>            cur.pop();<br>            visited[nums[i]] = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 表示当前这个值已经没有再用</span><br>        &#125;<br>    &#125;<br>    dfs(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="子集-力扣-78"><a href="#子集-力扣-78" class="headerlink" title="子集(力扣 78)"></a>子集(力扣 78)</h3><p>这类题 要画图 (一般都是树结构)</p>
<p>掌握得其实不太好…</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> subsets = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<br>    <span class="hljs-comment">// 这里的关键词是“任意顺序”，则 应该采取的是 二叉树 对每个数考虑 取与不取的思路。这个和排列是有区别的</span><br>    <span class="hljs-comment">// 思考树该怎么画！</span><br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-keyword">const</span> cur = [];<br>    <span class="hljs-keyword">const</span> len = nums.length;<br>    <span class="hljs-comment">// 还是深度遍历的思路</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">level</span>) </span>&#123;<br>        res.push(cur.slice()); <span class="hljs-comment">// 注意这里！不是到底才放入res里</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = level; i &lt; len; i++) &#123;<br>            cur.push(nums[i]);<br>            dfs(i + <span class="hljs-number">1</span>);<br>            cur.pop();<br>        &#125;<br>    &#125;<br><br>    dfs(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><blockquote>
<p>题目(力扣 77)：给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> combine = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n, k</span>) </span>&#123;<br>    <span class="hljs-comment">// 这里又是无视元素的顺序  所以又是 取 与 不取的关系</span><br>    <span class="hljs-comment">// 在子集那道题的基础上会加上一些限制</span><br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-keyword">const</span> cur = [];<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">level</span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur.length === k) &#123;    <span class="hljs-comment">// 新加的限制</span><br>            res.push(cur.slice());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = level; i &lt; n; i++) &#123;<br>            cur.push(i + <span class="hljs-number">1</span>);<br>            dfs(i + <span class="hljs-number">1</span>);<br>            cur.pop();<br>        &#125;<br>    &#125;<br>    dfs(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="回溯："><a href="#回溯：" class="headerlink" title="回溯："></a>回溯：</h3><p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就 “回溯” 返回，尝试别的路径<br>回溯算法的<strong>基本思想</strong>是：从一条路往前走，能进则进，不能进则退回来，换一条路再试</p>
<p>DFS 算法其实就是回溯思想的体现</p>
<h4 id="回溯什么时候用"><a href="#回溯什么时候用" class="headerlink" title="回溯什么时候用"></a>回溯什么时候用</h4><p>看两个特征：</p>
<p>题目中暗示了一个或多个解，并且要求我们详尽地列举出每一个解的内容时，一定要想到 DFS、想到递归回溯。<br>题目经分析后，可以转化为树形逻辑模型求解。</p>
<h4 id="回溯为什么这样用"><a href="#回溯为什么这样用" class="headerlink" title="回溯为什么这样用"></a>回溯为什么这样用</h4><p>递归与回溯的过程，本身就是<strong>穷举</strong>的过程。题目中要求我们列举每一个解的内容，解从哪来？解是基于穷举思想、对搜索树进行恰当地剪枝后得来的。</p>
<h4 id="回溯模板"><a href="#回溯模板" class="headerlink" title="回溯模板"></a>回溯模板</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">xxx</span>(<span class="hljs-params">入参</span>) </span>&#123;<br>  前期的变量定义、缓存等准备工作<br><br>  <span class="hljs-comment">// 定义路径栈</span><br>  <span class="hljs-keyword">const</span> path = []<br><br>  <span class="hljs-comment">// 进入 dfs</span><br>  dfs(起点)<br><br>  <span class="hljs-comment">// 定义 dfs</span><br>  <span class="hljs-function"><span class="hljs-title">dfs</span>(<span class="hljs-params">递归参数</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span>(到达了递归边界) &#123;<br>      结合题意处理边界逻辑，往往和 path 内容有关<br>      <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 注意这里也可能不是 for，视题意决定</span><br>    <span class="hljs-keyword">for</span>(遍历坑位的可选值) &#123;<br>      path.push(当前选中值)<br>      处理坑位本身的相关逻辑<br>      path.pop()<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面试篇</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>面试之道</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法之链表</title>
    <url>/2021/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>双指针： 关键字-&gt;“有序”和“数组”-&gt;双指针如果不行就用对撞指针！</p>
<p>二分查找问题: …</p>
<p>链表题型三类：</p>
<ul>
<li>链表的处理：合并、删除等(删除重点！)</li>
<li>链表的反转及其衍生题目</li>
<li>链表成环问题及其衍生题目</li>
</ul>
<h3 id="链表的合并"><a href="#链表的合并" class="headerlink" title="链表的合并"></a>链表的合并</h3><blockquote>
<p>题目(力扣 21)：将两个<strong>有序链表</strong>合并为一个新的<strong>有序链表</strong>并返回。新链表是通过拼接给定的两个链表的所有结点组成的。</p>
</blockquote>
<blockquote>
<p>示例：输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4 输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
</blockquote>
<p>解析：<strong>处理链表的本质，是处理链表结点之间的指针关系</strong>。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">var mergeTwoLists = <span class="hljs-keyword">function</span>(list1, list2) &#123;<br>    let head = new ListNode();   <span class="hljs-regexp">//</span> 创建一个头结点, 并标记了起始位置<br><br>    let cur = head;<br>    <span class="hljs-keyword">while</span>(list1 &amp;&amp; list2) &#123;<br>        <span class="hljs-keyword">if</span> (list1.val &lt;= list2.val) &#123;<br>            cur.<span class="hljs-keyword">next</span> = list1;<br>            list1 = list1.<span class="hljs-keyword">next</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur.<span class="hljs-keyword">next</span> = list2;<br>            list2 = list2.<span class="hljs-keyword">next</span>;<br>        &#125;<br>    cur = cur.<span class="hljs-keyword">next</span>;  <span class="hljs-regexp">//</span> 注意：cur 只是一个用来存储地址的变量而已，故cur = cur.<span class="hljs-keyword">next</span> 只是在移动位置 而 cur.<span class="hljs-keyword">next</span> = ... 的操作却是在空间层面上起作用<br>    &#125;<br><br>    <span class="hljs-regexp">//</span> 这里的代码可以如下化简<br>    <span class="hljs-regexp">//</span> <span class="hljs-keyword">if</span> (list1 == null) cur.<span class="hljs-keyword">next</span> = list2;<br>    <span class="hljs-regexp">//</span> <span class="hljs-keyword">if</span> (list2 == null) cur.<span class="hljs-keyword">next</span> = list1;<br><br>    <span class="hljs-regexp">//</span> 化简为：<br>    cur.<span class="hljs-keyword">next</span> = list1 == null ? list2 : list1;<br><br>    return head.<span class="hljs-keyword">next</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="链表的删除"><a href="#链表的删除" class="headerlink" title="链表的删除"></a>链表的删除</h3><blockquote>
<p>题目(力扣 83) 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次<br>示例 ：<br>输入: 1-&gt;1-&gt;2<br>输出: 1-&gt;2<br>示例 2:<br>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>输出: 1-&gt;2-&gt;3</p>
</blockquote>
<p>思路：将需要删除的目标结点的前驱结点 next 指针往后指一格</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">var deleteDuplicates = <span class="hljs-keyword">function</span>(head) &#123;<br>    let cur = head;<br>    <span class="hljs-keyword">while</span> (cur?.<span class="hljs-keyword">next</span>) &#123;   <span class="hljs-regexp">//</span> 这里的?.用得其实挺好(注意cur不存在的情况)<br>        <span class="hljs-keyword">if</span> (cur.val === cur.<span class="hljs-keyword">next</span>.val) &#123;<br>            <span class="hljs-regexp">//</span> 跳过这个重复节点， 注意：如果是连续删除多个值 这里的 cur 是没有变化的！只是cur.<span class="hljs-keyword">next</span> 在不断变化<br>            cur.<span class="hljs-keyword">next</span> = cur.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur = cur.<span class="hljs-keyword">next</span>;  <span class="hljs-regexp">//</span> 移动位置<br>        &#125;<br>    &#125;<br>    return head;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="链表的删除-2"><a href="#链表的删除-2" class="headerlink" title="链表的删除 2"></a>链表的删除 2</h3><blockquote>
<p>题目(力扣 82) 给定一个排序链表，删除所有含有重复数字的结点，只保留原始链表中 没有重复出现的数字。</p>
</blockquote>
<blockquote>
<p>示例<br>输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br>输出: 1-&gt;2-&gt;5<br>示例 2:<br>输入: 1-&gt;1-&gt;1-&gt;2-&gt;3<br>输出: 2-&gt;3</p>
</blockquote>
<p>思路：制造一个 <code>dummy</code> 节点。 注意：dummy 永远指向头结点</p>
<p>注意：在实际做链表的题的时候，就算 <code>dummy</code> 没有发挥作用，也可以写一个来作为保险！</p>
<p><strong>此题我掌握得不是太好</strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">var deleteDuplicates = <span class="hljs-keyword">function</span>(head) &#123;<br><br>    <span class="hljs-regexp">//</span> 排除极端情况(<span class="hljs-number">0</span>个节点或一个结点)<br>    <span class="hljs-keyword">if</span> (!head || !head.<span class="hljs-keyword">next</span>) &#123;<br>        return head;<br>    &#125;<br><br>    let dummy = new ListNode();  <span class="hljs-regexp">//</span> 自己创建一个dummy节点作为前驱结点(用来挑刺)<br>    dummy.<span class="hljs-keyword">next</span> = head;      <span class="hljs-regexp">//</span> 注意：dummy 永远指向头结点<br><br>    let cur = dummy;    <span class="hljs-regexp">//</span> cur 从dummy结点开始遍历<br><br>    <span class="hljs-regexp">//</span> 因为cur是从dummy开始遍历的，所以视野会更远(可以看两个结点)<br>    <span class="hljs-keyword">while</span> (cur.<span class="hljs-keyword">next</span> &amp;&amp; cur.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>) &#123;<br>        <span class="hljs-keyword">if</span> (cur.<span class="hljs-keyword">next</span>.val === cur.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>.val) &#123;<br>            let val = cur.<span class="hljs-keyword">next</span>.val;   <span class="hljs-regexp">//</span> 记住这个值<br>            <span class="hljs-regexp">//</span> 看后续是否还有这样重复的值 ----&gt; 为什么对比力扣<span class="hljs-number">83</span>题 这里多了 <span class="hljs-keyword">while</span> ？ 因为是要删掉重复的所有值<br>            <span class="hljs-keyword">while</span> (cur?.<span class="hljs-keyword">next</span>?.val === val) &#123;<br>                <span class="hljs-regexp">//</span> 这里的cur是没有变化的，变化的是cur.<span class="hljs-keyword">next</span><br>                cur.<span class="hljs-keyword">next</span> = cur.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur = cur.<span class="hljs-keyword">next</span>;<br>        &#125;<br>    &#125;<br><br>    return dummy.<span class="hljs-keyword">next</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="快慢指针-与-多指针"><a href="#快慢指针-与-多指针" class="headerlink" title="快慢指针 与 多指针"></a>快慢指针 与 多指针</h2><p>链表题目中一种坑爹类型： 反复遍历<br>涉及反复遍历的题目，一个明显的特征，会涉及相对复杂的链表操作(反转、指定位置的删除等)</p>
<p>快慢指针指的是两个一前一后的指针，两个指针往同一个方向走，只是一个快一个慢。快慢指针严格来说只能有俩，不过实际做题中，可能会出现一前、一中、一后的三个指针，这种超过两个指针的解题方法也叫“多指针法”</p>
<p>快慢指针+多指针，双管齐下，可以帮助我们解决链表中的大部分复杂操作问题</p>
<h3 id="删除链表的倒数第-N-个结点"><a href="#删除链表的倒数第-N-个结点" class="headerlink" title="删除链表的倒数第 N 个结点"></a>删除链表的倒数第 N 个结点</h3><blockquote>
<p>真题(力扣 19)：给定一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点<br>示例：<br>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br>当删除了倒数第二个结点后，链表变为 1-&gt;2-&gt;3-&gt;5.</p>
</blockquote>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 这种就直接使用 快慢指针来解决(养成个好习惯！再搭配一个dummy 作为头指针的前驱结点)<br>var removeNthFromEnd = <span class="hljs-keyword">function</span>(head, n) &#123;<br>    let dummy = new ListNode();<br>    dummy.<span class="hljs-keyword">next</span> = head;<br><br>    <span class="hljs-regexp">//</span> 排除极限情况(只有一个节点) --&gt; 如果是 return head，就要这样写，如果是return dummy.<span class="hljs-keyword">next</span> 就不用这样写<br>    <span class="hljs-regexp">//</span> <span class="hljs-keyword">if</span>(!head.<span class="hljs-keyword">next</span>) &#123;<br>    <span class="hljs-regexp">//</span>     return null;<br>    <span class="hljs-regexp">//</span> &#125;<br><br><br>    <span class="hljs-regexp">//</span> 创建快慢指针(并且都从 dummy 结点开始出发)<br>    let fast = dummy;<br>    let slow = dummy;<br><br>    let count = <span class="hljs-number">0</span>;<br>    <span class="hljs-regexp">//</span> 让快指针提前走n步(目的是为了保证，之后快慢指针一起走的时候，快指针到尾部恰巧慢指针到达倒数第n个的前一个位置)<br>    <span class="hljs-keyword">while</span>(count &lt; n) &#123;<br>        fast = fast.<span class="hljs-keyword">next</span>;<br>        count++;<br>    &#125;<br><br>    <span class="hljs-regexp">//</span> 现在快慢指针开始同时走<br>    <span class="hljs-keyword">while</span>(fast.<span class="hljs-keyword">next</span>) &#123;<br>        fast = fast.<span class="hljs-keyword">next</span>;<br>        slow = slow.<span class="hljs-keyword">next</span>;<br>    &#125;<br><br>    <span class="hljs-regexp">//</span> 此时，slow指针就在倒数第n给结点的前一个位置上<br>    <span class="hljs-regexp">//</span> 开始删除第n个结点<br>    slow.<span class="hljs-keyword">next</span> = slow.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br><br>    <span class="hljs-regexp">//</span> return head;<br>    return dummy.<span class="hljs-keyword">next</span>;   <span class="hljs-regexp">//</span> 不用返回head，不然要考虑head只有<span class="hljs-number">1</span>个结点的情况<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="多指针法-—-链表的反转"><a href="#多指针法-—-链表的反转" class="headerlink" title="多指针法 — 链表的反转"></a>多指针法 — 链表的反转</h3><blockquote>
<p>真题(力扣 206)：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点<br>示例：<br>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
</blockquote>
<p>核心思想：处理链表的本质，是处理链表结点之间的指针关系</p>
<p>注意：这里不太适合使用 <code>dummy</code> 结点。毕竟 <code>dummy</code> 结点是不能动的，一反转结果还让尾部长了一截</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 多指针大法<br>var reverseList = <span class="hljs-keyword">function</span>(head) &#123;<br>  <span class="hljs-regexp">//</span> 设置前 中 后三个指针 这三个指针的用处就是当你断掉结点之间的连接的时候，仍有指针给你标记住的不至于找不到被断掉的指针<br>  let prev = null;<br>  let cur = head;<br>  <span class="hljs-regexp">//</span> let after = head.<span class="hljs-keyword">next</span>;    <span class="hljs-regexp">//</span> 问题&amp;<br><br>  <span class="hljs-regexp">//</span> 考虑极限情况  没有结点 或 只有一个节点的情况<br>  <span class="hljs-keyword">if</span> (!head || !head.<span class="hljs-keyword">next</span>) return head;<br><br>  <span class="hljs-keyword">while</span>(cur) &#123;<br>    let after = cur.<span class="hljs-keyword">next</span>;<br><br>      <span class="hljs-regexp">//</span> 进行反转<br>      <span class="hljs-regexp">//</span>   after.<span class="hljs-keyword">next</span> = cur;   <span class="hljs-regexp">//</span> 问题&amp;<br>      cur.<span class="hljs-keyword">next</span> = prev;<br><br>      <span class="hljs-regexp">//</span> 前 中 后指针全部往后移动一个位置<br>      prev = cur;<br>      cur = after;<br>      <span class="hljs-regexp">//</span> after = after?.<span class="hljs-keyword">next</span>;  <span class="hljs-regexp">//</span> 对照上面的问题&amp; 标记 这里是死循环，不能这样搞 因为after.<span class="hljs-keyword">next</span> 已经连接到cur了！<br>  &#125;<br>  return prev;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="局部反转链表"><a href="#局部反转链表" class="headerlink" title="局部反转链表"></a>局部反转链表</h3><blockquote>
<p>真题(力扣)：反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p>
</blockquote>
<p>中指针开头， 前指针结尾 并且要记住 m 的前一个结点</p>
<p>注意：此题因为不需要整个链表反转，所以可以加一个 dummy 结点<br>示例：<br>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4<br>输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</p>
<p>算法题 特别是链表 还是要画个图！</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"> ——<br>A  B 出现这种 circle 结点是不行的! 这样 <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span>next = B  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>next = A 无穷无尽...<br> ——<br></code></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">var reverseBetween = <span class="hljs-keyword">function</span>(head, left, right) &#123;<br>    <span class="hljs-regexp">//</span> 因为不是整个链表旋转，所以可以来一个dummy结点<br>    let dummy = new ListNode();<br>    dummy.<span class="hljs-keyword">next</span> = head;<br><br>    let prevLeft = dummy;   <span class="hljs-regexp">//</span> 用于标记left的前驱结点的下标<br>    <span class="hljs-regexp">//</span> 因为本质上是链表的反转，所以仍需要前中后指针<br>    let prev = dummy;<br>    let cur = head;<br><br>    <span class="hljs-regexp">//</span> 总共要反转的数量<br>    let index = right - left; <span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br><br>    <span class="hljs-regexp">//</span> 先让prev，cur，prevLeft 到达目标位置<br>    <span class="hljs-keyword">while</span>(left &gt; <span class="hljs-number">0</span>) &#123;    <span class="hljs-regexp">//</span> 每循环一次  left -<span class="hljs-number">1</span><br>        prev = prev.<span class="hljs-keyword">next</span>; <span class="hljs-regexp">//</span> 前进一步<br>        <span class="hljs-keyword">if</span> (left &gt; <span class="hljs-number">1</span>) &#123;<br>            prevLeft = prevLeft.<span class="hljs-keyword">next</span>;<br>        &#125;<br>        cur = cur.<span class="hljs-keyword">next</span>;<br>        left = left - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-regexp">//</span> 此时，prevLeft 已经到达left的前驱位置了，所以不必再动！<br><br>    <span class="hljs-regexp">//</span> 先把prev 的<span class="hljs-keyword">next</span> 变为null 目的是防止 circle结点的出现！<br>    <span class="hljs-regexp">//</span> 所谓circle结点即<br>    <span class="hljs-regexp">//</span>  --<br>    <span class="hljs-regexp">//</span> o  o<br>    <span class="hljs-regexp">//</span>  --<br>    prev.<span class="hljs-keyword">next</span> = null;<br><br>    <span class="hljs-regexp">//</span> 开始进行反转<br>    <span class="hljs-keyword">while</span>(index &gt; <span class="hljs-number">0</span>) &#123;<br>        let after = cur.<span class="hljs-keyword">next</span>;   <span class="hljs-regexp">//</span> 在<span class="hljs-keyword">while</span>循环中创建 后指针<br>        cur.<span class="hljs-keyword">next</span> = prev;<br><br>        prev = cur;<br>        cur = after;<br>        index = index - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-regexp">//</span> 即最开始 left 指针 指向的那个结点 将指向right的右边一个结点 (即示例的 <span class="hljs-number">2</span> 连接 <span class="hljs-number">5</span>)<br>    prevLeft.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> = cur;<br>    <span class="hljs-regexp">//</span> 即prevLeft指针所指结点连接right指针指向的结点 (即示例的<span class="hljs-number">1</span> 连接 <span class="hljs-number">4</span>)<br>    prevLeft.<span class="hljs-keyword">next</span> = prev;<br><br>    return dummy.<span class="hljs-keyword">next</span>;    <span class="hljs-regexp">//</span> 因为有dummy结点，所以以dummy.<span class="hljs-keyword">next</span> 的方式作为返回值是最好的！<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="环形链表-成环问题非常简单，抓住关键点-flag"><a href="#环形链表-成环问题非常简单，抓住关键点-flag" class="headerlink" title="环形链表 (成环问题非常简单，抓住关键点 flag)"></a>环形链表 (成环问题非常简单，抓住关键点 flag)</h2><h3 id="判断链表是否成环"><a href="#判断链表是否成环" class="headerlink" title="判断链表是否成环"></a>判断链表是否成环</h3><blockquote>
<p>题目(力扣 141)：给定一个链表，判断链表中是否有环<br>示例：<br>[3,2,0,4]（链表结构如下图） 输出：true</p>
</blockquote>
<figure class="highlight xquery"><table><tr><td class="code"><pre><code class="hljs xquery">var hasCycle = <span class="hljs-keyword">function</span><span class="hljs-built_in">(head</span>) &#123;<br>    // 此题没必要给链表一个dummy结点  但会对结点进行属性的增添<br><br>    while<span class="hljs-built_in">(head</span>) &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">(head</span>.flag) &#123;   // flag要么是undefined 要么<span class="hljs-built_in">为true</span>则说明是成环了的<br>            <span class="hljs-keyword">return</span><span class="hljs-built_in"> true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-built_in"> head</span>.flag =<span class="hljs-built_in"> true</span>; // <span class="hljs-built_in">给head</span>结点注入 flag 属性 下次只要被检查出来结点有flag属性，则<br>           <span class="hljs-built_in"> head</span> =<span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span>;  // 往后走<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><span class="hljs-built_in"> false</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="定位环的起点"><a href="#定位环的起点" class="headerlink" title="定位环的起点"></a>定位环的起点</h3><blockquote>
<p>题目(力扣 142) 给定一个链表，返回链表开始入环的第一个结点。 如果链表无环，则返回 null</p>
</blockquote>
<figure class="highlight xquery"><table><tr><td class="code"><pre><code class="hljs xquery">var detectCycle = <span class="hljs-keyword">function</span><span class="hljs-built_in">(head</span>) &#123;<br>    while<span class="hljs-built_in">(head</span>) &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">(head</span>.flag) &#123;<br>            // <span class="hljs-keyword">delete</span><span class="hljs-built_in"> head</span>.flag 这个属性减不减掉都没什么关系<br>            <span class="hljs-keyword">return</span><span class="hljs-built_in"> head</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-built_in"> head</span>.flag =<span class="hljs-built_in"> true</span>;   // 即使加了一个新的属性也没什么影响<br>           <span class="hljs-built_in"> head</span> =<span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> null;<br>&#125;;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面试篇</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>面试之道</tag>
      </tags>
  </entry>
  <entry>
    <title>有效括号问题</title>
    <url>/2021/10/07/%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">/**<br> * 题目描述：给定一个只包括<span class="hljs-string">&#x27;(&#x27;</span>, <span class="hljs-string">&#x27;)&#x27;</span>, <span class="hljs-string">&#x27;&#123;&#x27;</span>, <span class="hljs-string">&#x27;&#125;&#x27;</span>, <span class="hljs-string">&#x27;[&#x27;</span>, <span class="hljs-string">&#x27;]&#x27;</span>的字符串,判断字符串是否有效<br> *<br> * 记住一个规律： 括号成立 意味着 对称性<br> */<br><br><span class="hljs-regexp">//</span> 括号问题，我们一般首选栈来做    ----&gt;   对称性<br><br><span class="hljs-regexp">//</span> 用一个map来维护左括号和右括号的对应关系<br><span class="hljs-regexp">//</span> map 关系真的非常的好用<br><span class="hljs-regexp">//</span> const leftToRight = &#123;<br><span class="hljs-regexp">//</span>   <span class="hljs-string">&quot;(&quot;</span>:<span class="hljs-string">&quot;)&quot;</span>,<br><span class="hljs-regexp">//</span>   <span class="hljs-string">&quot;&#123;&quot;</span>:<span class="hljs-string">&quot;&#125;&quot;</span>,<br><span class="hljs-regexp">//</span>   <span class="hljs-string">&quot;[&quot;</span>:<span class="hljs-string">&quot;]&quot;</span><br><span class="hljs-regexp">//</span> &#125;<br><br><span class="hljs-regexp">//</span> /**<br><span class="hljs-regexp">//</span>  * @param &#123;string&#125; s<br><span class="hljs-regexp">//</span>  * @return &#123;boolean&#125;<br><span class="hljs-regexp">//</span>  */<br><br><span class="hljs-regexp">//</span> <span class="hljs-regexp">//</span> 有些细节 我<br><span class="hljs-regexp">//</span> const isValid = <span class="hljs-keyword">function</span>(s) &#123;<br><span class="hljs-regexp">//</span>   <span class="hljs-regexp">//</span> 结合题意，空字符串无条件判断为 true<br><span class="hljs-regexp">//</span>   <span class="hljs-keyword">if</span> (!s) &#123;<br><span class="hljs-regexp">//</span>     return true;<br><span class="hljs-regexp">//</span>   &#125;<br><span class="hljs-regexp">//</span>   <span class="hljs-regexp">//</span> 初始化 stack 数组<br><span class="hljs-regexp">//</span>   const stack = [];<br><span class="hljs-regexp">//</span>   <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;<br><span class="hljs-regexp">//</span>     <span class="hljs-keyword">if</span> (s[i] === <span class="hljs-string">&#x27;(&#x27;</span> || s[i] === <span class="hljs-string">&#x27;&#123;&#x27;</span> || s[i] === <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br><span class="hljs-regexp">//</span>       stack.push(leftToRight[s[i]])<br><span class="hljs-regexp">//</span>     &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-regexp">//</span>       <span class="hljs-regexp">//</span> 但是人家写的是!stack.length || stack.pop() !== ch  好奇怪...<br><span class="hljs-regexp">//</span>       <span class="hljs-keyword">if</span> (stack.pop() !== s[i]) &#123;<br><span class="hljs-regexp">//</span>         return false;<br><span class="hljs-regexp">//</span>       &#125;<br><span class="hljs-regexp">//</span>     &#125;<br><span class="hljs-regexp">//</span>   &#125;<br><span class="hljs-regexp">//</span>   <span class="hljs-regexp">//</span> 若所有的括号都能配对成功，那么最后栈应该是空的<br><span class="hljs-regexp">//</span>   <span class="hljs-regexp">//</span> return !stack.length;<br><br><span class="hljs-regexp">//</span>   return true;<br><span class="hljs-regexp">//</span> &#125;<br><br><br><br><span class="hljs-regexp">//</span> 注意： ))))(((( 这种是错误的。左括号必须以正确的顺序闭合<br><br><span class="hljs-regexp">//</span> 对象映射大法 ----&gt;  注意！变量名千万搞错不能出错, 有时要好好检查检查自己的变量名...<br>const leftToRight = &#123;<br>  <span class="hljs-string">&quot;&#123;&quot;</span>:<span class="hljs-string">&quot;&#125;&quot;</span>,<br>  <span class="hljs-string">&quot;(&quot;</span>:<span class="hljs-string">&quot;)&quot;</span>,<br>  <span class="hljs-string">&quot;[&quot;</span>:<span class="hljs-string">&quot;]&quot;</span><br>&#125;<br><br><br><span class="hljs-regexp">//</span> 我自己想到一个方法。设置两个栈。一个栈放入左侧符号的映射。  一个栈放入右侧符号。 两个栈进行一一对比<br>const isValid = (str) =&gt; &#123;<br>  const stack = [];<br>  <span class="hljs-regexp">//</span> 数组缓存<br>  let len = str.length;<br><br>  <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>    <span class="hljs-keyword">if</span> (str[i] === <span class="hljs-string">&#x27;&#123;&#x27;</span> || str[i] === <span class="hljs-string">&#x27;[&#x27;</span> || str[i] === <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>      stack.push(leftToRight[str[i]]);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stack.length !== <span class="hljs-number">0</span> &amp;&amp; str[i] === stack[stack.length - <span class="hljs-number">1</span>]) &#123;<br>      stack.pop();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stack.length === <span class="hljs-number">0</span>) &#123;<br>      return false;<br>    &#125;<br>  &#125;<br>  return stack.length === <span class="hljs-number">0</span>;<br>&#125;<br><br>console.log(<span class="hljs-string">&#x27;test&#x27;</span>, isValid(<span class="hljs-string">&#x27;()[]&#123;&#125;&#x27;</span>));<br></code></pre></td></tr></table></figure>

<head>
  ..
  <script src="//cdn.jsdelivr.net/npm/@waline/client"></script>
  ...
</head>
<body>
  ...
  <div id="waline"></div>
  <script>
    Waline({
      el: '#waline',
       avatar: 'monsterid',
      serverURL: 'https://blog-api-9sizcti78-bruce-shuai.vercel.app/',
    });
  </script>
</body>
]]></content>
  </entry>
  <entry>
    <title>浅拷贝和深拷贝</title>
    <url>/2021/10/08/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<blockquote>
<p>前置知识：值赋值和引用赋值就不再赘述了, 相对而言挺基础的…</p>
</blockquote>
<p>我已知的能够在<code>js</code>里实现<code>拷贝</code>的 3 种现成方法 🧐</p>
<h4 id="3-种现成的实现浅拷贝的方法"><a href="#3-种现成的实现浅拷贝的方法" class="headerlink" title="3 种现成的实现浅拷贝的方法"></a>3 种现成的实现浅拷贝的方法</h4><h5 id="1-JSON-大法"><a href="#1-JSON-大法" class="headerlink" title="1. JSON 大法"></a>1. JSON 大法</h5><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// json大法</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 优点：最简单的实现深拷贝的方式</span><br><span class="hljs-comment"> * 缺点：</span><br><span class="hljs-comment"> * 支持的数据类型：String/Number/Boolean/Object/Array/null</span><br><span class="hljs-comment"> * 不支持的类型： undefined/Symbol/循环引用/函数/Date/RegExp</span><br><span class="hljs-comment"> */</span><br><br> <span class="hljs-keyword">const</span> obj1 = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">100</span>, <span class="hljs-attr">b</span>: &#123;<span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;123&#x27;</span>&#125;&#125;<br> <span class="hljs-keyword">const</span> obj2 = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(obj1))<br> <span class="hljs-built_in">console</span>.log(obj1 === obj2) <span class="hljs-comment">// false</span><br> 个人评价：事实上，<span class="hljs-number">90</span>%的情况下，上述方法已经够用了，一般不支持的类型这种用得少...<br></code></pre></td></tr></table></figure>

<h5 id="2-Object-assign-–-gt-浅拷贝-其实和解构方法一样：-…obj"><a href="#2-Object-assign-–-gt-浅拷贝-其实和解构方法一样：-…obj" class="headerlink" title="2.Object.assign() –&gt; 浅拷贝 (其实和解构方法一样：{…obj})"></a>2.Object.assign() –&gt; 浅拷贝 (其实和解构方法一样：{…obj})</h5><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj3 = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-attr">sorce</span>: [<span class="hljs-number">88</span>, <span class="hljs-number">100</span>]&#125;<br><span class="hljs-keyword">var</span> obj4 = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, obj3)  <span class="hljs-comment">// obj1 与 &#123;&#125; 合并， 内部的引用还是一样的</span><br><span class="hljs-built_in">console</span>.log(obj3 === obj4) <span class="hljs-comment">// false</span><br><br>个人评价： 用法方便简单，但是注意是浅拷贝，在做一些项目的时候，需要有清晰的脑袋知道自己是在做深拷贝还是浅拷贝<br></code></pre></td></tr></table></figure>

<h5 id="3-Lodash-库"><a href="#3-Lodash-库" class="headerlink" title="3.Lodash 库"></a>3.Lodash 库</h5><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// _.clone     浅拷贝</span><br><span class="hljs-comment">// _.deepclone 深拷贝</span><br><span class="hljs-keyword">var</span> obj5 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-attr">sorce</span>: [<span class="hljs-number">88</span>, <span class="hljs-number">100</span>]&#125;<br><span class="hljs-keyword">var</span> obj6 = _.cloneDeep(obj5);<br><span class="hljs-built_in">console</span>.log(obj5 === obj6)<br><br>个人评价： 不用说，牛逼！<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="深拷贝实现"><a href="#深拷贝实现" class="headerlink" title="深拷贝实现"></a>深拷贝实现</h4><h5 id="本套深拷贝实现方法前置知识"><a href="#本套深拷贝实现方法前置知识" class="headerlink" title="本套深拷贝实现方法前置知识"></a>本套深拷贝实现方法前置知识</h5><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// obj1 为一个普通对象</span><br><span class="hljs-keyword">let</span> obj1 = &#123;<br> <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span>,<br> <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;男&#x27;</span>,<br> <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br> <span class="hljs-attr">friends</span>: [<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-string">&#x27;小玉&#x27;</span>, <span class="hljs-string">&#x27;小萌&#x27;</span>]<br>&#125;<br><br><span class="hljs-comment">// 创建一个空对象 obj2</span><br><span class="hljs-keyword">let</span> obj2 = &#123;&#125;<br><span class="hljs-comment">// 依次将obj1对象里的属性赋值到obj2里(注意，要判断obj1里的属性是普通类型(值类型)还是引用类型)</span><br><span class="hljs-comment">// 值类型 直接复制。如果是引用类型还需要再深层进入引用类型中找到人家的值类型(递归大法)</span><br>obj2.name = obj1.name   <span class="hljs-comment">// 是否为普通类型</span><br>obj2.sex = obj1.sex     <span class="hljs-comment">// 是否为普通类型</span><br>obj2.age = obj1.age     <span class="hljs-comment">// 是否为普通类型</span><br>obj2.friends = obj1.friends <span class="hljs-comment">// 遍历循环obj1friends。返回新的friends</span><br><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 数据类型</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * typeof 1      // &quot;number&quot;</span><br><span class="hljs-comment"> * typeof &quot;a&quot;    // &quot;string&quot;</span><br><span class="hljs-comment"> * typeof true   // &quot;boolean&quot;</span><br><span class="hljs-comment"> * typeof &#123;&#125;     // &quot;object&quot;</span><br><span class="hljs-comment"> * typeof []     // &quot;object&quot;</span><br><span class="hljs-comment"> * typeof null   // &quot;object&quot;   &lt;---  这里容易产生误会</span><br><span class="hljs-comment"> * typeof undefined      // &quot;undefined&quot;</span><br><span class="hljs-comment"> * typeof function()&#123;&#125;   // &quot;function&quot;</span><br><span class="hljs-comment"> * typeof Symbol()       // &quot;symbol&quot;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Object.prototype.toString.call(1)         // &#x27;[object Number]&#x27;</span><br><span class="hljs-comment"> * Object.prototype.toString.call(&#x27;a&#x27;)       // &#x27;[object String]&#x27;</span><br><span class="hljs-comment"> * Object.prototype.toString.call(true)      // &#x27;[object Boolean]&#x27;</span><br><span class="hljs-comment"> * Object.prototype.toString.call(&#123;&#125;)        // &#x27;[object Object]&#x27;</span><br><span class="hljs-comment"> * Object.prototype.toString.call([])        // &#x27;[object Array]&#x27;</span><br><span class="hljs-comment"> * Object.prototype.toString.call(null)      // &#x27;[object Null]&#x27;</span><br><span class="hljs-comment"> * Object.prototype.toString.call(/a/)       // &#x27;[object RegExp]&#x27;</span><br><span class="hljs-comment"> * Object.prototype.toString.call(undefined) // &#x27;[object Undefined]&#x27;</span><br><span class="hljs-comment"> * Object.prototype.toString.call(function()&#123;&#125;)  // &#x27;[object Function]&#x27;</span><br><span class="hljs-comment"> * Object.prototype.toString.call(new Date())    // &#x27;[object Date]&#x27;</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>

<h5 id="开始实现深拷贝"><a href="#开始实现深拷贝" class="headerlink" title="开始实现深拷贝"></a>开始实现深拷贝</h5><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> deepClone = <span class="hljs-function">(<span class="hljs-params">src</span>) =&gt;</span> &#123;<br>  &lt;!-- 表示从下标为<span class="hljs-number">8</span>的元素开始一直裁剪到倒数第一个元素之前 --&gt;<br>  <span class="hljs-keyword">let</span> type = <span class="hljs-built_in">Object</span>.prototype.toString.call(src).slice(<span class="hljs-number">8</span>, -<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">let</span> dist = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&#x27;Number&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> src;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&#x27;String&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> src;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&#x27;Boolean&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> src;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&#x27;Object&#x27;</span>) &#123;<br>    dist = &#123;&#125;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&#x27;Array&#x27;</span>) &#123;<br>    dist = []<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&#x27;Function&#x27;</span>) &#123;<br>    <span class="hljs-comment">// ... 这个挺有困惑的</span><br>    dist = src.bind(<span class="hljs-built_in">this</span>);   <span class="hljs-comment">// 生成了一个新的函数，this指向的是什么</span><br>  &#125;<br>  <span class="hljs-comment">// let...in用法  和  let...of用法</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> src) &#123;<br>    dist[key] = deepClone(src[key]);<br>  &#125;<br>  <span class="hljs-keyword">return</span> dist;<br>&#125;<br><br><span class="hljs-keyword">let</span> obj1 = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;100&#x27;</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-string">&#x27;200&#x27;</span>,<br>  <span class="hljs-attr">c</span>: &#123;<span class="hljs-attr">d</span>: <span class="hljs-string">&#x27;300&#x27;</span>, <span class="hljs-attr">e</span>: &#123;<span class="hljs-attr">f</span>: <span class="hljs-string">&#x27;500&#x27;</span>&#125;&#125;,<br>  <span class="hljs-attr">fn</span>: <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;this is a function&#x27;</span>)&#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> obj2 = deepClone(obj1);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;obj1 === obj2 ?&#x27;</span>, obj1 === obj2);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;obj2&#x27;</span>, obj2);<br><br></code></pre></td></tr></table></figure>

<head>
  ..
  <script src="//cdn.jsdelivr.net/npm/@waline/client"></script>
  ...
</head>
<body>
  ...
  <div id="waline"></div>
  <script>
    Waline({
      el: '#waline',
       avatar: 'monsterid',
      serverURL: 'https://blog-api-9sizcti78-bruce-shuai.vercel.app/',
    });
  </script>
</body>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器工作原理与实践</title>
    <url>/2021/12/25/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p><a href="https://blog.poetries.top/browser-working-principle/guide/part1/lesson01.html#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B">网址</a></p>
<h3 id="进程-和-线程"><a href="#进程-和-线程" class="headerlink" title="进程 和 线程"></a>进程 和 线程</h3><p><strong>并行处理</strong>：计算机中的并行处理就是<strong>同一时刻</strong>处理多个任务</p>
<p>多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的</p>
<p><strong>进程</strong>：所谓进程即一个程序的运行实例。详细解释即：启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫做进程 (关键字：程序、数据存储、主线程、运行环境)</p>
<p>(线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率)</p>
<p>进程和线程之间的关系有以下4个特点</p>
<ol>
<li>进程中的任意一线程执行出错，都会导致整个进程的崩溃</li>
<li>线程之间共享进程中的数据</li>
<li>当一个进程关闭之后，操作系统会回收进程所占用的内存(即便是操作不当导致的内存泄露，当进程退出时，这些内存也会被正确回收)</li>
<li>进程之间的内容相互隔离(如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信(IPC)的机制了)</li>
</ol>
<h3 id="单进程浏览器时代"><a href="#单进程浏览器时代" class="headerlink" title="单进程浏览器时代"></a>单进程浏览器时代</h3><p>顾名思义：单进程浏览器指浏览器的所有功能模块都是运行在同一个进程里。(其实在2007年之前，市面上浏览器都是单进程的)</p>
<p>单进程浏览器会出现的问题：</p>
<ul>
<li>不稳定 –&gt; 为了让浏览器功能强大、页面丰富需要借助插件, 渲染引擎(插件、渲染引擎一崩会导致整个浏览器的崩溃) </li>
<li>不流畅 –&gt; 所有页面的渲染模块、JavaScript执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。</li>
<li>不安全 –&gt; 恶意插件能控制电脑</li>
</ul>
<h3 id="多进程浏览器时代"><a href="#多进程浏览器时代" class="headerlink" title="多进程浏览器时代"></a>多进程浏览器时代</h3><p>下图为2008年Chrome发布时的进程架构：<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-01-02-%E4%B8%8B%E5%8D%881.4bmtc56pa1e0.webp" alt="早期Chrome架构"></p>
<p><code>Chrome</code> 的页面是运行在单独的渲染进程中的，同时页面里的插件也是运行在单独的插件进程之中，而进程之间是通过<code>IPC</code>机制进行通信<br>–&gt; 解决不稳定的问题：由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就完美地解决了页面或者插件的崩溃会导致整个浏览器崩溃，也就是不稳定的问题<br>–&gt; 解决不流畅的问题：JavaScript也是运行在渲染进程中的，所以即使JavaScript阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中的。所以当我们再在Chrome中运行上面那个死循环的脚本时，没有响应的仅仅是当前的页面。对于内存泄漏的解决方法那就更简单了，因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄漏问题。<br>–&gt; 解决不安全的问题：多进程架构的额外好处是可以使用<strong>安全沙箱</strong>，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，例如你的文档和桌面。Chrome把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限</p>
<p>当前最新的Chrome的架构<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-01-02-%E4%B8%8B%E5%8D%882.78ajfwf3ark0.webp" alt="最新Chrome架构"><br>从图中可以看出，最新的Chrome浏览器包括：1个浏览器主进程、1个GPU进程、1个网络进程、多个渲染进程(v8引擎就是在此运行，默认情况下Chrome会为每个Tab标签创建一个渲染进程。处于安全考虑，渲染进程都是运行在沙箱模式下)和多个插件进程</p>
]]></content>
  </entry>
  <entry>
    <title>盒子模型</title>
    <url>/2021/11/23/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CSS篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>类型转换</title>
    <url>/2021/11/23/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h3 id="转化为-Number-类型"><a href="#转化为-Number-类型" class="headerlink" title="转化为 Number 类型"></a>转化为 Number 类型</h3><p>使用 Number()方法</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Number</span><span class="hljs-params">(<span class="hljs-string">&#x27;1&#x27;</span>)</span></span>  <span class="hljs-comment">//1</span><br><span class="hljs-function"><span class="hljs-title">Number</span><span class="hljs-params">(true)</span></span> <span class="hljs-comment">//1</span><br><span class="hljs-function"><span class="hljs-title">Number</span><span class="hljs-params">(false)</span></span><span class="hljs-comment">//0</span><br><span class="hljs-function"><span class="hljs-title">Number</span><span class="hljs-params">(undefined)</span></span> <span class="hljs-comment">//NaN</span><br><span class="hljs-function"><span class="hljs-title">Number</span><span class="hljs-params">(null)</span></span> <span class="hljs-comment">//0</span><br><span class="hljs-function"><span class="hljs-title">Number</span><span class="hljs-params">(<span class="hljs-string">&#x27;12s&#x27;</span>)</span></span> <span class="hljs-comment">//NaN</span><br><span class="hljs-function"><span class="hljs-title">Number</span><span class="hljs-params">(<span class="hljs-string">&#x27;s12&#x27;</span>)</span></span> <span class="hljs-comment">//NaN</span><br><span class="hljs-function"><span class="hljs-title">Number</span><span class="hljs-params">(&#123;&#125;)</span></span> <span class="hljs-comment">//NaN</span><br></code></pre></td></tr></table></figure>

<h3 id="类数组的转换"><a href="#类数组的转换" class="headerlink" title="类数组的转换"></a>类数组的转换</h3><p>对于类数组的定义：</p>
<ul>
<li>它必须是一个对象</li>
<li>它有 length 属性</li>
</ul>
<p><strong>按照这个标准，只要有 length 属性的对象就是类数组对象</strong></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">const book = &#123;<br>  <span class="hljs-built_in">name</span>: &#x27;how <span class="hljs-keyword">to</span> <span class="hljs-built_in">read</span> a book&#x27;,<br>  age: <span class="hljs-number">10</span>,<br>  <span class="hljs-built_in">length</span>: <span class="hljs-number">300</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="如何把类数组对象转换为真正的数组？"><a href="#如何把类数组对象转换为真正的数组？" class="headerlink" title="如何把类数组对象转换为真正的数组？"></a>如何把类数组对象转换为真正的数组？</h4><p>真题：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> arrayLike = &#123;<span class="hljs-number">0</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;Lucy&#x27;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;Daisy&#x27;</span>, length: <span class="hljs-number">3</span> &#125;<br></code></pre></td></tr></table></figure>

<p>注意：类数组的下标要是数字才能够进行数组的转化</p>
<p><strong>方法 1：Array 原型上的 slice 方法</strong><br>Array 原型上的 slice 方法—— 这个方法如果不传参数的话会返回原数组的一个拷贝，因此可以用此方法转换类数组到数组</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><code class="hljs elm"><span class="hljs-title">const</span> arr = <span class="hljs-type">Array</span>.proto<span class="hljs-keyword">type</span>.slice.call(arrayLike);<br></code></pre></td></tr></table></figure>

<p><strong>方法 2：Array.from 方法</strong><br>Array.from 方法——这是 ES6 新增的一个数组方法，专门用来把类数组转为数组</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">const</span> arr = Array.<span class="hljs-keyword">from</span>(<span class="hljs-built_in">array</span>Like);<br></code></pre></td></tr></table></figure>

<p><strong>方法 3：扩展运算符的方法</strong><br><strong>前提是这个类数组对象上部署了遍历器接口</strong>。在这个例子中，arrayLike 没有部署遍历器接口，所以这条路走不通。但一些对象，比如函数内部的 arguments 变量（它也是类数组对象），就满足条件，可以用这种方法来转换</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">demo</span><span class="hljs-params">()</span> &#123;</span><br>  console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;转换后的 arguments 对象: &#x27;</span>, [...<span class="hljs-keyword">arguments</span>])<br>&#125;<br><br>demo(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure>

<h3 id="显示类型转换"><a href="#显示类型转换" class="headerlink" title="显示类型转换"></a>显示类型转换</h3><p><code>JavaScript</code> 的类型转换的结果总是得到 <code>string</code>、<code>number</code> 和 <code>boolean</code> 类型的一种</p>
<ol>
<li><code>string</code> 和 <code>number</code><br><code>string</code> 和 <code>number</code> 类型的值进行互相转换，分别使用 <code>String</code> 和 <code>Number</code> 函数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">18</span>;<br><span class="hljs-keyword">const</span> b = <span class="hljs-built_in">String</span>(<span class="hljs-number">18</span>);      <span class="hljs-comment">// 这里面适合放置数字,布尔类型, null、undefiend、函数好像也行</span><br><span class="hljs-keyword">const</span> c = <span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;18&#x27;</span>);    <span class="hljs-comment">// 这里面只适合放置字符串的数字, 布尔类型</span><br><span class="hljs-keyword">const</span> d = <span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;18a&#x27;</span>);   <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure>

<p><code>number</code> 向 <code>string</code> 类型转换还可以使用 <code>toString</code> 方法</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><code class="hljs vbscript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">18</span>;<br><span class="hljs-keyword">const</span> b = a.<span class="hljs-keyword">to</span><span class="hljs-built_in">String</span>();<br></code></pre></td></tr></table></figure>

<p><code>string</code> 向 <code>number</code> 类型转换还可以使用一元操作符+</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> a = <span class="hljs-string">&#x27;18&#x27;</span>;<br><span class="hljs-keyword">const</span> b = +a;    <span class="hljs-comment">// 18</span><br></code></pre></td></tr></table></figure>

<p><code>string</code> 向 <code>number</code> 类型转换还可以使用 <code>parseInt</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-string">&#x27;18px&#x27;</span>;<br><span class="hljs-keyword">const</span> b = <span class="hljs-built_in">parseInt</span>(a);   <span class="hljs-comment">// 18;</span><br><span class="hljs-keyword">const</span> c = <span class="hljs-built_in">Number</span>(a);     <span class="hljs-comment">// NaN;</span><br></code></pre></td></tr></table></figure>

<p>可以看出，<code>parseInt</code> 与 <code>Number</code> 不同的地方在于，<code>parseInt</code> 允许传入非数字字符 (例如 px)，其从左往右解析，遇到非数字字符就会停下。而 <code>Number</code> 不允许传入非数字字符。</p>
<ol start="2">
<li>任意值转换成<code>boolean</code></li>
</ol>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">const <span class="hljs-selector-tag">a</span> = <span class="hljs-string">&#x27;123&#x27;</span><br>const <span class="hljs-selector-tag">b</span> = undefined<br>const c = <span class="hljs-number">0</span><br><span class="hljs-function"><span class="hljs-title">Boolean</span><span class="hljs-params">(a)</span></span> <span class="hljs-comment">// true</span><br><span class="hljs-function"><span class="hljs-title">Boolean</span><span class="hljs-params">(b)</span></span> <span class="hljs-comment">// false</span><br><span class="hljs-function"><span class="hljs-title">Boolean</span><span class="hljs-params">(c)</span></span> <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<p>实践中最常用的是 <code>!!</code> 符号</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> a = <span class="hljs-string">&#x27;123&#x27;</span><br><span class="hljs-keyword">const</span> b = <span class="hljs-literal">undefined</span><br><span class="hljs-keyword">const</span> c = <span class="hljs-number">0</span><br>!!a <span class="hljs-comment">// true</span><br>!!b <span class="hljs-comment">// false</span><br>!!c <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<p>注意题目中的类型转换是这种形式：<code>String(123)</code>，而不是这样：<code>new String(123)</code>，因为第一个才是进行包装类型转换，而第二个是生成实例。<br>关于一元操作符+还有一个用法，那就是将日期对象转换成 number</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">var</span> <span class="hljs-built_in">date</span> = <span class="hljs-literal">new</span> <span class="hljs-built_in">Date</span>( <span class="hljs-string">&quot;Mon, 1 Mar 2020 08:53:06&quot;</span> )<br>+<span class="hljs-built_in">date</span> <span class="hljs-comment">// 1583013186000</span><br><br></code></pre></td></tr></table></figure>

<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3>]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机通识-随笔</title>
    <url>/2021/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86-%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<h4 id="Terminal-Commands"><a href="#Terminal-Commands" class="headerlink" title="Terminal Commands"></a>Terminal Commands</h4><ol>
<li><code>pwd</code> 用于告诉你当前所在目录</li>
<li><code>ls</code> 用于告诉你当前目录层级的所有文件</li>
<li><code>ls -al</code></li>
<li><code>ls -a</code></li>
<li><code>clear</code> 清理当前终端内容</li>
<li><code>cd</code> 进入某个文件 <code>cd ..</code> 往上一个文件走</li>
<li><code>mkdir</code> 创建一个文件夹</li>
<li><code>touch</code> 创建一个文件</li>
<li><code>cp</code> 旧文件 新文件</li>
<li><code>mv</code> 旧文件 新文件</li>
<li>键盘上下键可以看前面自己写的命令</li>
<li><code>rm</code> 删除一个文件</li>
<li><code>rm -f</code> 删除一个文件夹</li>
<li><code>rm -r</code></li>
<li><code>vim</code> 修改文件 —&gt; <code>nano</code> 更好 vim 学习成本太高</li>
<li><code>cat</code> 查看文件的具体内容</li>
<li><code>echo</code></li>
<li><code>control + c</code> 终止当前终端</li>
</ol>
]]></content>
      <categories>
        <category>程序员素养篇</category>
      </categories>
  </entry>
  <entry>
    <title>跨域</title>
    <url>/2021/11/20/%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<h4 id="CORS-Cross-Origin-Resource-Sharing"><a href="#CORS-Cross-Origin-Resource-Sharing" class="headerlink" title="CORS(Cross-Origin Resource Sharing)"></a>CORS(Cross-Origin Resource Sharing)</h4><p>前两天，我在做一个聊天功能<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-20-at-10.03.24-AM.gif" alt="聊天功能"><br>的时候，就遇见了类似下面这种问题<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-20-at-10.07.41-AM.png" alt="跨域"></p>
<p>上图的意思是 当我们在<code>http://localhost:1234</code>的环境下，试图发送一个请求到<code>http://localhost:3000/items</code>。但是受到<strong>浏览器</strong>的<strong>同源策略</strong>(此处是因为违背同源策略中<code>端口一致</code>原则)影响。所以这就被判定为<strong>跨域行为</strong>。<strong>浏览器</strong>不允许这种操作，所以会禁止你请求发送！</p>
<blockquote>
<p>同源策略：协议一致(例如：http/https)、域名一致(例如：localhost)、端口一致(3000, 80 等等)</p>
</blockquote>
<p>我的聊天功能也是如此，在<code>localhost:3000</code>端口下运行<code>react</code>的代码，又在该<code>react项目</code>的<code>src文件夹</code>下创建了<code>server文件夹</code>并在此文件夹下运行<code>localhost:5000</code>端口同时进行<code>Socket.io</code>等通信操作, 导致跨域出现…</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>为了方便理解，我来弄一个小项目<br>代码目录：</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">-client</span><br><span class="hljs-string"></span>|<span class="hljs-string">   </span>|<span class="hljs-string">-index.html</span><br><span class="hljs-string"></span>|<span class="hljs-string">   </span>|<span class="hljs-string">-script.js</span><br><span class="hljs-string"></span>|<span class="hljs-string">-server</span><br><span class="hljs-string">    </span>|<span class="hljs-string">-...(老三样) -&gt;(nodejs express nodemon)</span><br><span class="hljs-string">    </span>|<span class="hljs-string">-server.js</span><br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">/* index.html */   用vscode插件 Live Server 打开5500端口运行该代码<br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./script.js&quot;</span> <span class="hljs-attr">defer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">/* script.js */</span><br><span class="hljs-function"><span class="hljs-title">fetch</span><span class="hljs-params">(<span class="hljs-string">&#x27;http://localhost:3000/data&#x27;</span>)</span></span>   <span class="hljs-comment">// 发送fetch请求</span><br>  <span class="hljs-selector-class">.then</span>(res =&gt; res<span class="hljs-selector-class">.json</span>())<br>  <span class="hljs-selector-class">.then</span>(data =&gt; console<span class="hljs-selector-class">.log</span>(data))<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* server.js */</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> app = express();<br><br>app.get(<span class="hljs-string">&#x27;/data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.json(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;bruce&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">21</span>&#125;)<br>&#125;)<br><br>app.listen(<span class="hljs-number">3000</span>);    <span class="hljs-comment">// 开启3000端口</span><br></code></pre></td></tr></table></figure>

<p>在 <code>5500</code> 端口出现下面的跨域错误：<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-27-at-7.47.27-PM.png" alt="CORS"></p>
<h4 id="为什么会出现跨域？"><a href="#为什么会出现跨域？" class="headerlink" title="为什么会出现跨域？"></a>为什么会出现跨域？</h4><p>简单说：保护用户安全，防止不同网站都能使用我们其他网站的<code>cookie</code>。导致我们的财产、个人隐私被其他网站知晓!</p>
<h4 id="如何解决跨域问题？-针对的是-Express"><a href="#如何解决跨域问题？-针对的是-Express" class="headerlink" title="如何解决跨域问题？ (针对的是 Express)"></a>如何解决跨域问题？ (针对的是 Express)</h4><p>此方法的解决思路如下：<br>你需要在每个请求时将 <code>Access-Control-Allow-Origin</code> 标头从服务器传递给客户端</p>
<blockquote>
<p><code>Access-Control-Allow-Origin</code> <strong>允许访问控制</strong></p>
</blockquote>
<p>方法是，将需要跨域的请求 在服务端使用<code>Access-Control-Allow-Origin</code> header。 下面我用代码来进行理解</p>
<p>首先要在服务端下载一个库： <code>npm i cors</code></p>
<p>然后在服务端进行下面的操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* server.js */</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> app = express();<br><span class="hljs-keyword">const</span> cors = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cors&#x27;</span>)<br><br>app.use(<br>  cors(&#123;<br>    <span class="hljs-attr">origin</span>: <span class="hljs-string">&quot;http://127.0.0.1:5500&quot;</span>   <span class="hljs-comment">// 这样就可以告诉浏览器，允许这个路径的用户实现跨域请求</span><br>  &#125;)<br>)<br><br><br>app.get(<span class="hljs-string">&#x27;/data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.json(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;bruce&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">21</span>&#125;)<br>&#125;)<br><br>app.listen(<span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-27-at-7.57.32-PM.png" alt="跨域成功"></p>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">app</span><span class="hljs-selector-class">.use</span>(<br>  cors(&#123;<br>    <span class="hljs-attribute">origin</span>: <span class="hljs-string">&quot;*&quot;</span>   <span class="hljs-comment">// 则允许任何来源都可以进行跨域</span><br>  &#125;)<br>)<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-27-at-8.00.20-PM.png" alt="允许任何源进行跨域"></p>
<h4 id="利用-cors-库限定跨域的请求方式"><a href="#利用-cors-库限定跨域的请求方式" class="headerlink" title="利用 cors 库限定跨域的请求方式"></a>利用 cors 库限定跨域的请求方式</h4><p>现在我把请求方式从 <code>get</code> 转变为 <code>put</code></p>
<p>注意：对于 <code>put</code> 这种相对复杂的请求浏览器将向服务器发送<code>preflight request</code>，询问服务器是否允许它提出此 PUT 请求。此<code>preflight request</code>将包含 <code>Access-Control-Request-Method</code> 和 <code>Access-Control-Request-Headers</code> 标题。这些标头包含客户端希望在请求中使用的方法和标头的值，如果方法和标头有效，服务器将返回。<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-27-at-8.31.46-PM.png" alt="preflight request"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* server.js */</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> app = express();<br><span class="hljs-keyword">const</span> cors = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cors&#x27;</span>)<br>app.use(<br>  cors(&#123;<br>    <span class="hljs-attr">origin</span>: <span class="hljs-string">&quot;http://127.0.0.1:5500&quot;</span>,<br>  &#125;)<br>)<br><br>app.put(<span class="hljs-string">&#x27;/data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.json(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;bruce&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">21</span>&#125;)<br>&#125;)<br><br>app.listen(<span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure>

<figure class="highlight sas"><table><tr><td class="code"><pre><code class="hljs sas"><span class="hljs-comment">/* script.js */</span><span class="hljs-meta"></span><br><span class="hljs-meta">fetch(</span><span class="hljs-string">&#x27;http://localhost:3000/data&#x27;</span>, &#123;<br>  method: <span class="hljs-string">&quot;PUT&quot;</span><br>&#125;)<br>  .th<span class="hljs-meta">en(</span>res =&gt; res.js<span class="hljs-meta">on(</span>))<br>  .th<span class="hljs-meta">en(</span>data =&gt; console<span class="hljs-meta">.log(</span>data))<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-27-at-8.07.30-PM.png" alt="OPTIONS"><br>从图中我们可以看见，它是允许我们用任何请求方式的：<br><code>Request Method: OPTIONS</code><br><code>Access-Control-Allow-Methods: GET, HEAD, PUT, PATCH, POST, DELETE</code></p>
<p>好，现在我们来限制请求方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* server.js */</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> app = express();<br><span class="hljs-keyword">const</span> cors = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cors&#x27;</span>)<br>app.use(<br>  cors(&#123;<br>    <span class="hljs-attr">origin</span>: <span class="hljs-string">&quot;http://127.0.0.1:5500&quot;</span>,<br>    <span class="hljs-attr">methods</span>: [<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;POST&#x27;</span>]   <span class="hljs-comment">// 只允许 GET 和 POST 请求</span><br>  &#125;)<br>)<br><br>app.put(<span class="hljs-string">&#x27;/data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.json(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;bruce&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">21</span>&#125;)<br>&#125;)<br><br>app.listen(<span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-27-at-8.10.57-PM.png" alt="请求限制1"><br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-27-at-8.36.03-PM.png" alt="请求限制2"></p>
<p>图中因为你仍旧使用的是 <code>PUT</code> 请求(该请求已被禁止)，所以会报错</p>
<h4 id="Dealing-With-Credentials"><a href="#Dealing-With-Credentials" class="headerlink" title="Dealing With Credentials"></a>Dealing With Credentials</h4><p>默认情况下，除非你明确告诉 <code>CORS</code>，否则 <code>CORS</code> 不会将你的 <code>cookie</code> 与请求一起发送<br>解决方法：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">/* script.js */</span><br>fetch(<span class="hljs-string">&#x27;http://localhost:3000/data&#x27;</span>, &#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;PUT&quot;</span>,<br>  <span class="hljs-attr">credentials</span>: <span class="hljs-string">&quot;include&quot;</span>    <span class="hljs-comment">// 添加这个！</span><br>&#125;)<br>  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.json())<br>  .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> console.log(data))<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* server.js */</span><br><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> app = express();<br><span class="hljs-keyword">const</span> cors = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cors&#x27;</span>)<br>app.use(<br>  cors(&#123;<br>    <span class="hljs-attr">origin</span>: <span class="hljs-string">&quot;http://127.0.0.1:5500&quot;</span>,<br>    <span class="hljs-attr">credentials</span>: <span class="hljs-literal">true</span>    <span class="hljs-comment">// 设置为true</span><br>  &#125;)<br>)<br><br><br><br>app.put(<span class="hljs-string">&#x27;/data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.json(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;bruce&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">21</span>&#125;)<br>&#125;)<br><br>app.listen(<span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-27-at-8.22.00-PM.png" alt="Credentials"></p>
<blockquote>
<p>额外补充，我在 <code>Socket.io</code>知识总结那里也有一种关于 <code>socket.io</code> 的跨域方式</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>高级</tag>
      </tags>
  </entry>
  <entry>
    <title>跨站点脚本攻击</title>
    <url>/2021/11/25/%E8%B7%A8%E7%AB%99%E7%82%B9%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>高级</tag>
      </tags>
  </entry>
  <entry>
    <title>?.运算符</title>
    <url>/2021/11/10/%E8%BF%90%E7%AE%97%E7%AC%A6-1/</url>
    <content><![CDATA[<p>在做项目的时候，我们可能会遇见下面这种情况</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><code class="hljs xquery">const DATA = [<br>  &#123;<br>    city: <span class="hljs-string">&#x27;重庆&#x27;</span>,<br>    collage: &#123;<br>     <span class="hljs-built_in"> name</span>: <span class="hljs-string">&#x27;重庆邮电大学&#x27;</span>,<br>      address: <span class="hljs-string">&#x27;南山街道&#x27;</span><br>    &#125;<br>  &#125;,<br>  &#123;<br>    city: <span class="hljs-string">&#x27;重庆&#x27;</span><br>  &#125;,<br>  &#123;<br>    city: <span class="hljs-string">&#x27;重庆&#x27;</span>,<br>    collage: &#123;<br>     <span class="hljs-built_in"> name</span>: <span class="hljs-string">&#x27;西南大学&#x27;</span><br>    &#125;<br>  &#125;<br>]<br><br>const CollageAddress = DATA.<span class="hljs-keyword">map</span>((<span class="hljs-type">item</span>) =&gt; &#123;<br>  const address = <span class="hljs-type">item</span> &amp;&amp; <span class="hljs-type">item</span>.collage &amp;&amp; <span class="hljs-type">item</span>.collage.address;<br>  <span class="hljs-keyword">return</span> address;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>上述方法是访问对象属性是 undefined 还是 null 的相对优雅的方法。但，始终显得比较臃肿。</p>
<p>下面用本篇文章的主题 <code>?.</code>来优雅的解决上述问题</p>
<blockquote>
<p>对象后面跟<code>?.</code>表示接下来的属性可能为<code>undefined</code>或者<code>null</code>或者有值</p>
</blockquote>
<figure class="highlight excel"><table><tr><td class="code"><pre><code class="hljs excel">const <span class="hljs-built_in">address</span> = item?.collage?.<span class="hljs-built_in">address</span><br></code></pre></td></tr></table></figure>

<p>如果<code>collage</code>、<code>address</code>未定义，我们的代码将返回(<code>undefined</code>)未定义，而不是抛出错误</p>
<h4 id="的其他用途"><a href="#的其他用途" class="headerlink" title="?.的其他用途"></a>?.的其他用途</h4><h5 id="调用某个对象的某个不确定是否存在的方法"><a href="#调用某个对象的某个不确定是否存在的方法" class="headerlink" title="调用某个对象的某个不确定是否存在的方法"></a>调用某个对象的某个不确定是否存在的方法</h5><p>例如：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">const windowCount = house<span class="hljs-selector-class">.getWindowCount</span> &amp;&amp; house<span class="hljs-selector-class">.getWindowCount</span>()<br></code></pre></td></tr></table></figure>

<p>上面的写法不够优雅，显得比较的笨重<br>使用<code>?.</code>进行优雅操作…</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> windowCount = house.getWindowCount?.()<br></code></pre></td></tr></table></figure>

<p>如果在<code>house</code>对象中存在<code>getWindowCount</code>方法。就会调用，如果不存在，只会返回未定义的函数，而不会调用该函数<br>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-function"><span class="hljs-title">func1</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;func1&#x27;</span>)<br>  &#125;<br>&#125;<br>obj.func1?.() <span class="hljs-comment">// func1</span><br>obj.func2?.() <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure>

<h5 id="搭配数组"><a href="#搭配数组" class="headerlink" title="?.搭配数组"></a>?.搭配数组</h5><p>如果你想按索引访问数组中的元素，但不确定是否定义了数组，那么你会用下面的代码：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">const firstElement</span> = arr &amp;&amp; arr[0];<br></code></pre></td></tr></table></figure>

<p>使用<code>?.</code>运算符：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> firstElement = arr?.[<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure>

<p>首先检查是否定义了<code>arr</code>变量，如果定义了，它将尝试访问指定的数组的索引。如果没有定义<code>arr</code>变量，则将返回未定义的变量，而不是尝试访问数组的索引。</p>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>奇淫技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>??运算符</title>
    <url>/2021/11/10/%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<p>在平常的项目中，我们会遇见这样的情况：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-keyword">score</span>: 5<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">score</span> = obj.<span class="hljs-keyword">score</span> || 10;   <span class="hljs-comment">// 如果obj.score 返回false，那么score就等于10，不然就等于obj.score</span><br></code></pre></td></tr></table></figure>

<p>但事实上会出现下面的问题：<br>如果</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-keyword">score</span>: 0<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">score</span> = obj.<span class="hljs-keyword">score</span> || 10;<br></code></pre></td></tr></table></figure>

<p>我所得到的是 10 分。但是我想要 0 分 也作为有意义的值…<br>为了让 0 分变得有意义，我需要这样做</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-keyword">score</span>: 5<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">score</span> =  (obj.<span class="hljs-keyword">score</span> == null) ? 10 : obj.<span class="hljs-keyword">score</span>  <span class="hljs-comment">// 这里用==而不用===可以同时解决null 和 undefined这两种情况</span><br></code></pre></td></tr></table></figure>

<p>这样，我就可以排除<code>obj.score</code>为<code>undefined</code>和<code>null</code>却不影响<code>obj.score === 0</code>这种情况。但是，这样写太笨重了…</p>
<p>下面来介绍本篇博客的主角 <code>??</code> 运算符</p>
<h4 id=""><a href="#" class="headerlink" title="??"></a>??</h4><p><code>??</code>运算符和<code>||</code>运算符执行逻辑很相似。但是<code>??</code>只会检查 <code>undefined/null</code><br>还是以上面我写的内容举例</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-keyword">score</span>: 0<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">score</span> = obj.<span class="hljs-keyword">score</span> ?? 10;  <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure>

<p>很轻松的，我就获得了 score 为 0 分…</p>
<p>为了更全面的观察 <code>??</code> 效果，我来更具体的展示</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">undefined ?? <span class="hljs-number">10</span> <span class="hljs-regexp">//</span> <span class="hljs-number">10</span><br>null ?? <span class="hljs-number">10</span>      <span class="hljs-regexp">//</span> <span class="hljs-number">10</span><br><span class="hljs-number">0</span> ?? <span class="hljs-number">10</span>         <span class="hljs-regexp">//</span> <span class="hljs-number">0</span><br>false ?? <span class="hljs-number">10</span>     <span class="hljs-regexp">//</span> false   &lt;- 这个值得注意注意<br><span class="hljs-string">&#x27;Hi&#x27;</span> ?? <span class="hljs-number">10</span>      <span class="hljs-regexp">//</span> Hi<br><span class="hljs-number">20</span> ?? <span class="hljs-number">10</span>        <span class="hljs-regexp">//</span> <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure>

<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p><code>||</code>、<code>&amp;&amp;</code>、<code>??</code>可以合在一起用，但是要用括号来控制执行顺序，不然报错!!</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-number">0</span> || <span class="hljs-literal">null</span> ?? <span class="hljs-number">10</span>   <span class="hljs-comment">// 报错</span><br>(<span class="hljs-number">0</span> || <span class="hljs-literal">null</span>) ?? <span class="hljs-number">10</span> <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>奇淫技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包</title>
    <url>/2021/11/27/%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<p><strong>闭包</strong>无处不在，下面这段非常简单的代码其实就暗含<strong>闭包</strong>之道！</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">const</span> <span class="hljs-keyword">print</span> = <span class="hljs-string">&#x27;A&#x27;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Print</span>(<span class="hljs-params"></span>) </span>&#123;<br>  console.log(<span class="hljs-keyword">print</span>);<br>&#125;<br><span class="hljs-keyword">Print</span>();   <span class="hljs-comment">//A</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>其实在其他编程语言中我们能够发现，函数内部是无法通过非参数的方式获取函数外部的变量。但是从上面我们习以为常的代码中，我们可以惊讶的发现，我们能够任意的在函数内部获取函数外面的变量！ 这种现象，其实我们就叫做<strong>闭包</strong></p>
</blockquote>
<p>每个作用域都能访问其外部作用域！ 所以在函数作用域中的 <code>print</code> 能够访问外部这个全局作用域下的 <code>print</code></p>
<p>下面对代码做一个升级！</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php">let <span class="hljs-keyword">print</span> = <span class="hljs-string">&#x27;A&#x27;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Print</span>(<span class="hljs-params"></span>) </span>&#123;<br>  console.log(<span class="hljs-keyword">print</span>);<br>&#125;<br><span class="hljs-keyword">print</span> = <span class="hljs-string">&#x27;B&#x27;</span>;<br><span class="hljs-keyword">Print</span>();    <span class="hljs-comment">// B</span><br><span class="hljs-keyword">print</span> = <span class="hljs-string">&#x27;C&#x27;</span><br><span class="hljs-keyword">Print</span>();    <span class="hljs-comment">// C</span><br></code></pre></td></tr></table></figure>

<p>可见，<code>Print</code> 函数内部的 <code>print</code> 第一次记打印的是 <code>B</code>，说明是在<strong>函数执行的时候</strong>，才会真正确定当前 <code>print</code> 的值！</p>
<h4 id="闭包的常用情景"><a href="#闭包的常用情景" class="headerlink" title="闭包的常用情景"></a>闭包的常用情景</h4><p>更多的人会把多个函数的嵌套作为闭包的使用场景</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outerFunction</span>(<span class="hljs-params">outerVariable</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> outer2 = <span class="hljs-string">&#x27;Hi&#x27;</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">innerFunction</span>(<span class="hljs-params">innerVariable</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(outer2);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Outer Variable: &#x27;</span> + outerVariable);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Inner Variable: &#x27;</span> + innerVariable);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> newFunction = outerFunction(<span class="hljs-string">&#x27;outside&#x27;</span>)<br>newFunction();<br>newFunction(<span class="hljs-string">&#x27;inside&#x27;</span>)<br></code></pre></td></tr></table></figure>

<figure class="highlight gams"><table><tr><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">// 打印结果：</span><br>Hi<br>Outer <span class="hljs-keyword">Variable</span>: outside<br>Inner <span class="hljs-comment">Variable: undefined</span><br><br>Hi<br>Outer <span class="hljs-comment">Variable: outside</span><br>Inner <span class="hljs-comment">Variable: inside</span><br></code></pre></td></tr></table></figure>

<p>当我们第一次调用<code>outerFunction</code>的时候，<code>outerVariable</code>我们设置为<code>outside</code>。而<code>innerFunction</code>中的 <code>outerVariable</code> 和 <code>outer2</code> 能够访问它外部的<code>outerVariable</code> 和 <code>outer2</code>这两个变量，这就是利用的闭包这个特性！</p>
<p>注意一个点，当 <code>outerFunction</code> 执行后，其内部的<code>outerVariable</code> 和 <code>outer2</code> 这两个变量除了<code>innerFunction</code>能够访问得到，其余方式都不能访问到！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outerFunction</span>(<span class="hljs-params">outerVariable</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> outer2 = <span class="hljs-string">&#x27;Hi&#x27;</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">innerFunction</span>(<span class="hljs-params">innerVariable</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(outer2);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Outer Variable: &#x27;</span> + outerVariable);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Inner Variable: &#x27;</span> + innerVariable);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> newFunction = outerFunction(<span class="hljs-string">&#x27;outside&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(outerVariable)   <span class="hljs-comment">// 报错：未定义</span><br><span class="hljs-built_in">console</span>.log(outer2)    <span class="hljs-comment">// 报错：未定义</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>思考：为何返回的<code>innerFunction</code> 即 <code>newFunction</code> 还能够访问到 <code>outerVariable</code> 和 <code>outer2</code> 呢？ 不是 <code>outerFunction</code> 已经被执行完毕了吗？</p>
</blockquote>
<p><strong>解答</strong>： 因为闭包的关系(这里有闭包是因为作用域的原因:大作用域包裹小作用域)，<code>innerFunction</code> 内部的<code>outerVariable</code> 和 <code>outer2</code>都能在<code>outerFunction</code>中找到，所以<code>innerFunction</code>中的<code>outerVariable</code> 和 <code>outer2</code>就是外部的<code>outerVariable</code> 和 <code>outer2</code>。本身就是同一个值！！即便外部这个函数已经执行完毕而不再了，但我内部函数仍拥有它曾经的变量！</p>
<p>为了佐证我的说法有下面代码：</p>
<figure class="highlight ceylon"><table><tr><td class="code"><pre><code class="hljs ceylon"><span class="hljs-keyword">function</span> <span class="hljs-keyword">outer</span>() &#123;<br>  const <span class="hljs-keyword">outer</span><span class="hljs-number">1</span> = &#123;a: <span class="hljs-number">123</span>&#125;;<br>  const <span class="hljs-keyword">outer</span><span class="hljs-number">2</span> = <span class="hljs-keyword">outer</span><span class="hljs-number">1</span>;     <span class="hljs-comment">// 地址赋值 所以这里的outer2 和 outer1一定是一样的</span><br>  console.log(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-keyword">outer</span><span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">function</span> inner() &#123;<br>    console.log(<span class="hljs-keyword">outer</span><span class="hljs-number">1</span> === <span class="hljs-keyword">outer</span><span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">outer</span><span class="hljs-number">1</span>.a = <span class="hljs-number">234</span>;<br>  &#125;<br>  inner();<br>  console.log(<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-keyword">outer</span><span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">outer</span>();<br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">// 打印结果：<br><span class="hljs-number">1</span> &#123;<span class="hljs-selector-tag">a</span>: <span class="hljs-number">123</span>&#125;<br>true<br><span class="hljs-number">2</span> &#123;<span class="hljs-selector-tag">a</span>: <span class="hljs-number">234</span>&#125;<br></code></pre></td></tr></table></figure>

<p>这里就说明了因为闭包的原因，上面例子中的<code>outer</code> 的变量<code>outer1</code>、<code>outer2</code>和 <code>inner</code> 上的变量<code>outer1</code>、<code>outer2</code>就是同一个变量</p>
<blockquote>
<p>只要有大作用域嵌套小作用域，就有闭包发挥威力的地方！</p>
</blockquote>
<h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><p>面试书讲闭包：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">引用了自由变量的函数就叫做闭包 <span class="hljs-comment">--- 修言</span><br></code></pre></td></tr></table></figure>

<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(i);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>打印结果： 5 5 5 5 5<br>解析：上面其实 i 是<strong>一个变量</strong> <strong>重点在一个，这里的 for 循环诞生了 5 个函数 function(){console.log(i)}，所以有 5 个函数作用域。</strong>。 <strong>setTimeout</strong>是宏任务，异步，当同步代码执行完后才会执行…setTimeout 里面的 i 是自由变量, 这 5 个函数获取的都是同一个变量 i</p>
<p>修改上述代码：打印 0 1 2 3 4</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(i);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>展现的是 let 变量的威力</p>
<hr>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;<br>  a = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(a)   <span class="hljs-comment">// 在代码定义的时候确定这个a是否是闭包，只有在代码执行时a才会获取真正的值</span><br>  &#125;<br>  a = <span class="hljs-number">3</span>;<br>&#125;<br><br>test()();   <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure>

<hr>
<figure class="highlight livescript"><table><tr><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">function</span> foo(a, b) &#123;<br>    <span class="hljs-built_in">console</span>.log(b);<br>    <span class="hljs-keyword">return</span> &#123;<br>      foo: <span class="hljs-keyword">function</span>(c) &#123;<br>        <span class="hljs-keyword">return</span> foo(c, a)<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">var</span> func1 = foo(<span class="hljs-number">0</span>);  <span class="hljs-regexp">// 此时 该func1里的a已经是0了   undefined</span><br><span class="hljs-regexp">  func1.foo(1);        //</span> 返回值为 foo<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span> --&gt;</span> <span class="hljs-number">0</span><br>  func1.foo<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">2</span>)</span>;        // 返回值为 <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>)</span> --&gt;</span> <span class="hljs-number">0</span><br>  func1.foo<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">3</span>)</span>;        // 返回值为 <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>)</span> --&gt;</span> <span class="hljs-number">0</span><br>  <span class="hljs-keyword">var</span> func2 = foo(<span class="hljs-number">0</span>).foo(<span class="hljs-number">1</span>).foo(<span class="hljs-number">2</span>).foo(<span class="hljs-number">3</span>); <span class="hljs-regexp">// foo(3, 2)    undefined 0 1 2</span><br><span class="hljs-regexp">  var func3 = foo(0).foo(1); //</span> foo<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span> --&gt;</span> <span class="hljs-literal">undefined</span> <span class="hljs-number">0</span><br>  func3.foo<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">2</span>)</span>; // <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)</span> --&gt;</span> <span class="hljs-number">1</span><br>  func3.foo<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">3</span>)</span>; // <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)</span> --&gt;</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<h4 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h4><h5 id="模拟私有变量的实现"><a href="#模拟私有变量的实现" class="headerlink" title="模拟私有变量的实现"></a>模拟私有变量的实现</h5><p>让类似 账号的密码变量 避免直接被找到</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 利用闭包生成IIFE，返回 User 类</span><br><span class="hljs-keyword">const</span> User = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 定义私有变量_password</span><br>  <span class="hljs-keyword">let</span> _password;<br><br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">username, password</span>)</span>&#123;<br>      <span class="hljs-comment">// 初始化私有变量_password</span><br>      _password = password;<br>      <span class="hljs-built_in">this</span>.username = username;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">login</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.username, _password);   <span class="hljs-comment">// 此IIFE执行后，_password只有在User这个class中才有了</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> User;<br>&#125;)()<br><br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&#x27;Bruce&#x27;</span>, <span class="hljs-string">&#x27;HeYang&#x27;</span>);<br><br><span class="hljs-built_in">console</span>.log(user.username);  <span class="hljs-comment">// Bruce</span><br><span class="hljs-built_in">console</span>.log(user.password);  <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">console</span>.log(user._password); <span class="hljs-comment">// undefined</span><br>user.login(); <span class="hljs-comment">// Bruce HeYang</span><br></code></pre></td></tr></table></figure>

<h5 id="偏函数-和-柯里化"><a href="#偏函数-和-柯里化" class="headerlink" title="偏函数 和 柯里化"></a>偏函数 和 柯里化</h5><p><strong>柯里化</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 柯里化</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateName</span>(<span class="hljs-params">prefix</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-keyword">type</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-title">functioin</span>(<span class="hljs-params">itemName</span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> prefix + <span class="hljs-keyword">type</span> + itemName;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> salesName = generateName(<span class="hljs-string">&#x27;大卖网&#x27;</span>);<br><span class="hljs-keyword">var</span> salesBabyName = salesName(<span class="hljs-string">&#x27;母婴&#x27;</span>);<br><span class="hljs-keyword">var</span> vegFreshName = generateName(<span class="hljs-string">&#x27;洗菜网&#x27;</span>)(<span class="hljs-string">&#x27;生鲜&#x27;</span>);<br><br>salesBabyName(<span class="hljs-string">&#x27;奶瓶&#x27;</span>);<br>vegFreshName(<span class="hljs-string">&#x27;菠菜&#x27;</span>)<br><br><span class="hljs-keyword">var</span> itemFullName = generateName(<span class="hljs-string">&#x27;洗菜网&#x27;</span>)(<span class="hljs-string">&#x27;生鲜&#x27;</span>)(<span class="hljs-string">&#x27;菠菜&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p><strong>偏函数</strong><br>偏函数不强调“单参数”这个概念，它的目标仅仅是把函数的入参拆解为两部分</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateName</span>(<span class="hljs-params">prefix</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>, itemName</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> prefix + <span class="hljs-keyword">type</span> + itemName;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 把三个参数分为两个部分传入</span><br><span class="hljs-keyword">var</span> itemFullName = generateName(<span class="hljs-string">&#x27;大卖网&#x27;</span>)(<span class="hljs-string">&#x27;母婴&#x27;</span>, <span class="hljs-string">&#x27;奶瓶&#x27;</span>)<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>项目一 知识点总结+反思</title>
    <url>/2021/12/02/%E9%A1%B9%E7%9B%AE%E4%B8%80-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-%E5%8F%8D%E6%80%9D/</url>
    <content><![CDATA[<p>(面试法宝之一)</p>
<p>项目一使用的内容</p>
<p>为什么我两个项目都在用 <code>react hooks</code> 因为未来的 <code>react 18</code> 就是完全面向 <code>react hooks</code> 而来的。我所做的项目 以及了解到的资料知道，<code>hooks</code> 其实能够胜任大多数的 class 工作。目前我好想就只知道错误边界这里不得不用 <code>class</code> 其余都没用到过 <code>class</code>。 而且 <code>hooks</code> 是灵活的，非常契合函数式编程的思维…我也无聊的时候会弄了一些 自定义的 <code>hooks</code>。</p>
<p>该项目的特点：</p>
<ul>
<li>以 TS 作为类型约束</li>
<li>代码全为 react hooks</li>
<li>自定义钩子</li>
<li>使用 react router v6</li>
<li>状态管理( redux toolkit、react query)</li>
<li>单元测试</li>
<li>任意的拖拽功能</li>
<li>context/react toolkit 来实现客户端的全局管理</li>
<li>react query 来实现服务端的全局管理</li>
<li>乐观更新 –&gt;</li>
</ul>
<p>后面要修改，我会把 <code>emotion</code> 变为 <code>tailwindcss</code> 然后在样式方面有进一步的提升</p>
<p>本项目的后端 借助的是 npm 包 npm-jira-tool <strong>分布式后端服务</strong> 开发者工具用 MSW 以 Service Worker 为原理实现了”分布式后端”</p>
<ol>
<li>请求被 Service Worker 代理</li>
<li>后端逻辑处理后，以 localStorage 为数据库进行增删改查操作</li>
</ol>
<p>每个用户的浏览器上都安装了一个独立的后端服务和数据库，再也不受任何中心化服务的影响 点击’清空数据库’便可以重置后端服务</p>
<ol>
<li> HTTP 请求精准控制 开发者工具可以精准地控制 HTTP 请求的时间、失败概率、失败规则</li>
</ol>
<p>感觉这个项目的很多东西都过度封装了，就难以理解… 比如这个 useAsync 就不好用</p>
<p>异步操作被打断问题</p>
<p>react query 其实扮演着我自定义的 useAsync 的作用</p>
<p>拖拽原理：</p>
]]></content>
      <categories>
        <category>面试篇</category>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目之道</tag>
      </tags>
  </entry>
  <entry>
    <title>项目三 知识点总结+反思</title>
    <url>/2021/12/02/%E9%A1%B9%E7%9B%AE%E4%B8%89-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-%E5%8F%8D%E6%80%9D/</url>
    <content><![CDATA[<p>(面试法宝之三)</p>
<p>该板块 严肃的说不是项目 而是 自己所积累的各种 custom react hooks</p>
]]></content>
      <categories>
        <category>面试篇</category>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目之道</tag>
      </tags>
  </entry>
  <entry>
    <title>项目中的小技巧</title>
    <url>/2021/10/31/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h4 id="amp-amp-的使用"><a href="#amp-amp-的使用" class="headerlink" title="&amp;&amp;的使用"></a>&amp;&amp;的使用</h4><p>先看用法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 如果&amp;&amp;左右两边都有效则返回的是&amp;&amp;右边的内容, 否则返回左边的</span><br><span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-number">123</span>   <span class="hljs-comment">// 123</span><br><br><span class="hljs-number">0</span> &amp;&amp; <span class="hljs-number">123</span>      <span class="hljs-comment">// 0</span><br><br><span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-number">123</span>  <span class="hljs-comment">// false</span><br><br><span class="hljs-number">123</span> &amp;&amp; <span class="hljs-number">456</span>    <span class="hljs-comment">// 456</span><br></code></pre></td></tr></table></figure>

<h4 id="的使用"><a href="#的使用" class="headerlink" title="|| 的使用"></a>|| 的使用</h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-number">2</span> || <span class="hljs-number">3</span>       <span class="hljs-comment">// 2</span><br><span class="hljs-number">0</span> || <span class="hljs-number">3</span>       <span class="hljs-comment">// 3</span><br><span class="hljs-literal">false</span> || <span class="hljs-number">3</span>   <span class="hljs-comment">// 3</span><br><span class="hljs-literal">undefined</span>||<span class="hljs-number">3</span> <span class="hljs-comment">// 3</span><br><span class="hljs-literal">null</span> || <span class="hljs-number">3</span>    <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure>

<h4 id="的作用"><a href="#的作用" class="headerlink" title="== 的作用"></a>== 的作用</h4><p>正常情况下，能用 <code>===</code> 运算符就不要用 <code>==</code> 运算符。 我认为的唯一一种情况下推荐使用<code>==</code>的情况就是在你认为<code>undefined</code>、<code>null</code> 都应该为同一类状态的时候才可以使用<br>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-literal">undefined</span> == <span class="hljs-literal">null</span>  <span class="hljs-comment">// true</span><br><span class="hljs-literal">false</span> == <span class="hljs-literal">null</span>      <span class="hljs-comment">// false</span><br><span class="hljs-literal">false</span> == <span class="hljs-literal">undefined</span> <span class="hljs-comment">// false</span><br><span class="hljs-number">0</span> == <span class="hljs-literal">null</span>          <span class="hljs-comment">// false</span><br><span class="hljs-number">0</span> == <span class="hljs-literal">undefined</span>     <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">someValue == <span class="hljs-literal">null</span> <span class="hljs-comment">// 其实 someValue 与 null 或者 与 undefined 比较的时候 得到的结果是一致的</span><br></code></pre></td></tr></table></figure>

<h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 常见情况：</span><br><span class="hljs-keyword">const</span> number = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> result;<br><br><span class="hljs-keyword">if</span> (number &gt;= <span class="hljs-number">50</span>) &#123;<br>  result = <span class="hljs-string">&#x27;Not to fifty!&#x27;</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  result = <span class="hljs-string">&#x27;It could be worse&#x27;</span><br>&#125;<br><br><span class="hljs-built_in">console</span>.log(result);  <span class="hljs-comment">// It could be worse</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 用三元运算符</span><br><span class="hljs-keyword">const</span> number = <span class="hljs-number">5</span>;<br><span class="hljs-comment">// 完美的浓缩着代码....</span><br><span class="hljs-keyword">const</span> result = number &gt;= <span class="hljs-number">50</span> ? <span class="hljs-string">&#x27;Not to fifty!&#x27;</span> : <span class="hljs-string">&#x27;It could be worse&#x27;</span><br><span class="hljs-built_in">console</span>.log(result);  <span class="hljs-comment">// It could be worse</span><br></code></pre></td></tr></table></figure>

<p>注意：对于<strong>三元运算符</strong> 仅限于做简单的返回值的事。不要做其他例如对象属性修改这种麻烦的操作…不然可能有意想不到的操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> user = &#123;...&#125;<br><span class="hljs-comment">// 下述操作其实就会懵逼。不要这样做</span><br>user.valid ? user.save() : user.printErrors()<br><br><span class="hljs-comment">// 老老实实用if……else……</span><br><span class="hljs-keyword">if</span> (user.valid) &#123;<br>  user.save()<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  user.printErrors()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>嵌套事也不要做…</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> number = <span class="hljs-number">12</span>;<br><span class="hljs-keyword">let</span> result;<br><br><span class="hljs-keyword">if</span> (number === <span class="hljs-number">0</span>) &#123;<br>  result = <span class="hljs-string">&#x27;You have nothing&#x27;</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (number &lt; <span class="hljs-number">10</span>) &#123;<br>  result = <span class="hljs-string">&#x27;You have very little&#x27;</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  result = <span class="hljs-string">&#x27;You have a lot&#x27;</span><br>&#125;<br><br><span class="hljs-built_in">console</span>.log(result)<br></code></pre></td></tr></table></figure>

<p>下面这种嵌套不要做…难以理解，难以解析</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">result = number === <span class="hljs-number">0</span> ? <span class="hljs-string">&#x27;You have nothing : (</span><br><span class="hljs-string">  number &lt; 10 ? &#x27;</span>You have very little<span class="hljs-string">&#x27; : &#x27;</span>You have a lot<span class="hljs-string">&#x27;</span><br><span class="hljs-string">)</span><br><span class="hljs-string"></span><br><span class="hljs-string">console.log(result)</span><br></code></pre></td></tr></table></figure>

<p>写代码不是为了追求短…而是为了让代码的可读性更好。就算有段代码写 10 行其实可以压缩成 1 行，但是如果写 10 行可读性大于写 1 行。那也应该选择写 10 行的代码…</p>
<h4 id="操作符"><a href="#操作符" class="headerlink" title="??操作符"></a>??操作符</h4><p>专门有篇博客讲解</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>奇淫技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>项目二 知识点总结+反思</title>
    <url>/2021/12/02/%E9%A1%B9%E7%9B%AE%E4%BA%8C-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-%E5%8F%8D%E6%80%9D/</url>
    <content><![CDATA[<p>(面试法宝之二)</p>
<p>该项目的特点：</p>
<ul>
<li>纯 <code>React hooks</code></li>
<li>未采用任何 <code>style-components</code> 或其他 <code>css in js</code> 的方式而是使用的 <code>css</code> 的 <code>BEM</code> 的技巧来解决 css 模块化问题</li>
<li>利用 <code>firebase</code> 来实现的用户认证 （未来 firebase 这部分还会增加新的东西）</li>
<li>使用 <code>socket.io</code> 来实现聊天功能</li>
<li>react router v6</li>
<li>未来应该补充更多 css 的新东西</li>
</ul>
<h4 id="自问自答环节："><a href="#自问自答环节：" class="headerlink" title="自问自答环节："></a>自问自答环节：</h4><p>谈一谈你自己做的这些 备忘录、图片编辑、聊天室、文件管理是如何实现的吧！ 你在这个项目中遇见过什么困难呢？</p>
<p>BEM 的优势与 CSS-in-JS 的对比<br>–&gt; 曾经用过的 CSS-in-JS 方法(react17 使用的方法，一个是 emotion)<br>–&gt; BEM 的优势，你为什么要这样做呢？</p>
<p>Firebase:<br>–&gt; 你为什么要用<code>firebase</code>，说一说你对<code>firebase</code>的理解，你用<code>firebase</code>做了哪些内容<br>–&gt; auth 服务 你自己做过类似的功能吗？</p>
<p>Socket.io:<br>–&gt; 谈一谈你对<code>socket.io</code>的理解, 你在使用过程中是否遇见过什么困难？<br>–&gt; 谈一谈 WebSocket 你对于这个的理解是怎样的</p>
<p>React Router v6:<br>–&gt; 谈一谈 React Router v6 版本有什么变化…<br>–&gt; 谈一谈你对 React Router 的理解</p>
<h4 id="整体项目的询问："><a href="#整体项目的询问：" class="headerlink" title="整体项目的询问："></a>整体项目的询问：</h4><p>这两个项目你都使用了 <code>React Hooks</code>，你对于 <code>React Hooks</code> 的理解是怎么样的？<br>你有使用过 <code>React Class</code> 吗？ 对于 <code>React Class</code> 里面的内容 知道多少呢？ 有使用这个做过什么项目吗？</p>
<hr>
<h4 id="Authentication-firebase-版本的-–-gt-这个要对比我项目一-自己使用的-auth-方法"><a href="#Authentication-firebase-版本的-–-gt-这个要对比我项目一-自己使用的-auth-方法" class="headerlink" title="Authentication(firebase 版本的) –&gt; 这个要对比我项目一 自己使用的 auth 方法"></a>Authentication(firebase 版本的) –&gt; 这个要对比我项目一 自己使用的 auth 方法</h4><p>事实上，使用 firebase 的话，auth 服务是非常丰富的，可以用手机号、邮箱、github 等等方式进行密码修改等操作，。我在项目中仅使用了现在比较流行的利用邮箱来进行密码重置，完成这项看似比较复杂的功能，其实只需要调用一个 firebase 提供的接口就能完成…非常的方便<br>账户注册、账户登录、密码重置(利用 Email)、更新密码、创建 authenticated routes</p>
<p>而且我可以直接在 firebase 网站上查询或者删除 用户</p>
<p>使用流程：需要两个环境–&gt; 一个用于开发 一个用于上线 需要在代码里，安装 <code>firebase</code> 库:<br><code>firebase</code></p>
<p>而让 firebase 能够全局使用 也是结合了 context 来实现的，我个人的理解是(因为我之前也用过 redux、redux-toolkit 来实现全局管理，但感觉多多少少会有些麻烦，但是 useContext 个人感觉是一气呵成的那种，自己封装一个钩子，全局使用，很舒服, 并且还有 react 的 useReducer 钩子，我个人感觉非常方便)</p>
<p>process.env 和 .env 文件的无情玩法….</p>
<p>并利用 firebase + React Router v6 版本 实现未登录状态的重定向(不允许你输入路由就能直接进入某个页面)</p>
<p>Promise.all 的应用</p>
<p>利用 firebase 实现 文件存储 功能<br>firebase 网页对于 文件从层次结构也是非常清晰的…<br>非常方便，我可以仅仅通过一个接口知道 文件创建的时间、层次结构…等等各种信息</p>
<p>== 用法一般局限于一些小的情况</p>
<p>对于文件管理 上一个文件夹、下一个文件夹…： 我就使用了 useReducer</p>
<p>自己纠错： 以某个模块的方式进行筛查，比如某个模块有问题， 先把这个模块注释，看是否还会出现问题什么的…</p>
<p>省略号大法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 超出的文本隐藏 */</span><br><span class="hljs-attribute">overflow</span>: hidden;<br><span class="hljs-comment">/* 溢出用省略号显示 */</span><br><span class="hljs-attribute">text-overflow</span>: ellipsis;<br><span class="hljs-comment">/* 溢出不换行 */</span><br><span class="hljs-attribute">white-space</span>: nowrap;<br></code></pre></td></tr></table></figure>

<p>面包屑这里是一个非常重要的点!! 如何根据接口来实现前后文件的链接</p>
<p>firebase 还可以自定义一些配置</p>
<p>这里的 <code>&lt;input type=&#39;file&#39; /&gt;</code> 标签要好好研究研究</p>
<p>还有 opciaty 和 hidden 的区别是什么</p>
<p>难点在于路径的转换，</p>
<p>要知道每个模块的作用</p>
<p>a 标签的 target 属性是怎么操作的??…</p>
<p>react portal 的用法</p>
<p>重复文件覆盖问题</p>
<p>input 标签 和 label 标签的搭配使用这里需要再弄弄</p>
]]></content>
      <categories>
        <category>面试篇</category>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目之道</tag>
      </tags>
  </entry>
  <entry>
    <title>项目开发经验总结&amp;思考</title>
    <url>/2021/11/12/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93-%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h4 id="项目文件命名"><a href="#项目文件命名" class="headerlink" title="项目文件命名"></a>项目文件命名</h4><p>建议在 <code>react</code> 项目开发中 css 文件的命名方式 应该是</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 名字全小写，内容用 - 来分割<br>abc.css<br>abc-def.css<br></code></pre></td></tr></table></figure>

<p>建议在 <code>react</code> 项目开发中 js、jsx、ts、tsx 文件的命名方式应该是 驼峰式且首字母大写</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 一般来说上述的四种类型文件都分别项目中的模块。模块最好首字母大写</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Abc</span>.</span></span>js<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AbcDef</span>.</span></span>js<br></code></pre></td></tr></table></figure>

<h4 id="关于-css-命名"><a href="#关于-css-命名" class="headerlink" title="关于 css 命名"></a>关于 css 命名</h4><p>对于自定义 <code>css</code> 命名。遵循 <code>BEM</code> 的规范。我已经在博客里写过 <code>BEM</code> 的使用方法, 忘了就去看</p>
<h4 id="关于-常量命名"><a href="#关于-常量命名" class="headerlink" title="关于 常量命名"></a>关于 常量命名</h4><p>常量全大写,取名字尽量有意义，用下划线进行分割</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> SAMPLE_DATA = ...<br></code></pre></td></tr></table></figure>

<h4 id="关于路由命名"><a href="#关于路由命名" class="headerlink" title="关于路由命名"></a>关于路由命名</h4><figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">abc</span>-def   // 利用-来进行名称分割<br><span class="hljs-keyword">a</span><br><span class="hljs-keyword">ab</span><br><span class="hljs-keyword">abc</span><br></code></pre></td></tr></table></figure>

<h4 id="在-React-项目中给页面-细粒度-的增添-Loading-和-Error-状态-主要是提高的用户体验"><a href="#在-React-项目中给页面-细粒度-的增添-Loading-和-Error-状态-主要是提高的用户体验" class="headerlink" title="在 React 项目中给页面 细粒度 的增添 Loading 和 Error 状态(主要是提高的用户体验)"></a>在 React 项目中给页面 细粒度 的增添 Loading 和 Error 状态(主要是提高的用户体验)</h4><p>loading、error 的逻辑就是在接口请求前后，进行状态判断。因为 useEffect 是在组件挂载之后才会运行。而可能在组件挂载中使用的一些数据，还没有通过 useEffect 中的接口请求获取到。所以，弄一个 loading 界面显示，来代替还未完全获取完数据的组件</p>
]]></content>
      <categories>
        <category>面试篇</category>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目之道</tag>
      </tags>
  </entry>
  <entry>
    <title>ExpressJS 知识点总结</title>
    <url>/2021/11/20/ExpressJS-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>提示：本篇博客内容较长 应耐心看</p>
</blockquote>
<h4 id="nodejs-文件创建基本步骤"><a href="#nodejs-文件创建基本步骤" class="headerlink" title="nodejs 文件创建基本步骤"></a>nodejs 文件创建基本步骤</h4><p><a href="https://github.com/Bruce-shuai/ExpressJS-study">相关代码</a></p>
<p>在写<code>Express JS</code>之前，我们需要安装<code>nodejs</code>(毕竟 express 是 nodejs 的一个框架…)</p>
<p>然后安装<code>npm init -y</code><br>当前文件夹内部内容如下</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">|-package.json</span><br></code></pre></td></tr></table></figure>

<p>(在 <code>node</code> 开发中使用 <code>npm init</code> 会生成一个 <code>pakeage.json</code> 文件，这个文件主要是用来记录这个项目的详细信息的，它会将我们在项目开发中所要用到的包，以及项目的详细信息等记录在这个项目中。 方便在以后的版本迭代和项目移植的时候会更加的方便)</p>
<p>然后安装<code>express</code>:</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i express<br></code></pre></td></tr></table></figure>

<p>当前文件夹内部内容如下:</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">|-node_modules</span><br><span class="hljs-string">|-package-lock.json</span><br><span class="hljs-string">|-package.json</span><br></code></pre></td></tr></table></figure>

<p>然后安装<code>nodemon</code></p>
<figure class="highlight q"><table><tr><td class="code"><pre><code class="hljs q">npm i --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span> nodemon<br></code></pre></td></tr></table></figure>

<p>安装<code>nodemon</code>成功之后,将 package.json 中的</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>  <span class="hljs-string">&quot;test&quot;</span>: <span class="hljs-string">&quot;echo \&quot;</span><span class="hljs-keyword">Error</span>: <span class="hljs-keyword">no</span> <span class="hljs-keyword">test</span> specified\<span class="hljs-string">&quot; &amp;&amp; exit 1&quot;</span><br>&#125;,<br><br>修改为：<br><span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>  <span class="hljs-string">&quot;devStart&quot;</span>: <span class="hljs-string">&quot;nodemon xxxx&quot;</span>  <span class="hljs-comment">// xxxx 是我们要重启的文件(核心server文件)</span><br>&#125;,<br><br></code></pre></td></tr></table></figure>

<p>(<code>nodemon</code>的效果在于，我们每次修改 <code>node</code> 代码之后，都需要重启服务器才能看到最新的效果，<code>nodemon</code>是一个监听<code>node</code>代码文件变化的工具，文件一旦变更，就会自动重启<code>node</code>服务，即<strong>热更新</strong>操作，避免我们自己手动重启<code>nodejs</code>，大大方便了我们使用 <code>nodejs</code>)</p>
<blockquote>
<p><strong>注意：</strong> 上面的这几个模块，其实是使用 <code>nodejs</code> 都要安装的,所以要非常熟悉！！</p>
</blockquote>
<p>当前文件夹内部如下：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">|- ...         <span class="hljs-regexp">//</span> 我用... 代表 node_modules、package-lock.json、package.json<br>|-server.js    <span class="hljs-regexp">//</span> 为整个server端最核心的文件<br></code></pre></td></tr></table></figure>

<p>这时候，再在 package.json 文件中把</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-string">&quot;devStart&quot;</span>: <span class="hljs-string">&quot;nodemon xxxx&quot;</span> 中的xxxx用<span class="hljs-keyword">server</span>.js来代替即<br><span class="hljs-string">&quot;devStart&quot;</span>: <span class="hljs-string">&quot;nodemon server.js&quot;</span><br></code></pre></td></tr></table></figure>

<p>下面，我将把最核心的 <code>server 端</code>代码，写在这个<code>server.js</code>文件里。</p>
<p>然后，输入：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">npm <span class="hljs-builtin-name">run</span> devStart<br></code></pre></td></tr></table></figure>

<p>效果如下：<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-20-at-3.34.03-PM.png" alt="nodemon初体验1" width="250px"></p>
<p>我们在<code>server.js</code>这个空文件下写一句简单的代码</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">console.<span class="hljs-built_in">log</span>(&#x27;你好啊！nodejs&#x27;);  <span class="hljs-comment">// 用的就是js</span><br></code></pre></td></tr></table></figure>

<p>此时，<code>nodemon</code>开始自动发挥作用！<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-20-at-3.38.00-PM.png" alt="nodemon初体验2" width="250px"></p>
<p>好！现在 nodejs 的核心文件及相应的库已搭建完成！！</p>
<h4 id="ExpressJS-初体验"><a href="#ExpressJS-初体验" class="headerlink" title="ExpressJS 初体验"></a>ExpressJS 初体验</h4><h5 id="搭建最简单的-ExpressJS-代码"><a href="#搭建最简单的-ExpressJS-代码" class="headerlink" title="搭建最简单的 ExpressJS 代码"></a>搭建最简单的 ExpressJS 代码</h5><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* server.js */</span><br><br>const express = require(<span class="hljs-string">&#x27;express&#x27;</span>);  <span class="hljs-regexp">//</span> 第一步：调用之前下载的express库<br><br>const app = express(); <span class="hljs-regexp">//</span> 第二步: 创建一个app变量，用于调用express函数, 只有调用这个express函数，我们才能创建整个server端！<br><br>app.listen(<span class="hljs-number">3004</span>);   <span class="hljs-regexp">//</span> 第三步: 为了让我们的server端真正运行起来，我们需要把我们的服务器放在一个可用的端口上！<br></code></pre></td></tr></table></figure>

<p>现在，我们的 <code>server</code> 端就在<code>端口3004</code> 里运作起来了！！</p>
<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-20-at-3.46.45-PM.png" alt="express初体验1" width="250px">

<p>由于，我们当前我们的 server 端没有任何路由，所以出现<code>Cannot GET /</code></p>
<h5 id="搭建路由-routes"><a href="#搭建路由-routes" class="headerlink" title="搭建路由(routes)"></a>搭建路由(routes)</h5><p>因此，我们开始在 server 端搭建路由！</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* server.js */</span><br><br>const express = require(<span class="hljs-string">&#x27;express&#x27;</span>);<br>const app = express();<br><br><span class="hljs-regexp">//</span> 最简单的搭建route的方式如下：<br>/**<br>  app.get()<br>  app.post()<br>  app.<span class="hljs-keyword">delete</span>()<br>  ...   <span class="hljs-regexp">//</span> 我可以搭建任何http请求方式的路由<br>*/<br><br><span class="hljs-regexp">//</span> 现在搭建一个根路由, 两个参数，第二个参数是一个函数<br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, (req, res, <span class="hljs-keyword">next</span>) =&gt; &#123;  <span class="hljs-regexp">//</span> 这个函数有三个参数，但是第三个参数(可选参数)，实际上<span class="hljs-number">99.9</span>%的可能上都不会使用<br>  res.send(<span class="hljs-string">&#x27;你好！！&#x27;</span>)  <span class="hljs-regexp">//</span> 注意：res是response的缩写<br>&#125;)。这里的数据会显示到客户端 <span class="hljs-number">3004</span> 端口上<br><br>app.listen(<span class="hljs-number">3004</span>);<br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-20-at-3.59.39-PM.png" alt="express初体验2" width="250px">

<h6 id="res-response-的一系列操作"><a href="#res-response-的一系列操作" class="headerlink" title="res(response) 的一系列操作"></a>res(response) 的一系列操作</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><br><span class="hljs-keyword">const</span> app = express();<br><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.sendStatus(xxx);  <span class="hljs-comment">// xxx是状态码，我们可以给客户端传对应的http状态码</span><br>&#125;)<br><br>app.listen(<span class="hljs-number">3004</span>);<br></code></pre></td></tr></table></figure>

<p>效果如下：xxx 我用 500 代替<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-20-at-4.03.46-PM.png" alt="状态码初体验1" width="300px"></p>
<p>显而易见，客户端就出现 500 这种状态了！！</p>
<p>更进一步，我想在传状态码的同时，发一些对应的内容，应该有如下操作</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(req, res)</span> =&gt;</span> &#123;<br>  res.status(<span class="hljs-number">500</span>).send(<span class="hljs-string">&#x27;当前状态码：500&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-20-at-4.07.08-PM.png" alt="状态码初体验2" width="300px">

<p>甚至我还可以发送一些 json 数据…</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(req, res)</span> =&gt;</span> &#123;<br>  res.status(<span class="hljs-number">500</span>).json(&#123;message: <span class="hljs-string">&quot;这是json数据&quot;</span>&#125;)<br>&#125;)<br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-20-at-4.09.51-PM.png" alt="状态码初体验3" width="300px">

<p>事实上，我们在前后端接口数据传递的时候，<code>json 字符串</code>是最常用的！！</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(req, res)</span> =&gt;</span> &#123;<br>  res.json(&#123;message: <span class="hljs-string">&quot;这是json数据&quot;</span>&#125;)  <span class="hljs-regexp">//</span> 我们甚至可以无视状态码！！<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>我们还可以发送一些文件，让客户端直接下载…</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(req, res)</span> =&gt;</span> &#123;<br>  res.download(<span class="hljs-string">&#x27;xxx&#x27;</span>) <span class="hljs-regexp">//</span> xxx是对应文件<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>我们还可以通过<code>res</code> 来对<code>html文件</code>进行系列操作(非常常用)</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(req, res)</span> =&gt;</span> &#123;<br>  res.render(<span class="hljs-string">&#x27;xxx&#x27;</span>) <span class="hljs-regexp">//</span> xxx是对应html文件的路径<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>事实上，在 server 端，我们常习惯创建一个<code>views</code>文件夹放置呈现视觉效果的文件</p>
<p>当前文件夹</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">-...</span><br><span class="hljs-string"></span>|<span class="hljs-string">-views</span><br><span class="hljs-string"></span>|<span class="hljs-string">  </span>|<span class="hljs-string">-index.html</span><br><span class="hljs-string"></span>|<span class="hljs-string">-server.js</span><br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">/* views/index.html */<br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  学习Express JS<br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(req, res)</span> =&gt;</span> &#123;<br>  res.render(<span class="hljs-string">&#x27;xxx&#x27;</span>) <span class="hljs-regexp">//</span> xxx是对应html文件的路径<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>但仅仅上面的操作是无法展示出 view 的内容的，我们需要给 server 端安装<code>view engine</code></p>
<p>而推荐使用的<code>view engine</code>是<code>ejs</code>,因为它的操作和<code>html</code>非常一直，所以上手是非常快的…<br>安装 <code>ejs</code>，作为可视引擎</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i ejs<br></code></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> express = require(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> app = express();<br><br><span class="hljs-comment">// 使用 view engine</span><br>app.<span class="hljs-keyword">set</span>(<span class="hljs-string">&#x27;view engine&#x27;</span>, <span class="hljs-string">&#x27;ejs&#x27;</span>);<br><br>app.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, (req, res) =&gt; &#123;<br>  res.render(<span class="hljs-string">&#x27;index&#x27;</span>)<br>&#125;)<br><br>app.listen(<span class="hljs-number">3004</span>);<br></code></pre></td></tr></table></figure>

<p>把 <code>index.html</code> 文件后缀改为 <code>index.ejs</code></p>
<blockquote>
<p>在 <code>vscode</code> 中可安装 <code>EJS language support</code> 这个插件来给 ejs 代码 提供语法高亮</p>
</blockquote>
<p>效果展示：<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-20-at-5.37.19-PM.png" alt="ejs初体验1" width="300px"></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">app.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, (req, <span class="hljs-keyword">res</span>) =&gt; &#123;<br>  <span class="hljs-keyword">res</span>.render(<span class="hljs-string">&#x27;index&#x27;</span>, &#123;tex<span class="hljs-variable">t:</span> <span class="hljs-string">&#x27;World&#x27;</span>&#125;) // 这里的第二个参数是一个对象，可以传递给<span class="hljs-keyword">view</span>文件<br>&#125;)<br></code></pre></td></tr></table></figure>

<figure class="highlight mel"><table><tr><td class="code"><pre><code class="hljs mel"><span class="hljs-comment">/* index.ejs*/</span><br>Hello, &lt;%= <span class="hljs-keyword">text</span> %&gt;<br><span class="hljs-comment">// &lt;%= %&gt;  能够有非常多的操作...</span><br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-20-at-5.41.24-PM.png" alt="ejs初体验2" width="300px">

<figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">/* index.ejs*/</span><br>Hello, &lt;<span class="hljs-meta">%</span>= text<span class="hljs-number">1111</span> <span class="hljs-meta">%</span>&gt;  <span class="hljs-comment">// 有时候变量可能并未在express里设置，则view呈现的就是错误的内容</span><br><br><span class="hljs-comment">// 解决方法：在未知变量前加上 locals 这样，即便text1111这个变量未在服务端设置。仅仅会变成undefined而不会报错！</span><br>Hello, &lt;<span class="hljs-meta">%</span>= locals.text<span class="hljs-number">1111</span> || <span class="hljs-string">&#x27;Defalt&#x27;</span> <span class="hljs-meta">%</span>&gt;<br></code></pre></td></tr></table></figure>

<h4 id="单独为路由创建一个文件夹-routes"><a href="#单独为路由创建一个文件夹-routes" class="headerlink" title="单独为路由创建一个文件夹 routes"></a>单独为路由创建一个文件夹 routes</h4><p>我们其实可以发现。 在服务端，会有各种各样的路由出现。例如</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/* server.js */</span><br><br><span class="hljs-keyword">const</span> express = require(<span class="hljs-string">&#x27;express&#x27;</span>);<br><br><span class="hljs-keyword">const</span> app = express();<br><br>app.<span class="hljs-keyword">set</span>(<span class="hljs-string">&#x27;view engine&#x27;</span>, <span class="hljs-string">&#x27;ejs&#x27;</span>)<br><br>app.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, (req, res) =&gt; &#123;<br>  res.render(<span class="hljs-string">&#x27;index&#x27;</span>,&#123;text: <span class="hljs-string">&#x27;World&#x27;</span>&#125;)<br>&#125;)<br><br>app.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;/users&#x27;</span>, (req, res) =&gt; &#123;<br>  ...<br>&#125;)<br><br>app.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;/users/news&#x27;</span>, (req, res) =&gt; &#123;<br>  ...<br>&#125;)<br><br><span class="hljs-comment">// ...各种路由</span><br>app.listen(<span class="hljs-number">3004</span>);<br></code></pre></td></tr></table></figure>

<p>如果在一个文件里塞入过多路由，有项目经验的伙伴其实就能察觉到不对劲，这会让文件显得非常的臃肿！！且难以维护！！</p>
<p>所以我们要为<code>route</code>建立单独的文件夹(routes)，并且<code>express</code>也给我们提供了对应的方法</p>
<p>当前文件夹</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">—...</span><br><span class="hljs-string"></span>|<span class="hljs-string">-routes</span><br><span class="hljs-string"></span>|<span class="hljs-string">  </span>|<span class="hljs-string">-user.js  // 此文件放置所有user路由的内容</span><br><span class="hljs-string"></span>|<span class="hljs-string">-views</span><br><span class="hljs-string"></span>|<span class="hljs-string">  </span>|<span class="hljs-string">-index.ejs</span><br><span class="hljs-string"></span>|<span class="hljs-string">-server.js</span><br></code></pre></td></tr></table></figure>

<p>整理时候：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* routes/user.js */</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> router = express.Router();<br><br>router.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">&quot;这是User路径&quot;</span>)<br>&#125;)<br><br>router.get(<span class="hljs-string">&#x27;/new&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">&quot;这是User 下 的new路径&quot;</span>)<br>&#125;)<br><br><span class="hljs-built_in">module</span>.exports = router;<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* server.js */</span><br><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><br><span class="hljs-keyword">const</span> app = express();<br><br>app.set(<span class="hljs-string">&#x27;view engine&#x27;</span>, <span class="hljs-string">&#x27;ejs&#x27;</span>)<br><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.render(<span class="hljs-string">&#x27;index&#x27;</span>,&#123;<span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;World&#x27;</span>&#125;)<br>&#125;)<br><br><span class="hljs-keyword">const</span> userRouter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./routes/users&#x27;</span>)  <span class="hljs-comment">// 这里用的是相对路径</span><br><br>app.use(<span class="hljs-string">&#x27;/users&#x27;</span>, userRouter);  <span class="hljs-comment">// &#x27;这里的users 只用写一次&#x27;</span><br><br><span class="hljs-comment">// ...各种路由</span><br>app.listen(<span class="hljs-number">3004</span>);<br></code></pre></td></tr></table></figure>

<p>现在我想给路由增加参数：例如：<code>/users/1</code>、<code>/users/2</code> … 显然，如果我们自己手写 1、2、3…是 不灵活且麻烦的事，我们可以使用<code>:</code>+<code>变量</code>的操作</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">router.get(<span class="hljs-string">&#x27;/:id&#x27;</span>, (req, res) =&gt; &#123;<br>  <span class="hljs-regexp">//</span> req.param.id  <span class="hljs-regexp">//</span> 这里的id 对应:后面的id (变量名自己任意拟定)<br>  res.send(`Get User With ID <span class="hljs-variable">$&#123;req.params.id&#125;</span>`)<br>&#125;)<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong> router 是<strong>由从上到下</strong>的执行顺序<br>例如：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">routes/users.js<br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> router = express.Router();<br><br><br>router.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">&quot;这是User路径&quot;</span>)<br>&#125;)<br><br>router.get(<span class="hljs-string">&#x27;/:id&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// req.param.id</span><br>  res.send(<span class="hljs-string">`Get User With ID <span class="hljs-subst">$&#123;req.params.id&#125;</span>`</span>)<br>&#125;)<br><br>router.get(<span class="hljs-string">&#x27;/new&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">&quot;这是User 下 的new路径&quot;</span>)<br>&#125;)<br><br><span class="hljs-built_in">module</span>.exports = router;<br></code></pre></td></tr></table></figure>

<p>然后我在浏览器输入： <a href="http://localhost:3004/users/51">http://localhost:3004/users/51</a></p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">浏览器页面如下显示： Get <span class="hljs-keyword">User</span> <span class="hljs-title">With</span> ID <span class="hljs-number">51</span><br></code></pre></td></tr></table></figure>

<p>但如果我这样输入：<a href="http://localhost:3004/users/new">http://localhost:3004/users/new</a></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">浏览器页面如下显示： <span class="hljs-keyword">Get</span> <span class="hljs-keyword">User</span> <span class="hljs-keyword">With</span> ID <span class="hljs-built_in">new</span><br></code></pre></td></tr></table></figure>

<p>而不是</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">这是<span class="hljs-keyword">User</span> <span class="hljs-title">下 的new</span>路径<br></code></pre></td></tr></table></figure>

<p>因为 <code>new</code> 的路径设置是放在了<code>:id</code> 这个路径之后的</p>
<p>所以，有时候为了避免这样的误解,我们应该把这种变量的路径放在文件的<strong>最下方</strong>！</p>
<h5 id="同路径下多种请求方式的简写"><a href="#同路径下多种请求方式的简写" class="headerlink" title="同路径下多种请求方式的简写"></a>同路径下多种请求方式的简写</h5><p>现在有一个新问题出现：同个路径下我如果有多种请求方式，应该怎样简写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">router.get(<span class="hljs-string">&#x27;/:id&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">`Get User With ID <span class="hljs-subst">$&#123;req.params.id&#125;</span>`</span>)<br>&#125;)<br><br>router.post(<span class="hljs-string">&#x27;/:id&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">`Post User With ID <span class="hljs-subst">$&#123;req.params.id&#125;</span>`</span>)<br>&#125;)<br><br>router.put(<span class="hljs-string">&#x27;/:id&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">`Put User With ID <span class="hljs-subst">$&#123;req.params.id&#125;</span>`</span>)<br>&#125;)<br><br>router.delete(<span class="hljs-string">&#x27;/:id&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">`Delete User With ID <span class="hljs-subst">$&#123;req.params.id&#125;</span>`</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>简写方式如下：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">router.route(<span class="hljs-string">&quot;/:id&quot;</span>)<br>.get(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">`Get User With ID <span class="hljs-subst">$&#123;req.params.id&#125;</span>`</span>)<br>&#125;)<br>.post(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">`Post User With ID <span class="hljs-subst">$&#123;req.params.id&#125;</span>`</span>)<br>&#125;)<br>.put(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">`Put User With ID <span class="hljs-subst">$&#123;req.params.id&#125;</span>`</span>)<br>&#125;)<br>.delete(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">`Delete User With ID <span class="hljs-subst">$&#123;req.params.id&#125;</span>`</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>

<h5 id="router-param-函数的生神奇使用"><a href="#router-param-函数的生神奇使用" class="headerlink" title="router.param 函数的生神奇使用"></a>router.param 函数的生神奇使用</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* routes/users.js */</span><br>router.get(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">&quot;这是User路径&quot;</span>)<br>&#125;)<br><br>router.route(<span class="hljs-string">&quot;/:id&quot;</span>)<br>.get(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">`Get User With ID <span class="hljs-subst">$&#123;req.params.id&#125;</span>`</span>)<br>&#125;)<br>.post(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">`Post User With ID <span class="hljs-subst">$&#123;req.params.id&#125;</span>`</span>)<br>&#125;)<br>.put(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">`Put User With ID <span class="hljs-subst">$&#123;req.params.id&#125;</span>`</span>)<br>&#125;)<br>.delete(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">`Delete User With ID <span class="hljs-subst">$&#123;req.params.id&#125;</span>`</span>)<br>&#125;)<br><br>router.param(<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res, next, id</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(id);<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>这时候的效果如下：</p>
<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-20-at-7.43.10-PM.png" alt="param函数初体验1" width="250px">

<p>页面上还是显现的<code>/users</code>下面的内容，同时该页面在无穷的加载中,但是控制台的内容显示如下<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-20-at-7.45.14-PM.png" alt="param函数初体验2" width="250px"></p>
<p>页面在无穷加载的原因是我们没有进行 <code>next()</code> 操作，所以 param 函数里面的代码没有运行</p>
<figure class="highlight moonscript"><table><tr><td class="code"><pre><code class="hljs moonscript">router.param(<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(req, res, <span class="hljs-built_in">next</span>, id)</span> =&gt;</span> &#123;<br>  console.log(id);<br>  <span class="hljs-built_in">next</span>();<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>好了，现在页面显示</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">Get <span class="hljs-keyword">User</span> <span class="hljs-title">With</span> ID <span class="hljs-number">11</span><br></code></pre></td></tr></table></figure>

<p>并且停止无穷加载<br>这里涉及<strong>中间件</strong>的知识，这里的内容我会另写一篇博客…</p>
<p>现在，我们进行更多的灵活操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">router.route(<span class="hljs-string">&quot;/:id&quot;</span>)<br>.get(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(req.user)<br>  res.send(<span class="hljs-string">`Get User With ID <span class="hljs-subst">$&#123;req.params.id&#125;</span>`</span>)<br>&#125;)<br>.post(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">`Post User With ID <span class="hljs-subst">$&#123;req.params.id&#125;</span>`</span>)<br>&#125;)<br>.put(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">`Put User With ID <span class="hljs-subst">$&#123;req.params.id&#125;</span>`</span>)<br>&#125;)<br>.delete(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">`Delete User With ID <span class="hljs-subst">$&#123;req.params.id&#125;</span>`</span>)<br>&#125;)<br><br><span class="hljs-keyword">const</span> users = [&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;帅得乱七八糟&#x27;</span>&#125;, &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;帅得歪瓜裂枣&#x27;</span>&#125;]<br>router.param(<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res, next, id</span>) =&gt;</span> &#123;<br>  req.user = users[id];<br>  <span class="hljs-built_in">console</span>.log(req.user);<br>  next();<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>我在浏览器上输入：…/users/1<br>有如下打印：<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-20-at-7.57.45-PM.png" alt="param函数初体验3" width="250px"></p>
<p>下面来一个 <code>middleware</code> 操作…<br>一般只有使用<code>middleware</code>才会动用<code>next</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* server.js */</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> app = express();<br><br>app.set(<span class="hljs-string">&#x27;view engine&#x27;</span>, <span class="hljs-string">&#x27;ejs&#x27;</span>)<br><br>app.use(logger)   <span class="hljs-comment">// 新增内容</span><br><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.render(<span class="hljs-string">&#x27;index&#x27;</span>,&#123;<span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;World&#x27;</span>&#125;)<br>&#125;)<br><br><span class="hljs-keyword">const</span> userRouter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./routes/users&quot;</span>);<br><br>app.use(<span class="hljs-string">&quot;/users&quot;</span>, userRouter);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logger</span>(<span class="hljs-params">req, res, next</span>) </span>&#123;  <span class="hljs-comment">// 新增内容 使用中间件</span><br>  <span class="hljs-built_in">console</span>.log(req.originalUrl)<br>  next();<br>&#125;<br><br>app.listen(<span class="hljs-number">3004</span>);<br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-20-at-8.05.54-PM.png" alt="param函数初体验4" width="250px">

<p>因为我当前页面在 <code>.../users/1</code> 。所以打印的内容也是 <code>/users/1</code></p>
<p>注意，中间件也是从上到下执行，为了避免一些错误。例如下面：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* server.js */</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> app = express();<br><br>app.set(<span class="hljs-string">&#x27;view engine&#x27;</span>, <span class="hljs-string">&#x27;ejs&#x27;</span>)<br><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.render(<span class="hljs-string">&#x27;index&#x27;</span>,&#123;<span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;World&#x27;</span>&#125;)<br>&#125;)<br><br>app.use(logger)   <span class="hljs-comment">// 注意：我的位置</span><br><br><span class="hljs-keyword">const</span> userRouter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./routes/users&quot;</span>);<br><br>app.use(<span class="hljs-string">&quot;/users&quot;</span>, userRouter);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logger</span>(<span class="hljs-params">req, res, next</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(req.originalUrl)<br>  next();<br>&#125;<br><br>app.listen(<span class="hljs-number">3004</span>);<br></code></pre></td></tr></table></figure>

<p>我当前页面在 <code>.../</code> 。但是打印的内容是 <code>/users/1</code><br>因为 app.user 没有注意到在自己上面的 app.get(‘/‘…)<br>所以，你想让中间件对所有路由起效，则应该把中间件的使用(<code>app.use(...)</code>)放在所有路由<strong>上面</strong></p>
<p>如果想让中间件作用于指定路由，应该是如下操作！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* server.js */</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> app = express();<br><br>app.set(<span class="hljs-string">&#x27;view engine&#x27;</span>, <span class="hljs-string">&#x27;ejs&#x27;</span>)<br><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>,logger, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;  <span class="hljs-comment">// 我想作用于 &#x27;/&#x27; 路由</span><br>  res.render(<span class="hljs-string">&#x27;index&#x27;</span>,&#123;<span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;World&#x27;</span>&#125;)<br>&#125;)<br><br><span class="hljs-keyword">const</span> userRouter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./routes/users&quot;</span>);<br><br>app.use(<span class="hljs-string">&quot;/users&quot;</span>, userRouter);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logger</span>(<span class="hljs-params">req, res, next</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(req.originalUrl)<br>  next();<br>&#125;<br><br>app.listen(<span class="hljs-number">3004</span>);<br></code></pre></td></tr></table></figure>

<p>这样，只有我执行 <code>.../</code> 这个根路径的时候，<code>logger</code>函数才会生效，其余路径都不会生效</p>
<p>甚至我可以在一个路径上执行多个中间件</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">app.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>,logger,logger,logger (req, <span class="hljs-keyword">res</span>) =&gt; &#123;  // 我想作用于 <span class="hljs-string">&#x27;/&#x27;</span> 路由<br>  <span class="hljs-keyword">res</span>.render(<span class="hljs-string">&#x27;index&#x27;</span>,&#123;tex<span class="hljs-variable">t:</span> <span class="hljs-string">&#x27;World&#x27;</span>&#125;)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>这样，我仅在浏览器上刷新根路径的时候，控制台(vscode 里的控制台)才会打印 3 次 <code>/</code></p>
<h4 id="渲染静态文件-静态文件可以是-html、css、js"><a href="#渲染静态文件-静态文件可以是-html、css、js" class="headerlink" title="渲染静态文件(静态文件可以是 html、css、js)"></a>渲染静态文件(静态文件可以是 html、css、js)</h4><p>创建一个 <code>public</code> 文件夹</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">-...</span><br><span class="hljs-string"></span>|<span class="hljs-string">-public</span><br><span class="hljs-string"></span>|<span class="hljs-string">   </span>|<span class="hljs-string">-test</span><br><span class="hljs-string"></span>|<span class="hljs-string">      </span>|<span class="hljs-string">-tt.html</span><br><span class="hljs-string"></span>|<span class="hljs-string">   </span>|<span class="hljs-string">-index.html</span><br><span class="hljs-string"></span>|<span class="hljs-string">-routes</span><br><span class="hljs-string"></span>|<span class="hljs-string">   </span>|<span class="hljs-string">-user.js</span><br><span class="hljs-string"></span>|<span class="hljs-string">-views</span><br><span class="hljs-string"></span>|<span class="hljs-string">-server.js</span><br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">/* index.html */<br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  这是index.html 文件<br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">/* tt.html文件 */<br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  乱七八糟的内容<br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight zephir"><table><tr><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">/* server.js */</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> app = express();<br><br>app.set(<span class="hljs-string">&#x27;view engine&#x27;</span>, <span class="hljs-string">&#x27;ejs&#x27;</span>)<br><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, (req, res) =&gt; &#123;<br>  res.render(<span class="hljs-string">&#x27;index&#x27;</span>,&#123;text: <span class="hljs-string">&#x27;World&#x27;</span>&#125;)<br>&#125;)<br><br>app.<span class="hljs-keyword">use</span>(express.<span class="hljs-keyword">static</span>(<span class="hljs-string">&quot;public&quot;</span>))  <span class="hljs-comment">// 增添的内容</span><br><br><span class="hljs-keyword">const</span> userRouter = <span class="hljs-keyword">require</span>(<span class="hljs-string">&quot;./routes/users&quot;</span>);<br><br>app.<span class="hljs-keyword">use</span>(<span class="hljs-string">&quot;/users&quot;</span>, userRouter);<br><br>app.listen(<span class="hljs-number">3004</span>);<br></code></pre></td></tr></table></figure>

<p>现在，我可以在浏览器渲染<code>public</code>里面的静态文件了</p>
<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-20-at-8.47.21-PM.png" alt="静态文件渲染1" width="250px">

<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-20-at-8.48.10-PM.png" alt="静态文件渲染2" width="250px">

<h4 id="前后端数据常用操作：解析-form-json-数据"><a href="#前后端数据常用操作：解析-form-json-数据" class="headerlink" title="前后端数据常用操作：解析 form/json 数据"></a>前后端数据常用操作：解析 form/json 数据</h4><p>现在文件夹有如下变化</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">-...</span><br><span class="hljs-string"></span>|<span class="hljs-string">-public</span><br><span class="hljs-string"></span>|<span class="hljs-string">   </span>|<span class="hljs-string">-test</span><br><span class="hljs-string"></span>|<span class="hljs-string">      </span>|<span class="hljs-string">-tt.html</span><br><span class="hljs-string"></span>|<span class="hljs-string">   </span>|<span class="hljs-string">-index.html</span><br><span class="hljs-string"></span>|<span class="hljs-string">-routes</span><br><span class="hljs-string"></span>|<span class="hljs-string">   </span>|<span class="hljs-string">-user.js</span><br><span class="hljs-string"></span>|<span class="hljs-string">-views</span><br><span class="hljs-string"></span>|<span class="hljs-string">   </span>|<span class="hljs-string">-users</span><br><span class="hljs-string"></span>|<span class="hljs-string">      </span>|<span class="hljs-string">-new.ejs</span><br><span class="hljs-string"></span>|<span class="hljs-string">-server.js</span><br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">/* new.ejs 文件 */<br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/users&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>      名字：<br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&lt;%= locals.username %&gt; &quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* routes/user.js */</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express&quot;</span>)<br><span class="hljs-keyword">const</span> router = express.Router()<br><br><br>router.get(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">&quot;...&quot;</span>)<br>&#125;)<br>router.post(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(req.body.username)<br>&#125;)<br><br><span class="hljs-comment">// 注意：这里是get请求</span><br>router.get(<span class="hljs-string">&quot;/new&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.render(<span class="hljs-string">&quot;users/new&quot;</span>, &#123;<span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;帅得乱七八糟&#x27;</span>&#125;)<br>&#125;)<br><span class="hljs-built_in">module</span>.exports = router;<br></code></pre></td></tr></table></figure>

<figure class="highlight zephir"><table><tr><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">/* server.js */</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> app = express();<br><br>app.set(<span class="hljs-string">&#x27;view engine&#x27;</span>, <span class="hljs-string">&#x27;ejs&#x27;</span>)<br><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>,logger, (req, res) =&gt; &#123;<br>  res.render(<span class="hljs-string">&#x27;index&#x27;</span>,&#123;text: <span class="hljs-string">&#x27;World&#x27;</span>&#125;)<br>&#125;)<br><br>app.<span class="hljs-keyword">use</span>(express.<span class="hljs-keyword">static</span>(<span class="hljs-string">&quot;public&quot;</span>))<br><br>app.<span class="hljs-keyword">use</span>(express.urlencoded(&#123; extended: <span class="hljs-keyword">true</span>&#125;)) <span class="hljs-comment">// 重点关注： 才能让req.body.username获取form表格数据起效果</span><br><br><br><span class="hljs-keyword">const</span> userRouter = <span class="hljs-keyword">require</span>(<span class="hljs-string">&quot;./routes/users&quot;</span>);<br><br>app.<span class="hljs-keyword">use</span>(<span class="hljs-string">&quot;/users&quot;</span>, userRouter);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logger</span><span class="hljs-params">(req, res, next)</span> </span>&#123;<br>  console.log(req.originalUrl)<br>  next();<br>&#125;<br><br>app.listen(<span class="hljs-number">3004</span>);<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-20-at-9.42.24-PM.gif" alt="效果"></p>
<p>更多操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* routes/user.js */</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express&quot;</span>)<br><span class="hljs-keyword">const</span> router = express.Router()<br><br><br>router.get(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">&quot;...&quot;</span>)<br>&#125;)<br><span class="hljs-keyword">const</span> users = [&#123;<span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;帅得歪瓜裂枣&#x27;</span>&#125;, &#123;<span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;帅得一塌糊涂&#x27;</span>&#125;]<br><br><br>router.post(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> isValid = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">if</span>(isValid) &#123;<br>    users.push(&#123;<span class="hljs-attr">firstName</span>: req.body.username&#125;)<br>    res.redirect(<span class="hljs-string">`/users/<span class="hljs-subst">$&#123;users.length - <span class="hljs-number">1</span>&#125;</span>`</span>)  <span class="hljs-comment">// 重定向</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Error&#x27;</span>)<br>    res.render(<span class="hljs-string">&#x27;users/user&#x27;</span>, &#123;<span class="hljs-attr">username</span>: req.body.username&#125;)<br>  &#125;<br>&#125;)<br><br>router.route(<span class="hljs-string">&quot;/:id&quot;</span>)<br>.get(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(req.user)<br>  res.send(<span class="hljs-string">`Get User With ID <span class="hljs-subst">$&#123;req.params.id&#125;</span>`</span>)<br>&#125;)<br>.post(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">`Post User With ID <span class="hljs-subst">$&#123;req.params.id&#125;</span>`</span>)<br>&#125;)<br>.put(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">`Put User With ID <span class="hljs-subst">$&#123;req.params.id&#125;</span>`</span>)<br>&#125;)<br>.delete(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">`Delete User With ID <span class="hljs-subst">$&#123;req.params.id&#125;</span>`</span>)<br>&#125;)<br><br>router.get(<span class="hljs-string">&quot;/new&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.render(<span class="hljs-string">&quot;users/new&quot;</span>, &#123;<span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;帅得乱七八糟&#x27;</span>&#125;)<br>&#125;)<br><span class="hljs-built_in">module</span>.exports = router;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-20-at-9.58.52-PM.gif" alt="灵活用法"></p>
<p><strong>注意：</strong> 如果你想传递 json 文件和表格一样，你需要在 server.js 文件里 增添一行代码：<br>代码如下：<code>app.use(express.json())</code></p>
<p>其实上述代码对应提交 form 表格的<code>app.use(express.urlencoded(&#123; extended: true&#125;))</code> 所以这两者放的位置也差不多</p>
<h4 id="处理-Query-parameters"><a href="#处理-Query-parameters" class="headerlink" title="处理 Query parameters"></a>处理 Query parameters</h4><p>非常简单。只需在相应的路径通过 <code>req.query.name</code>来获取</p>
<p>例如：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">/* routes/users */</span><br>router<span class="hljs-selector-class">.get</span>(<span class="hljs-string">&quot;/&quot;</span>, (req, res) =&gt; &#123;<br>  res<span class="hljs-selector-class">.send</span>(req<span class="hljs-selector-class">.query</span>.food) <span class="hljs-comment">// food 就是url中参数里键值对的键</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-20-at-10.07.37-PM.gif" alt="query param"></p>
<h4 id="解析-req-body-内容"><a href="#解析-req-body-内容" class="headerlink" title="解析 req.body 内容"></a>解析 req.body 内容</h4><p>需要安装一个库:<code>npm i body-parser</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* server.js */</span><br><span class="hljs-keyword">const</span> bodyParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;body-parser&#x27;</span>);<br><br>app.use(bodyParser.json());   <span class="hljs-comment">// 因为使用的是json版本的body内容</span><br>app.post(<span class="hljs-string">&#x27;...&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> xxx = req.body.xxx;<br>&#125;)<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Node.JS篇</category>
      </categories>
      <tags>
        <tag>全栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket.io 知识总结</title>
    <url>/2021/11/21/Socket-io-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="socket-io-介绍"><a href="#socket-io-介绍" class="headerlink" title="socket.io 介绍"></a>socket.io 介绍</h4><p>本博客涉及的项目:<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-30-at-11.01.18-PM.gif" alt="项目"><br>源代码:<a href="https://github.com/Bruce-shuai/societ.io-study">点击</a></p>
<p><code>socket.io</code>的作用是 可以<strong>持久化</strong>的连接客户端和服务端 —&gt; 这里涉及 <code>WebSocket</code> 的知识！这块知识有待学习！<br>在正常情况下，你发送一个<code>fetch</code>或<code>ajax</code>请求，是在告诉服务端给我(客户端)一些数据，然后服务端就给我(客户端)一些数据，之后就停止数据的发送。<br>所以，如果你想要 10 条不同的 <code>fetch</code> 请求数据，你需要发送 10 次客户端的请求到 server 端。</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta">fetch、ajax ====&gt;  <span class="hljs-keyword">server</span> ====&gt; <span class="hljs-keyword">client</span><br>fetch、ajax ====&gt;  <span class="hljs-keyword">server</span> ====&gt; <span class="hljs-keyword">client</span><br>fetch、ajax ====&gt;  <span class="hljs-keyword">server</span> ====&gt; <span class="hljs-keyword">client</span><br>fetch、ajax ====&gt;  <span class="hljs-keyword">server</span> ====&gt; <span class="hljs-keyword">client</span><br>fetch、ajax ====&gt;  <span class="hljs-keyword">server</span> ====&gt; <span class="hljs-keyword">client</span><br>fetch、ajax ====&gt;  <span class="hljs-keyword">server</span> ====&gt; <span class="hljs-keyword">client</span><br>fetch、ajax ====&gt;  <span class="hljs-keyword">server</span> ====&gt; <span class="hljs-keyword">client</span><br>fetch、ajax ====&gt;  <span class="hljs-keyword">server</span> ====&gt; <span class="hljs-keyword">client</span><br>fetch、ajax ====&gt;  <span class="hljs-keyword">server</span> ====&gt; <span class="hljs-keyword">client</span><br>fetch、ajax ====&gt;  <span class="hljs-keyword">server</span> ====&gt; <span class="hljs-keyword">client</span><br></code></pre></td></tr></table></figure>

<p>但是如果是 <code>Socket.io</code> 就不一样了, 我只需要一次连接(是 WebSocket 的连接方式)，WebSocket 能够连接客户端和服务端并且是持续性的，不会断开(除非你自己断开)；这样就可以一次 <code>WebSocket</code>连接然后进行多次服务端和客户端进行通信。这样也极大的节省了通信之中连接和关闭的时间。</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta">WebSocket ====&gt; <span class="hljs-keyword">server</span> ====&gt; <span class="hljs-keyword">client</span><br></code></pre></td></tr></table></figure>

<p>相对于 <code>HTTP</code> 这种非持久的协议而言，<code>Websocket</code> 是一个持久化的协议</p>
<p>对于 <code>Socket.io</code> 我认为比较有特点的就是聊天功能实现，完全能展示<code>Socket.io</code>的优势！其实我之前有个项目的一个功能就是利用的<code>Socket.io</code>来实现通话，现在，此篇博客，我再以一个聊天小功能来讲解一下<code>Socket.io</code></p>
<p>注意：<code>socket.io</code> 是涉及 <code>server</code> 端的，所以应该对 <code>nodejs</code> 有一定的了解才行！</p>
<h4 id="socket-io-的搭建"><a href="#socket-io-的搭建" class="headerlink" title="socket.io 的搭建"></a>socket.io 的搭建</h4><figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">server 文件夹安装的相关库：<br><span class="hljs-built_in">npm</span> init -y<br><span class="hljs-built_in">npm</span> i nodemon<br><span class="hljs-built_in">npm</span> i socket.io<br></code></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* server/</span>server.js */<br>const io = require(<span class="hljs-string">&#x27;socket.io&#x27;</span>)(<span class="hljs-number">3004</span>)  <span class="hljs-regexp">//</span> 让 socket.io 运行在<span class="hljs-number">3004</span>端口上<br><br><span class="hljs-regexp">//</span> 每次有一个用户连接了server端，这里便会有一个socket实例生成<br>io.on(<span class="hljs-string">&#x27;connection&#x27;</span>, socket =&gt; &#123;<br>  console.log(socket.id);  <span class="hljs-regexp">//</span> 这里的id是随机的，当有用户连接上socket.io时，就会分配一个id<br>&#125;)<br></code></pre></td></tr></table></figure>

<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">client</span> 文件夹要安装的相关库<br>npm i socket.io-<span class="hljs-keyword">client</span><br></code></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* client/</span>App.js */<br><span class="hljs-regexp">//</span> 相关的核心代码<br>import &#123;io&#125; from <span class="hljs-string">&#x27;socket.io-client&#x27;</span>;   <span class="hljs-regexp">//</span> 这里的io其实也是一个函数，我们可以通过这个io获得独立的socket<br><br>const socket = io(<span class="hljs-string">&#x27;http://localhost:3004&#x27;</span>);    <span class="hljs-regexp">//</span> 目的是连接到前面我设置的<span class="hljs-number">3004</span>端口上的服务端 (注意！这一步应单独放在react组件外，不要放在react组件内部，不然容易造成莫名的死循环！！)<br><br><span class="hljs-keyword">function</span> App() &#123;   <span class="hljs-regexp">//</span> react组件<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>前后端连接完成！ 但看似简单，其实此时会出现一个问题：即<strong>跨域</strong><br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-22-at-9.34.41-AM.png" alt="跨域"></p>
<p>因为，我客户端使用的 react 代码，运行在 localhost:3000 端口，我们在 3000 端口上又要向在 3004 端口上的服务端发送请求，所以会造成跨域问题！</p>
<p>事实上，针对 <code>socket.io</code> 解决跨域问题是简单的！ 方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* server/server.js */</span><br><span class="hljs-keyword">const</span> io = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;socket.io&#x27;</span>)(<span class="hljs-number">3004</span>)<br>                ↓<br><span class="hljs-keyword">const</span> io = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;socket.io&#x27;</span>)(<span class="hljs-number">3004</span>, &#123;<br>  <span class="hljs-attr">cors</span>: &#123;<br>    <span class="hljs-attr">origin</span>: [<span class="hljs-string">&#x27;http://localhost:3000&#x27;</span>],   <span class="hljs-comment">// 允许本机的3000端口进行访问，所以，我client的react代码应该运行在3000端口才行！！</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>这样，跨域问题得到解决！</p>
<p>现在我们来观察一个现象<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-11-22-at-9.43.17-AM.gif" alt="观察随机id值"></p>
<p>我们可以看见，在控制台出现了多条字符串，其实这些字符串是因为我创建了多个聊天框(其余聊天框我是通过浏览器的无痕窗口来创建的(同样是 localhost:3000)) <code>server</code> 端的 <code>console.log(socket.id);</code> 发挥的作用！</p>
<h4 id="client-和-server-端的通信"><a href="#client-和-server-端的通信" class="headerlink" title="client 和 server 端的通信"></a>client 和 server 端的通信</h4><p><strong>客户端</strong>:<code>socket.on</code> 接收服务端传过来的数据！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* client/App.js */</span><br><span class="hljs-keyword">import</span> &#123;io&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;socket.io-client&#x27;</span>;<br><span class="hljs-keyword">const</span> socket = io(<span class="hljs-string">&#x27;http://localhost:3004&#x27;</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br><br>  <span class="hljs-comment">// 先来检验一下两端通信  socket.on 是用来接收数据</span><br>  <span class="hljs-comment">// socket.on(&#x27;event&#x27;, any-type-content)   // event 表示监听的事件(监听从server传来的事件)  第二个参数是任何类型的数据都可以</span><br>  ...<br><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    socket.on(<span class="hljs-string">&#x27;any-custom-event&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;   <span class="hljs-comment">// 注意这里的事件名</span><br>      setMessages(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> [...prev, <span class="hljs-string">`你当前连接的socket id号: <span class="hljs-subst">$&#123;socket.id&#125;</span>`</span>])<br>    &#125;)<br>  &#125;, [])<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* server.js */</span><br><span class="hljs-keyword">const</span> &#123; instrument &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@socket.io/admin-ui&quot;</span>);<br><br><span class="hljs-keyword">const</span> io = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;socket.io&#x27;</span>)(<span class="hljs-number">3004</span>, &#123;<br>  <span class="hljs-attr">cors</span>: &#123;<br>    <span class="hljs-attr">origin</span>: [<span class="hljs-string">&quot;http://localhost:3001&quot;</span>, <span class="hljs-string">&quot;https://admin.socket.io&quot;</span>],   <span class="hljs-comment">// 允许本机的3000端口进行访问</span><br>  &#125;<br>&#125;)<br><br>io.on(<span class="hljs-string">&#x27;connection&#x27;</span>, <span class="hljs-function"><span class="hljs-params">socket</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(socket.id);<br>  io.emit(<span class="hljs-string">&#x27;any-custom-event&#x27;</span>, socket.id)   <span class="hljs-comment">// 这里是发送方(emit) 注意！client 和 server端连接的这个事件要匹配！</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-12-01-at-8.29.42-AM.png" alt="基本通信"></p>
<hr>
<p><strong>客户端</strong>: <code>socket.emit</code> 客户端发送数据给服务端</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* client/App.js */</span><br><span class="hljs-keyword">import</span> &#123;io&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;socket.io-client&#x27;</span>;<br><span class="hljs-keyword">const</span> socket = io(<span class="hljs-string">&#x27;http://localhost:3004&#x27;</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  ...<br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// 注意这里  事件名，你自己随意写，但后端接收的事件名要一致。  然后你可以发任何你想发的数据</span><br>    socket.emit(<span class="hljs-string">&#x27;any-custom-event2&#x27;</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;可以发任何内容&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-string">&#x27;函数&#x27;</span>)<br>  &#125;, [])<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/* server.js */</span><br><span class="hljs-keyword">const</span> &#123; instrument &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@socket.io/admin-ui&quot;</span>);<br><br><span class="hljs-keyword">const</span> io = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;socket.io&#x27;</span>)(<span class="hljs-number">3004</span>, &#123;<br>  <span class="hljs-attr">cors</span>: &#123;<br>    <span class="hljs-attr">origin</span>: [<span class="hljs-string">&quot;http://localhost:3001&quot;</span>, <span class="hljs-string">&quot;https://admin.socket.io&quot;</span>],   <span class="hljs-comment">// 允许本机的3000端口进行访问</span><br>  &#125;<br>&#125;)<br><br>io.on(<span class="hljs-string">&#x27;connection&#x27;</span>, <span class="hljs-function"><span class="hljs-params">socket</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(socket.id);<br>  socket.on(<span class="hljs-string">&#x27;any-custom-event2&#x27;</span>, <span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>, func</span>) =&gt;</span> &#123;     <span class="hljs-comment">// 匹配对应的事件名字以及用回调函数来接收客户端发送过来的任何数据</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;number&#x27;</span>, <span class="hljs-built_in">number</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;string&#x27;</span>, <span class="hljs-built_in">string</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;func&#x27;</span>, func);<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-12-01-at-8.41.51-AM.png" alt="控制台打印内容"></p>
<hr>
<p>上面的代码全是最基本的示例，下面完整的展示一下 <code>socket.io</code> 的魅力</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* client */</span><br><span class="hljs-keyword">import</span> &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./css/app.css&#x27;</span>;<br><span class="hljs-keyword">import</span> Display <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./component/Display&#x27;</span>;  <span class="hljs-comment">// 显示框 --&gt; 代码简单，请看源码</span><br><span class="hljs-keyword">import</span> Form <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./component/Form&#x27;</span>;        <span class="hljs-comment">// 输入框 --&gt; 代码简单，请看源码</span><br><span class="hljs-keyword">import</span> &#123;io&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;socket.io-client&#x27;</span>;        <span class="hljs-comment">// 注意这里！</span><br><span class="hljs-keyword">import</span> &#123; v4 <span class="hljs-keyword">as</span> uuidV4 &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;uuid&#x27;</span><br><br><br><span class="hljs-keyword">const</span> id = uuidV4();<br><span class="hljs-keyword">const</span> socket = io(<span class="hljs-string">&#x27;http://localhost:3004&#x27;</span>);  <span class="hljs-comment">// 不要把这行代码放入组件里</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [messages, setMessages] = useState([]);<br>  <span class="hljs-keyword">const</span> [room, setRoom] = useState();<br><br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendMessage</span>(<span class="hljs-params">newMessage</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(newMessage);<br>    socket.emit(<span class="hljs-string">&#x27;send-message&#x27;</span>, newMessage)  <span class="hljs-comment">// 发送数据到server端</span><br>    setMessages(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> [...prev, newMessage])<br>  &#125;<br><br>  <span class="hljs-comment">// 这里由于我对于socket.on和react之间渲染的关系理解还不到位，所以为了控制代码执行次数，我只能使用useEffect 的空依赖了</span><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    socket.on(<span class="hljs-string">&#x27;receive-message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">receiveMessage</span>) =&gt;</span> &#123;<br>      setMessages(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> [...prev, receiveMessage]<br>      &#125;)<br>    &#125;)<br>  &#125;, [])<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendRoom</span>(<span class="hljs-params">newRoom</span>) </span>&#123;<br>    setRoom(newRoom)<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;app-container&quot;</span>&gt;</span></span><br><span class="xml">      &#123;`id: $&#123;id&#125;`&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Display</span> <span class="hljs-attr">messageList</span>=<span class="hljs-string">&#123;messages&#125;/</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Form</span> <span class="hljs-attr">sendMessage</span>=<span class="hljs-string">&#123;sendMessage&#125;</span> <span class="hljs-attr">sendRoom</span>=<span class="hljs-string">&#123;sendRoom&#125;/</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* server */</span><br><span class="hljs-keyword">const</span> &#123; instrument &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@socket.io/admin-ui&quot;</span>);<br><br><span class="hljs-keyword">const</span> io = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;socket.io&#x27;</span>)(<span class="hljs-number">3004</span>, &#123;<br>  <span class="hljs-attr">cors</span>: &#123;<br>    <span class="hljs-attr">origin</span>: [<span class="hljs-string">&quot;http://localhost:3001&quot;</span>],    <span class="hljs-comment">// 这里必须让客户端在3001端口运行~</span><br>  &#125;<br>&#125;)<br><br>io.on(<span class="hljs-string">&#x27;connection&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">// 这里的connection 应该是必写的，人家文档也是这样写的</span><br>  socket.on(<span class="hljs-string">&#x27;send-message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> &#123;<br>    io.emit(<span class="hljs-string">&#x27;receive-message&#x27;</span>, message)   <span class="hljs-comment">// 将从客户端接收到的数据发送给所有用户 --&gt; 注意这里是所有用户哦</span><br>  &#125;)<br>&#125;)<br><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-12-01-at-9.32.57-AM.gif" alt="效果图1"></p>
<p>其实从上面的效果图我们就已经发现了，我给全局发送信息，但我自己还能接受到自己发送的信息！这其实不太合理，解决办法 <code>io.emit</code> –&gt; <code>socket.broadcast.emit</code> 这样，自己发送的信息就不会又发送给自己了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* server */</span><br><span class="hljs-keyword">const</span> &#123; instrument &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@socket.io/admin-ui&quot;</span>);<br><br><span class="hljs-keyword">const</span> io = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;socket.io&#x27;</span>)(<span class="hljs-number">3004</span>, &#123;<br>  <span class="hljs-attr">cors</span>: &#123;<br>    <span class="hljs-attr">origin</span>: [<span class="hljs-string">&quot;http://localhost:3001&quot;</span>],<br>  &#125;<br>&#125;)<br><br>io.on(<span class="hljs-string">&#x27;connection&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  socket.on(<span class="hljs-string">&#x27;send-message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> &#123;<br>    socket.broadcast.emit(<span class="hljs-string">&#x27;receive-message&#x27;</span>, message)  <span class="hljs-comment">// 只有这里有一点变化</span><br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>这样就大功告成！</p>
<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-12-01-at-9.41.54-AM.gif" alt="效果图2"></p>
<p>上述已完成了最基本的各用户之间的通信功能</p>
<blockquote>
<p>总结一下：<br><code>socket.emit(&#39;任何事件名&#39;, 任何数据)</code> // 用于数据的发送<br><code>socket.on(&#39;对应发送的事件名&#39;, (对应发送的数据) =&gt; &#123;执行一系列的操作...&#125;)</code> // 用于数据的接收<br><code>io.on</code> 是 <code>server</code> 端发给每个连接此 <code>server</code> 端用户的</p>
</blockquote>
<h4 id="建立用户私聊和群聊"><a href="#建立用户私聊和群聊" class="headerlink" title="建立用户私聊和群聊"></a>建立用户私聊和群聊</h4><h5 id="自定义用户-id"><a href="#自定义用户-id" class="headerlink" title="自定义用户 id"></a>自定义用户 id</h5><p>核心代码：<code>socket.join</code></p>
<p>注意，在默认情况，所有连接好的用户都会拥有一个它们自己的房间(room)即 <code>socket.id</code>(在文章前部分我有讲述)。所以，如果我想发送特别的数据给其他指定人物，我可以直接使用<code>socket.id</code>! 但另一方面，如果用 <code>socket.io</code> 给定的 <code>id</code> 显然不太灵活，因此，我可以自定义自己独特的 <code>id</code>，因为这不仅更贴近实际生活场景，且方便 <code>react</code> 获取静态的具体的数据，而非一刷新页面就有新的 <code>socket.id</code>出现。不过，这里，我没有完整实现 <code>react</code> 获取静态的数据，毕竟这需要个人用户认证功能 和 <code>localStorage</code> 里的相关内容！但是我有一个项目确实实在在完成了数据的静态存储！</p>
<p>自定义用户 id 方法如下：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* client */</span><br><br><span class="hljs-regexp">//</span> const socket = io(<span class="hljs-string">&#x27;http://localhost:3004&#x27;</span>)  <span class="hljs-regexp">//</span> 旧<br>                    |<br>                    v<br>const socket = io(<span class="hljs-string">&#x27;http://localhost:3004&#x27;</span>, &#123; query: &#123; id &#125;&#125;); <span class="hljs-regexp">//</span> 新---&gt; 这里的id是变量，我可以使用自己想要的字符。这里我用了 uuid 来实现，具体，可见源代码<br></code></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* server */</span><br>io.on(<span class="hljs-string">&#x27;connection&#x27;</span>, socket =&gt; &#123;<br><br>  const id = socket.handshake.query.id;  <span class="hljs-regexp">//</span> 在client 传递过来的id<br>  socket.join(id);   <span class="hljs-regexp">//</span> 绑定id<br><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="私聊某人"><a href="#私聊某人" class="headerlink" title="私聊某人"></a>私聊某人</h5><p>原理：利用私聊人的 id 来建立连接</p>
<p>核心变化：<code>socket.broadcast.emit()</code> –&gt; <code>socket.to(room).emit()</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* client */</span><br><span class="hljs-keyword">import</span> &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./css/app.css&#x27;</span>;<br><span class="hljs-keyword">import</span> Display <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./component/Display&#x27;</span>;<br><span class="hljs-keyword">import</span> Form <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./component/Form&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;io&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;socket.io-client&#x27;</span>;   <span class="hljs-comment">// 这里的io其实也是一个函数，我们可以通过这个io获得独立的socket</span><br><span class="hljs-keyword">import</span> &#123; v4 <span class="hljs-keyword">as</span> uuidV4 &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;uuid&#x27;</span><br><br><span class="hljs-keyword">const</span> id = uuidV4();<br><br><span class="hljs-keyword">const</span> socket = io(<span class="hljs-string">&#x27;http://localhost:3004&#x27;</span>, &#123; <span class="hljs-attr">query</span>: &#123; id &#125;&#125;);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [messages, setMessages] = useState([]);<br>  <span class="hljs-keyword">const</span> [room, setRoom] = useState();<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendMessage</span>(<span class="hljs-params">newMessage</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(newMessage);<br>    socket.emit(<span class="hljs-string">&#x27;send-message&#x27;</span>, newMessage, room)    <span class="hljs-comment">// 注意这里，这里的room是我要私聊人的id</span><br>    setMessages(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> [...prev, newMessage])<br>  &#125;<br><br><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    socket.on(<span class="hljs-string">&#x27;receive-message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">receiveMessage</span>) =&gt;</span> &#123;<br>      setMessages(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> [...prev, receiveMessage]<br>      &#125;)<br>    &#125;)<br>  &#125;, [])<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendRoom</span>(<span class="hljs-params">newRoom</span>) </span>&#123;<br>    setRoom(newRoom)<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;app-container&quot;</span>&gt;</span></span><br><span class="xml">      &#123;`id: $&#123;id&#125;`&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Display</span> <span class="hljs-attr">messageList</span>=<span class="hljs-string">&#123;messages&#125;/</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Form</span> <span class="hljs-attr">sendMessage</span>=<span class="hljs-string">&#123;sendMessage&#125;</span> <span class="hljs-attr">sendRoom</span>=<span class="hljs-string">&#123;sendRoom&#125;/</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* server */</span><br><span class="hljs-keyword">const</span> &#123; instrument &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@socket.io/admin-ui&quot;</span>);<br><br><span class="hljs-keyword">const</span> io = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;socket.io&#x27;</span>)(<span class="hljs-number">3004</span>, &#123;<br>  <span class="hljs-attr">cors</span>: &#123;<br>    <span class="hljs-attr">origin</span>: [<span class="hljs-string">&quot;http://localhost:3001&quot;</span>, <span class="hljs-string">&quot;https://admin.socket.io&quot;</span>],   <span class="hljs-comment">// 允许本机的3000端口进行访问</span><br>  &#125;<br>&#125;)<br>io.on(<span class="hljs-string">&#x27;connection&#x27;</span>, <span class="hljs-function"><span class="hljs-params">socket</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> id = socket.handshake.query.id;<br>  socket.join(id);<br><br>  socket.on(<span class="hljs-string">&#x27;send-message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">message, room</span>) =&gt;</span> &#123;  <span class="hljs-comment">// 接收要私聊人的id</span><br>    <span class="hljs-keyword">if</span> (!room) &#123;  <span class="hljs-comment">// 如果没有特别私聊的人，就所有人都可以接收到数据</span><br>      socket.broadcast.emit(<span class="hljs-string">&#x27;receive-message&#x27;</span>, message)<br>    &#125; <span class="hljs-keyword">else</span> &#123;     <span class="hljs-comment">// 否则，发给私聊的人！</span><br>      socket.to(room).emit(<span class="hljs-string">&#x27;receive-message&#x27;</span>, message);<br>    &#125;<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>效果如下：<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-12-01-at-10.15.34-AM.gif" alt="效果图3"></p>
<h5 id="建立群聊"><a href="#建立群聊" class="headerlink" title="建立群聊"></a>建立群聊</h5><p>原理：创建 <code>room</code>，然后用户加入该 <code>room</code></p>
<p>核心代码：<code>socket.join(room)</code> 前面创建个人的 id 也是用的此方法</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">/* client */</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendRoom</span></span>(<span class="hljs-keyword">new</span><span class="hljs-type">Room</span>) &#123;<br>    setRoom(<span class="hljs-keyword">new</span><span class="hljs-type">Room</span>)<br>    socket.emit(<span class="hljs-string">&#x27;join-room&#x27;</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Room</span>);     <span class="hljs-comment">// 要加入群聊的房间号 --&gt; 此行为新加入的代码</span><br>  &#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/* server */</span><br>io.<span class="hljs-keyword">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, (socket =&gt; &#123;<br>  ...<br>  socket.<span class="hljs-keyword">on</span>(<span class="hljs-string">&quot;join-room&quot;</span>, room =&gt; &#123;  <span class="hljs-comment">// 新加入的代码</span><br>    socket.join(room)<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-12-01-at-10.32.39-AM.gif" alt="效果图4"></p>
<p>更有趣的是，你可以加入非常多的房间，这是被允许的！</p>
<h4 id="socket-on-amp-socket-emit-都可以发送回调函数"><a href="#socket-on-amp-socket-emit-都可以发送回调函数" class="headerlink" title="socket.on &amp; socket.emit 都可以发送回调函数"></a>socket.on &amp; socket.emit 都可以发送回调函数</h4><p>注意：回调函数必须是最后一个参数才行！<br>这里的回调函数可以让你肆意传递 <code>server</code> 端的数据或者 <code>client</code> 端的数据到对方这里！</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">/* client */</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendRoom</span></span>(<span class="hljs-keyword">new</span><span class="hljs-type">Room</span>) &#123;<br>    setRoom(<span class="hljs-keyword">new</span><span class="hljs-type">Room</span>)<br>    socket.emit(<span class="hljs-string">&#x27;join-room&#x27;</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Room</span>, (data) =&gt; &#123;  <span class="hljs-comment">// 增加了回调</span><br>      console.log(<span class="hljs-string">&#x27;callback&#x27;</span>, data);<br>    &#125;);     <span class="hljs-comment">// 要加入群聊的房间号</span><br>  &#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* server */</span><br>io.on(<span class="hljs-string">&quot;connection&quot;</span>, (<span class="hljs-function"><span class="hljs-params">socket</span> =&gt;</span> &#123;<br>  ...<br>  <span class="hljs-comment">// 注意：io.on 是发给所有用户的  socket.on 是发给限定用户的</span><br>  socket.on(<span class="hljs-string">&quot;join-room&quot;</span>, <span class="hljs-function">(<span class="hljs-params">room, cb</span>) =&gt;</span> &#123;<br>    socket.join(room);<br>    cb(<span class="hljs-string">`哈哈哈，你加入的房间号是：<span class="hljs-subst">$&#123;room&#125;</span>`</span>);  <span class="hljs-comment">// server端的数据 room 将传递给client端</span><br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>这种回调操作，能够让 <code>server</code> 端和 <code>client</code> 端传递的数据更加迅速和稳定！</p>
<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-12-01-at-10.48.43-AM.gif" alt="效果图5"></p>
<h4 id="admin-ui-让用户连接的内容可视化"><a href="#admin-ui-让用户连接的内容可视化" class="headerlink" title="admin-ui 让用户连接的内容可视化"></a>admin-ui 让用户连接的内容可视化</h4><figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i @socket.io<span class="hljs-regexp">/admin-ui   /</span>/ 似乎前后端都要安装！<br></code></pre></td></tr></table></figure>

<p>然后在 server 端导入下面内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* server.js */</span><br><span class="hljs-keyword">const</span> &#123; instrument &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@socket.io/admin-ui&quot;</span>);<br>...<br>instrument(io, &#123;<br>  <span class="hljs-attr">auth</span>: <span class="hljs-literal">false</span>     <span class="hljs-comment">// 这里是false，因为当前我们就没有用户认证这一板块的内容</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<p>然后登录此网站：<a href="https://admin.socket.io/">https://admin.socket.io/</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-12-01-at-11.15.28-AM.png" alt="admin-ui"></p>
<p>在此网站，我们可以可视化的看见各种我们的 <code>socket.io</code> 的信息<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-12-01-at-11.19.21-AM.png" alt="admin-ui页面"></p>
<p>为了防止跨域问题：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">const io = require(<span class="hljs-string">&#x27;socket.io&#x27;</span>)(<span class="hljs-number">3004</span>, &#123;<br>  cors: &#123;<br>    origin: [<span class="hljs-string">&quot;http://localhost:3001&quot;</span>, <span class="hljs-string">&quot;https://admin.socket.io&quot;</span>],   <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;https://admin.socket.io&quot;</span> 这里的操作不要忘记！<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<h4 id="自定义-namespaces"><a href="#自定义-namespaces" class="headerlink" title="自定义 namespaces"></a>自定义 namespaces</h4><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/* server */</span><br><br><span class="hljs-comment">// 创建一个namespace</span><br><span class="hljs-keyword">const</span> userIo = io.of(<span class="hljs-string">&#x27;/user&#x27;</span>)<br>userIo.<span class="hljs-keyword">on</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, socket =&gt; &#123;<br>  console.log(<span class="hljs-string">&#x27;connected to user namespace&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* client */</span><br>const socket = io(<span class="hljs-string">&#x27;http://localhost:3004&#x27;</span>, &#123; query: &#123; id &#125;&#125;);  <span class="hljs-regexp">//</span> 得到一个独立的socket<br>const userSocket = io(<span class="hljs-string">&#x27;http://localhost:3004/user&#x27;</span>);  <span class="hljs-regexp">//</span> 对标socket<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-12-01-at-11.28.19-AM.png" alt="控制台打印内容"></p>
<h4 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h4><p><code>namespace</code> 搭配 <code>middleware</code> 还是挺好用的(例如 用户认证)</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* client */</span><br>const socket = io(<span class="hljs-string">&#x27;http://localhost:3004&#x27;</span>, &#123; query: &#123; id &#125;&#125;);  <span class="hljs-regexp">//</span> 得到一个独立的socket<br>const userSocket = io(<span class="hljs-string">&#x27;http://localhost:3004/user&#x27;</span>, &#123;auth: &#123;token: <span class="hljs-string">&#x27;Test&#x27;</span>&#125;&#125;);  <span class="hljs-regexp">//</span> 对标socket<br></code></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* server */</span><br><br><span class="hljs-regexp">//</span> 创建一个namespace<br>const userIo = io.of(<span class="hljs-string">&#x27;/user&#x27;</span>)<br>userIo.on(<span class="hljs-string">&#x27;connection&#x27;</span>, socket =&gt; &#123;<br>  console.log(<span class="hljs-string">&#x27;connected to user namespace with username&#x27;</span> + socket.username);<br>&#125;)<br><br><span class="hljs-regexp">//</span> 中间件的打开方式<br>userIo.use((socket, <span class="hljs-keyword">next</span>) =&gt; &#123;  <span class="hljs-regexp">//</span> <span class="hljs-keyword">next</span>表示下一个middleware，如果我们调用<span class="hljs-keyword">next</span>() 表示我们当前的进展一切ok，如果无法进入则出现error<br>  <span class="hljs-keyword">if</span> (socket.handshake.auth.token) &#123;<br>    socket.username = getUsernameFromToken(socket.handshake.auth.token)<br>    <span class="hljs-keyword">next</span>();   <span class="hljs-regexp">//</span> 成功匹配<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">next</span>(new Error(<span class="hljs-string">&#x27;Please Send Token&#x27;</span>)) <span class="hljs-regexp">//</span> 匹配失败<br>  &#125;<br>&#125;)<br><br><span class="hljs-keyword">function</span> getUsernameFromToken(token) &#123;<br>  return token;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-12-01-at-11.49.56-AM.png" alt="middleware"></p>
<p>注意：用户端的 <code>socket</code> 和 <code>userSocket</code> 是互不干扰的！</p>
<h4 id="socket-io-的断开连接-和-重新连接"><a href="#socket-io-的断开连接-和-重新连接" class="headerlink" title="socket.io 的断开连接 和 重新连接"></a>socket.io 的断开连接 和 重新连接</h4><p><code>socket.connect()</code> socket.io 连接<br><code>socket.disconnect()</code> socket.io 连接断开</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* client */</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  ...<br>  <span class="hljs-comment">// 键盘事件</span><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&quot;keydown&quot;</span>, connect)   <span class="hljs-comment">// 不要自己在这里写回调(而是引入一个函数作为回调)，不然 reomve监听事件 也只能在参数这里自己写回调(两个函调函数实质不一样)，则达不到remove的效果</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">document</span>.removeEventListener(<span class="hljs-string">&quot;keydown&quot;</span>, connect)<br>  &#125;)<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">connect</span>(<span class="hljs-params">e</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (e.key === <span class="hljs-string">&#x27;c&#x27;</span>) &#123;<br>      socket.connect();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (e.key === <span class="hljs-string">&#x27;d&#x27;</span>) &#123;<br>      socket.disconnect();<br>    &#125;<br>  &#125;<br> <span class="hljs-keyword">return</span> ...<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;<br></code></pre></td></tr></table></figure>

<p>效果如下：<br>我先在最左边页面上用键盘上按了 d 则，最左边的页面已经断开连接，后来我又在最左边的页面上按了 c,则页面开始重新连接<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Recording-2021-12-01-at-12.14.38-PM.gif" alt="打开和断开连接"></p>
<p>注意：在默认情况下，你断开连接后又重新连接，则 socket.io 会记住你之前传的数据。<br>但如果你不想这样了，你重新连接，想要一个新的开始：<br>方法： <code>socket.emit()</code> –转变为–&gt; <code>socket.volatile.emit()</code></p>
]]></content>
      <categories>
        <category>WebSocket篇</category>
      </categories>
      <tags>
        <tag>全栈</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇文章解决Promise...then，async/await执行顺序类型题</title>
    <url>/2021/10/08/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E8%A7%A3%E5%86%B3Promise-then%EF%BC%8Casync-await%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E7%B1%BB%E5%9E%8B%E9%A2%98/</url>
    <content><![CDATA[<p>最近我在沸点里摸鱼的时候，发现了一些掘友在不约而同的讨论一种类型的题，即 Promise…then, async/await 执行顺序类型的题。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61f40af93cec47d281efaa67db337670~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-06-10 下午10.18.25.png"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdb16e753c6742ae94f531022a41d789~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-06-10 下午10.16.31.png"><br>恰好，在前一段时间我对此种类型的题有所研究 📃。因此，我也想趁这个机会看看是否能把这种类型的题讲述清楚。</p>
<p>废话就不多说了，先出几道题，大伙试试看，能不能把这几道题做出来！<br>（注：以下题目都是从网上以及掘友发的沸点里获取的）</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">题目一：<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">100</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">200</span>);<br>&#125;)<br><span class="hljs-built_in">Promise</span>.resolve().<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">300</span>);<br>&#125;)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">400</span>);<br>求打印结果：<br></code></pre></td></tr></table></figure>

<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">题目二：<br><span class="hljs-built_in">Promise</span>.resolve().<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;error1&#x27;</span>)<br>&#125;).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);<br>&#125;)<br>求打印结果：<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">题目三：<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async1 start&#x27;</span>);<br>  <span class="hljs-keyword">await</span> async2();<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async1 end&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async2&#x27;</span>);<br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script start&#x27;</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>)<br>async1()<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span> (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>  resolve()<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise2&#x27;</span>)<br>&#125;)<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script end&#x27;</span>)<br>求打印结果：<br></code></pre></td></tr></table></figure>

<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">题目四：<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>);<br>  resolve();<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2&#x27;</span>);<br>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3&#x27;</span>);<br>    resolve();<br>  &#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;4&#x27;</span>);<br>  &#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;5&#x27;</span>);<br>  &#125;)<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;6&#x27;</span>);<br>&#125;)<br><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;7&#x27;</span>);<br>  resolve()<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;8&#x27;</span>);<br>&#125;)<br>求打印结果：<br></code></pre></td></tr></table></figure>

<p>不知道大家对于上面四道题是否感觉有点恶心？哈哈，如果感到恶心，就对了！跟着这篇文章走，相信大家在文章看完之后能轻松解决上面的几道题！</p>
<p>废话不多说，如果有兴趣就接着往下看吧！</p>
<hr>
<p>首先我们需要知道这类题型实质是在考察以下几个内容</p>
<ul>
<li>异步</li>
<li>event loop 执行机制</li>
<li>Promise 语法</li>
<li>async/await 语法</li>
<li>宏任务、微任务</li>
</ul>
<p>其实，掌握了上述的五个内容，无论这类题型怎么变，你都能将题玩于股掌之间(他强任他强，清风拂山岗)。</p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>由于能开始思考这道题的兄弟，想必还是有一定的 JS 基础。所以我也不再细讲啥是异步、以及 event loop 执行机制了(这类博文网上一抓一大把~)。我只简单分享一下我对于异步的一些感悟：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-number">1</span>、异步是用来解决JS单线程等待这种问题的<br><span class="hljs-number">2</span>、异步是基于回调函数的形式来实现的<br><span class="hljs-number">3</span>、常见的异步有：<span class="hljs-built_in">setTimeout</span>、ajax、<span class="hljs-built_in">Promise</span>……<span class="hljs-keyword">then</span>、<span class="hljs-keyword">async</span>/<span class="hljs-keyword">await</span>、图片加载、网络请求资源<br><span class="hljs-number">4</span>、牢记<span class="hljs-number">5</span>个版块  Call Stack、 Web APIs、 Browser <span class="hljs-built_in">console</span>、 Callback Queue<br>、 micro task queue 这五个版块透露出异步的执行过程<br><span class="hljs-number">5</span>、宏任务是在DOM渲染后触发，微任务是在DOM渲染前触发<br></code></pre></td></tr></table></figure>

<h3 id="Promise、-Async-await"><a href="#Promise、-Async-await" class="headerlink" title="Promise、 Async/await"></a>Promise、 Async/await</h3><p>很多讲<code>Promise</code>的文章都说过，<code>Promise</code>的出现是为了解决臭名昭著的<code>callback hell</code>。由于异步是基于回调函数的形式来实现的，那么异步就离不开回调函数。但在上古时期，反人类的嵌套回调让老一辈的程序员们苦不堪言…而 Promise 搭配 then 展现的管道式回调函数，让异步更直观、更优雅的展现出来，广受大家好评！</p>
<p>而<code>async/await</code> 是 ECMAScript 2017 提出的内容。但事实上它们只是<code>Promise</code>的语法糖，但这颗 🍬 贼甜！</p>
<p>针对<code>Promise</code>以及<code>async/await</code>的骚用法，我想尝试用千层饼的套路来讲讲~</p>
<h5 id="第一层："><a href="#第一层：" class="headerlink" title="第一层："></a>第一层：</h5><p>Promise 是一个类（函数），接受一个回调函数作为参数，并且这个回调函数的参数也有两个，这两个参数约定俗成被命名为 <code>resolve</code>, <code>reject</code></p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    ...<br>&#125;)<br></code></pre></td></tr></table></figure>

<h5 id="第二层："><a href="#第二层：" class="headerlink" title="第二层："></a>第二层：</h5><p><code>resolve</code>, <code>reject</code>这两个参数其实也都是函数</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode">Promise<span class="hljs-comment">((resolve, reject)</span> =&gt; &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-comment">(...)</span> &#123;<br>        resolve<span class="hljs-comment">(...)</span>;     <span class="hljs-comment">// 执行resolve函数</span><br>    &#125; else &#123;<br>        reject<span class="hljs-comment">(...)</span>;      <span class="hljs-comment">// 执行reject函数</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<h5 id="第三层："><a href="#第三层：" class="headerlink" title="第三层："></a>第三层：</h5><p>对于紧跟 Promise 实例的<code>then</code>，其参数等于<code>resolve</code>接受的参数；紧跟 Promise 实例的<code>catch</code>，其参数等于<code>reject</code>接受的参数。</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">const p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve)</span> =&gt;</span> &#123;    <span class="hljs-regexp">//</span> p为<span class="hljs-built_in">Promise</span>实例<br>    const a = <span class="hljs-number">100</span>;<br>    resolve(a);<br>&#125;)<br><br>p1.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(param)</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;param:&#x27;</span>, param);      <span class="hljs-regexp">//</span> param: <span class="hljs-number">100</span><br>&#125;)<br><br>const p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    const a = <span class="hljs-number">100</span>;<br>    reject(a);<br>&#125;)<br><br>p2.<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">(param)</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;param&#x27;</span>, param);<br>&#125;)<br><br></code></pre></td></tr></table></figure>

<h5 id="第四层："><a href="#第四层：" class="headerlink" title="第四层："></a>第四层：</h5><p>Promise 的实例有三种状态： <code>pending(加载中)</code>、<code>fulfilled(执行成功)</code>、<code>rejected(执行错误)</code>。其实我们很好理解这三种状态，因为它们恰好对应了<code>异步正在执行</code>和<code>异步执行完的结果</code>(无非成功或失败两种状态)这三种状态</p>
<p>三种状态的表现：</p>
<ul>
<li>pending: Promise 实例处于<code>pending</code>状态时，不会触发 then 和 catch。</li>
<li>fufilled: Promise 实例处于<code>fulfilled</code>状态时，只会触发 then(不会触发 catch)</li>
<li>rejected： Promise 实例处于<code>rejected</code>状态时，只会触发 catch(不会触发 then)</li>
</ul>
<p>(无论是 then 还是 catch，它们里面都是回调函数)</p>
<p>那么问题来了，如何判断 Promise 实例对象是处于那种状态呢？</p>
<p>很简单，看下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 啥也没有做~</span><br>&#125;)<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;p&#x27;</span>, p);<br></code></pre></td></tr></table></figure>

<p>Chrome 控制台显示结果如下图：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a40d9c5af8794683b9660bd378bd0316~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-06-12 下午9.00.33.png"></p>
<p>截图说明了此时的 Promise 实例是处于<code>pending</code>状态的。其实，当 Promise 内部的回调不执行<code>resolve</code>或<code>reject</code>的时候，Promise 实例就处于<code>pending</code>状态！</p>
<p>再看下面的代码 👇🏻</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"> <span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;    <span class="hljs-comment">// p1为Promise实例</span><br>     <span class="hljs-keyword">const</span> a = <span class="hljs-number">100</span>;<br>     resolve(a);<br> &#125;)<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;p1&#x27;</span>, p1)    <span class="hljs-comment">// fulfilled</span><br><br> <span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>     <span class="hljs-keyword">const</span> a = <span class="hljs-number">100</span>;<br>     reject(a);<br> &#125;)<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;p2&#x27;</span>, p2)    <span class="hljs-comment">// rejected</span><br></code></pre></td></tr></table></figure>

<p>Chrome 控制台显示结果如下图：<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/508e710a9a0847d69cc13e1f79e03ef7~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-06-12 下午9.03.58.png"></p>
<p>这里的代码是借用的第三层的代码，其实看到这儿就解释了第三层的套路。对于第一个 Promise 实例执行参数<code>resolve</code>就代表了，当前 Promise 实例对象的状态为<code>fulfilled</code>，因此接下来可以触发 then，以及对应的回调。如果 Promise 实例对象执行了<code>reject</code>，则实例对象的状态变为了 <code>rejected</code>，可以触发 catch~ 有兴趣的小伙伴可以试试，在<code>fulfilled</code>状态执行下 catch 或者在<code>rejected</code>状态下执行下 then，试试能否执行代码成功。</p>
<h5 id="第五层："><a href="#第五层：" class="headerlink" title="第五层："></a>第五层：</h5><p>在第五层有 3 句至理名言需要知道(不需要去死记硬背，下面我会用例子帮助你理解)</p>
<blockquote>
<p>无论是 then 还是 catch 里的回调内容只要代码正常执行或者正常返回，则当前新的 Promise 实例为 fulfilled 状态。如果有报错或返回 Promise.reject()则新的 Promise 实例为 rejected 状态。</p>
</blockquote>
<blockquote>
<p>fulfilled 状态能够触发 then 回调</p>
</blockquote>
<blockquote>
<p>rejected 状态能够触发 catch 回调</p>
</blockquote>
<p>举例之前我先补充一个小知识！</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Promise</span>.resolve()  表示一个fulfilled状态的<span class="hljs-built_in">Promise</span>实例<br><span class="hljs-built_in">Promise</span>.reject()   表示一个rejected状态的<span class="hljs-built_in">Promise</span>实例<br></code></pre></td></tr></table></figure>

<p>好，我将放码过来！</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">题目一：<br><span class="hljs-built_in">Promise</span>.resolve().<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>&#125;).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>初看此题，感觉似乎此题有点难度~ 不过，结合我的三句至理名言，我们一起来分析一下此题！！</p>
<p><code>Promise.resolve()</code> 是一个状态为<code>fulfilled</code>状态的 Promise 实例。<code>fulfilled</code>状态能够触发 then 回调。因此，第一个 then 会被执行，并且能够顺利打印结果而不报错！故 Promise.resolve().then(() =&gt; {console.log(1)}) 这个新的 Promise 实例为<code>fulfilled</code>状态，所以可以触发下一个 then，但是无法触发 catch，故 catch 的内容忽略，从而执行第二个 then 的内容。 所以，此题的打印结果为： 1 3</p>
<p>好了，下面再来看看第二题(此题也是文章开头出的第二题)：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Promise</span>.resolve().<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;error1&#x27;</span>);<br>&#125;).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>有了上一题的经验，做这一道题就轻松很多了~ Promise.resolve()是一个<code>fulfilled</code>状态的实例，所以可以触发 then，而第一个 then 之中有 throw new Error(‘error1’) 这种报错操作，则 Promise.resolve.then(() =&gt; {<br>console.log(1);<br>throw new Error(‘error1’)<br>})就是一个<code>rejected</code>状态的 Promise 实例，所以可以触发 catch，catch 的内容是可以正常执行的，没有报错误，则 Promise.resolve().then(…).catch(…)是一个<code>fulfilled</code>状态的 Promise 实例，可以触发 then，故 then 的内容能够被执行。</p>
<p>故代码结果为： 1 2 3</p>
<h5 id="第六层："><a href="#第六层：" class="headerlink" title="第六层："></a>第六层：</h5><p>做了前面两道题，不知道大家有没有一点困惑。感觉我似乎有意回避了 then、catch 的返回值即(return …),而且也没有在 then、catch 里写具体的参数。导致我在第五层的第一句至理名言“无论是 then 或者 catch 里的内容只要正常执行或者正常返回…”也没有完全体现出来。 大家别慌，其实这正是我要讲的第六层套路~</p>
<p>then、catch 参数的来头其实就是我在第三层套路里就讲过<code>“紧跟Promise实例的then的参数等于resolve接受的参数；紧跟Promise实例的catch的参数等于reject接受的参数。”</code>。如果 then、catch 里的回调，没有写返回内容，则 then 或 catch 后面即将被触发的 then 或 catch 是无法接受到参数的；而如果有返回内容，即 return… 那么无论返回的是普通值还是是 Promise 实例，其实都会对应被转化为 Promise 的实例(Promise.resolve(…)或者 Promise.reject(…))</p>
<p>结合代码再来理解一下~</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">&#x27;我想出错&#x27;</span>).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">(err)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(err);<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;我不想出错&#x27;</span>;  <span class="hljs-regexp">//</span> 会被自动封装成<span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">&#x27;我不想出错&#x27;</span>)<br>&#125;).<span class="hljs-keyword">then</span>(data =&gt; &#123;<br>  <span class="hljs-built_in">console</span>.log(data);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">&#x27;我不想出错&#x27;</span>)<br>&#125;).<span class="hljs-keyword">then</span>(data =&gt; &#123;<br>  <span class="hljs-built_in">console</span>.log(data);<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>代码打印结果：<br>我想出错<br>我不想出错<br>我不想出错</p>
<h5 id="第七层："><a href="#第七层：" class="headerlink" title="第七层："></a>第七层：</h5><p>第七层套路，我来谈谈 async/await。 因为 Promise 的出现主要是为了解决异步的回调地狱问题。将噩梦般的嵌套回调变为了优雅的管道式回调。但这始终是逃不掉“回调”二字。而 async/await 虽说只是 Promise 的语法糖，但让你“脱离”了回调，拥抱了同步代码~</p>
<p>下面我再分享大家五句经典语录~</p>
<blockquote>
<p>执行 async 函数，返回的是 Promise 对象</p>
</blockquote>
<blockquote>
<p>await 必须在 async 包裹之下执行</p>
</blockquote>
<blockquote>
<p>await 相当于 Promise 的 then 并且同一作用域下 await 下面的内容全部作为 then 中回调的内容</p>
</blockquote>
<blockquote>
<p>try……catch 可捕获异常，代替了 Promise 的 catch</p>
</blockquote>
<blockquote>
<p>异步中先执行微任务，再执行宏任务</p>
</blockquote>
<p>且看下面的代码分析：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;我是async函数&#x27;</span>;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async:&#x27;</span>, fn());<br></code></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d97ad91369b344ee8e168444253fa1b0~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-06-13 下午10.23.56.png"></p>
<p>这里的 fn() 相当于 Promise.resolve(‘我是 async 函数’)，验证了第一条语录！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">&#x27;帅得乱七八糟&#x27;</span>);<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> p; <span class="hljs-comment">// await就相当于Promise.then, 故data就是then的参数</span><br>  <span class="hljs-built_in">console</span>.log(data);    <span class="hljs-comment">// 这里的代码为then中回调的内容</span><br>&#125;)()<br></code></pre></td></tr></table></figure>

<p>上面的这段代码，大家可以试着把<code>async</code>删掉，结果一定会报错！这就验证了第二条语录！上面代码的注释结合第三条语录，大家应该能够体会到<code>await</code>的作用！</p>
<p>再看下面一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">&#x27;err&#x27;</span>);<br>  <span class="hljs-comment">// await + try...catch 相当于 Promise.catch</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> p;<br>    <span class="hljs-built_in">console</span>.log(res);<br>  &#125; <span class="hljs-keyword">catch</span>(ex) &#123;  <span class="hljs-comment">// ex 来源于reject()里面的数</span><br>    <span class="hljs-built_in">console</span>.error(ex);<br>  &#125;<br>&#125;)()<br></code></pre></td></tr></table></figure>

<p>打印结果为 err，验证了第四条语录。</p>
<p>在此补充一点内容：</p>
<ul>
<li>常见的微任务： Promise……then、 async/await</li>
<li>常见的宏任务： setTimeout、setInterval<blockquote>
<p>考虑过在文章里谈谈宏任务和微任务的执行机制，但限于篇幅以及本篇文章的侧重点在于解题于是就不过多赘述其他内容了，有兴趣的朋友可以在评论区讨论一下。</p>
</blockquote>
</li>
</ul>
<p>其实看到这儿，文章开始出的所有题目都能够解决了。不信就试试 💪🏻</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">题目三:<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async1 start&#x27;</span>);<br>  <span class="hljs-keyword">await</span> async2();<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async1 end&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async2&#x27;</span>);<br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script start&#x27;</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>)<br>async1()<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span> (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>  resolve()<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise2&#x27;</span>)<br>&#125;)<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script end&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>此题需要注意两个点</p>
<ol>
<li>new Promise()内部的回调函数是当成同步函数执行</li>
<li>执行到 await code 时，会先执行 code，再执行 await</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">代码分析：<br><span class="hljs-number">1.</span> 先执行同步代码。<br><span class="hljs-number">2.</span> 所以首先执行 console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>);<br><span class="hljs-number">3.</span> setTimeout为宏任务，先不执行<br><span class="hljs-number">4.</span> 执行async1函数 console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async1 start&#x27;</span>); 以及 async2(); await由于是Promise.then的语法糖是异步代码，先不执行<br><span class="hljs-number">5.</span> <span class="hljs-keyword">new</span> Promise() 内部代码要执行，后面的<span class="hljs-keyword">then</span>的内容为微任务先不执行<br><span class="hljs-number">6.</span>执行console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>)<br><span class="hljs-number">7.</span>同步代码执行结束<br><span class="hljs-number">8.</span>开始按代码顺序执行微任务<br><span class="hljs-number">9.</span>先执行 console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async1 end&#x27;</span>); 前面说过，await下面的代码相当于<span class="hljs-keyword">then</span>里回调的内容<br><span class="hljs-number">10.</span><span class="hljs-keyword">new</span> Promise.then里面的内容 console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;promise2&#x27;</span>)<br><span class="hljs-number">11.</span> 最后执行 宏任务代码，即setTimeout里的内容<br><br>执行结果：<br>script <span class="hljs-keyword">start</span><br>async1 <span class="hljs-keyword">start</span><br>async2<br>promise1<br>script <span class="hljs-keyword">end</span><br>async1 <span class="hljs-keyword">end</span><br>promise2<br>setTimeout<br></code></pre></td></tr></table></figure>

<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">题目四：<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>);<br>  resolve();<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2&#x27;</span>);<br>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3&#x27;</span>);<br>    resolve();<br>  &#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;     <span class="hljs-regexp">//</span> 📌<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;4&#x27;</span>);<br>  &#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;5&#x27;</span>);<br>  &#125;)<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;6&#x27;</span>);   <span class="hljs-regexp">//</span> 📌<br>&#125;)<br><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;7&#x27;</span>);<br>  resolve()<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;8&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">代码分析：<br><span class="hljs-number">1.</span>先执行同步代码<br><span class="hljs-number">2.</span>setTimeout 为宏任务，先不执行<br><span class="hljs-number">3.</span><span class="hljs-keyword">new</span> Promise里的代码作为同步代码，要执行 console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;1&#x27;</span>); 而<span class="hljs-keyword">then</span>作为微任务，先不执行<br><span class="hljs-number">4.</span>又是一个<span class="hljs-keyword">new</span> Promise,所以和第三步同理。只执行 console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;7&#x27;</span>);<br><span class="hljs-number">5.</span>开始执行异步代码<br><span class="hljs-number">6.</span>执行第一个<span class="hljs-keyword">new</span> Promise里的<span class="hljs-keyword">then</span> 即console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;2&#x27;</span>);以及<span class="hljs-keyword">new</span> Promise的同步代码 console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;3&#x27;</span>);<br><span class="hljs-number">7.</span>这步有点意思，这里不是执行console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;4&#x27;</span>); 而是执行console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;8&#x27;</span>);<br><span class="hljs-number">8.</span>注释为📌的两个<span class="hljs-keyword">then</span>是同层级的，所以按照执行顺序来打印<br><span class="hljs-number">9.</span>执行第三个层级的<span class="hljs-keyword">then</span>，所有微任务代码完成<br><span class="hljs-number">10.</span>执行宏任务代码，即console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;0&#x27;</span>);<br><br>代码结果：<br><span class="hljs-number">1</span><br><span class="hljs-number">7</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">8</span><br><span class="hljs-number">4</span><br><span class="hljs-number">6</span><br><span class="hljs-number">5</span><br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<p>说有千层饼套路，其实只有 7 层套路，但这每一层套路都是我对于 Promise、async/await 的感悟，有些内容并未细讲，比如微任务、宏任务与 DOM 之间的执行顺序这种相对底层的内容本文并未谈及，毕竟这篇文章的侧重点是在解决 Promise、async/await 执行顺序类型题。本文也可能有内容错误或逻辑错误，也请大家多多包涵，多多指出，谢谢！！</p>
<p>好了，大功已告成！想必通过这些题，大家已经领悟到了解决此类题型的奥义！</p>
<head>
  ..
  <script src="//cdn.jsdelivr.net/npm/@waline/client"></script>
  ...
</head>
<body>
  ...
  <div id="waline"></div>
  <script>
    Waline({
      el: '#waline',
       avatar: 'monsterid',
      serverURL: 'https://blog-api-9sizcti78-bruce-shuai.vercel.app/',
    });
  </script>
</body>
]]></content>
      <categories>
        <category>JavaScript篇</category>
      </categories>
      <tags>
        <tag>基本功</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2021/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/30573146">对称加密和非对称加密</a></p>
<p><a href="liaoxuefeng.com/wiki/1252599548343744/1304227729113121">摘要</a><br><a href="https://www.bilibili.com/video/BV1w4411m7GL?from=search&seid=18369141538307426732&spm_id_from=333.337.0.0">https vs http</a></p>
<p><a href="https://juejin.cn/post/7002781373014474759#comment">CDN</a></p>
<p><strong>以太网、局域网二者关系</strong><br><code>以太网</code>只是组成互联网的一个子集，<code>以太网</code>是现在主流的<code>局域网标准</code>，而互联网是指将大量的局域网连接起来，进行资源的分享。</p>
<p><a href="https://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">阮一峰 互联网协议</a></p>
<p>每一层都是为了完成一种功能。为了实现这些功能，就需要大家都<code>遵守共同的规则</code>。大家都遵守的规则，就叫做<code>&quot;协议&quot;</code>（protocol）</p>
<p><code>IP协议</code>的作用主要有两个，一个是为每一台计算机<code>分配IP地址</code>，另一个是确定哪些地址在<code>同一个子网络</code></p>
<p><strong>“端口”是 0 到 65535 之间的一个整数</strong>，正好 16 个二进制位。<strong>0 到 1023 的端口被系统占用，用户只能选用大于 1023 的端口</strong>。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系</p>
<p><a href="https://www.youtube.com/watch?v=HGetnD4ISrw&list=PLgJ_1RCsjcSmUw-DoTfD8kVJGqxz7MjNd&index=70">教程</a></p>
<p>注意： 计算机网络 不仅仅是软件概念，还包含了硬件设备并且计算机网络不仅仅是信息通信，还可以支持广泛的应用</p>
<h5 id="计算机网络的分类："><a href="#计算机网络的分类：" class="headerlink" title="计算机网络的分类："></a>计算机网络的分类：</h5><p><strong>按网络的作用范围分类</strong>：广域网(WAN)、城域网(MAN)、局域网(LAN)</p>
<p>广域网：范围：几十到几千公里 区域：跨省、跨国<br>城域网：范围：5KM-50KM 区域：城市间<br>局域网：范围：1KM 以内(有点小啊)区域：地区内</p>
<p><strong>按网络的使用者分类</strong>：公用网络、专用网络(军方、公司、银行)</p>
<h5 id="互联网的发展历史"><a href="#互联网的发展历史" class="headerlink" title="互联网的发展历史"></a>互联网的发展历史</h5><ul>
<li><p>第一个阶段： 单个网络 ARPANET —&gt; 计算机利用<strong>交换机</strong>来完成信息的交互(计算机数量是非常少的)</p>
</li>
<li><p>第二个阶段： 三层结构的互联网 —&gt;</p>
</li>
</ul>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><code class="hljs gherkin">        主干网<br>          |<span class="hljs-string"></span><br><span class="hljs-string">    主干网----主干网</span><br><span class="hljs-string">      </span>|<span class="hljs-string">        </span>|<br>  +-------+   ...<br>地区网   地区网<br>  |<span class="hljs-string">       </span>|<br>校园网   校园网<br></code></pre></td></tr></table></figure>

<p>全国(美国)的学校政府公司这些网连在一起的</p>
<ul>
<li>第三个阶段： 多层次 ISP 互联网<br>ISP(Internet Service Provider): 网络服务提供商 —&gt; 例如：中国电信、中国移动、中国联通</li>
</ul>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli">            主干ISP     <span class="hljs-string">//</span> 跨国操作<span class="hljs-string">...</span><br>              |<br>       主干ISP<span class="hljs-params">----</span>主干ISP<br>         |        |<br>     +<span class="hljs-params">-------</span>+   <span class="hljs-string">...</span><br>   地区ISP  地区ISP<br>     |<br>  +<span class="hljs-params">------</span>+<br>公司     校园<br></code></pre></td></tr></table></figure>

<p>主干 ISP: 例如 中国移动<br>地区 ISP: 例如 四川移动</p>
<h5 id="中国互联网的发展简史"><a href="#中国互联网的发展简史" class="headerlink" title="中国互联网的发展简史"></a>中国互联网的发展简史</h5><figure class="highlight brainfuck"><table><tr><td class="code"><pre><code class="hljs brainfuck">  <span class="hljs-comment">1980年开始</span>    <span class="hljs-comment">1989年第一个</span>        <span class="hljs-comment">1994接入</span><br>  <span class="hljs-comment">互联网实验</span>     <span class="hljs-comment">公共网络建立运行</span>    <span class="hljs-comment">国际互联网</span><br>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span>&gt; --<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span>&gt; --<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span>&gt;<br></code></pre></td></tr></table></figure>

<p>5 个中国最大的计算机公用网络</p>
<ol>
<li>中国电信互联网</li>
<li>中国联通互联网</li>
<li>中国移动互联网</li>
<li>中国教育与科研计算机网</li>
<li>中国科学技术网</li>
</ol>
<h5 id="计算机网络的层次结构"><a href="#计算机网络的层次结构" class="headerlink" title="计算机网络的层次结构"></a>计算机网络的层次结构</h5><p>首先先考虑一个问题</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">计算机<span class="hljs-selector-tag">A</span> 和 计算机<span class="hljs-selector-tag">B</span>如何进行通信？<br><br>我们需要考虑一些问题：<br> 例如：如何保证数据通路顺畅？<br>      如何识别目的计算机？<br>      当前目的计算机状态是怎样的？<br>      计算机传递的数据是否是错误的？<br>...可见，计算机通信要考虑的问题是繁多而复杂的。为了解决这些问题。我们采用分层来实现不同的功能<br></code></pre></td></tr></table></figure>

<p>分层要考虑的东西：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">顶层：  网络应用数据  <span class="hljs-comment">---&gt;  视频、文件、游戏</span><br>下一层：数据可靠通信  <span class="hljs-comment">---&gt;  数据错误、重复</span><br>下一层：物理网络接入  <span class="hljs-comment">---&gt;  光电等物理特性</span><br></code></pre></td></tr></table></figure>

<h5 id="层次结构设计的基本原则-这些设计思想是值得学习的…"><a href="#层次结构设计的基本原则-这些设计思想是值得学习的…" class="headerlink" title="层次结构设计的基本原则(这些设计思想是值得学习的…)"></a>层次结构设计的基本原则(这些设计思想是值得学习的…)</h5><ul>
<li>各层之间是相互独立的(某一层是不需要知道下一层的原理或实现是怎么样的…层与层之间的耦合度是非常低的…)</li>
<li>每一层要有足够的灵活性，以方便应对未来的变化</li>
<li>各层之间完全解耦(上一层的变化是不影响下一层的…)</li>
</ul>
<h5 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h5><figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">应用层  <span class="hljs-comment">----&gt;  为计算机用户提供接口和服务</span><br>表示层  <span class="hljs-comment">----&gt;  数据处理(编码解码、加密解密等)</span><br>会话层  <span class="hljs-comment">----&gt;  管理(建立、维护、重连)通信会话</span><br>传输层  <span class="hljs-comment">----&gt;  管理端到端的通信连接</span><br>网络层  <span class="hljs-comment">----&gt;  数据路由(决定数据在网络的路径)</span><br>数据链路层 <span class="hljs-comment">--&gt;  管理相邻节点之间的数据通信</span><br>物理层  <span class="hljs-comment">----&gt;  数据通信的光电物理特性</span><br></code></pre></td></tr></table></figure>

<ul>
<li>OSI 本来想要成为全球计算机都遵循的标准</li>
<li>OSI 在市场化过程中困难重重，TCP/IP 在全球范围成功运行</li>
<li>OSI 最终并没有成为广为使用的标准模型<ul>
<li>原因如下：</li>
</ul>
<ol>
<li>OSI 的专家缺乏实际操作经验…</li>
<li>OSI 标准制定周期过长，按 OSI 标准生产的设备无法及时进入市场</li>
<li>OSI 模型设计的并不合理，一些功能在多层中重复出现</li>
</ol>
</li>
</ul>
<h5 id="TCP-IP-四层模型"><a href="#TCP-IP-四层模型" class="headerlink" title="TCP/IP 四层模型"></a>TCP/IP 四层模型</h5><ul>
<li>应用层 (包含了 OSI 的 应用层、表示层、会话层) —&gt; 一些协议：HTTP/FTP</li>
<li>传输层 —&gt; 一些协议：TCP/UDP</li>
<li>网络层 —&gt; 一些协议：IP/ICMP</li>
<li>网络接口层 (包含了 物理层、数据链路层) –&gt; 一些协议：Ethernet/ARP/RARP</li>
</ul>
<p>通信过程</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">计算机A</span>                         <span class="hljs-comment">计算机B</span><br> <span class="hljs-comment">应用层</span>                          <span class="hljs-comment">应用层</span><br> <span class="hljs-comment">传输层</span>      --<span class="hljs-literal">-</span>&gt; <span class="hljs-comment">路由器</span> --<span class="hljs-literal">-</span>&gt;     <span class="hljs-comment">传输层</span><br> <span class="hljs-comment">网络层</span>           <span class="hljs-comment">网络层</span>          <span class="hljs-comment">网络层</span><br> <span class="hljs-comment">网络接口层</span>        <span class="hljs-comment">网络接口层</span>      <span class="hljs-comment">网络接口层</span><br></code></pre></td></tr></table></figure>

<h5 id="现代互联网的网络拓扑"><a href="#现代互联网的网络拓扑" class="headerlink" title="现代互联网的网络拓扑"></a>现代互联网的网络拓扑</h5><ul>
<li><p>边缘部分(用户可以直接接触的部分)<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/%E8%BE%B9%E7%BC%98%E9%83%A8%E5%88%86-%E5%AE%B6%E5%BA%AD.qb1jknhbm8w.png" alt="边缘部分"><br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/%E8%BE%B9%E7%BC%98%E9%83%A8%E5%88%86-%E4%BC%81%E4%B8%9A.2zlos9ma7bo0.png" alt="边缘部分"><br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91.5g08pnr99c80.png" alt="网络拓扑"><br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-11-at-6.58.37-PM.38vof6hxygc0.png" alt="核心部分"></p>
<p>海底电缆相互连接…???</p>
<p>客户-服务器(C/S)模式<br>对等连接(P2P)模式 (下载速度更快…)</p>
</li>
<li><p>核心部分</p>
</li>
</ul>
<h5 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h5><p>速率单位：bps = bit/s<br>为什么电信拉的 100M 光纤，测试峰值速度只有 12M 每秒?</p>
<p>网络常用单位(Mbps)<br>100M/s = 100Mbps = 100Mbit/s<br>100Mbit/s = (100 / 8)MB/s = 12.5MB/s</p>
<h6 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h6><ul>
<li>发送时延</li>
<li>传播时延</li>
<li>排队时延</li>
<li>处理时延</li>
</ul>
<p>总时延 = 发送时延 + 传播时延 + 排队时延 + 处理时延</p>
<h6 id="往返时间-RTT"><a href="#往返时间-RTT" class="headerlink" title="往返时间 RTT"></a>往返时间 RTT</h6><p>RTT 是评估网络质量的一项重要指标<br>RTT 表示的是数据报文在端到端通信中的来回一次的时间<br>通常使用 ping 命令来查看 RTT<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/ping.3ede6r5ghy00.png" alt="ping"></p>
<h4 id="物理层概述"><a href="#物理层概述" class="headerlink" title="物理层概述"></a>物理层概述</h4><h5 id="物理层的作用"><a href="#物理层的作用" class="headerlink" title="物理层的作用"></a>物理层的作用</h5><ul>
<li>连接不同的物理设备(跨国 isp –&gt; 通过海底电缆进行连接…)</li>
<li>传输比特流</li>
</ul>
<p>连接不同物理设备的介质：双绞线、同轴电缆、光纤、红外线、无线(电磁波)、激光</p>
<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/%E6%AF%94%E7%89%B9%E6%B5%81.bzz72eiwus0.png" alt="比特流"></p>
<h5 id="信道的基本概念"><a href="#信道的基本概念" class="headerlink" title="信道的基本概念"></a>信道的基本概念</h5><ul>
<li>信道是往一个方向发送信息的媒体</li>
<li>一条通信电路包含一个接收信道和一个发送信道(即两条信道)</li>
</ul>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">          发送信道<br>设备A  &lt;-----------&gt;  设备B<br>          接收信道<br></code></pre></td></tr></table></figure>

<ul>
<li>单工通信信道<ul>
<li>只能一个方向通信，没有反方向反馈的信道</li>
<li>有线电视、无线电收音机(只能接收，不能发送)等</li>
</ul>
</li>
<li>半双工通信信道<ul>
<li>双方都可以发送和接收信息</li>
<li>不能双方同时发送，也不能同时接收</li>
</ul>
</li>
<li>全双工通信信道<ul>
<li>双方都可以同时发送和接收信息</li>
</ul>
</li>
</ul>
<h5 id="分用-复用技术"><a href="#分用-复用技术" class="headerlink" title="分用-复用技术"></a>分用-复用技术</h5><figure class="highlight brainfuck"><table><tr><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">设备1</span> --<span class="hljs-literal">+</span>                            <span class="hljs-literal">+</span>-- <span class="hljs-comment">设备4</span><br><span class="hljs-comment">设备2</span> --<span class="hljs-comment">|</span>--<span class="hljs-literal">-</span> <span class="hljs-comment">复用</span> --<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span> <span class="hljs-comment">分用</span> --<span class="hljs-literal">-</span><span class="hljs-comment">|</span>-- <span class="hljs-comment">设备5</span><br><span class="hljs-comment">设备3</span> --<span class="hljs-literal">+</span>                            <span class="hljs-literal">+</span>-- <span class="hljs-comment">设备6</span><br><br></code></pre></td></tr></table></figure>

<h5 id="数据链路层概述"><a href="#数据链路层概述" class="headerlink" title="数据链路层概述"></a>数据链路层概述</h5><ul>
<li><p>封装成帧</p>
<ul>
<li>“帧”是数据链路层数据的基本单位</li>
<li>发送端在网络层的一段数据前后添加特定标记形成“帧”</li>
<li>接收端根据前后特定标记识别出“帧”</li>
<li>(物理层不会管你“帧”不“帧”，物理层只管比特流的传输。这里也说明了层与层之间是相互独立，完全解耦的)<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-14-at-10.24.26-AM.zvv3inrxkz4.png" alt="封装成帧"></li>
</ul>
</li>
<li><p>透明传输</p>
<ul>
<li>“透明”在计算机领域是非常重要的一个术语</li>
<li>一种实际存在的事物却又看起来不存在一样</li>
<li>即是控制字符在帧数据中，但是要当作不存在的去处理<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-14-at-10.29.06-AM.3o19ml6y9tq0.png" alt="没有透明传输会出现的问题"><br>ESC 是转义字符<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-14-at-10.30.58-AM.2j99msq02ea0.png" alt="透明传输"><ul>
<li>这个转义字符和编程语言中的”&quot;功能是非常相似的</li>
</ul>
</li>
</ul>
</li>
<li><p>差错监测</p>
<ul>
<li><p>物理层只管传输比特流，无法控制是否出错</p>
</li>
<li><p>数据链路层负责起“差错检测”的工作</p>
</li>
<li><p>奇偶校验码<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-14-at-10.40.05-AM.3yco91z14js0.png" alt="奇偶校验码"></p>
<p>&lt;—奇偶校验码的局限性—&gt;<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-14-at-10.42.35-AM.493mxsqda8y0.png" alt="奇偶校验码的局限性"></p>
</li>
<li><p>循环冗余校验码 CRC<br>–&gt; 更成熟的差错监测</p>
<ul>
<li>一种根据传输或保存的数据而<strong>产生固定位数校验码</strong>的方法</li>
<li><strong>检测</strong>数据传输或者保存后可能出现的错误</li>
<li>生成的数字计算出来并且<strong>附加到数据后面</strong></li>
<li>模“2”除法<ul>
<li>模“2”除法是二进制下的除法</li>
<li>与算术除法类似，但除法不错位，实际是“异或”操作<ul>
<li>异或操作</li>
<li>0 xor 0 = 0</li>
<li>0 xor 1 = 1</li>
<li>1 xor 0 = 1</li>
<li>1 xor 1 = 0</li>
<li><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-14-at-10.51.48-AM.622jua94k8g0.png" alt="模“2”除法"></li>
</ul>
</li>
</ul>
</li>
<li>具体操作<ul>
<li>选定一个用于校验的多项式 G(x), 并在数据尾部添加 r 个 0</li>
<li>将添加 r 个 0 后的数据，使用模“2”除法除以多项式的位串</li>
<li>得到的余数填充在原数据 r 个 0 的位置得到可校验的位串<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-14-at-11.10.46-AM.7avoq98rzp80.png" alt="循环冗余校验码CRC-1"><br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-14-at-11.13.26-AM.39suzj8cu7w0.png" alt="循环冗余校验码CRC-2"><br>101001000 =&gt; 101001<strong>001</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="最大传输单元-MTU"><a href="#最大传输单元-MTU" class="headerlink" title="最大传输单元 MTU"></a>最大传输单元 MTU</h4><ul>
<li>MTU –&gt; 最大传输单元<ul>
<li>数据链路层的数据帧也不是无限大的(数据帧长度受 MTU 限制)</li>
<li>数据帧过长或过小都会影响传输的效率 (以太网 MTU 一般为 1500 字节)</li>
</ul>
</li>
<li>路径 MTU<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-28-at-10.26.13-AM.dw0l58n12nk.png" alt="路径MTU"></li>
</ul>
<h4 id="以太网协议讲解"><a href="#以太网协议讲解" class="headerlink" title="以太网协议讲解"></a>以太网协议讲解</h4><figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">                   |---&gt;设备C<br>设备A -----&gt;路由器-&gt;|<br>                   |---&gt;设备B<br>路由器怎么知道A要发给谁？<br></code></pre></td></tr></table></figure>

<ul>
<li><p>MAC 地址</p>
<ul>
<li>MAC 地址(物理地址、硬件地址)</li>
<li>每一个设备都拥有唯一的 MAC 地址(如何查看 MAC 地址呢？) -</li>
<li><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-10-28-at-10.40.03-AM.26rz5cnw8uow.png" alt="MAC"></li>
<li>MAC 地址共<code>48位</code>,使用十六进制表示</li>
<li>```<br>我的MAC地址：14:7d:da:a5:20:c8 –&gt; 4(16进制-&gt;4位) * 2 * 6(总共6组，每组2个)<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span> 以太网协议<br><span class="hljs-bullet">  -</span> 以太网是一种使用广泛的<span class="hljs-strong">**局域网**</span>技术<br><span class="hljs-bullet">  -</span> 以太网是一种应用于<span class="hljs-strong">**数据链路层**</span>的协议<br><span class="hljs-bullet">  -</span> 使用以太网可以完成相邻设备的<span class="hljs-strong">**数据帧**</span>传输<br><br></code></pre></td></tr></table></figure>
<pre><code>        以太网协议
</code></pre>
目的地址     源地址     类型     帧数据      CRC(校验码)<br>6(MAC地址)  6        2       45~1500      4<br>6表示6个字节       类型表示帧数据<br>1个字节8位       是什么类型的帧数据<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><br>MAC 地址表(是一个映射表)<br>![MAC地址表](https:<span class="hljs-regexp">//</span>cdn.jsdelivr.net<span class="hljs-regexp">/gh/</span>Bruce-shuai<span class="hljs-regexp">/picBed@master/</span>Screen-Shot-<span class="hljs-number">2021</span>-<span class="hljs-number">10</span>-<span class="hljs-number">28</span>-at-<span class="hljs-number">10.55</span>.<span class="hljs-number">11</span>-AM.<span class="hljs-number">3</span>bhpm4ldhac0.png)<br><br>MAC 地址表实质是路由器所拥有的!<br>![路由器实现原理](https:<span class="hljs-regexp">//</span>cdn.jsdelivr.net<span class="hljs-regexp">/gh/</span>Bruce-shuai<span class="hljs-regexp">/picBed@master/</span>Screen-Shot-<span class="hljs-number">2021</span>-<span class="hljs-number">10</span>-<span class="hljs-number">28</span>-at-<span class="hljs-number">11.00</span>.<span class="hljs-number">19</span>-AM.<span class="hljs-number">1</span>y9ghg39ruzk.png)<br><br>![路由器没找到MAC地址](https:<span class="hljs-regexp">//</span>cdn.jsdelivr.net<span class="hljs-regexp">/gh/</span>Bruce-shuai<span class="hljs-regexp">/picBed@master/</span>Screen-Shot-<span class="hljs-number">2021</span>-<span class="hljs-number">10</span>-<span class="hljs-number">28</span>-at-<span class="hljs-number">11.03</span>.<span class="hljs-number">21</span>-AM.<span class="hljs-number">64</span>kg5mwnjw80.png)<br><br>![路由器跨设备传输数据](https:<span class="hljs-regexp">//</span>cdn.jsdelivr.net<span class="hljs-regexp">/gh/</span>Bruce-shuai<span class="hljs-regexp">/picBed@master/</span>Screen-Shot-<span class="hljs-number">2021</span>-<span class="hljs-number">10</span>-<span class="hljs-number">28</span>-at-<span class="hljs-number">11.15</span>.<span class="hljs-number">44</span>-AM.<span class="hljs-number">5</span>x0sbfvsnow0.png)<br>--&gt; 需要学习网络层的内容才能解决跨设备传输数据问题<br><br><span class="hljs-comment">#### 网络层</span><br><br>注意：网络层是路由器最顶层的协议了...<br><br>&gt; 网络层 ---&gt; 数据路由(决定数据在网络的路径)<br><br>**数据链路层**只能解决相邻物理结点传输(比如：相邻的路由器与电脑)<br><br>**网络层**是可以解决大结点之间的数据传递的<br><br>路由器可以分为**家庭路由器**和**企业路由器**<br><br></code></pre></td></tr></table></figure>
网络层IP协议相关 –&gt;  IP协议  子网划分 简单路由过程<br> |<br>网络层其他协议   –&gt;  ARP协议与RARP协议 ICMP协议<br> |<br>IP的路由算法  –&gt;  路由的概述  内部网关路由协议   外部网关路由协议</li>
</ul>
</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-section">#### IP 协议讲解</span><br><br><span class="hljs-bullet">-</span> 虚拟互连网络<br><span class="hljs-bullet">  -</span> 实际的计算机网络是错综复杂的<br><span class="hljs-bullet">  -</span> 物理设备通过使用 IP 协议，屏蔽了物理网络之间的差异<br><span class="hljs-bullet">  -</span> 当网络中的主机使用 IP 协议连接时，则无需关注网络细节<br><span class="hljs-bullet">  -</span> 协议使得复杂的<span class="hljs-strong">**实际网络**</span>变为一个<span class="hljs-strong">**虚拟互连的网络**</span><br><span class="hljs-bullet">  -</span> IP 协议使得网络层可以屏蔽底层细节而专注网络层的数据转发<br><span class="hljs-bullet">  -</span> IP 协议<span class="hljs-strong">**解决了在虚拟网络中数据报传输路径的问题**</span><br><span class="hljs-bullet">-</span> IP 协议<br><br>ip 地址是每一个网络设备唯一的身份<br><br>MAC 地址：一直不变，刻在电脑硬件里的<br>IP 地址：电脑放在不同地方(星巴克、图书馆)，IP 地址会不一样(受网络环境的影响)<br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-11-at-10.23.36-AM.png&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;300px&quot;</span>/&gt;</span></span><br><br><span class="hljs-bullet">-</span> IP 地址长度为 32 位，常分为 4 个 8 位<br><span class="hljs-bullet">-</span> IP 地址常使用<span class="hljs-strong">**点分十进制**</span>来表示(0~255.0~255.0~255.0~255)<br><br></code></pre></td></tr></table></figure>
<p>114.114.114.114<br>8.8.8.8<br>1.1.1.1<br>255.255.255.255</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in"></span><br><span class="hljs-built_in">IP </span>地址共： 2^32 = 4294961296 (大约 42 亿个)<br><br>&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-11-at-10.28.26-AM.png&quot;</span> <span class="hljs-attribute">width</span>=<span class="hljs-string">&quot;300px&quot;</span>/&gt;<br><br>&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-11-at-10.29.18-AM.png&quot;</span> <span class="hljs-attribute">width</span>=<span class="hljs-string">&quot;300px&quot;</span> <span class="hljs-attribute">alt</span>=<span class="hljs-string">&quot;ip头部信息&quot;</span>/&gt;<br><br>版本: 占 4 位，指的是<span class="hljs-built_in"> IP </span>协议的版本，通信双方的版本**必须一致**，当前主流版本是 4，即 `IPv4`, 也有 `IPv6`<br>首部位长度：占 4 位，最大数值为 15，表示的是<span class="hljs-built_in"> IP </span>首部长度，单位是“32 位字”(4 个字节)，也即是<span class="hljs-built_in"> IP </span>首部最大长度为 60(15 \* 4) 字节<br>总长度：占 16 位，最大数值为 65535，表示的是<span class="hljs-built_in"> IP </span>数据报总长度(IP 首部+IP 数据)<br><br>TTL: 占 8 位，表明<span class="hljs-built_in"> IP </span>数据报文在网络中的寿命，每经过一个设备(包括路由器、计算机)，TTL 减 1，当 <span class="hljs-attribute">TTL</span>=0 时，网络设备必须丢弃该报文 --&gt; 避免网络报文在网络中无限的传输，消耗带宽<br><br>协议：占 8 位，表明<span class="hljs-built_in"> IP </span>数据所携带的具体数据是什么协议(如：TCP、UDP 等)<br><br></code></pre></td></tr></table></figure>
<p>协议名： ICMP | IGMP | IP | TCP | UDP<br>字段值：   1  |   2  |  4 |  6  | 17</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><br>首部检验和： 占 16 位，校验<span class="hljs-built_in"> IP </span>首部是否有出错<br><br>源<span class="hljs-built_in"> IP </span>地址<br><br>目的<span class="hljs-built_in"> IP </span>地址<br><br><span class="hljs-comment">#### IP 协议的转发流程</span><br><br>&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-11-at-10.45.43-AM.png&quot;</span> <span class="hljs-attribute">width</span>=<span class="hljs-string">&quot;300px&quot;</span> <span class="hljs-attribute">alt</span>=<span class="hljs-string">&quot;逐跳&quot;</span> /&gt;<br>&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-11-at-10.47.59-AM.png&quot;</span> <span class="hljs-attribute">width</span>=<span class="hljs-string">&quot;300px&quot;</span> <span class="hljs-attribute">alt</span>=<span class="hljs-string">&quot;路由表&quot;</span> /&gt;<br>&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-11-at-10.50.03-AM.png&quot;</span> <span class="hljs-attribute">width</span>=<span class="hljs-string">&quot;300px&quot;</span> <span class="hljs-attribute">alt</span>=<span class="hljs-string">&quot;转发流程&quot;</span> /&gt;<br><br><span class="hljs-comment">#### ARP 协议与 RARP 协议</span><br><br><span class="hljs-comment">### 传输层</span><br><br>传输层 &lt;----&gt; 管理端到端的通信连接<br><br></code></pre></td></tr></table></figure>
<p>设备A  —&gt;  虚拟的互联网络 —&gt; 设备B<br>浏览器      进程与进程的通信     网站后台</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><code class="hljs erlang"><br>- 使用端口<span class="hljs-params">(Port)</span>来标记不同的网络进程<br>- 端口<span class="hljs-params">(Port)</span>使用 16 比特位表示<span class="hljs-params">(<span class="hljs-number">0</span>~<span class="hljs-number">65535</span>)</span><br><br></code></pre></td></tr></table></figure>
<p>FTP | HTTP | HTTPS | DNS | TELNET<br> 21 |  80  |  443  |  53 |  23</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><br>&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-11-at-11.17.47-AM.png&quot;</span> <span class="hljs-attribute">width</span>=<span class="hljs-string">&quot;300px&quot;</span> <span class="hljs-attribute">alt</span>=<span class="hljs-string">&quot;tcp&amp;udp&quot;</span>&gt;<br><br><span class="hljs-comment">#### UDP 协议详解</span><br><br>- UDP(用户数据报协议)<br>- UDP 是一个非常简单的协议<br><br> &lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-11-at-11.21.16-AM.png&quot;</span> <span class="hljs-attribute">width</span>=<span class="hljs-string">&quot;300px&quot;</span> <span class="hljs-attribute">alt</span>=<span class="hljs-string">&quot;udp协议详解&quot;</span>&gt;<br><br> &lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-11-at-11.22.50-AM.png&quot;</span> <span class="hljs-attribute">width</span>=<span class="hljs-string">&quot;300px&quot;</span> <span class="hljs-attribute">alt</span>=<span class="hljs-string">&quot;udp协议详解&quot;</span>&gt;<br><br>**UPD 首部**<br><br></code></pre></td></tr></table></figure>
<p>16位端口号   |  16位目的端口号<br>16位UDP长度     16位UDP校验和<br>        UDP数据</p>
<pre><code>
- UDP 是**无连接**协议(无连接：指机器进行通信前不需要建立连接)
- UDP 不能保证可靠的交付数据(&quot;想发就发&quot;, &quot;无法保证数据在网络中是否丢失&quot;)
- UDP 是面向报文传输的(应用层传来的数据 UDP 协议不会做任何的处理)
- UDP 没有**拥塞控制**(UDP 不会感知当前网络是否堵塞，想传数据就传数据)
- UDP 的首部开销很小

#### TCP 协议详解

- TCP(传输控制协议)
- TCP 协议是计算机网络中非常复杂的一个协议

![tcp](https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-18-at-10.18.54-AM.png)

- TCP 是面向连接的协议
- TCP 的一个连接有两端(点到点通信)
- TCP 提供可靠的传输服务
- TCP 协议提供全双工的通信(全双工：例如我和你打电话，我们可以同时说话)
- TCP 是面向字节流的协议(字节流：流(流入进程 流出进程))
  ![TCP协议头部](https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-18-at-10.31.15-AM.png)

* 序号： 0~2^32 - 1 (一个字节一个序号)
* 确认号： 0~2^32 - 1 (一个字节一个序号) (期望收到数据的首字节序号)
* 数据偏移： 占 4 位：0~15，单位为：32 位字
* TCP 标记： 占 6 位，每位各有不同意义 (重点)
  ![TCP标记](https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-18-at-10.39.47-AM.png)
* 窗口：占 16 位：0~2^16 - 1 (窗口指明允许对方发送的数据量)
* 紧急指针： 紧急数据(URG = 1) 指定紧急数据在报文的位置
* TCP 选项： 最多 40 字节 支持未来的拓展

##### 可靠传输的基本原理

- 停止等待协议

1. 无差错的情况
   ![停止等待协议](https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-18-at-10.52.58-AM.png)

2. 有差错的情况
   ![超时重传1](https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-18-at-10.55.05-AM.png)
   ![超时重传2](https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-18-at-10.55.59-AM.png)
   ![超时重传3](https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-18-at-10.57.35-AM.png)
   - 发送的消息在路上丢失了
   - 确认的消息在路上丢失了
   - 确认的消息很久才到
     都可以通过超时重传来保证可靠传输

- 超时定时器： 每发送一个消息，都需要设置一个定时器
- 停止等待协议是最简单的可靠传输协议
- 停止等待协议对信道的利用效率不高

* 连续 ARQ 协议
  - ARQ(自动重传请求)
    ![滑动窗口](https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/Screen-Shot-2021-11-18-at-11.06.41-AM.png)
  - 累计确认...

##### TCP 协议的可靠传输

- TCP 的可靠传输基于连续 ARQ 协议
- TCP 的滑动窗口以字节为单位
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>HTTP协议-随笔</title>
    <url>/2021/12/25/HTTP%E5%8D%8F%E8%AE%AE-%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<p><a href="https://zq99299.github.io/note-book2/http-protocol/02/01.html#%E5%8F%B2%E5%89%8D%E6%97%B6%E6%9C%9F">透视 HTTP 协议</a></p>
<p><strong>互联网初期</strong><br>20世纪60年代，美国国防部高等研究生计划署(ARPA)建立了ARPA网，被认为是如今互联网的始祖<br>20世纪70年代，基于对ARPA网的实践和思考，研究人员发明出了著名的<code>TCP/IP</code>协议。</p>
<p>1989年，一个老头 伯纳斯·李 发表了一篇论文，这篇论文提出了在互联网上构建超链接文档系统的构想。<br>他在这篇论文中提到了三项关键技术 <strong>超链接文档系统三项关键技术：</strong></p>
<ul>
<li>URI: 即<strong>统一资源标识符</strong>，作为互联网上资源的<strong>唯一身份</strong>。 (注意：<a href="https://www.zhihu.com/question/21950864">uri和url的区别</a>)</li>
<li>HTML: 即超文本标记语言，描述超文本文档。</li>
<li>HTTP：即<strong>超文本传输协议</strong>，用来传输超文本。</li>
</ul>
<p><strong>HTTP/0.9</strong><br>HTTP/0.9 是于1991年提出的 –&gt; 主要是用于学术交流 需求是非常简单的 以<strong>纯文本格式</strong>交流<br>90 年代初期：结构简单，页面内容只可读。所以只允许 <code>GET</code> 请求(从服务器里获取HTML文档) 并且在响应请求之后立即关闭连接 (无法持久连接)<br>(当时只有一个请求行，没有请求头和请求体。  返回的文件内容是以ASCII字符流来传输的因为都是HTML格式的文件，所以用ASCII字节码传输比较合适)</p>
<p><strong>HTTP/1.0</strong>  –&gt; 具备多种类型资源的接受和方法<br>1996 年正式发布<br>由于多媒体的发展(例如：图片格式、MP3音乐格式的出现)，开始准备往HTTP里添加各种特性</p>
<ol>
<li>增加了 <code>HEAD</code>、<code>POST</code> 等新方法   —&gt;  注意：POST 请求是在1.0版本才出现的…</li>
<li>增加了响应状态码，标记可能的错误原因</li>
<li>引入了协议版本号概念</li>
<li>引入了 HTTP Header（头部–&gt; 响应头和请求头）的概念，让 HTTP 处理请求和响应更加灵活；</li>
<li>传输的数据不再仅限于文本ASCII码格式(支持多媒体格式)。</li>
<li>为了缓解服务器的压力，在HTTP/1.0中提供了**Cache机制(Cache-control?)**，用来缓存已经下载过的数据</li>
</ol>
<p>HTTP/1.0的方案是通过请求头和响应头来进行协商，来判断该文件将返回什么类型的文件、该采用什么形式的压缩方式，提供什么语言的文件，以及文件的具体编码方式：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">accep<span class="hljs-variable">t:</span> text/html<br>accept-encodin<span class="hljs-variable">g:</span> gzip, deflate, <span class="hljs-keyword">br</span><br>accept-Charse<span class="hljs-variable">t:</span> ISO-<span class="hljs-number">8859</span>-<span class="hljs-number">1</span>, utf-<span class="hljs-number">8</span><br>accept-<span class="hljs-keyword">language</span>: zh-CN, zh<br></code></pre></td></tr></table></figure>


<p>问题：队头阻塞问题<br>HTTP 1.0 请求与请求之间是串行的，如果我发送了A请求，那么A请求的响应返回之前，你的B请求不管多么着急都出不去。如果A就是请求卡在那，B请求也就只能堵着不能动<br>HTTP 1.1 使用管线化来解决这个问题：允许多个HTTP请求批量地提交给服务器，不过尽管发送动作可以并行，但是服务器依然需要根据请求顺序来回复浏览器的请求。本质上还是存在队头阻塞问题<br>HTTP 2 利用多路复用，一次连接建立后，只要这个连接还在，那么客户端就可以在一个链接中批量发起多个请求，并且请求之间不堵塞，请求之间高度独立，实现真正并行请求</p>
<p><strong>HTTP/1.1</strong> –&gt; 支持长连接、虚拟主机、引入cookie<br>1999 年发布，HTTP/1.1是对HTTP/1.0的小幅度修正，但有一个重要的区别是：<strong>它是一个正式的标准</strong></p>
<ol>
<li>增加了 <code>PUT</code>、<code>DELETE</code> 等新的方法；</li>
<li>增加了缓存管理和控制； (缓存管理是啥？ 控制是啥？) –&gt;  这里是指的CDN吗？</li>
<li>明确了连接管理，<strong>允许持久连接</strong>； (持久连接在HTTP/1.1中是默认开启的，所以你不需要专门为了持久连接去HTTP请求头设置信息，如果你不想要采用持久连接，可以在HTTP请求头中加上 <code>Connection:close</code> 目前浏览器中对于同一个域名，默认允许同时建立6个TCP持久连接，这样减轻了服务器额外的负担)</li>
<li>允许<strong>响应数据分块</strong>（chunked），利于传输大文件</li>
<li>强制要求 Host 头，让互联网主机托管成为可能(提供虚拟主机)(一台物理主机上绑定多个虚拟主机，每个虚拟主机都有自己的单独的域名，这些单独的域名都公用同一个IP地址，因此，HTTP/1.1的请求头中增加了Host字段，用来表示当前的域名地址，这样服务器就可以根据不同的Host值做不同的处理)。 </li>
<li>引入了客户端 <code>Cookie</code> </li>
</ol>
<p><strong>HTTP/1.1依旧存在的问题</strong><br>队头阻塞问题依旧严重<br>TCP的慢启动   —&gt; 不太懂…<br>同时开启了多条TCP连接，那么这些连接会竞争固定的带宽  —&gt; 这是一个细节<br>安全性问题</p>
<h3 id="HTTP-2-–-gt-性能优化-核心就是多路复用"><a href="#HTTP-2-–-gt-性能优化-核心就是多路复用" class="headerlink" title="HTTP/2  –&gt; 性能优化 核心就是多路复用"></a>HTTP/2  –&gt; 性能优化 核心就是多路复用</h3><p>2015 年发布 –&gt; 以 google SPDY 协议为基础，综合其它多方的意见推出HTTP/2</p>
<p>影响HTTP/1.1效率的三个主要因素<br>HTTP/1.1对于带宽的利用率很低。比如100M带宽，实际的下载速度只能到达12M/s,加载速度也就2M/s左右。出现这些问题的原因如下：</p>
<ul>
<li>TCP慢启动：刚开始建立好TCP连接后TCP会采用一个很慢的速度去发送数据，后面才慢慢加快，这个过程其实就是慢启动 (这其实也是为了减少网络拥塞的一种策略)</li>
<li>同时开启多条TCP连接会竞争这固定的带宽： 并且有点TCP连接下载的是一些关键资源，例如html、css文件，而有些是图片、视频资源，但是多条TCP连接无法选择哪些关键资源优先下载</li>
<li>队头堵塞问题</li>
</ul>
<p>而多路复用能解决上述的三个问题：<br><strong>细谈多路复用：</strong><br>HTTP/2的思路是一个域名只使用一个TCP长连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动，也避免了多个TCP连接竞争带宽所带来的的问题。并且HTTP/2实现了资源的并行请求，不需要一个资源请求完才能进行下一个资源的请求。可以把请求分成一帧一帧的数据去传输，这样带来了一个额外的好处，就是当收到一个优先级高的请求时，比如收到JS或者CSS关键资源的请求，服务器可以暂停之前的请求来优先处理关键资源的请求(利用的就是二进制分帧，并且这些分帧都带有ID编号，服务器接收到这些帧后，会将所有相同ID的帧合并为一条完整的请求信息。)</p>
<p>注意：对于开发者而言，其实是没有感知变化的。我们依然可以使用cookie来保持登录状态，使用cache来缓存本地文件，真正变化的是传输方式，而开发者其实是感受不到传输变化的</p>
<p>二进制分帧层还能够实现请求的优先级、服务器推送、头部压缩等特性。从而大大提升了文件传输效率</p>
<blockquote>
<p>由于 <code>HTTPS</code> 已经在安全方面做的非常好了，所以 <code>HTTP/2</code> 的<strong>唯一目标</strong>就是<strong>改进性能</strong></p>
</blockquote>
<h4 id="高度兼容HTTP-1-1"><a href="#高度兼容HTTP-1-1" class="headerlink" title="高度兼容HTTP/1.1"></a>高度兼容HTTP/1.1</h4><p><code>HTTP/2</code> 对于 HTTP的兼容性非常强(降低了学习成本~) –&gt;<br> <code>HTTP/2</code> 把 HTTP 分解成了 <code>语义</code> 和 <code>语法</code> 这两个部分，<strong>语义层不做改动</strong>，与HTTP/1完全一致(例如：请求方法、URI、状态码、头字段等都没有变化)<br>甚至 <code>HTTP/2</code> 没有在 <code>URI</code> 里引入新的协议名，仍然用 <code>HTTP</code> 表示明文协议,用 <code>HTTPS</code> 表示加密协议  –&gt; 让用户也是平滑过渡</p>
<p>在语义保持稳定不变前提下，<code>HTTP/2</code>在语法层做了巨大的改变。<strong>完全更改了HTTP报文的传输格式</strong>(不再是纯文本，而是二进制协议)</p>
<h4 id="HTTP-2的变化"><a href="#HTTP-2的变化" class="headerlink" title="HTTP/2的变化"></a>HTTP/2的变化</h4><h5 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h5><p>利用专门研发的算法：HPACK 进行报文 Header压缩 –&gt; 压缩率：50%~90%<br>因为在语义上 HTTP/2 和 HTTP/1是兼容的，所以报文还是有 <code>Header + Body</code> 构成的，但是在<strong>请求发送前</strong>，必须要用 <code>HPACK</code> 算法来压缩头部数据<br>HTTP/2 由于压缩头部，流量损耗会进一步降低</p>
<h5 id="请求优先级"><a href="#请求优先级" class="headerlink" title="请求优先级"></a>请求优先级</h5><p>HTTP/2提供了请求优先级，可以在发送请求时，标上该请求的优先级，这样服务器接受到请求之后，会优先处理优先级高的请求</p>
<h5 id="二进制格式，不再是纯文本"><a href="#二进制格式，不再是纯文本" class="headerlink" title="二进制格式，不再是纯文本"></a>二进制格式，不再是纯文本</h5><p>报文由原来的纯文本格式 转变为 二进制格式：非常方便计算机的解析 精确度上升，速度上升<br>头部数据压缩之后，<code>HTTP/2</code> 就要把报文拆成二进制的帧准备发送<br>原来的 <code>Header</code> + <code>Body</code> 报文结构 –打散为–&gt;  多个 「二进制帧(HEADERS帧存放头数据、DATA帧存放实体数据)」 “碎片”</p>
<h5 id="虚拟的「流」"><a href="#虚拟的「流」" class="headerlink" title="虚拟的「流」"></a>虚拟的「流」</h5><p>流是二进制帧的<strong>双向传输序列</strong><br>以流(虚拟的)的方式传递 二进制帧<br>HTTP/2 可以在一个TCP连接上用 流 同时发送多个「碎片化」的消息 –&gt; 多路复用：多个往返通信都复用一个连接来处理<br>(注意：虽然帧是乱序收发，但是同一个流里都有相同的流ID)<br>流中的帧不是无序的，有着严格的先后顺序</p>
<p>在流的层面上看，消息是一些有序的帧序列，而在连接的层面上看，消息却是乱序收发的帧。多个请求/响应之间没有了顺序关系，不需要排队等待，也就不会出现队头阻塞问题，降低了延迟，大幅度提高了连接的利用率</p>
<h5 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h5><p>在 HTTP1.x 中，如果用户请求了资源 A，结果发现自己如果要用资源 A，那么必须依赖资源 B，这时他不得不再消耗一个请求。<br>HTTP2.0 中，允许服务器主动向客户端 push 资源。也就是说当服务器发现客户端请求了资源 A，却忘了请求资源 A 依赖的资源 B 时，它可以主动将资源 B 顺手推送给客户端，没必要再消耗一个请求</p>
<h5 id="强化安全"><a href="#强化安全" class="headerlink" title="强化安全"></a>强化安全</h5><p>互联网上通常所能见到的 <code>HTTP/2</code> 都是使用 <code>HTTPS</code> 协议名，跑在 <code>TLS 1.2+</code>上面, 禁用了很多不安全的密码套件<br><code>h2</code>: 表示加密的HTTP/2<br><code>h2c</code>: 表示明文的 HTTP/2， 多出的字母<code>c</code>的意思是<code>clear text</code> </p>
<h6 id="细节问题"><a href="#细节问题" class="headerlink" title="细节问题"></a>细节问题</h6><p>HTTP/2.0 的普及率不算太高， 很多网站是 HTTP/1.1</p>
<p>HTTP/2 把 <strong>头部压缩</strong> 作为性能改进的一个重点</p>
<p>HTTP/2 的消息不再是 <strong>Header+Body</strong> 的形式，而是分散为多个二进制帧(请求发送前会把<code>Header + Body</code>,进行头部压缩之后拆解为二进制的帧进行发送<strong>即先压缩再拆解</strong>)</p>
<blockquote>
<p>问题：HTTP/2 的大文件上传该怎么操作呢？ </p>
</blockquote>
<blockquote>
<p>把简单的系统变复杂，要比把复杂的系统变简单容易得多</p>
</blockquote>
<h3 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h3><p>2018 年发布 –&gt; 基于 <code>google</code> 的 <code>QUIC</code> 协议<br>在HTTP/2的基础上实现了质的飞跃，真正完美地解决了队头阻塞问题<br>基于UDP来实现的</p>
<p>对于TCP连接，可以看成是一个按照顺序传输数据的管道，管道中的任意一个数据丢失了，那之后的数据都需要等待该数据的重新传输<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-01-26-%E4%B8%8B%E5%8D%884.78ynw7u5s8w0.webp" alt="http/1.1队头阻塞"><br>把在TCP传输过程中，由于单个数据包的丢失而造成的阻塞称为TCP上的队头阻塞</p>
<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-01-26-%E4%B8%8B%E5%8D%884.71xewyyclec0.webp" alt="http/2队头阻塞"><br>我们知道在 HTTP/2 中，多个请求是跑在一个 TCP 管道中的，如果其中任意一路数据流中出现了丢包的情况，那么就会阻塞该 TCP 连接中的所有请求。这不同于 HTTP/1.1，使用 HTTP/1.1 时，浏览器为每个域名开启了 6 个 TCP 连接，如果其中的 1 个 TCP 连接发生了队头阻塞，那么其他的 5 个连接依然可以继续传输数据</p>
<h4 id="HTTP-是什么？"><a href="#HTTP-是什么？" class="headerlink" title="HTTP 是什么？"></a>HTTP 是什么？</h4><p>HTTP: 超文本传输协议 –&gt; 拆成三个部分： 超文本、传输、协议<br>协议： 一种约束、规范，遵守协议则就要遵守这些约束和规范<br>传输： A 传给 B，B 传给 A。HTTP 是双向协议。 这里恰好可以用客户端、服务端的数据传送来说明<br>超文本：所谓超文本，字面意思就是超越文本的文本。它是文字、图片、视频、音乐等多媒体的混合体，并且它拥有超链接。能够从一个超文本跳跃到另一个超文本</p>
<h4 id="为什么HTTP要设置成无状态的"><a href="#为什么HTTP要设置成无状态的" class="headerlink" title="为什么HTTP要设置成无状态的"></a>为什么HTTP要设置成无状态的</h4><p>无状态是为了降低服务端的压力，避免http连接长期占用服务器资源。对于服务器端的缓存、负载均衡都有一定的好处</p>
<h4 id="URI-和-URL的区别？"><a href="#URI-和-URL的区别？" class="headerlink" title="URI 和 URL的区别？"></a>URI 和 URL的区别？</h4><p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-01-10-%E4%B8%8A%E5%8D%889.19c21x1b8b8g.webp" alt="URI 和 URL的区别"></p>
<p>URI 和 URL 都能够指定唯一的一个资源。但是URI的宗旨是 无论你用的是什么方式，只要你能唯一的确定一个资源，就都算URI的一种实现，而URL就是用定位的方式(…/…/…/)来定位具体的资源<br>URI = URL + URN</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>nginx.org<span class="hljs-regexp">/en/</span>download.html<br>协议名：http<br>主机名：nginx.org<br>路径：<span class="hljs-regexp">/en/</span>download.html<br></code></pre></td></tr></table></figure>

<h4 id="Web-服务器"><a href="#Web-服务器" class="headerlink" title="Web 服务器"></a>Web 服务器</h4><p>Apache、 Nginx、IIS、Tomcat</p>
<h4 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h4><p>TCP 属于传输层 IP 属于网际层</p>
<p>HTTP 协议就运行在 TCP/IP 上</p>
<h5 id="IP-协议"><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h5><p>主要目的是解决寻址和路由问题，以及如何在两点间传送数据包</p>
<h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>域名用 <code>.</code> 分割成多个单词，级别从左到右逐级升高<br>最右边的被称为 顶级域名</p>
<h4 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h4><p>URI = URL + URN<br>URI 本质上是一个字符串，这个字符串的作用是 唯一地标记资源的位置或者名字</p>
<h3 id="网络："><a href="#网络：" class="headerlink" title="网络："></a>网络：</h3><p>互联网实际是由许许多多个 <strong>规模略小的网络</strong> 连接而成的<br>我们常说的 <strong>上网</strong> 实际上访问的只是互联网的一个子集 <strong>”万维网“</strong>，它基于HTTP协议，传输HTML等超文本资源，能力也就被限制在HTTP协议之内<br>互联网上还有许多万维网之外的资源，例如常用的电子邮件、BT 和 Magnet 点对点下载、FTP 文件下载、SSH 安全登录、各种即时通信服务等等，它们需要用各自的专有协议来访问(说明了HTTP在互联网中所占的范围是什么样的)<br>不过由于 HTTP 协议非常灵活、易于扩展，而且「超文本」的表述能力很强，所以很多其他原本不属于 HTTP 的资源也可以「包装」成 HTTP 来访问，这就是我们为什么能够总看到各种网页应用——例如微信网页版、邮箱网页版——的原因</p>
<h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>浏览器的名字叫：Web Browser 这里的Web指的是 World Wide Web，也就是万维网(万维网和HTTP的渊源之深，上面有讲)<br>浏览器本质上是一个 HTTP 协议中的 请求方，使用 HTTP 协议获取网络上的各种资源。(说明浏览器和HTTP的关联度是非常大的)</p>
<p>在HTTP协议里，浏览器的角色被称为<code>User Agent(ua)</code>即<strong>用户代理</strong>, 意思就是作为访问者的「代理」来发起HTTP请求。我们通常也称为客户端</p>
<h3 id="Web-服务器-1"><a href="#Web-服务器-1" class="headerlink" title="Web 服务器"></a>Web 服务器</h3><p>协议另一端的应答方(响应方)<br>服务器： <strong>Web Server</strong></p>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p><a href="https://segmentfault.com/a/1190000039045541#:~:text=CDN%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%98%AF%E9%87%87%E7%94%A8,%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B4%E6%8E%A5%E5%93%8D%E5%BA%94%E7%94%A8%E6%88%B7%E8%AF%B7%E6%B1%82%E3%80%82">一篇比较好的博客</a><br>CDN是利用了缓存技术，解决如何将数据快速可靠从源站传递到用户的问题。用户获取数据时不需要直接从源站获取，通过CDN分发，用户可以从一个较优的服务器获取数据，从而达到快速访问，并减少源站负载压力的目的。</p>
<h3 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h3><p>HTTP协议没有规定用户代理后面必须是「真正的人类」，它也完全可以是「机器人」，这些「机器人」的正式名称就叫做<strong>爬虫</strong>，实际上是一种可以自动访问Web资源的应用程序。互联网上至少有 50% 的流量都是由爬虫产生的，如果你的网站今天的访问量是十万，那么里面至少有五六万是爬虫机器人，而非真实的用户。<br>绝大多数的爬虫都是由各大搜索引擎「放」出来的，<strong>抓取网页存入庞大的数据库，再建立关键字索引，这样我们才能够在搜索引擎中快速地搜索到互联网角落里的页面</strong>。</p>
<p>反爬虫技术：</p>
<ul>
<li>robots.txt 约定哪些该爬，哪些不该爬。 无论是爬虫还是反爬虫，用到的基本技术都是两个，一个HTTP，一个HTML</li>
<li>在浏览某些网站时遇到过要求验证你不是机器人的页面，这也是一种反爬虫手段</li>
</ul>
<h3 id="WAF-网络应用防火墙"><a href="#WAF-网络应用防火墙" class="headerlink" title="WAF 网络应用防火墙"></a>WAF 网络应用防火墙</h3><p>WAF 通常位于Web服务器之前，可以阻止如SQL注入、跨站脚本等攻击</p>
<h3 id="TCP-IP-1"><a href="#TCP-IP-1" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>TCP/IP 协议实际上是一系列网络通信协议的统称，其中最核心的两个协议是 TCP 和 IP<br>TCP/IP是有多种协议共同构成的一个协议栈<br>这个协议栈有4层：<br>应用层<br>传输层 (TCP协议：基于IP协议提供可靠(数据不易丢失)的、字节流形式的通信，是HTTP协议得以实现的基础)：保证数据在IP地址标记的两点之间可靠地传输，是TCP协议工作的层次<br>网际层 (IP协议：主要目的是寻址和路由问题，以及如何在两点间传送数据包。  IP协议 v4版本大约有42亿个，v6版本大约有2^128个)在链接层的基础上，用IP地址去替换MAC地址，把许多局域网、广域网连接成一个虚拟的巨大网络<br>链接层：负责在以太网、WiFi这样的底层网络上发生原始数据包，使用MAC地址来标记网络上的设备(也叫MAC层)</p>
<h3 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h3><p>7层模型<br>物理层： 电缆、光纤<br>链路层<br>网络层<br>传输层<br>会话层  –&gt; 下面这三层对应TCP/IP的应用层<br>表示层<br>应用层</p>
<h3 id="DNS-1"><a href="#DNS-1" class="headerlink" title="DNS"></a>DNS</h3><p><a href="https://juejin.cn/post/6909041150728863752">相关博客一</a><br><a href="https://segmentfault.com/a/1190000023694985">相关博客二</a><br><strong>DNS</strong>的作用就是通过域名找到对应的IP地址<br>查找顺序：浏览器 操作系统 host文件 | DNS根服务器 一级域名 二级域名 三级域名 返回客户端   —&gt; 这是递归查询<br>（客户端电脑使用的DNS就是本地DNS服务器）</p>
<ol>
<li>本地客户端向服务器发起请求查询IP地址 (这里是向本地DNS服务器发起请求过程中进行下面的2 3 4 步)</li>
<li>查看浏览器有无该域名的IP缓存</li>
<li>查看操作系统有无该域名的IP缓存</li>
<li>查看Host文件有无该域名的解析配置</li>
<li>前面都没有找到IP地址的情况下，会去DNS根服务器查询，会找出对应的一级域名 比如.com的服务器</li>
<li>在一级域名服务器找 比如google.com这个二级域名服务器</li>
<li>接下来查找<a href="http://www.google.com这个三级域名的地址/">www.google.com这个三级域名的地址</a></li>
<li>找到后返回给客户端</li>
</ol>
<p>注意一个问题： host 到 本地DNS服务器 的查询方式是递归查询     本地DNS服务器 到 根域名服务器等后面的域名服务器的查询方式是迭代</p>
<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-02-06-%E4%B8%8A%E5%8D%889.25bhtoh1sl6o.webp" alt="递归查询 vs 迭代查询"><br><strong>递归查询</strong>时，返回的结果只有两种：查询成功或查询失败<br><strong>迭代查询</strong>，返回的是最佳的查询点或者主机地址<br>这里的本地域名服务器是咋用的？ 应该就是本地客户端向本地服务器发起请求查询IP地址</p>
<h5 id="片段标识符-这个是牛爷爷"><a href="#片段标识符-这个是牛爷爷" class="headerlink" title="片段标识符 这个是牛爷爷"></a>片段标识符 这个是牛爷爷</h5><p>它是 URI 所定位的资源内部的一个 锚点 或者说是 标签，浏览器可以在获取资源后直接 跳转到它指示的位置。但片段标识符仅能由浏览器这样的客户端使用，服务器是看不到的。也就是说，浏览器永远不会把带 #fragment 的 URI 发送给服务器，服务器也永远不会用这种方式去处理资源的片段</p>
<h5 id="URI的编码机制"><a href="#URI的编码机制" class="headerlink" title="URI的编码机制"></a>URI的编码机制</h5><h4 id="域名的解析"><a href="#域名的解析" class="headerlink" title="域名的解析"></a>域名的解析</h4><p>IP 地址必须转换成 MAC 地址才能访问主机一样，域名也必须要转换成 IP 地址，这个过程就是 域名解析</p>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>它的全称是 HTTP over SSL/TLS 即允许在<strong>SSL/TLS协议</strong>上的HTTP<br>SSL/TLS 本身就是一个负责加密通信的安全协议</p>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>计算机科学领域里的任何问题，都可以通过引入一个中间层来解决」（在这句话后面还可以再加上一句「如果一个中间层解决不了问题，那就再加一个中间层」</p>
<p>代理(Proxy)是HTTP协议中请求方和应答方中间的一个缓解，作为中转站，既可以转发客户端的请求，也可以转发服务器的应答<br>代理的种类：<br>匿名代理：隐匿被代理的机器，外界看到的只是一个代理服务器<br>透明代理：传输过程是透明开放的，外界既知道代理，也知道客户端<br>正向代理：靠近客户端，代表客户端向服务器发送请求<br>反向代理：靠近服务器端，代表服务器响应客户端的请求</p>
<p>(注意：CDN就是一种反向代理/透明代理，代替源站服务器响应客户端的请求)</p>
<p>代理可以做的事：<br>负载均衡：把访问请求均匀分散到多台机器，实现访问集群化<br>内容缓存<br>安全防护<br>数据处理</p>
<h3 id="域名的形式"><a href="#域名的形式" class="headerlink" title="域名的形式"></a>域名的形式</h3><p>域名层级关系是从右往左层级依次降低<br>域名不仅能够代替IP地址还能够用来标识虚拟主机，决定由哪个虚拟主机来对外提供服务，还是个名字空间系统，使用多级域名可以划分不同的国家、地区、组织、公司…可以作为一种身份的标识</p>
<h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p>根域名服务器 –&gt; 顶级域名服务器 –&gt; 权威域名服务器<br>呈现树状的分布式查询系统<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-01-24-%E4%B8%8A%E5%8D%8810.1oitsnf5iicg.webp" alt="域名查询系统"><br>大公司也会建立自己的DNS服务器，被称为 非权威域名服务器，可以缓存之间的查询结果，如果有记录了，就无需再向根服务器发起查询，直接返回对应的IP地址(例如google的 8.8.8.8)</p>
<p>DNS的恶意操作：</p>
<ul>
<li>域名屏蔽：对域名直接不解析，返回错误，让你无法拿到IP地址，也就无法访问该网站</li>
<li>域名劫持(域名污染)：你要访问A网站，但DNS给了你B网站</li>
</ul>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>最开始两端都为<strong>CLOSED</strong>状态。在通信前双方都会建立TCB，服务器创建完TCB后便会进入<strong>LISTEN</strong>状态，就可以等待客户端发送数据了</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">浏览器</span>      <span class="hljs-comment">服务器</span><br> --<span class="hljs-literal">-</span><span class="hljs-comment">SYN报文</span>--<span class="hljs-literal">-</span>&gt;<br> &lt;--<span class="hljs-comment">SYN/ACK</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><br> --<span class="hljs-literal">-</span><span class="hljs-comment">ACK报文</span>--<span class="hljs-literal">-</span>&gt;<br></code></pre></td></tr></table></figure>
<ul>
<li>第一次握手<ul>
<li>客户端向服务器发送连接请求报文段(SYN)。这个报文段中是包含自身的数据通讯初始序号。 发送请求后，客户端变进入了SYN-SENT状态</li>
</ul>
</li>
<li>第二次握手<ul>
<li>服务端收到连接请求报文段后，如果是同意连接，则会发送一个应答(ACK + SYN)报文段。这个应答中也会包含自身的数据通讯初始序号，发送完数据后，服务端就进入SYN-RECEIVED状态</li>
</ul>
</li>
<li>第三次握手<ul>
<li>当客户端收到服务端发送的同意应答后，向服务端发送一个确认报文(ACK)。客户端发完这个报文段后就进入ESTABLISHED状态，此时建立成功了</li>
</ul>
</li>
</ul>
<p>SYN报文：连接请求报文   SYN = 1 / ACK = 0; 表示这是一个连接请求报文<br>ACK报文：同意连接报文</p>
<p>序号：seq  (浏览器初始化x   服务器初始化y)<br>确认号：ack (ack = x + 1, ack = y + 1) 即在对方发送的序号基础上+1</p>
<p>为什么要三次握手呢？<br>这三次握手恰好就能让双方都能确认当前对方的网络状态如何，防止失效的连接请求报文段被服务端接受，造成错误<br>关键字：TCP的超时重传机制   服务端一直等待，造成资源浪费</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><figure class="highlight brainfuck"><table><tr><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">浏览器</span>      <span class="hljs-comment">服务器</span><br>  --<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">FIN</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span>&gt;<br>  &lt;--<span class="hljs-literal">-</span><span class="hljs-comment">ACK</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><br>  &lt;--<span class="hljs-literal">-</span><span class="hljs-comment">FIN</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span>  <span class="hljs-comment">//</span> <span class="hljs-comment">前两次挥手都只是对分手这件事做确认，但不会立即执行。第三次，当服务器把自己想传的东西传完后，就通知浏览器进行真正的分开</span><br>  --<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">ACK</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span>&gt;<br></code></pre></td></tr></table></figure>
<p>FIN报文， FIN = 1表示此报文段的发生发请求释放运输连接<br>ACK报文， ACK = 1表示确认要求</p>
<ul>
<li>第一次握手<ul>
<li>客户端如果认为数据发送完成，则它就需要向服务端发送连接释放请求(发送FIN报文段)</li>
</ul>
</li>
<li>第二次握手<ul>
<li>服务器 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，表示 客户端 到 服务端 的连接已经释放，不接收 客户端 发的数据了。但是因为 TCP 连接时双向的，所以 服务端 仍旧可以发送数据给 客户端</li>
</ul>
</li>
<li>第三次握手<ul>
<li>服务端把还没有发完的数据发送给客户端，完成后会向客户端发送请求连接释放请求，然后服务端便会进入LAST-ACK状态</li>
</ul>
</li>
<li>第四次握手<ul>
<li>客户端收到释放请求后，向服务器发送应答确认，此时A进入TIME-WAIT状态，这状态会持续2MSL(最大段生存期，指报文段在网络中生存的时间，超时则会被抛弃)，若该时间段内没有服务端的重发请求就进入CLOSED状态，B收到应答确认后就会进入CLOSED 状态</li>
<li>(因为发送报文和半关闭状态是不冲突的)</li>
</ul>
</li>
</ul>
<p>为什么需要经过时间等待计时器设置的时间 2MSL（一个报文的来回时间） 后才会进入 CLOSED 状态？<br>（这样做的目的是确保服务端收到自己的 ACK 报文。如果服务端在规定时间内没有收到客户端发来的 ACK 报文的话，服务端会重新发送 FIN 报文给客户端，客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文给服务端）</p>
<p>为什么要四次握手呢？<br>两次握手就可以释放一端到另一端的TCP连接，但是完全释放连接需要四次握手</p>
<h4 id="可靠传输的基本原理"><a href="#可靠传输的基本原理" class="headerlink" title="可靠传输的基本原理"></a>可靠传输的基本原理</h4><ul>
<li>停止等待协议<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-01-25-%E4%B8%8B%E5%8D%887.c4i97oxtzg0.webp" alt="停止等待协议"><br>发送方发送消息后，需要等待接收方有反馈之后，才会继续发送新的消息：即停止-等待-停止-等待<br>但上述是理想情况</li>
</ul>
<p>下面如果有差错的情况：<br>超时重传：发送方发送消息后，迟迟没有等待到接收方的确认消息。发送方等待一段时间后会重新发送消息。</p>
<ul>
<li><p>发送的消息在路上丢失了</p>
</li>
<li><p>确认的消息在路上丢失了</p>
</li>
<li><p>确认的消息很久才到<br>(停止等待协议通过超时重传保证可靠传输)<br>超时定时器：每发送一个消息，都需要设置一个定时器<br>注意：停止等待协议对信道的利用效率不高</p>
</li>
<li><p>连续ARQ协议(在停止等待协议的基础上进行改造的)</p>
</li>
<li><p>ARQ(自动重传请求)  —&gt;  单个发送和确认效率低，则进行批量发送和确认<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-01-25-%E4%B8%8B%E5%8D%887.57tfvduels40.webp" alt="连续ARQ协议&amp;滑动窗口"></p>
</li>
</ul>
<p>累计确认：只要收到某个消息的确认消息，则表示这一个消息之前的消息我都已经收到了(减少收到确认消息报文的数量，以此提升网络效率)</p>
<h4 id="TCP-协议是如何保证可靠传输的-有序且完整的传递数据"><a href="#TCP-协议是如何保证可靠传输的-有序且完整的传递数据" class="headerlink" title="TCP 协议是如何保证可靠传输的(有序且完整的传递数据)"></a>TCP 协议是如何保证可靠传输的(有序且完整的传递数据)</h4><p>TCP的可靠传输是基于连续ARQ协议的(滑动窗口、累计确认)<br>TCP的滑动窗口以字节为单位<br>窗口左边是已经确认的字节序号，窗口右边是不允许发送的字节序号</p>
<p>假设有一段字节流需要传输：<br>假设滑动窗口的大小为7<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-01-25-%E4%B8%8B%E5%8D%887.3tv3e85chj00.webp" alt="滑动窗口"><br>这里的确认号要注意一下</p>
<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-01-25-%E4%B8%8B%E5%8D%887.43yfcq4muhk0.webp" alt="滑动窗口往前推动"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-01-25-%E4%B8%8B%E5%8D%888.7l9gfglshs80.webp" alt="数据未收到，重传"><br>选择重传：避免传送重复已有的字节</p>
<h4 id="TCP的超时重传"><a href="#TCP的超时重传" class="headerlink" title="TCP的超时重传"></a>TCP的超时重传</h4><p>TCP 具有超时重传机制，即间隔一段时间没有等到数据包的回复时，重传这个数据包</p>
<h4 id="TCP的流量控制-TCP特有的功能，UDP这些协议是没有这个的"><a href="#TCP的流量控制-TCP特有的功能，UDP这些协议是没有这个的" class="headerlink" title="TCP的流量控制(TCP特有的功能，UDP这些协议是没有这个的)"></a>TCP的流量控制(TCP特有的功能，UDP这些协议是没有这个的)</h4><p>所谓的流量控制就是发送方传数据传得太快而接收方还来不及接受这么多的数据。利用<strong>滑动窗口机制</strong>可以很方便的在TCP连接上实现对发送方的流量控制。<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-01-25-%E4%B8%8B%E5%8D%889.6q1e34lxeio0.webp" alt="TCP协议的流量控制"></p>
<h4 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h4><p>网络数据报文过多的时候，造成拥塞的发生(就像公路拥挤)<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-01-25-%E4%B8%8B%E5%8D%889.5z9195qtiqo0.webp" alt="TCP协议的拥塞控制"></p>
<p><strong>流量控制</strong> vs <strong>TCP拥塞控制</strong></p>
<ul>
<li>流量控制考虑点对点的通信量的控制</li>
<li>拥塞控制考虑整个网络，是全局性的考虑</li>
</ul>
<p>通过报文超时则认为是拥塞</p>
<h5 id="慢启动算法"><a href="#慢启动算法" class="headerlink" title="慢启动算法"></a>慢启动算法</h5><ul>
<li>由小到大逐渐增加发送数据量</li>
<li>每收到一个报文确认就 +1<br>1  2  4  8  16…   指数增长<br>慢启动阈值(ssthresh)  到达这个阈值之后就不会再增长了</li>
</ul>
<p>每一次发送的数据报文的数量<br>发送的轮次</p>
<h5 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h5><ul>
<li>维护一个拥塞窗口的变量</li>
<li>只要网络不拥塞，就试探着拥塞窗口调大<br>17 18 19 … 试探性的增长</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-01-25-%E4%B8%8B%E5%8D%889.6p4wc1jdpck0.webp" alt="拥塞控制"></p>
<h3 id="UDP-和-TCP-的区别-优劣点"><a href="#UDP-和-TCP-的区别-优劣点" class="headerlink" title="UDP 和 TCP 的区别(优劣点)"></a>UDP 和 TCP 的区别(优劣点)</h3><p>UDP: </p>
<ul>
<li>连接不可靠，不能传送大文件</li>
<li>速度比TCP更快</li>
<li>头部开销小:UDP头部8个字节，TCP头部20个字节</li>
<li>UDP不止支持一对一传输，还可以支持一对多、多对多、多对一的方式</li>
</ul>
<p>TCP:</p>
<ul>
<li>面向连接的(三次握手、四次挥手)、可靠的、基于字节流(UDP是基于数据报，而TCP是基于字节流)的传输层协议</li>
</ul>
<h4 id="HTTP-特点"><a href="#HTTP-特点" class="headerlink" title="HTTP 特点"></a>HTTP 特点</h4><h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><p>只有同时具备 机密性、完整性、身份认证、不可否认 这四个特性，通信双方的利益才能保障</p>
<h6 id="HTTPS-1"><a href="#HTTPS-1" class="headerlink" title="HTTPS"></a>HTTPS</h6><p><a href="https://zhuanlan.zhihu.com/p/43789231">比较好的一篇文章</a><br>HTTP是明文传输。如果在浏览器和服务器之间传输数据的时候，有中间人来 窃取/伪造/篡改 数据，就会出现问题。比如我们常见的WiFi钓鱼路由器。这是缺乏安全性的。</p>
<p>HTTPS 本身并没有什么惊世骇俗的本事，全是靠着后面的 SSL/TLS 撑腰(TLS/SSL 是在TCP和HTTP之间插入的安全层，即先要通过SSL才能到达TCP协议)</p>
<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-02-06-%E4%B8%8A%E5%8D%8811.1hx4vp18w4ww.webp" alt="HTTPS VS HTTP"><br><strong>HTTPS协议提供了三个关键的指标</strong></p>
<ul>
<li>加密：数据不会被窃取 –&gt; 混合加密</li>
<li>数据一致性：数据不会被篡改 –&gt; 摘要算法</li>
<li>身份认证：知道发送方的真实身份 –&gt; 签名算法(认证)</li>
</ul>
<p><strong>HTTPS的握手过程</strong></p>
<h4 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h4><p>HTTPS最重要的组成部分就是TLS协议了，因为是这个协议保证了安全性<br>TLS是SSL的后续版本，是一种在两台设备之间用户身份验证和加密的一种协议<br>TLS(SSL)是一个独立的协议，不只有HTTP可以使用，其他应用层协议也可以使用，如SMTP(电子邮件协议)、Telnet(远程登录协议)等都可以使用</p>
<p>结合了密钥交换算法、签名算法、对称加密算法、摘要算法等组成的一个密码串</p>
<h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><p>加密和解密都使用的是相同的钥匙。<br>如果单单使用对称加密，这个密码在传输过程中是明文的中间人仍然可以获取到密码</p>
<h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><p>这个涉及公钥 私钥<br>非对称加密算法的设计要比对称算法难得多</p>
<h5 id="公钥和私钥"><a href="#公钥和私钥" class="headerlink" title="公钥和私钥"></a>公钥和私钥</h5><p>公钥和私钥是多对一的关系<br>注意：公钥加密过的信息，只有私钥能解开；私钥加密过的信息，所有和它有关系的公钥都能解开<br>证书能够确认 这个公钥是谁发的(避免中间人乱给公钥)</p>
<p>你还是以明文的方式传递公钥，就算被中间人得到也没关系，因为解密公钥只能用私钥。而服务器里藏有私钥，其他人都无法知道</p>
<p>存在的问题：</p>
<ul>
<li>非对称加密的效率比较低：解密的速度慢，影响用户打开页面的速度</li>
<li>仍然不够安全：中间人可以用公钥加密数据发送给服务器，服务器能够用私钥解开</li>
</ul>
<h4 id="混合加密：非对称加密-结合-对称加密"><a href="#混合加密：非对称加密-结合-对称加密" class="headerlink" title="混合加密：非对称加密 结合 对称加密"></a>混合加密：非对称加密 结合 对称加密</h4><p>TSL使用的是混合加密(因为非对称加密的运算速度很慢，对称加密速度快)<br>具体流程如下：<br>发送方使用公钥加密 <strong>对称的密钥</strong>，接收方收到后，利用私钥解密从而获取 <strong>对称的密钥</strong></p>
<p><strong>加密过程</strong><br>首先浏览器会给服务器发送一个<code>client_random</code>和一个加密的方法列表</p>
<p>服务器接受后给浏览器返回另一个随机数<code>server_random</code>和加密方法</p>
<p>现在两者拥有三种相同的凭证: <code>client_random</code>, <code>server_random</code>和<code>加密方法</code></p>
<p>接着用这个加密方法将两个随机数混合起来生成密钥，这个密钥就是浏览器和服务器通信的<code>暗号</code>了</p>
<p><img src="https://segmentfault.com/img/bVbCCMD" alt="SSL : TLS 握手过程"></p>
<h4 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h4><p>MD5 最常用于验证文件的完整性<br>你可以把摘要算法理解成一种特殊的压缩算法，它能够把任意长度的数据压缩成一种固定长度的字符串，这就好像是给数据加了一把锁<br>就能够实现数据的完整性，哪怕你在文件中改变一个标点符号，增加一个空格，生成的文件摘要也会完全不同</p>
<h4 id="添加数字证书"><a href="#添加数字证书" class="headerlink" title="添加数字证书"></a>添加数字证书</h4><p>为了解决非对称加密中公匙来源的不安全性。我们可以使用数字证书和数字签名来解决。<br>需要服务器向浏览器证明“我就是我”<br>让权威机构颁发证书<br>服务器不是将公钥给浏览器，而是给的数字证书，而公钥就放在数字证书里面<br>浏览器会对证书进行验证</p>
<p>“数字签名”用于防止数字证书被篡改</p>
<p><strong>CA</strong><br>CA的全称(Certificate Authority)，证书认证机构，你必须让CA颁布具有认证过的公钥，才能解决公钥的信任问题<br>全世界具有认证的 CA 就几家</p>
<h5 id="数字证书的申请和验证"><a href="#数字证书的申请和验证" class="headerlink" title="数字证书的申请和验证"></a>数字证书的申请和验证</h5><p>服务器 向CA申请证书，在其过程需要提供公钥(私钥自己留着)，所在公司，站点等信息，CA会去审核你的信息是否合法等操作，如果审核通过，就会向极客时间签发认证的数字证书，包含了原本的公钥、序号以及CA生成的签名等内容</p>
<p>浏览器会读取证书内容验证证书的合法性。</p>
<h5 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h5><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>websocket 是基于TCP上全双工通信的协议 也就是一个持久化的网络通信协议(服务器也可以主动推送信息给客户端，进行双向的数据传输，所以只需一次握手就可以进行通信了，http是要三次握手才行)<br>http 是一个半双工的协议(同一时刻，只能单向传输数据)</p>
<p>HTTP/1.1是当前网站主流的协议。HTTP协议是无状态的，所以每一次的请求都是被当成独立的，唯一的。有时候，这样重复的发送请求就会造成冗余的数据传输(例如重复的cookie、session id)。<br>对于频繁的数据交互来说，你使用HTTP协议效率低下且会有很多冗余的数据进行发送传输，并且你还只能从客户端向服务器主动发送数据，而服务器不能(没有权限)主动向客户端发送数据，只有客户端主动去找服务器，这样即使服务器的数据发生了更改，也无法及时的告诉客户端发生了什么变化</p>
<p>当然有http轮询请求(隔一段时间发送一次请求)来克服上述问题，但始终效果不太好，非常占用服务器资源</p>
<p>WebSocket 解决了 HTTP 不适用于实时通信的这个问题<br>只要客户端和服务器建立起了连接，就能够实时的进行双向数据通信</p>
<p><strong>WebSocket特点</strong></p>
<ul>
<li>建立在TCP协议之上，服务端要想实现这个websocket也非常容易</li>
<li>与HTTP协议有良好的兼容性，默认端口也是80和443，并且握手阶段采用HTTP协议</li>
<li>数据格式(二进制、文本)比较轻量，性能开销小，通讯高效</li>
<li>可以发送文本，也可以发送二进制</li>
<li>没有同源限制，客户端可以与任意服务器进行通信</li>
</ul>
<p>类似的技术：WebRTC(直播就是用的这个技术)</p>
<h4 id="WebSocket通信原理"><a href="#WebSocket通信原理" class="headerlink" title="WebSocket通信原理"></a>WebSocket通信原理</h4><p>握手阶段采用的是HTTP协议<br>发送的请求依然是HTTP请求</p>
<p>Connection: keep-alive, Upgrade  –&gt;  告诉服务器要建立升级的协议<br>Upgrade: websocket  –&gt;  升级为websocket<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-02-07-%E4%B8%8B%E5%8D%888.14kttagac9k0.webp" alt="websocket"><br>一次HTTP请求后，只要响应头回到浏览器就已经建立好连接了(已经升级为WebSocket协议了)<br>注意Sec-WebSocket-Key 和 Sec-WebSocket-Accept<br>Sec-WebSocket-Key的哈希值用来表示这是哪一个客户端(未来的客户端可能会很多)<br>Sec-WebSocket-Accept的哈希值用来表示这是哪一个服务端</p>
<h4 id="WebSocket-服务端与客户端实现"><a href="#WebSocket-服务端与客户端实现" class="headerlink" title="WebSocket 服务端与客户端实现"></a>WebSocket 服务端与客户端实现</h4><p>先要使用http，然后升级http为websocket</p>
<h5 id="SocketNode"><a href="#SocketNode" class="headerlink" title="SocketNode"></a>SocketNode</h5><p>这里其实就用到了发布订阅模式(服务器给所有客户端进行推送，最笨的方法，服务端里用数组来存储要连接的客户端，然后后面服务器推送数据给每个已存储的客户端)</p>
<h5 id="Socket-io-更高级的SocketNode，简直可以无脑操作聊天室而不用知道websocket"><a href="#Socket-io-更高级的SocketNode，简直可以无脑操作聊天室而不用知道websocket" class="headerlink" title="Socket.io (更高级的SocketNode，简直可以无脑操作聊天室而不用知道websocket)"></a>Socket.io (更高级的SocketNode，简直可以无脑操作聊天室而不用知道websocket)</h5><p>自定义事件 .emit(‘custom-event’, callback)  .on(‘custom-event’, callback)   io.xx 是广播的方式进行发送信息<br>Socket.io 需要进行跨域处理(Socket.io 是在尽可能的让用户忽略websocket的内容,直接使用http来做…，实际上websocket是没有跨域的…)，官网有给方法如何处理</p>
<p>Socket.io 背后就是使用了发布订阅模式</p>
<h3 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h3><p><strong>2xx 成功</strong></p>
<ul>
<li>200 OK， 表示从客户端发来的请求在服务器端被正确处理</li>
<li>204 No Content, 表示后端处理成功，但是并不需要什么实体数据</li>
<li>206 进行范围请求，只会获取一部分的资源</li>
</ul>
<p><strong>3xx 重定向</strong></p>
<ul>
<li>301 永久重定向(配合location，浏览器自动处理)</li>
<li>302 临时重定向(配合location，浏览器自动处理)</li>
<li>304 跟协商缓存相关，表示服务端资源未过期</li>
</ul>
<p><strong>4xx 客户端错误</strong></p>
<ul>
<li>400 前端发送了一个不合法的json文件，后端无法解析</li>
<li>401 表示未授权，需要发送HTTP请求并带有认证信息 (token失效的时候就会显示)</li>
<li>403 服务器拒绝该请求的访问</li>
<li>404 在服务器中没有找到该请求的资源</li>
<li>405 表示请求的方式不对</li>
</ul>
<p><strong>5xx 服务端错误</strong></p>
<ul>
<li>500 表示服务器端在执行请求时发生了错误</li>
<li>501 表示服务器不支持当前请求所需要的某个功能</li>
<li>503 表明服务器暂时处于繁忙/维护状态</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>前端面试之道 JS</title>
    <url>/2021/12/08/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93-JS/</url>
    <content><![CDATA[<h2 id="JS-的执行机制"><a href="#JS-的执行机制" class="headerlink" title="JS 的执行机制"></a>JS 的执行机制</h2><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><blockquote>
<p>只有理解了 JS 的执行上下文，才能更好地理解 JS 语言本身(包括变量提升、作用域、闭包等)</p>
</blockquote>
<h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><p>在写 JS 代码的时候，会发现一个<strong>特性</strong>，即：在第一个变量定义之前使用它，不会报错(没定义就使用则会报错)，但是该变量的值会为<code>undefined</code>，而不是定义时的值。在一个函数定义之前使用它，不会出错，且函数能正确执行</p>
<p>出现该特性的原因就是 <strong>变量提升</strong></p>
<h5 id="JS-中的声明和赋值"><a href="#JS-中的声明和赋值" class="headerlink" title="JS 中的声明和赋值"></a>JS 中的声明和赋值</h5><p>先看看 JS 中变量的声明和赋值：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">// 一行普通的代码： var <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;帅得乱七八糟&#x27;</span>;<br>// 上述代码可以看成下面两行代码组成：<br>var <span class="hljs-type">name</span> = undefined;      <span class="hljs-comment">---&gt;  此为声明</span><br><span class="hljs-type">name</span> = <span class="hljs-string">&#x27;帅得乱七八糟&#x27;</span>;       <span class="hljs-comment">---&gt;  此为赋值</span><br></code></pre></td></tr></table></figure>

<p>再来看看 JS 中函数的声明和赋值：</p>
<figure class="highlight nim"><table><tr><td class="code"><pre><code class="hljs nim">// 此为一个普通的函数声明<br>function foo() &#123;<br>  console.log(&#x27;foo&#x27;)<br>&#125;<br>// 可以转化为下面的代码<br>function foo = () =&gt; &#123;<br>  console.log(&#x27;foo&#x27;)<br>&#125;<br><br>// 此函数：先声明变量bar，再把函数赋值给bar<br><span class="hljs-keyword">var</span> bar = function() <span class="hljs-meta">&#123;...&#125;</span><br>// 可以拆分为声明和赋值：<br><span class="hljs-keyword">var</span> bar = undefined;    ---&gt;  此为声明<br>bar = function() <span class="hljs-meta">&#123;...&#125;</span>; ---&gt;  此为赋值<br></code></pre></td></tr></table></figure>

<h5 id="变量提升-1"><a href="#变量提升-1" class="headerlink" title="变量提升"></a>变量提升</h5><blockquote>
<p>所谓变量提升，即在 JS 代码<strong>执行之前</strong>中，<strong>JS 引擎</strong>会把<strong>变量的声明部分</strong>和<strong>函数的声明部分</strong>提升到代码开头的“行为” (注意，JS 引擎对非声明操作，不做任何处理)。变量被提升后，会给变量设置默认值，这个默认是即<code>undefined</code></p>
</blockquote>
<h5 id="编译和执行"><a href="#编译和执行" class="headerlink" title="编译和执行"></a>编译和执行</h5><blockquote>
<p>注意：实际上变量和函数声明在代码里的位置是不会改变的，而且是在<strong>编译阶段</strong>被 JavaScript 引擎放入内存中。一段<code>JavaScript</code>代码在执行之前需要被<code>JavaScript</code>引擎编译，编译完成之后，才会进入执行阶段。</p>
</blockquote>
<p>一段 js 代码 -&gt; 先编译 -&gt; 后执行<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-01-10-%E4%B8%8B%E5%8D%885.3dhl918syno0.webp" alt="JS代码编译和执行"></p>
<p>上图可见：输入一段代码，经过编译后，会生成两部分内容：执行上下文和可执行代码。并且在执行上下文中存在一个<strong>变量环境对象</strong>，这个对象保存了变量提升的内容</p>
<p>执行阶段：<br>JS 引擎 按照顺序一行一行的执行… 遇见函数执行或者赋值操作，先在环境变量中进行对应查找，找到后进行函数执行或者变量赋值操作</p>
<p><strong>一段代码中出现了相同的变量或者函数该怎么办？</strong><br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-01-10-%E4%B8%8B%E5%8D%885.20j6laeeh90g.webp" alt="出现相同的变量或者函数该怎么办"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">例如：<br>showName()<br><span class="hljs-keyword">var</span> showName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showName</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-comment">// 输出1</span><br></code></pre></td></tr></table></figure>

<h4 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h4><p>三种类型：</p>
<ul>
<li>当 JS 在执行全局代码之前，会编译全局代码并创建全局上下文，而且在整个页面的生命周期内，全局执行上下文只有一份。</li>
<li>当调用一个函数的时候(正在执行这个函数)，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁</li>
<li>当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文</li>
</ul>
<p>–&gt; 执行上下文是在代码编译的时候才产生的</p>
<h3 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h3><blockquote>
<p>调用栈是用来管理函数调用关系的一种数据结构</p>
</blockquote>
<h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><blockquote>
<p>所谓函数调用，其实就是运行一个函数，具体使用方式是使用函数名称跟着一对小括号</p>
</blockquote>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br>add();<br></code></pre></td></tr></table></figure>

<p>当刚执行到 add()之前时，全局执行上下文是这样的一个状态：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm">全局执行上下文：<br>  变量环境<br>  a = <span class="hljs-number">2</span><br>  <span class="hljs-keyword">add</span> = <span class="hljs-meta">function</span>() &#123;<span class="hljs-keyword">b</span> = <span class="hljs-number">10</span><span class="hljs-comment">; return a + b&#125;</span><br><br>  词法环境：<br>  ...<br></code></pre></td></tr></table></figure>

<p>当执行到 add 这儿时，JS 会判断这是一个函数调用，那么将执行以下操作：</p>
<ul>
<li>首先，从全局执行上下文中，取出 add 函数代码</li>
<li>其次，对 add 函数的这段代码进行编译，并创建该函数的执行上下文和可执行代码</li>
<li>最后，执行代码，输出结果</li>
</ul>
<p>完整流程如下：<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-01-10-%E4%B8%8B%E5%8D%8810.2k6udolwot40.webp" alt="函数执行上下文步骤"></p>
<p>由于 JS 本身就是面向函数式编程的，函数非常的多，且层次逻辑复杂多样，所以就可能存在多个执行上下文，JS 引擎是如何管理这些执行上下文的呢？<br>答案是：用栈来管理</p>
<h4 id="栈结构管理多个执行上下文-JS-调用栈"><a href="#栈结构管理多个执行上下文-JS-调用栈" class="headerlink" title="栈结构管理多个执行上下文(JS 调用栈)"></a>栈结构管理多个执行上下文(JS 调用栈)</h4><p>JavaScript 引擎正是利用栈的这种结构来管理执行上下文的。通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈。<br>同时调用栈是 JS 引擎追踪函数执行的一个机制(这个机制能很好的找到各个函数之间的调用关系)</p>
<p>在分析复杂结构代码，或者检查 Bug 时，调用栈都是非常有用的(chrome 控制台打断点后，可以看见调用栈)</p>
<h4 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h4><blockquote>
<p>注意：调用栈也是有大小的，当入栈的执行上下文超过一定数目后，JS 引擎就会报错，我们把这种错误叫做<strong>栈溢出</strong></p>
</blockquote>
<p>特别是在写递归代码的时候，很容易出现栈溢出的情况</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">division</span>(a,b)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">division(a,b)</span><br>&#125;<br>console.log(division(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure>

<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>事实上，JS 存在变量提升这种特性，从而导致了很多与直接不符的代码，这也是 JS 的一个重要设计缺陷</p>
<p>思考一个问题，为什么 JS 会存在变量提升呢？ 这需要从作用域讲起…</p>
<p><strong>作用域</strong>是指在程序中定义变量的区域，<strong>该位置决定了变量的生命周期</strong>。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期</p>
<p>所谓的块级作用域：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> <span class="hljs-keyword">if</span> 块<br><span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) &#123;&#125;<br><br><span class="hljs-regexp">//</span> <span class="hljs-keyword">while</span> 块<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;&#125;<br><br><span class="hljs-regexp">//</span> 函数块<br><span class="hljs-keyword">function</span> foo() &#123;&#125;<br><br><span class="hljs-regexp">//</span> <span class="hljs-keyword">for</span> 循环块<br><span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;&#125;<br><br><span class="hljs-regexp">//</span> 单独一个块<br></code></pre></td></tr></table></figure>

<blockquote>
<p>和 Java、C/C++不同，ES6 之前是不支持块级作用域的，因为当初设计这门语言的时候，并没有想到 JavaScript 会火起来，所以只是按照最简单的方式来设计。没有了块级作用域，再把作用域内部的变量统一提升无疑是最快速、最简单的设计，不过这也直接导致了函数中的变量无论是在哪里声明的，在编译阶段都会被提取到执行上下文的变量环境中，所以这些变量在整个函数体内部的任何地方都是能被访问的，这也就是 JavaScript 中的变量提升。 (当时创建 js 的时候，也只是为了图个方便…)</p>
</blockquote>
<h4 id="变量提升所带来的问题"><a href="#变量提升所带来的问题" class="headerlink" title="变量提升所带来的问题"></a>变量提升所带来的问题</h4><ol>
<li>变量容易在不被察觉的情况下被覆盖掉<br>在函数执行过程中，JS 会优先从当前的执行上下文中查找变量</li>
<li>本应该被销毁的变量没有被销毁</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;<br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(i);   <span class="hljs-comment">// 7</span><br>&#125;<br>foo()<br></code></pre></td></tr></table></figure>

<h4 id="ES6-带来的解决变量提升的方法"><a href="#ES6-带来的解决变量提升的方法" class="headerlink" title="ES6 带来的解决变量提升的方法"></a>ES6 带来的解决变量提升的方法</h4><p>ES6 引入了 let 和 const 关键字，从而使 JavaScript 也能像其他语言一样拥有了块级作用域。这解决了变量提升带来的困扰</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">varTest</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">var</span> x = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 同样的变量!</span><br>    <span class="hljs-built_in">console</span>.log(x);  <span class="hljs-comment">// 2</span><br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(x);  <span class="hljs-comment">// 2</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>进行改造</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">letTest</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">let</span> x = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 不同的变量</span><br>    <span class="hljs-built_in">console</span>.log(x);  <span class="hljs-comment">// 2</span><br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(x);  <span class="hljs-comment">// 1</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意：因为 let 关键字(const 同理)是支持块级作用域的，所以在编译阶段，JavaScript 引擎并不会把 if 块中通过 let 声明的变量存放到变量环境中，这也就意味着在 if 块通过 let 声明的关键字，并不会提升到全函数可见。所以在 if 块之内打印出来的值是 2，跳出语块之后，打印出来的值就是 1 了。这种就非常符合我们的编程习惯了：作用块内声明的变量不影响块外面的变量。</p>
<h4 id="JS-是如何支持块级作用域的"><a href="#JS-是如何支持块级作用域的" class="headerlink" title="JS 是如何支持块级作用域的"></a>JS 是如何支持块级作用域的</h4><p>块级变量是在执行上下文中的词法环境存放的(也是一个栈结构)</p>
<p>JS 引擎执行代码的时候，也是先在执行上下文中的词法环境中 从栈顶向下查找， 如果没找到继续在变量环境中查找</p>
<blockquote>
<p>块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript 引擎也就同时支持了变量提升和块级作用域了</p>
</blockquote>
<h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><p>先记住一句话： 变量是通过作用域链来查找的</p>
<p>其实在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为<code>outer</code><br>当一段代码使用了一个变量时，<strong>JavaScript 引擎</strong>首先会在“当前的执行上下文”中查找该变量， 比如一段代码在查找 <code>myName</code> 变量时，如果在当前的变量环境中没有查找到，那么 <strong>JavaScript 引擎</strong>会继续在 outer 所指向的执行上下文中查找。为了直观理解，你可以看下面这张图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-01-11-%E4%B8%8A%E5%8D%887.660frge57dc0.webp" alt="外部引用"></p>
<p>我们把这个查找的链条就称为作用域链</p>
<h4 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h4><p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-01-11-%E4%B8%8A%E5%8D%888.6ssjlq61e2g0.webp" alt="作用域的层次结构"></p>
<p>词法作用域就是根据代码的位置(代码结构)来决定的，而 JS 作用域链是由词法作用域来决定的，所以词法作用域链的顺序是：foo 函数作用域 –&gt; bar 函数作用域 –&gt; main 函数作用域 –&gt; 全局作用域</p>
<p>词法作用域和执行上下文关系是怎么的呢？</p>
<h4 id="闭包-scope"><a href="#闭包-scope" class="headerlink" title="闭包(scope)"></a>闭包(scope)</h4><blockquote>
<p>在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包</p>
</blockquote>
<h5 id="闭包的回收机制"><a href="#闭包的回收机制" class="headerlink" title="闭包的回收机制"></a>闭包的回收机制</h5><p>通常，如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。</p>
<p>如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。</p>
<p>所以在使用闭包的时候，你要尽量注意一个原则：如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 做一道题：</span><br><span class="hljs-keyword">var</span> bar = &#123;<br>    <span class="hljs-attr">myName</span>:<span class="hljs-string">&quot;time.geekbang.com&quot;</span>, <span class="hljs-comment">// 1</span><br>    <span class="hljs-attr">printName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(myName)     <span class="hljs-comment">// 注意：这里的myName是无法使用1号的myName的，他们两个是平行关系。而词法作用域讲究的是包含关系，所以这里的myName 只能使用 外层函数的myName，即 3 号</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> myName = <span class="hljs-string">&quot; 极客时间 &quot;</span><br>    <span class="hljs-keyword">return</span> bar.printName<br>&#125;<br><span class="hljs-keyword">let</span> myName = <span class="hljs-string">&quot; 极客邦 &quot;</span>        <span class="hljs-comment">// 3</span><br><span class="hljs-keyword">let</span> _printName = foo()<br>_printName()<br>bar.printName()<br><br></code></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">var obj = &#123;<br>  name: <span class="hljs-string">&#x27;jack&#x27;</span>,   <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br>  <span class="hljs-keyword">func</span>: <span class="hljs-keyword">function</span>() &#123;console.log(name)&#125;   <span class="hljs-regexp">//</span> 和<span class="hljs-number">1</span>号是平行关系<br>&#125;<br><br>obj.<span class="hljs-keyword">func</span>();    <span class="hljs-regexp">//</span> undefined  这里是不能使用<span class="hljs-number">1</span>号的<br></code></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">let obj = &#123;<br>  name: <span class="hljs-string">&#x27;jack&#x27;</span>,   <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br>  <span class="hljs-keyword">func</span>: <span class="hljs-keyword">function</span>() &#123;console.log(name)&#125;   <span class="hljs-regexp">//</span> 和<span class="hljs-number">1</span>号还是平行关系<br>&#125;<br><br>obj.<span class="hljs-keyword">func</span>();    <span class="hljs-regexp">//</span> undefined  这里是不能使用<span class="hljs-number">1</span>号的<br></code></pre></td></tr></table></figure>

<h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>上述的代码，我讲了对象内部函数(也是属性)和内部属性是平行关系，无法进行调用，因此 JS 搞出了 this 机制来解决这个问题！！(终于知道了很多来龙去脉)<br>还是用上面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;jack&#x27;</span>,<br>  <span class="hljs-attr">func</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)&#125;<br>&#125;<br>obj.func();<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意：作用域链和 this 是两套不同的系统，二者之间基本没有太多的联系</p>
</blockquote>
<p>完整的执行上下文内容如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-01-11-%E4%B8%8A%E5%8D%889.4wchdr98vj40.webp" alt="执行上下文"></p>
<p>执行上下文主要分为三种：全局执行上下文、函数执行上下文、eval 执行上下文 故 this 也对应有三种：全局执行上下文的 this、函数中的 this 和 eval 中的 this</p>
<p>注意：使用对象来调用其内部的一个方法，该方法的 this 是指向对象本身的</p>
<p><a href="https://blog.poetries.top/browser-working-principle/guide/part2/lesson11.html#this-%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%BC%BA%E9%99%B7%E4%BB%A5%E5%8F%8A%E5%BA%94%E5%AF%B9%E6%96%B9%E6%A1%88">this 的设计缺陷以及应对方案</a></p>
<h2 id="作用域-1"><a href="#作用域-1" class="headerlink" title="作用域"></a>作用域</h2><blockquote>
<p>所谓<strong>作用域</strong>即提前约定好的一套存储变量、访问变量的规则,更多时候，我们提到作用域的时候，指的是这个规则约束下的一个变量、函数、标识符可以被访问的区域</p>
</blockquote>
<figure class="highlight delphi"><table><tr><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">var</span> <span class="hljs-keyword">name</span> = <span class="hljs-string">&#x27;HeYang&#x27;</span>;<br><br>上述代码在JS 引擎中是这样来理解的<br>* <span class="hljs-keyword">var</span> <span class="hljs-keyword">name</span> (编译时处理)<br>* <span class="hljs-keyword">name</span> = <span class="hljs-string">&#x27;HeYang&#x27;</span> (执行时处理)<br></code></pre></td></tr></table></figure>

<h3 id="JS-代码-lt-gt-编译与执行"><a href="#JS-代码-lt-gt-编译与执行" class="headerlink" title="JS 代码&lt;-&gt;编译与执行"></a>JS 代码&lt;-&gt;编译与执行</h3><p><strong>注意</strong>：JS 代码是一边编译一边执行(所有的 JS 代码片段在执行之前都会被编译，只是这个编译的过程非常短暂（可能就只有几微妙、或者更短的时间)</p>
<p><strong>编译阶段：</strong> <strong>编译器</strong>会找遍<strong>当前作用域</strong>看看是不是已经有一个叫 <code>name</code> 的变量(自由变量)了。如果有，那么就<strong>忽略</strong> <code>var name</code> 这个声明，继续编译下去；如果没有，则在当前作用域里新增一个 <code>name</code>。然后，编译器会为引擎生成运行时所需要的代码，程序就进入了执行阶段</p>
<p><strong>执行阶段：</strong> <strong>JS 引擎</strong>在执行代码的时候，仍然会找遍当前作用域，看看是不是有一个叫 name 的变量(这里说的是定义 name 变量的代码)。如果能找到，那么万事大吉，我来给你赋值。如果找不到，它也不会灰心，它会从当前作用域里 “探出头去”，看看 “外面” 有没有，或者 “外面的外面” 有没有(找定义变量 name 的代码)。如果最终仍然找不到 name 变量(定义变量 name 的代码)，引擎就会抛出一个异常。—&gt; JS 引擎向外找该变量(定义该变量的源头)的过程 其实展示的就是<strong>作用域链</strong></p>
<h3 id="作用域链-1"><a href="#作用域链-1" class="headerlink" title="作用域链"></a>作用域链</h3><p>在 JS 中，一共有三种作用域：</p>
<ul>
<li>全局作用域</li>
<li>函数作用域： 在函数内部定义的变量，拥有函数作用域(函数的参数也属于函数作用域里面的)</li>
<li>块级作用域： 针对的是由 <code>let</code> 和 <code>const</code> 这两个关键词定义的变量, 在一个{} 包裹住，这个{}就拥有块级作用域</li>
</ul>
<p>注意：var 是感受不到块级作用域的！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-keyword">var</span> me = <span class="hljs-string">&#x27;HeYang&#x27;</span>;<br>  <span class="hljs-built_in">console</span>.log(me);    <span class="hljs-comment">// HeYang</span><br>&#125;<br><span class="hljs-built_in">console</span>.log(me);    <span class="hljs-comment">// HeYang</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>自由变量</strong>：在函数中被使用，但它既不是函数参数、也不是函数的局部变量，而是一个不属于当前作用域的变量，此时它相对于当前作用域来说，就是一个自由变量</p>
</blockquote>
<p><strong>引用了自由变量的函数,就叫做<code>闭包</code></strong></p>
<h3 id="LHS、RHS"><a href="#LHS、RHS" class="headerlink" title="LHS、RHS"></a>LHS、RHS</h3><p><code>LHS</code>、<code>RHS</code>，是<strong>JS 引擎</strong>在<strong>执行代码</strong>的时候，查询变量的两种方式</p>
<blockquote>
<p>L、R 分别意味着 <code>Left</code>、<code>Right</code> 。<code>Left</code>、<code>Right</code>是相对于<strong>赋值操作</strong>来说的</p>
</blockquote>
<p>当变量出现在赋值操作的左侧时，执行的就是 LHS 操作，右侧则执行 RHS 操作</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">name</span> = <span class="hljs-string">&#x27;HeYang&#x27;</span><span class="hljs-comment">;    // 变量name出现在左侧。LHS 意味着 变量赋值或将数据写入内存，强调的是 写</span><br></code></pre></td></tr></table></figure>

<figure class="highlight delphi"><table><tr><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">var</span> myName = <span class="hljs-keyword">name</span>;  <span class="hljs-comment">// 变量name出现在右侧。RHS 意味着 变量查找或从内存中读取， 强调的是 读</span><br></code></pre></td></tr></table></figure>

<h3 id="词法作用域-1"><a href="#词法作用域-1" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>作用域： 词法作用域、动态作用域(冷门，不用了解)</p>
<p>JS 作用域使用的就是 词法作用域(静态作用域)</p>
<p><strong>静态作用域</strong> 是在你写代码的时候，作用域以及作用域之间的关系就已经定下来了(即当你在写代码的时候哪个作用域内定义了什么变量，或者是用的什么自由变量，变量与作用域之间的归属关系就已经被定下来了)</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">var <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;bruce&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-keyword">inner</span>() &#123;<br>  console.log(<span class="hljs-type">name</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-keyword">outer</span>() &#123;<br>  var <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;hy&#x27;</span>;<br>  <span class="hljs-keyword">inner</span>();<br>&#125;<br><br><span class="hljs-keyword">outer</span>();   // <span class="hljs-string">&#x27;bruce&#x27;</span><br></code></pre></td></tr></table></figure>

<p><strong>欺骗词法作用域的方式</strong>： eval 和 with (但是由于 eval 和 with 有强烈的副作用，所以不要使用) 会对作用域做一定的修改 –&gt; 但是不用了解为啥要修改…</p>
<h2 id="闭包真题"><a href="#闭包真题" class="headerlink" title="闭包真题"></a>闭包真题</h2><h3 id="真题一"><a href="#真题一" class="headerlink" title="真题一"></a>真题一</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(i);<br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(i);<br></code></pre></td></tr></table></figure>

<p>打印结果： 5、5、5、5、5 –&gt; 理由：循环了 5 次，则有 5 个同层的函数作用域(function(){console.log(i)})出现。而这 5 个函数作用域的 i 都是同一个自由变量。即父作用域的变量 i。 setTimeout 为异步代码，故隔了 1s 后，这些函数才执行，此时，自由变量 i 已经是 5 了</p>
<p><strong>升级</strong><br>现在我想让代码打印出 0 1 2 3 4</p>
<p><strong>方法一</strong><br>使用 let 让每次 for 循环都产生一个块级作用域</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(i);<br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>方法二</strong><br>使用 setTimeout 的第三个参数(setTimeout 从第三个入参位置开始往后，是可以传入无数个参数的。这些参数会作为回调函数的附加参数存在)<br>原理就是产生了函数作用域</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(j);<br>    &#125;, <span class="hljs-number">1000</span>, i);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>方法三</strong><br>在 setTimeout 外面再套一层立即执行函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>)</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(j);<br>    &#125;, <span class="hljs-number">1000</span>)<br>  &#125;)(i)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="真题二"><a href="#真题二" class="headerlink" title="真题二"></a>真题二</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span> (<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> num = []<br>  <span class="hljs-keyword">var</span> i<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    num[i] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(i)<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> num[<span class="hljs-number">9</span>]<br>&#125;<br><br>test()()   <span class="hljs-comment">// 执行结果为：10 --&gt; 闭包之道</span><br></code></pre></td></tr></table></figure>

<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> test = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> num = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> num++<br>  &#125;<br>&#125;())<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>  test()<br>&#125;<br>console.log(test())   <span class="hljs-comment">// 执行结果为：10 --&gt; 闭包之道</span><br></code></pre></td></tr></table></figure>

<h3 id="真题三"><a href="#真题三" class="headerlink" title="真题三"></a>真题三</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>)</span>&#123;<br>  a = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(a);<br>  &#125;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;<br>&#125;<br>test()();   <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure>

<h2 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h2><h3 id="模拟私有变量的实现"><a href="#模拟私有变量的实现" class="headerlink" title="模拟私有变量的实现"></a>模拟私有变量的实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 利用闭包生成 IIFE，返回 User 类</span><br><br><span class="hljs-keyword">const</span> User = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> _password;<br><br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">username, password</span>)</span> &#123;<br>      <span class="hljs-built_in">this</span>.username = username;<br>      _password = password;   <span class="hljs-comment">// 注意这里，在函数里使用自由变量(闭包大法)</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">login</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.username, _password)<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> User;<br>&#125;)()<br><br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&#x27;HeYang&#x27;</span>, <span class="hljs-string">&#x27;123456&#x27;</span>)<br><br><span class="hljs-built_in">console</span>.log(user.username)   <span class="hljs-comment">// HeYang</span><br><span class="hljs-built_in">console</span>.log(user.password)   <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">console</span>.log(user._password)  <span class="hljs-comment">// undefined</span><br>user.login() <span class="hljs-comment">// HeYang 123456</span><br></code></pre></td></tr></table></figure>

<h3 id="偏函数与柯里化"><a href="#偏函数与柯里化" class="headerlink" title="偏函数与柯里化"></a>偏函数与柯里化</h3><p>柯里化和偏函数并不复杂（只是名字有点拗口），它们都是可以帮我们把需要多个入参的函数，转化为需要更少入参的函数的方法。</p>
<h4 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h4><p>柯里化是把接受 n 个参数的 1 个函数改造为只接受 1 个参数的 n 个互相嵌套的函数的过程。也就是 fn (a, b, c)fn(a,b,c) 会变成 fn (a)(b)(c)fn(a)(b)(c)。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateName</span>(<span class="hljs-params">prefix</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-keyword">type</span></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">itemName</span>) </span>&#123;<br>            <span class="hljs-keyword">return</span> prefix + <span class="hljs-keyword">type</span> + itemName    <span class="hljs-comment">// 使用自由变量的函数 --&gt; 闭包</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 生成大卖网商品名专属函数</span><br><span class="hljs-keyword">var</span> salesName = generateName(<span class="hljs-string">&#x27;大卖网&#x27;</span>)<br><br><span class="hljs-comment">// “记住”prefix，生成大卖网母婴商品名专属函数</span><br><span class="hljs-keyword">var</span> salesBabyName = salesName(<span class="hljs-string">&#x27;母婴&#x27;</span>)<br><br><span class="hljs-comment">// &quot;记住“prefix和type，生成洗菜网生鲜商品名专属函数</span><br><span class="hljs-keyword">var</span> vegFreshName = generateName(<span class="hljs-string">&#x27;洗菜网&#x27;</span>)(<span class="hljs-string">&#x27;生鲜&#x27;</span>)<br><br><span class="hljs-comment">// 输出 &#x27;大卖网母婴奶瓶&#x27;</span><br>salesBabyName(<span class="hljs-string">&#x27;奶瓶&#x27;</span>)<br><span class="hljs-comment">// 输出 &#x27;洗菜网生鲜菠菜&#x27;</span><br>vegFreshName(<span class="hljs-string">&#x27;菠菜&#x27;</span>)<br><br><span class="hljs-comment">// 啥也不记，直接生成一个商品名</span><br><span class="hljs-keyword">var</span> itemFullName = generateName(<span class="hljs-string">&#x27;洗菜网&#x27;</span>)(<span class="hljs-string">&#x27;生鲜&#x27;</span>)(<span class="hljs-string">&#x27;菠菜&#x27;</span>)<br></code></pre></td></tr></table></figure>

<h4 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h4><p>偏函数应用是不强调 “单参数” 这个概念的。它的目标仅仅是把函数的入参拆解为两部分。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateName</span>(<span class="hljs-params">prefix</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>, itemName</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> prefix + <span class="hljs-keyword">type</span> + itemName<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 把3个参数分两部分传入</span><br><span class="hljs-keyword">var</span> itemFullName = generateName(<span class="hljs-string">&#x27;大卖网&#x27;</span>)(<span class="hljs-string">&#x27;母婴&#x27;</span>, <span class="hljs-string">&#x27;奶瓶&#x27;</span>)<br></code></pre></td></tr></table></figure>

<h2 id="JS-内存管理机制解析"><a href="#JS-内存管理机制解析" class="headerlink" title="JS 内存管理机制解析"></a>JS 内存管理机制解析</h2><h3 id="JS-内存生命周期"><a href="#JS-内存生命周期" class="headerlink" title="JS 内存生命周期"></a>JS 内存生命周期</h3><p>内存管理是每一种编程语言都会具备的一种基本能力<br>不过 JS 并没有暴露任何内存操作给开发者，而是自己默默地自动完成了所有的管理动作</p>
<p><strong>JS 的内存生命周期</strong><br>挖坑(分配内存) –&gt; 用坑(内存的读写操作) –&gt; 还坑(内存的释放)</p>
<h3 id="栈内存和堆内存"><a href="#栈内存和堆内存" class="headerlink" title="栈内存和堆内存"></a>栈内存和堆内存</h3><p>栈(线性表)<br>堆(树结构)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">  <span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> b = <span class="hljs-string">&quot;Hello World&quot;</span><br>  <span class="hljs-keyword">let</span> c = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">let</span> d = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;修言&#x27;</span> &#125;;<br>  <span class="hljs-keyword">let</span> e = [<span class="hljs-string">&#x27;修言&#x27;</span>, <span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-string">&#x27;bear&#x27;</span>];<br>&gt;----------------------------------&lt;<br>  a —— <span class="hljs-built_in">Number</span>类型 —— 基本类型 —— 栈内存<br>  b —— <span class="hljs-built_in">String</span>类型 —— 基本类型 —— 栈内存<br>  c —— <span class="hljs-literal">null</span> —— 基本类型 —— 栈内存<br>  d —— <span class="hljs-built_in">Object</span> —— 引用类型 —— 堆内存<br>  e —— <span class="hljs-built_in">Array</span> —— 引用类型 —— 堆内存<br></code></pre></td></tr></table></figure>

<h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>即内存的释放(还坑)<br><strong>每隔一段时间</strong>，JS 的<strong>垃圾收集器</strong>就会对变量做 “巡检”。当它判断一个变量不再被需要之后，它就会把这个变量所占用的内存空间给释放掉，这个过程叫做<strong>垃圾回收</strong></p>
<p>JS 是如何知道一个变量是否不被需要的呢？ 使用的就是垃圾回收算法！<br>在 JS 中，我们讨论的垃圾回收算法有两种 &lt;——&gt; 引用计数法和标记清除法</p>
<h4 id="引用计数法-过时，现代浏览器没有再使用这个的了"><a href="#引用计数法-过时，现代浏览器没有再使用这个的了" class="headerlink" title="引用计数法 (过时，现代浏览器没有再使用这个的了)"></a>引用计数法 (过时，现代浏览器没有再使用这个的了)</h4><p>这里的引用 指的是用一个变量指向了一个值，那么就创建了一个针对这个值的 “引用”：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">const <span class="hljs-keyword">user</span> <span class="hljs-title">= [name</span>: &#x27;帅得乱七八糟&#x27;, age: <span class="hljs-number">21</span>]<br></code></pre></td></tr></table></figure>

<p>具体分析一下： 赋值表达式是从右向左读的。这行代码首先是开辟了一块内存，把右侧这个数组塞了进去，此时这个数组就占据了一块内存。随后 user 变量指向它，这就是创建了一个指向该数组的 “引用”。此时数组的引用计数就是 1</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><code class="hljs xl"><br><span class="hljs-function"><span class="hljs-title">user</span> --1--&gt;</span>  [<span class="hljs-keyword">name</span>: <span class="hljs-string">&#x27;帅得乱七八糟&#x27;</span>, age: <span class="hljs-number">21</span>]<br></code></pre></td></tr></table></figure>

<blockquote>
<p>在<code>引用计数法</code>的机制下，内存中的每一个值都会对应一个引用计数。当垃圾收集器感知到某个值的引用计数为 0 时，就判断它 “没用” 了，随即这块内存就会被释放。</p>
</blockquote>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">user</span> <span class="hljs-title">= null</span>;   // 则计数就会变成<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<h4 id="引用计数法的局限性"><a href="#引用计数法的局限性" class="headerlink" title="引用计数法的局限性"></a>引用计数法的局限性</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">function badCycle() &#123;<br>  <span class="hljs-selector-tag">var</span> cycleObj1 = &#123;&#125;<br>  <span class="hljs-selector-tag">var</span> cycleObj2 = &#123;&#125;<br>  cycleObj1<span class="hljs-selector-class">.target</span> = cycleObj2<br>  cycleObj2<span class="hljs-selector-class">.target</span> = cycleObj1<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">badCycle</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>

<figure class="highlight brainfuck"><table><tr><td class="code"><pre><code class="hljs brainfuck">         --<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">1</span>--<span class="hljs-literal">-</span>&gt;<br><span class="hljs-comment">cycleObj1</span>         <span class="hljs-comment">cycleObj2</span><br>         &lt;--<span class="hljs-literal">-</span><span class="hljs-comment">1</span>--<span class="hljs-literal">-</span><br></code></pre></td></tr></table></figure>

<p>即便 badCycle 函数执行完。引用计数仍未被清 0</p>
<blockquote>
<p><code>引用计数法</code>无法甄别循环引用场景下的 “垃圾”！</p>
</blockquote>
<h4 id="标记清除法-目前都是用的这种方法"><a href="#标记清除法-目前都是用的这种方法" class="headerlink" title="标记清除法(目前都是用的这种方法)"></a>标记清除法(目前都是用的这种方法)</h4><p>在标记清除算法中，一个变量是否被需要的判断标准，是它是否可抵达<br>这个算法有两个阶段，分别是标记阶段和清除阶段：<br><strong>标记阶段</strong>:垃圾收集器会先找到根对象，在浏览器里，根对象是 Window；在 Node 里，根对象是 Global。从根对象出发，垃圾收集器会扫描所有可以通过根对象触及的变量，这些对象会被标记为 “可抵达”。<br><strong>清除阶段</strong>:没有被标记为 “可抵达” 的变量，就会被认为是不需要的变量，这波变量会被清除</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">function badCycle() &#123;<br>  <span class="hljs-selector-tag">var</span> cycleObj1 = &#123;&#125;<br>  <span class="hljs-selector-tag">var</span> cycleObj2 = &#123;&#125;<br>  cycleObj1<span class="hljs-selector-class">.target</span> = cycleObj2<br>  cycleObj2<span class="hljs-selector-class">.target</span> = cycleObj1<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">badCycle</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>

<p>badCycle 执行完毕后，从根对象 Window 出发，cycleObj1 和 cycleObj2 都会被识别为不可达的对象，它们会按照预期被清除掉。这样一来，循环引用的问题，就被标记清除干脆地解决掉了。</p>
<h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>内存泄露：该释放的变量（内存垃圾）没有被释放，仍然霸占着原有的内存不松手，导致内存占用不断攀高，带来性能恶化、系统崩溃等一系列问题，这种现象就叫内存泄漏</p>
<h4 id="闭包的错误使用造成的内存泄露"><a href="#闭包的错误使用造成的内存泄露" class="headerlink" title="闭包的错误使用造成的内存泄露"></a>闭包的错误使用造成的内存泄露</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> theThing = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">var</span> replaceThing = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> originalThing = theThing;<br>  <span class="hljs-keyword">var</span> unused = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (originalThing) <span class="hljs-comment">// 自由变量的使用，闭包操作</span><br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;嘿嘿嘿&quot;</span>);<br>  &#125;;<br>  theThing = &#123;<br>    <span class="hljs-attr">longStr</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1000000</span>).join(<span class="hljs-string">&#x27;*&#x27;</span>),<br>    <span class="hljs-attr">someMethod</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;哈哈哈&quot;</span>);<br>    &#125;<br>  &#125;;<br>&#125;;<br><span class="hljs-built_in">setInterval</span>(replaceThing, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure>

<p><strong>在 V8 中，一旦不同的作用域位于同一个父级作用域下，那么它们会共享这个父级作用域</strong></p>
<p>注意：unused 是一个闭包。 并且，unused 和 someMethod 都位于同一个父级作用域下，共享这个父级作用域<br>无法被回收的无用 originalThing 越堆积越多，最终导致严重的内存泄漏<br><strong>—&gt; 此题有点懵…没看懂…</strong></p>
<h4 id="内存泄漏成因分析"><a href="#内存泄漏成因分析" class="headerlink" title="内存泄漏成因分析"></a>内存泄漏成因分析</h4><ol>
<li>误写全局变量</li>
</ol>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>&#123;<br>  test = <span class="hljs-string">&#x27;123&#x27;</span>;  <span class="hljs-comment">// test 就是全局变量</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>根据垃圾回收策略，本来 me 这个变量，如果被 var 声明过，它作为函数作用域内的变量，在函数调用结束后就会消失 —— 这也是我们所期望的。但现在它是一个全局变量了，永远无法被清除。这样的变量一多，问题就来了</p>
<ol start="2">
<li><p>忘记清除的 setInterval 和 setTimeout<br>在 setInterval 和链式调用的 setTimeout 这两种场景下，定时器的工作可以说都是无穷无尽的。当定时器囊括的函数逻辑不再被需要、而我们又忘记手动清除定时器时，它们就会永远保持对内存的占用。因此当我们使用定时器时，一定要先问问自己：我打算什么时候干掉这玩意儿？</p>
</li>
<li><p>清除不当的 DOM</p>
</li>
</ol>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">const myDiv = document.get<span class="hljs-constructor">ElementById(&#x27;<span class="hljs-params">myDiv</span>&#x27;)</span><br><br><span class="hljs-keyword">function</span> handle<span class="hljs-constructor">MyDiv()</span> &#123;<br>    <span class="hljs-comment">// 一些与myDiv相关的逻辑</span><br>&#125;<br><br><span class="hljs-comment">// 使用myDiv</span><br>handle<span class="hljs-constructor">MyDiv()</span><br><br><span class="hljs-comment">// 尝试”删除“ myDiv</span><br>document.body.remove<span class="hljs-constructor">Child(<span class="hljs-params">document</span>.<span class="hljs-params">getElementById</span>(&#x27;<span class="hljs-params">myDiv</span>&#x27;)</span>);<br><br></code></pre></td></tr></table></figure>

<p>因为 myDiv 这个变量对这个 DOM 的引用仍然存在，它仍然是一块 “可抵达” 的内存。这种你以为已经清除、但其实活得好好的 DOM 一旦堆积，将带来不可预期的内存隐患。 <strong>(为什么会出现这种情况 我还不知道啊…)</strong></p>
<h2 id="this-1"><a href="#this-1" class="headerlink" title="this"></a>this</h2><h3 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h3><p>多数情况下，this 指向<strong>调用它</strong>所在方法的<strong>那个对象</strong>(谁调的函数，this 就归谁。当调用方法没有明确对象时，this 就指向全局对象。在浏览器中，指向 window；在 Node 中，指向 Global。（严格模式下，指向 undefined))</p>
<p><strong>this 的指向是在调用时决定的，而不是在书写时决定的。这点和闭包恰恰相反</strong></p>
<h4 id="区分-“声明位置”-与-“调用位置”"><a href="#区分-“声明位置”-与-“调用位置”" class="headerlink" title="区分 “声明位置” 与 “调用位置”"></a>区分 “声明位置” 与 “调用位置”</h4><p>js 是词法作用域模型，无论我是一个对象也好，一个方法也好，它的生命周期只和我们声明它的位置有关。我把它写在哪个位置，它就活在哪个位置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 声明位置</span><br><span class="hljs-keyword">var</span> me = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xiuyan&#x27;</span>,<br>  <span class="hljs-attr">hello</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`你好，我是<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>`</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> you = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xiaoming&#x27;</span>,<br>  <span class="hljs-attr">hello</span>: me.hello<br>&#125;<br><br><span class="hljs-comment">// 调用位置</span><br>me.hello() <span class="hljs-comment">// xiuyan</span><br>you.hello() <span class="hljs-comment">// xiaoming</span><br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 声明位置</span><br><span class="hljs-keyword">var</span> me = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xiuyan&#x27;</span>,<br>  <span class="hljs-attr">hello</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`你好，我是<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>`</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> you = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xiaoming&#x27;</span>,<br>  <span class="hljs-attr">hello</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> targetFunc = me.hello  <span class="hljs-comment">// 获取的只是 functioin() &#123;console.log(`你好，我是$&#123;this.name&#125;`)&#125; 这块堆空间的地址</span><br>    targetFunc() <span class="hljs-comment">// --恒等于--&gt;  functioin() &#123;console.log(`你好，我是$&#123;this.name&#125;`)&#125; 的执行结果(调用这段代码的是全局对象)</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;BigBear&#x27;</span><br><br><span class="hljs-comment">// 调用位置</span><br>you.hello()   <span class="hljs-comment">// BigBear</span><br></code></pre></td></tr></table></figure>

<h4 id="特殊情况下的-this-指向"><a href="#特殊情况下的-this-指向" class="headerlink" title="特殊情况下的 this 指向"></a>特殊情况下的 this 指向</h4><p>好消息！在三种特殊情境下，this 会 100% 指向 window：</p>
<ul>
<li>立即执行函数（IIFE）</li>
<li>setTimeout 中传入的函数</li>
<li>setInterval 中传入的函数</li>
</ul>
<p>直接秒杀~</p>
<p>原因：<br>立即执行函数作为<strong>一个匿名函数</strong>，在被调用的时候，我们往往就是直接调用，而不会（也无法）通过属性访问器（ 即 xx.xxx） 这样的形式来给它指定一个所在对象，所以它的 this 是非常确定的，就是默认的全局对象 window</p>
<p>setTimeout 和 setInterval，都是在全局作用域下实现的。无论是 setTimeout 还是 setInterval 里传入的函数，都会首先被交付到全局对象手上</p>
<h4 id="严格模式的局限"><a href="#严格模式的局限" class="headerlink" title="严格模式的局限"></a>严格模式的局限</h4><h5 id="普通函数-非箭头函数-在严格模式下的表现"><a href="#普通函数-非箭头函数-在严格模式下的表现" class="headerlink" title="普通函数(非箭头函数)在严格模式下的表现"></a>普通函数(非箭头函数)在严格模式下的表现</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showThis</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>&#125;<br><br>showThis() <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure>

<h5 id="全局代码中的-this-在严格模式下的表现"><a href="#全局代码中的-this-在严格模式下的表现" class="headerlink" title="全局代码中的 this 在严格模式下的表现"></a>全局代码中的 this 在严格模式下的表现</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)  <span class="hljs-comment">// Window对象</span><br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span><br><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;BigBear&#x27;</span><br><br><span class="hljs-keyword">var</span> me = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xiuyan&#x27;</span>,<br>  <span class="hljs-attr">hello</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 全局作用域下实现的延时函数</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`你好，我是<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>`</span>)<br>    &#125;)<br>  &#125;<br>&#125;<br><br>me.hello() <span class="hljs-comment">// 你好，我是BigBear</span><br></code></pre></td></tr></table></figure>

<p><strong>像这样处于全局代码中的 this， 不管它是否处于严格模式下，它的 this 都指向 Window（这点要特别注意，区分度非常高，很多同学面试的时候会误以为这里也是 undefined ）</strong><br>见到 ‘use strict’ 就立刻认为 this 会是 undefined ， 无疑是件更危险的事情</p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数中的 this 比较特别，它和严格模式、非严格模式啥的都没关系。它和闭包很相似，都是认“词法作用域”的家伙。所以说箭头函数中的 this，和你如何调用它无关，由你书写它的位置决定（和咱们普通函数的 this 规则恰恰相反～）</p>
<p><strong>箭头函数的 this 指向是静态的，“一次便是一生”，指向不会再改变</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;BigBear&#x27;</span><br><span class="hljs-keyword">var</span> me = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xiuyan&#x27;</span>,<br>  <span class="hljs-comment">// 声明位置</span><br>  <span class="hljs-attr">hello</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)   <span class="hljs-comment">// 因为 this 在书写的时候，它所在的作用域是全局作用域(忽视箭头函数的作用域)，于是这个 this 就和全局对象绑在了一起(注意，这里无块级作用域，块级作用域 需要关键字 let const)</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 调用位置</span><br>me.hello() <span class="hljs-comment">// BigBear</span><br></code></pre></td></tr></table></figure>

<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> = <span class="hljs-number">1</span><br><span class="hljs-selector-tag">var</span> obj = &#123;<br>  <span class="hljs-selector-tag">a</span>: <span class="hljs-number">2</span>,<br>  func2: () =&gt; &#123;<br>    console<span class="hljs-selector-class">.log</span>(this.a)<br>  &#125;,<br><br>  func3: function() &#123;<br>    console<span class="hljs-selector-class">.log</span>(this.a)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// func1</span><br><span class="hljs-selector-tag">var</span> func1  = () =&gt; &#123;<br>  console<span class="hljs-selector-class">.log</span>(this.a)<br>&#125;<br><br><span class="hljs-comment">// func2</span><br><span class="hljs-selector-tag">var</span> func2 = obj<span class="hljs-selector-class">.func2</span><br><span class="hljs-comment">// func3</span><br><span class="hljs-selector-tag">var</span> func3 = obj<span class="hljs-selector-class">.func3</span><br><br><span class="hljs-function"><span class="hljs-title">func1</span><span class="hljs-params">()</span></span>    <span class="hljs-comment">// 1</span><br><span class="hljs-function"><span class="hljs-title">func2</span><span class="hljs-params">()</span></span>    <span class="hljs-comment">// 1</span><br><span class="hljs-function"><span class="hljs-title">func3</span><span class="hljs-params">()</span></span>    <span class="hljs-comment">// 1</span><br>obj<span class="hljs-selector-class">.func2</span>()  <span class="hljs-comment">// 1</span><br>obj<span class="hljs-selector-class">.func3</span>()  <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure>

<h3 id="this-指向的改变"><a href="#this-指向的改变" class="headerlink" title="this 指向的改变"></a>this 指向的改变</h3><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust">                                                     ___call --&gt; <span class="hljs-keyword">fn</span>.call(target, arg1, arg2, arg3)<br>                      |-----改变后直接进行函数调用----&gt; |___apply -&gt; <span class="hljs-keyword">fn</span>.apply(target,[arg1, arg2, arg3])<br>改变函数的this指向 ---&gt; |<br>                      |-------仅做改变，不做执行-----&gt; bind ---&gt; <span class="hljs-keyword">fn</span>.bind(target, arg1, arg2)<br></code></pre></td></tr></table></figure>

<p>手写 call、apply、bind (这个在手写博客那一章里…)</p>
<h2 id="执行上下文与调用栈"><a href="#执行上下文与调用栈" class="headerlink" title="执行上下文与调用栈"></a>执行上下文与调用栈</h2><p>执行上下文：JS 引擎在执行过程中对代码进行了又一次的 “划分”，这样做的目的，是为了分解复杂度</p>
<h3 id="执行上下文-1"><a href="#执行上下文-1" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>执行上下文，从定义上理解，是 “执行代码的环境”</p>
<h4 id="执行上下文的分类"><a href="#执行上下文的分类" class="headerlink" title="执行上下文的分类"></a>执行上下文的分类</h4><ul>
<li>全局上下文 —— 全局代码所处的环境，不在函数中的代码都在全局执行上下文中</li>
<li>函数上下文 —— 在函数调用时创建的上下文</li>
<li>Eval 执行上下文 —— 运行 Eval 函数中的代码时所创建的环境，Eval 被前端诟病多年，故不在讨论范围</li>
</ul>
<p>代码执行阶段才会有的~</p>
<p><strong>全局上下文</strong>： JS 脚本跑起来之后，第一个被创建的执行上下文就是全局上下文</p>
<h4 id="执行上下文的生命周期"><a href="#执行上下文的生命周期" class="headerlink" title="执行上下文的生命周期"></a>执行上下文的生命周期</h4><p>创建阶段 —— 执行上下文的初始化状态，此时<strong>一行代码都还没有执行</strong>，只是做了一些准备工作<br>执行阶段 —— 逐行执行脚本里的代码(执行上下文在执行阶段里其实始终是处在一个动态)</p>
<p><strong>站在上下文角度，才能真正理解 “变量提升” 的本质</strong></p>
<p><strong>函数上下文</strong>： 在函数被调用的时候才会产生…</p>
<h4 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h4><p><strong>作用域其实就是当前所处的执行上下文</strong><br><strong>调用栈是在执行的过程中形成的，而作用域链可是在书写阶段就决定了</strong></p>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>es6 的 class 也是原型的一个语法糖而已</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, age</span>)</span> &#123;<br>   <span class="hljs-built_in">this</span>.name = name<br>   <span class="hljs-built_in">this</span>.age = age<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;肉骨头真好吃&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码等价于下面的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Dog</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><br>Dog.prototype.eat = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;肉骨头真好吃~&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>关键字：实例、构造函数、原型对象<br>在 JavaScript 中，每个构造函数都拥有一个 <strong>prototype</strong> 属性，它指向构造函数的原型对象，这个原型对象中有一个 <strong>construtor</strong> 属性指回构造函数；每个实例都有一个<strong>proto</strong>属性，当我们使用构造函数去创建实例时，实例的<strong>proto</strong>属性就会指向构造函数的原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个Dog构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Dog</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name<br>  <span class="hljs-built_in">this</span>.age = age<br>&#125;<br>Dog.prototype.eat = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;肉骨头真好吃&#x27;</span>)<br>&#125;<br><span class="hljs-comment">// 使用Dog构造函数创建dog实例</span><br><span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&#x27;旺财&#x27;</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure>

<p>上述关系：<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2021-12-12-%E4%B8%8B%E5%8D%884.10.11.png" alt="原型"></p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 输出<span class="hljs-string">&quot;肉骨头真好吃&quot;</span><br>dog.eat()<br><span class="hljs-regexp">//</span> 输出<span class="hljs-string">&quot;[object Object]&quot;</span><br>dog.toString()<br></code></pre></td></tr></table></figure>

<p>明明没有在 dog 实例里手动定义 eat 方法和 toString 方法，它们还是被成功地调用了。这是因为当我试图访问一个 JavaScript 实例的属性 / 方法时，它首先搜索这个实例本身；当发现实例没有定义对应的属性 / 方法时，它会转而去搜索实例的原型对象；如果原型对象中也搜索不到，它就去搜索原型对象的原型对象，这个搜索的轨迹，就叫做原型链</p>
<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2021-12-12-%E4%B8%8B%E5%8D%884.26.33.png" alt="原型链"></p>
<p><strong>这些彼此相连的 prototype，就构成了所谓的 “原型链”</strong></p>
<p>注： 几乎所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例，除了 Object.prototype（当然，如果我们手动用 Object.create(null) 创建一个没有任何原型的对象，那它也不是 Object 的实例）</p>
<h3 id="原型-amp-原型链题目"><a href="#原型-amp-原型链题目" class="headerlink" title="原型&amp;原型链题目"></a>原型&amp;原型链题目</h3><h4 id="原型基础-构造函数基础"><a href="#原型基础-构造函数基础" class="headerlink" title="原型基础 + 构造函数基础"></a>原型基础 + 构造函数基础</h4><p><strong>此题易错！</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> A = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;<br>A.prototype.n = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> A();<br>A.prototype = &#123;<br>  <span class="hljs-attr">n</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">m</span>: <span class="hljs-number">3</span><br>&#125;<br><span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> A();<br><br><span class="hljs-built_in">console</span>.log(b.n);  <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.log(b.m);  <span class="hljs-comment">// undefined</span><br><br><span class="hljs-built_in">console</span>.log(c.n);  <span class="hljs-comment">// 2</span><br><span class="hljs-built_in">console</span>.log(c.m);  <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure>

<p><strong>注意：b 实例明明和 c 实例继承自一个原型，却有着不同的表现</strong></p>
<figure class="highlight elm"><table><tr><td class="code"><pre><code class="hljs elm">因为<br><span class="hljs-type">A</span>.proto<span class="hljs-keyword">type</span> = &#123;<br>  n: 2,<br>  m: 3<br>&#125;<br>切断了旧的proto<span class="hljs-keyword">type</span>。而b引用的是旧的prototype。而c引用的是新的prototype<br></code></pre></td></tr></table></figure>

<p>这是一道坑爹题…</p>
<h4 id="自有属性与原型继承属性"><a href="#自有属性与原型继承属性" class="headerlink" title="自有属性与原型继承属性"></a>自有属性与原型继承属性</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;a&#x27;</span><br>  <span class="hljs-built_in">this</span>.color = [<span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;yellow&#x27;</span>]<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span>(<span class="hljs-params"></span>) </span>&#123;<br><br>&#125;<br>B.prototype = <span class="hljs-keyword">new</span> A()<br><span class="hljs-keyword">var</span> b1 = <span class="hljs-keyword">new</span> B()<br><span class="hljs-keyword">var</span> b2 = <span class="hljs-keyword">new</span> B()<br><br>b1.name = <span class="hljs-string">&#x27;change&#x27;</span><br>b1.color.push(<span class="hljs-string">&#x27;black&#x27;</span>)<br><br><span class="hljs-built_in">console</span>.log(b2.name) <span class="hljs-comment">// &#x27;a&#x27;</span><br><span class="hljs-built_in">console</span>.log(b2.color)<br></code></pre></td></tr></table></figure>

<h2 id="变量提升与暂时性死区"><a href="#变量提升与暂时性死区" class="headerlink" title="变量提升与暂时性死区"></a>变量提升与暂时性死区</h2><h3 id="变量提升-2"><a href="#变量提升-2" class="headerlink" title="变量提升"></a>变量提升</h3><p>在 “var” 时代，有一个特别的现象：<strong>不管我们的变量声明是写在程序的哪个角落，最后都会被提到作用域的顶端去</strong></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">console.log(<span class="hljs-built_in">num</span>);   <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">var</span> <span class="hljs-built_in">num</span> = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>// 等价于下面的代码</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">var</span> <span class="hljs-built_in">num</span>;<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">num</span>);<br><span class="hljs-built_in">num</span> = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>在函数作用域里，也会有类似的现象发生</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNum</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(num)<br>  <span class="hljs-keyword">var</span> num = <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNum</span>() &#123;</span><br>  var <span class="hljs-built_in">num</span><br>  console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">num</span>)<br>  <span class="hljs-built_in">num</span> = <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="变量提升的原理"><a href="#变量提升的原理" class="headerlink" title="变量提升的原理"></a>变量提升的原理</h3><p>跟 js 编译过程有关<br>所有的 JS 代码片段在执行之前都会被编译，只是这个编译的过程非常短暂（可能就只有几微妙、或者更短的时间），紧接着这段代码就会被执行<br>正是在这个短暂的编译阶段里，JS 引擎会搜集所有的变量声明，并且提前让声明生效。至于剩下的语句，则需要等到执行阶段、等到执行到具体的某一句的时候才会生效</p>
<h3 id="被禁用的变量提升"><a href="#被禁用的变量提升" class="headerlink" title="被禁用的变量提升"></a>被禁用的变量提升</h3><blockquote>
<p>用 let 和 const 的变量提升仅仅是声明提升，var 的变量提升是声明提升加初始化提升</p>
</blockquote>
<blockquote>
<p>const 声明的变量，必须在声明同时被初始化，否则会报错;const 声明的变量，在赋值过后，值不可以再被更改。否则同样会报错</p>
</blockquote>
<h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> me = <span class="hljs-string">&#x27;xiuyan&#x27;</span>;<br><br>&#123;<br>	me = <span class="hljs-string">&#x27;bear&#x27;</span>;   <span class="hljs-comment">// 这里是暂时性死区</span><br>	<span class="hljs-keyword">let</span> me;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码报错！</p>
<h3 id="细小知识点"><a href="#细小知识点" class="headerlink" title="细小知识点"></a>细小知识点</h3><h4 id="typeof-操作符的用法"><a href="#typeof-操作符的用法" class="headerlink" title="typeof 操作符的用法"></a>typeof 操作符的用法</h4><p><code>typeof</code>用来返回一个值的变量类型，对于不同类型的变量其返回值如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span> === <span class="hljs-string">&#x27;undefined&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span> === <span class="hljs-string">&#x27;boolean&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-number">89</span> === <span class="hljs-string">&#x27;number&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-string">&#x27;Hey&#x27;</span> === <span class="hljs-string">&#x27;string&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span>() === <span class="hljs-string">&#x27;symbol&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-built_in">BigInt</span>(<span class="hljs-number">1</span>) === <span class="hljs-string">&#x27;bigint&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&#x27;abc&#x27;</span>) === <span class="hljs-string">&#x27;object&#x27;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span> === <span class="hljs-string">&#x27;object&#x27;</span>   <span class="hljs-comment">// 这里要注意</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125; === <span class="hljs-string">&#x27;function&#x27;</span><br><span class="hljs-keyword">typeof</span> &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>&#125; === <span class="hljs-string">&#x27;object&#x27;</span><br></code></pre></td></tr></table></figure>

<p>注意 typeof 是用来返回值的类型，而不是返回<strong>变量的类型</strong>因为 JavaScript 中的变量是没有类型的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a) <span class="hljs-comment">// &#x27;number&#x27;</span><br>a = <span class="hljs-string">&#x27;1&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a) <span class="hljs-comment">// &#x27;string&#x27;</span><br></code></pre></td></tr></table></figure>

<p>a 变量是没有类型的，但是赋给 a 变量的值确是有类型的</p>
]]></content>
      <categories>
        <category>面试篇</category>
        <category>基本功</category>
      </categories>
      <tags>
        <tag>面试之道</tag>
      </tags>
  </entry>
</search>
