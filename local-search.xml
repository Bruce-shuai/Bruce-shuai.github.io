<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>一篇文章掌握性能优化大法之防抖和节流</title>
    <link href="/2021/10/13/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%8E%8C%E6%8F%A1%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%A4%A7%E6%B3%95%E4%B9%8B%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
    <url>/2021/10/13/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%8E%8C%E6%8F%A1%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%A4%A7%E6%B3%95%E4%B9%8B%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<p>相信一提到前端性能优化，大家脑子里就会一下映射出许多内容。例如：懒加载、CDN 缓存、DOM 优化、图片优化、Webpack 的优化配置…但今天我想谈论的一个性能优化点是<strong>防抖</strong>和<strong>节流</strong>函数，因为它俩够“小巧”，但发挥的作用却不容小觑！</p><p>在实际写项目的时候，我们会发现，一些事件总是会被频繁触发。例如鼠标事件、键盘事件、scroll 事件…</p><p>举个小例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">let</span> input = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;[name=&quot;username&quot;]&#x27;</span>)</span><br><span class="javascript">  input.addEventListener(<span class="hljs-string">&#x27;keyup&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.value)</span><br><span class="javascript">  &#125;)</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e1b22b590194ef58b3cf9ce2853aaa0~tplv-k3u1fbpfcp-watermark.image" alt="debounce1.gif"></p><p>由上述非常简短的代码及效果图，我们就可以发现，频繁的触发回调是真的要命 😭😭😭,它不仅会造成大量的计算引发页面卡顿还会造成频繁的网络请求导致不必要的流量浪费以及极低的用户体验…为了规避这类情况，我们急需控制回调的触发频率，让回调函数被触发的次数恰到好处！因此，防抖函数和节流函数闪亮登场 ✨</p><hr><h3 id="防抖函数-debounce"><a href="#防抖函数-debounce" class="headerlink" title="防抖函数(debounce)"></a>防抖函数(debounce)</h3><h4 id="防抖函数核心逻辑"><a href="#防抖函数核心逻辑" class="headerlink" title="防抖函数核心逻辑"></a>防抖函数核心逻辑</h4><p>人为设定一段<strong>延迟时间</strong>，用于延迟执行<strong>回调函数 A</strong>。如果在延迟时间内，用户反复触发这个<strong>回调函数 A</strong>，则只会重复刷新延迟时间，而频繁被触发的<strong>回调函数 A</strong>中，<strong>仅最后一次触发的回调函数 A 是能被执行的</strong>。</p><h4 id="写防抖函数的五大要素"><a href="#写防抖函数的五大要素" class="headerlink" title="写防抖函数的五大要素"></a>写防抖函数的五大要素</h4><p>好了，上文已经讲解了防抖函数的核心逻辑，现在大家来熟悉一下写防抖函数的五大要素，从而方便理解下文真正的防抖函数 💪🏻</p><ul><li><ol><li>需要使用闭包</li></ol></li><li><ol start="2"><li>需要 setTimeout、clearTimeout 的灵活运用</li></ol></li><li><ol start="3"><li>防抖函数的第一个参数为需要被触发的回调函数</li></ol></li><li><ol start="4"><li>防抖函数会返回一个函数</li></ol></li><li><ol start="5"><li>回调函数的 this 指向需要和防抖函数返回的这个函数 this 指向保持一致</li></ol></li></ul><h4 id="手写防抖函数"><a href="#手写防抖函数" class="headerlink" title="手写防抖函数"></a>手写防抖函数</h4><p>请大家在看代码的同时注意我的注释！！！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// fnA 是要被触发的回调函数   delay是延迟时间</span><br><span class="hljs-keyword">let</span> debounce = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fnA, delay</span>) </span>&#123;<br>    <span class="hljs-comment">// timer是定时器，如果在延迟时间内频繁触发回调函数A，则会重复刷新延迟时间timer</span><br>    <span class="hljs-comment">// 注意：这里会运用到闭包！！(请不了解闭包基础知识的朋友先去看一下闭包基础知识后再继续看这篇博客)</span><br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">// 防抖函数会返回一个函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-comment">// 锁定当前this的指向，方便控制fnA的this指向和这个返回函数的this指向保持一致</span><br>        <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">this</span>;<br>        <span class="hljs-comment">// 保留调用防抖函数时传入的参数</span><br>        <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">arguments</span>;<br><br>        <span class="hljs-comment">// 如果在延迟时间内频繁触发回调函数A，则重复刷新延迟时间timer</span><br>        <span class="hljs-keyword">if</span> (timer) &#123;<br>            <span class="hljs-built_in">clearTimeout</span>(timer);<br>        &#125;<br>        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-comment">// 将fn的this指向和防抖函数返回的这个函数的this指向保持一致</span><br>            fnA.call(context, ...arguments)<br>        &#125;, delay)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>好啦，手写代码完成。接下来，我们试一试防抖函数</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">let</span> input = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;[name=&quot;username&quot;]&#x27;</span>)</span><br><span class="javascript">  <span class="hljs-comment">// 注意：addEventListener的this总是当前正在处理事件的那个DOM对象</span></span><br><span class="javascript">  input.addEventListener(<span class="hljs-string">&#x27;keyup&#x27;</span>, debounce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.value)</span><br><span class="javascript">  &#125;, <span class="hljs-number">2000</span>))</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71fab3e4f6044064b640a1fa5964349d~tplv-k3u1fbpfcp-watermark.image" alt="debounce2.gif"></p><p>快速输入 12345677 后，需再等待 2s 才会执行真正的回调函数。这就是防抖函数发挥的真正作用！消除了过多而不必要的回调函数。</p><p><strong>附赠一个化简版的<code>debounce</code></strong></p><p>这个版本的<code>debounce</code>使用了箭头函数，原理和上面的<code>debounce</code>是一样的。(关于此题的箭头函数使用，也许本篇博客的<strong>彩蛋 2</strong>能给你一个提示)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> debounce = <span class="hljs-function">(<span class="hljs-params">fn, delay</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...<span class="hljs-built_in">arguments</span></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;arguments&#x27;</span>, <span class="hljs-built_in">arguments</span>)<br>    <span class="hljs-keyword">if</span> (timer) &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timer);<br>    &#125;<br>    <span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;测试&#x27;</span><br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      fn.call(<span class="hljs-built_in">this</span>, ...arguments)<br>    &#125;, delay)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="节流函数-throttle"><a href="#节流函数-throttle" class="headerlink" title="节流函数(throttle)"></a>节流函数(throttle)</h3><h4 id="节流函数的核心逻辑"><a href="#节流函数的核心逻辑" class="headerlink" title="节流函数的核心逻辑"></a>节流函数的核心逻辑</h4><p>人为设定一段间隔时间，<strong>当第一次触发回调函数 A 时，回调函数 A 被立即执行并且开始计时</strong>。在这段间隔时间内，无论用户触发多少次<strong>回调函数 A</strong>，都不会被执行。</p><h4 id="写节流函数的五大要素"><a href="#写节流函数的五大要素" class="headerlink" title="写节流函数的五大要素"></a>写节流函数的五大要素</h4><p>事实上，节流的五大要素和防抖非常相似(只有第二点有区别)，所以当看懂防抖函数的代码后，在手写节流代码时就显得比较轻松了！</p><ul><li><ol><li>需要使用闭包</li></ol></li><li><ol start="2"><li>结合时间戳来判断时间间隔</li></ol></li><li><ol start="3"><li>节流函数的第一个参数为需要被触发的回调函数</li></ol></li><li><ol start="4"><li>节流函数会返回一个函数</li></ol></li><li><ol start="5"><li>回调函数的 this 指向需要和节流函数返回的这个函数 this 指向保持一致</li></ol></li></ul><h4 id="手写节流函数"><a href="#手写节流函数" class="headerlink" title="手写节流函数"></a>手写节流函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-comment">// fnA 表示回调函数A， interval表示间隔时间</span><br> <span class="hljs-keyword">let</span> throttle = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fnA, interval</span>) </span>&#123;<br>  <span class="hljs-comment">// last 运用闭包知识</span><br>  <span class="hljs-comment">// last 为上一次触发回调的时间, 初始化为0 方便第一次触发事件就能运行回调函数</span><br>  <span class="hljs-keyword">let</span> last = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 返回一个函数</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 记录当前的时间戳</span><br>    <span class="hljs-keyword">let</span> now = <span class="hljs-built_in">Date</span>.now();<br>    <span class="hljs-comment">// 保留调用节流函数时传入的参数</span><br>    <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">arguments</span>;<br>    <span class="hljs-comment">// 回调函数的this指向需要和节流函数返回的这个函数this指向保持一致</span><br>    <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-comment">// 通过时间差来判断再一次触发的回调函数是否还在这段时间间隔内</span><br>    <span class="hljs-keyword">if</span> (now - last &gt;= interval) &#123;<br>      last = now;<br>      fnA.call(context, ...args)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码效果：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd4d3d0f930b4882b09c4a52ff1d071c~tplv-k3u1fbpfcp-watermark.image" alt="throttle1.gif"></p><p>事实上，防抖和节流函数的相似度是非常高的, 相信大家在理解完我手写防抖和节流函数时所提及的 5 大要素以及我的代码注释后，能够对防抖和节流函数感到更加亲切！剩下的就是靠你自己手写一下代码，让代码真正变成你自己拥有的。</p><p>本篇文章可能会有作者笔误或理解错误的地方，请大家多多指出！ 如果这篇文章对你有帮助的话，还请给这篇文章点一个赞吧 💕</p><hr><p>下面的三个彩蛋实则是我在写这篇博客时突然想到的三个关于 this 和作用域比较有意思的点，如果大家有兴趣，不妨看一看！</p><h5 id="彩蛋-1"><a href="#彩蛋-1" class="headerlink" title="彩蛋 1"></a>彩蛋 1</h5><p>在上述防抖函数中，我使用到了 setTimeout。而事实上对于<code>setTimeout</code>的<code>this</code>指向，其实也是有一些学问在里面的。<br>给大家送福利！在下述三种情况，this 会 100%指向 window</p><ul><li>立即执行函数(IIFE)</li><li>setTimeout 中传入的函数(非箭头函数)</li><li>setInterval 中传入的函数(非箭头函数)</li></ul><h5 id="彩蛋-2"><a href="#彩蛋-2" class="headerlink" title="彩蛋 2"></a>彩蛋 2</h5><p>对于 setTimeout 的箭头函数的思考</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;帅得乱七八糟&#x27;</span><br><br><span class="hljs-keyword">var</span> me = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;帅得歪瓜裂枣&#x27;</span>,<br>  <span class="hljs-attr">hello1</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 箭头函数中的 this，和你如何调用它无关，由你书写它的位置决定</span><br>  <span class="hljs-comment">// 这里的this的作用域是hello1函数作用域。所以，谁调用hello1，这里的this就指向谁</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-comment">// 指向me</span><br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`你好，我是<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>`</span>)<br>    &#125;)<br>  &#125;,<br>  <span class="hljs-attr">hello2</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;   <span class="hljs-comment">// 指向window(彩蛋1里有提到)</span><br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`你好，我是<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>`</span>)<br>    &#125;)<br>  &#125;<br>&#125;<br><br>me.hello1();   <span class="hljs-comment">// 你好，我是帅得歪瓜裂枣</span><br>me.hello2();   <span class="hljs-comment">// 你好，我是帅得乱七八糟</span><br><br></code></pre></td></tr></table></figure><h5 id="彩蛋-3"><a href="#彩蛋-3" class="headerlink" title="彩蛋 3"></a>彩蛋 3</h5><p>关于回调函数的参数问题</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">let func = <span class="hljs-function"><span class="hljs-params">(fn)</span> =&gt;</span> &#123;<br>    fn();<br>&#125;<br>let callback = <span class="hljs-function"><span class="hljs-params">(param)</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(param)<br>&#125;<br>let fn = function() &#123;<br>    let param = <span class="hljs-number">123</span>;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(param);   <span class="hljs-regexp">//</span> <span class="hljs-number">1</span>s后打印： <span class="hljs-number">123</span><br>    &#125;, <span class="hljs-number">1000</span>)<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">(param)</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(param);   <span class="hljs-regexp">//</span> <span class="hljs-number">1</span>s后打印： <span class="hljs-literal">undefined</span><br>    &#125;, <span class="hljs-number">3000</span>)<br><br>    func(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> callback(param))      <span class="hljs-regexp">//</span> <span class="hljs-number">123</span><br>    func(<span class="hljs-function"><span class="hljs-params">(param)</span> =&gt;</span> callback(param)) <span class="hljs-regexp">//</span> <span class="hljs-literal">undefined</span><br>&#125;<br>fn();<br></code></pre></td></tr></table></figure><p>为何我给回调的参数加上<code>param</code>，则打印变为<code>undefined</code>？ 这其实是函数作用域在作怪！如果在回调的参数上加<code>param</code>，则该回调内的所有<code>param</code>(包括回调的参数<code>param</code>)都是属于该回调函数的作用域内。而很明显，回调里的<code>param</code>没有赋上任何值，所以是<code>undefined</code>。如果参数没有 param，则回调内的<code>param</code>就会向上一层作用域内寻找<code>param</code>，恰好 fn 里有定义<code>param</code> 且值为 123。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Emotion的安装和基本使用</title>
    <link href="/2021/10/10/Emotion%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/10/10/Emotion%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>更细节的操作应该看官网指导：<br><a href="https://emotion.sh/docs/introduction">Emotion 官网</a></p><h5 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h5><p>针对 react 框架</p><blockquote><p>npm i @emotion/react<br>npm i @emotion/styled @emotion/react</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS-in-JS</title>
    <link href="/2021/10/10/CSS-in-JS/"/>
    <url>/2021/10/10/CSS-in-JS/</url>
    
    <content type="html"><![CDATA[<blockquote><p>注意：css 模块与 webpack 的相关内容有待补充！</p></blockquote><p><code>CSS-in-JS</code> 不是指某一个具体的库，是指<strong>组织 CSS 代码的一种方式</strong>，代表库有 <a href="https://styled-components.com/">styled-component</a> 和 <a href="https://emotion.sh/docs/introduction">emotion</a>。</p><h4 id="传统-CSS-的缺陷"><a href="#传统-CSS-的缺陷" class="headerlink" title="传统 CSS 的缺陷"></a>传统 CSS 的缺陷</h4><ol><li><p>缺乏模块组织<br>在传统的 JS 和 CSS 中其实都没有<strong>模块</strong>的概念，后来在 JS 界陆续有了 CommonJS 和 ECMAScript Module, 以及<code>webpack</code>为主的模块打包工具渐渐的成熟。而<code>CSS-in-JS</code>就可以用<strong>模块化的方式</strong>组织 CSS，<strong>依托与 JS 的模块化方案</strong>。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> styled <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@emotion/styled&#x27;</span>;<br><br><span class="hljs-comment">// styled 其实就是一个模块</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Button = styled.button<span class="hljs-string">`</span><br><span class="hljs-string"> color: turquoise;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure></li><li><p>缺乏作用域<br>传统的 <code>CSS</code> 只有一个<code>全局作用域</code>，比如说一个 class 可以匹配全局的任意元素。随着项目成长，CSS 会变得越来越难以组织，最终导致失控。<code>CSS-in-JS</code> 可以通过生成独特的选择符，来实现作用域的效果。</p></li></ol><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.css-1c4ktv6</span> &gt;* &#123;   <span class="hljs-comment">// 1c4ktv6是哈希</span><br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">0</span> <span class="hljs-meta">!important</span>;<br>  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">0</span> <span class="hljs-meta">!important</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> css = <span class="hljs-function"><span class="hljs-params">styleBlock</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> className = someHash(styleBlock);<br>  <span class="hljs-keyword">const</span> styleEl = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;style&#x27;</span>);<br>  styleEl.textContent = <span class="hljs-string">`</span><br><span class="hljs-string">    .<span class="hljs-subst">$&#123;className&#125;</span> &#123;</span><br><span class="hljs-string">      <span class="hljs-subst">$&#123;styleBlock&#125;</span></span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">  `</span>;<br>  <span class="hljs-built_in">document</span>.head.appendChild(styleEl);<br>  <span class="hljs-keyword">return</span> className;<br>&#125;<br><span class="hljs-keyword">const</span> className = css(<span class="hljs-string">`</span><br><span class="hljs-string">  color: red;</span><br><span class="hljs-string">  padding: 20px;</span><br><span class="hljs-string">`</span>);<br></code></pre></td></tr></table></figure><ol start="3"><li>隐式依赖，让样式难以追踪</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-class">.target</span> <span class="hljs-selector-class">.name</span> <span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><br><span class="hljs-selector-tag">body</span> <span class="hljs-selector-id">#container</span> <span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">color</span>: green<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!doctype <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;container&#x27;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;target&#x27;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;name&#x27;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是啥颜色？<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    // 这会让人懵逼的...<br>     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>那么这个 h1 元素最终显式为什么颜色？加入你想要追踪这个影响这个 h1 的样式，怎么追踪？</p><p>而 CSS-in-JS 的方案就简单直接、易于追踪：</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs hsp">export const <span class="hljs-keyword">Title</span> = styled.h1`<br>  <span class="hljs-keyword">color</span>: green<span class="hljs-comment">;</span><br>`<br>&lt;<span class="hljs-keyword">Title</span>&gt;<br>  我是啥颜色？<br>&lt;/<span class="hljs-keyword">Title</span>&gt;<br></code></pre></td></tr></table></figure><ol start="4"><li><p>没有变量<br>传统的 CSS 规则里没有变量…(其实有–var 变量)，但是在 CSS-in-JS 中可以方便地控制变量：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">const</span> Container = styled.<span class="hljs-keyword">div</span>(props =&gt; (&#123;<br> <span class="hljs-keyword">display</span>: <span class="hljs-string">&#x27;flex&#x27;</span>,<br> flexDirection: props.column &amp;&amp; <span class="hljs-string">&#x27;column&#x27;</span><br>&#125;))<br></code></pre></td></tr></table></figure></li><li><p>CSS 选择器与 HTML 元素高度耦合</p></li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-class">.target</span> <span class="hljs-selector-class">.name</span> <span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-selector-tag">body</span> <span class="hljs-selector-id">#container</span> <span class="hljs-selector-tag">h1</span> &#123;<br>    <span class="hljs-attribute">color</span>: green<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!doctype <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;container&#x27;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;target&#x27;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;name&#x27;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是啥颜色？<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果你想把 h1 改成 h2，必须要同时改动 CSS 和 HTML。而在 CSS-in-JS 中，HTML 和 CSS 是结合在一起的，易于修改。(这其实是在程序层次上需要极力去避免的…)</p><hr><h4 id="Emotion-介绍"><a href="#Emotion-介绍" class="headerlink" title="Emotion 介绍"></a>Emotion 介绍</h4><p>Emotion 是目前最受欢迎的 CSS-in-JS 库之一，它还对 React 作了很好的适应，可以方便地创建 styled component，也支持写行内样式：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/** @jsx jsx */</span><br><span class="hljs-keyword">import</span> &#123; jsx &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@emotion/react&#x27;</span>;<br><br>render(<br>  &lt;<span class="hljs-keyword">div</span><br>    css=&#123;&#123;<br>      backgroundColor: <span class="hljs-string">&#x27;hotpink&#x27;</span>,<br>      <span class="hljs-string">&#x27;&amp;:hover&#x27;</span>: &#123;<br>        color: <span class="hljs-string">&#x27;lightgreen&#x27;</span><br>      &#125;<br>    &#125;&#125;<br>  &gt;<br>    <span class="hljs-keyword">This</span> has a hotpink background.<br>  &lt;/<span class="hljs-keyword">div</span>&gt;<br><br>)<br></code></pre></td></tr></table></figure><p>这种写法比起 React 自带的 style 的写法功能更强大，比如可以处理级联、伪类等 style 处理的不了的情况：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">color:</span> <span class="hljs-string">&quot;red&quot;</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&gt;</span>&#123;keyword&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发个人博客反思和总结</title>
    <link href="/2021/10/09/%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%8F%8D%E6%80%9D%E5%92%8C%E6%80%BB%E7%BB%93/"/>
    <url>/2021/10/09/%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%8F%8D%E6%80%9D%E5%92%8C%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h4 id="开发过程"><a href="#开发过程" class="headerlink" title="开发过程"></a>开发过程</h4><ol><li>购买域名 Namecheap —&gt; 算了，最后还是去的阿里云买的…国外的 支付方式有点困难<br>.com 和 .net 有什么区别呢？</li></ol><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-title">.com （商业机构）；</span><br><span class="hljs-title">.net （从事互联网服务的机构）；</span><br></code></pre></td></tr></table></figure><p>买的域名对于所在区域有什么影响没？</p><ol start="2"><li>设定 DNS 将域名停泊到 Cloudflare，因为它有免费的 SSL 以及全球 CND 加速等服务(采用免费方案)，然后设定 DNS， 加入两个 A 记录<br>(<a href="https://zhuanlan.zhihu.com/p/86961133">https://zhuanlan.zhihu.com/p/86961133</a>)</li></ol><h2 id="cloudflare-的优势是什么-cnd-是什么东东？"><a href="#cloudflare-的优势是什么-cnd-是什么东东？" class="headerlink" title="cloudflare 的优势是什么 cnd 是什么东东？"></a>cloudflare 的优势是什么 cnd 是什么东东？</h2><p><a href="https://cloud.tencent.com/developer/article/1137135">cloudflare 相关知识</a><br>SEO –&gt;<br>建站需要什么东西</p><ol><li>域名</li><li>空间(主机) —&gt; 存储网站的地方</li><li>程序(目前已经有开源程序了)</li></ol><p><strong>域名</strong>:heyang.xyz (域名是租的…) 具有唯一性<br>注意：<br>不要购买中文域名(如果有 seo)<br>买常用的后缀<br>容易记忆的</p><p><strong>什么是网站空间？</strong><br>服务器(专业电脑，更强大) —&gt; 目前干脆就用自己的电脑当一个服务器算了…(不行，电脑要一直开机才行…但事实上不可能一直开机)<br>空间(服务器里的文件夹)<br>上述的这个文件夹可以和域名链接在一起(所以访问网站，其实就是通过域名打开服务器里的文件夹)</p><p>空间所以我们采用租的方式…</p><p><strong>建站程序</strong><br>事实上大多数都是用的建站程序来写的…<br>WordPress<br>织梦</p><hr><p>HEXO<br>安装 nodejs –&gt; nodejs 让 js 成为了与 php、py、perl、ruby 等服务端你语言平起平坐的脚本语言</p><blockquote><p>hexo 安装：npm intall hexo-cli -g</p></blockquote><p>利用 github 的仓库作为 hexo 的服务器来搭建个人网站</p><p>个人博客的话，用 hexo 完全不需要去另外购买空间，可以托管到个 ithub、coding 等托管平台，免费提供的空间完全足够了，毕竟一篇文章顶天不过十几 kb</p><hr><p><a href="https://pages.github.com/">https://pages.github.com</a></p><p>采用 github page + hexo</p><p><a href="https://hexo.io/">hexo 网站</a><br><a href="https://hexo.io/plugins/">hexo 插件</a></p><p>.github.io 是一个二级域名… 二级域名有什么不同之处吗？</p><p><a href="https://hexo.io/themes/">hexo 主题</a></p><p>我喜欢的主题：<a href="https://github.com/blleng/hexo-theme-lx">hexo-theme-lx</a><br><a href="https://github.com/zhaoo/hexo-theme-zhaoo">推荐 hexo 主题</a></p><p><a href="https://github.com/fluid-dev/hexo-theme-fluid">最牛逼最适合我的 hexo 主题</a><br>fluid 这个主题文档相当的详尽不错！</p><blockquote><p>hexo 清理缓存，重新部署:<br>hexo clean &amp;&amp; hexo g -d<br>—&gt; 当我使用了这个命令后，我所更新的东西就会自动放在<a href="https://bruce-shuai.github.io/%E9%87%8C%E4%BA%86%E3%80%82%E8%80%8C%E4%B8%8D%E6%98%AF%E7%94%A8git">https://bruce-shuai.github.io/里了。而不是用git</a> add . git commit -m …这些操作…</p></blockquote><h4 id="为博客绑定自己的域名…"><a href="#为博客绑定自己的域名…" class="headerlink" title="为博客绑定自己的域名…"></a>为博客绑定自己的域名…</h4><p>资料<br><a href="https://cloud.tencent.com/developer/article/1435908">dns 解析</a></p><p><a href="https://www.bilibili.com/video/BV1rb411n79N?from=search&seid=2760737936132922743&spm_id_from=333.337.0.0">该域名的教程</a></p><hr><p><a href="https://blog.justlovesmile.top/">看这位大佬的 hexo 笔记能学到很多</a><br><a href="http://blog.itchenliang.club/posts/22350780-f32d-11ea-bb4a-d3e1cbe3d59d/">魔改 hexo</a><br><a href="https://pxxyyz.com/categories/">fluid 大佬博客</a><br><a href="https://i.vince.pub/p/fluid-doc-pr/#%E4%B8%80%E8%A8%80">fluid 又一个大佬博客</a><br><a href="https://papiboy.gitee.io/2021/03/25/hexo%E7%BE%8E%E5%8C%96%E9%A1%B5%E9%9D%A2/">再一位 fluid 大佬</a><br><a href="https://www.itrhx.com/2018/08/27/A04-Hexo-blog-topic-personalization/">再来一篇 fluid 美化的博客</a><br><a href="https://blog.jalenchuh.cn/posts/hexo-fluid/">这位大佬的 fluid 的美化教程很不错</a><br><a href="https://emoryhuang.cn/blog/1729600336.html">再一位大佬</a><br><a href="https://blog.justlovesmile.top/posts/c8972b63.html">hexo 的使用</a></p><p><a href="https://segmentfault.com/a/1190000012805627">更换 hexo 主题</a></p><p><a href="https://waline.js.org/guide/get-started.html#leancloud-%E8%AE%BE%E7%BD%AE-%E6%95%B0%E6%8D%AE%E5%BA%93">hexo 评论区 Waline 插件</a></p><p><a href="https://www.pexels.com/zh-cn/">免费图片网站</a><br><a href="https://undraw.co/search">免费 svg 图片网站</a></p><hr><p><strong>博客性能优化：</strong></p><hr><p><strong>cdn</strong><br>GitHub+jsDelivr+PicGo 搭建免费图床<br>相关博客：<br><a href="https://blog.justlovesmile.top/posts/c8972b63.html">https://blog.justlovesmile.top/posts/c8972b63.html</a><br><a href="https://segmentfault.com/a/1190000020240864">https://segmentfault.com/a/1190000020240864</a></p><p><strong>–&gt; 无需下载软件的方法：<a href="picx.xpoet.cn">PicX</a></strong><br>用 cdn 外链的好处是什么？</p><hr><h2 id="Artitalk"><a href="#Artitalk" class="headerlink" title="Artitalk"></a><strong>Artitalk</strong></h2><p>发布说说<br>官网：<a href="https://artitalk.js.org/">https://artitalk.js.org/</a></p><hr><p>SEO</p><hr><p>留言板</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">一言： https://developer.hitokoto.cn/sentence/#<span class="hljs-variable">%E6</span><span class="hljs-variable">%8</span>E<span class="hljs-variable">%A5</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%8</span>F<span class="hljs-variable">%A3</span><span class="hljs-variable">%E8</span><span class="hljs-variable">%AF</span><span class="hljs-variable">%B4</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%98</span><span class="hljs-variable">%8</span>E  // 这个网站的api有点骚~<br></code></pre></td></tr></table></figure><hr><p>loading 动画：<br><a href="https://www.zyoushuo.cn/post/69e.html">1</a></p><hr><p>更改的内容效果先在 hexo server –debug 上观看(一般来说有大的改动，需重启 hexo server –debug)<br>如果感觉更改的不错(依次输入下面三个语句 上传到 heyang.xyz 里)：<br>hexo generate<br>hexo deploy<br>hexo clean</p><hr><h4 id="性能检测："><a href="#性能检测：" class="headerlink" title="性能检测："></a>性能检测：</h4><p>不多赘述，这篇文章讲得非常好！<a href="https://juejin.cn/book/6844733750048210957/section/6844733750123692046">修言-Performance、LightHouse 与性能 API</a></p><p>解决国内 github+hexo 打开页面慢的方法：<br>由于国内访问 github 的速度较慢，因此可以通过双部署同时部署到 Coding<a href="https://coding.net/">https://coding.net/</a></p>]]></content>
    
    
    <categories>
      
      <category>IT随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>互联网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>post请求和get请求的区别</title>
    <link href="/2021/10/09/post%E8%AF%B7%E6%B1%82%E5%92%8Cget%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/10/09/post%E8%AF%B7%E6%B1%82%E5%92%8Cget%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h4 id="1-有哪些请求方式？"><a href="#1-有哪些请求方式？" class="headerlink" title="1.有哪些请求方式？"></a>1.有哪些请求方式？</h4><ul><li>get</li><li>post</li><li>put</li><li>patch</li><li>delete<br>…</li></ul><h4 id="2-get-请求和-post-请求的区别"><a href="#2-get-请求和-post-请求的区别" class="headerlink" title="2.get 请求和 post 请求的区别"></a>2.get 请求和 post 请求的区别</h4><p><strong>get 请求</strong><br>1）一般用来从服务器获取数据 (有时候会在 url 里增添参数 表示获取有一定限制(筛选数据)的数据)<br>2）1 中提到可以在 url 里添加参数，但这样做的话，安全性，隐私性就比较差。并且参数的长度是有限制的(不然，如果无限长，url 的长度就无限长…非常恐怖…)<br>3）当 发送 get 请求时，刷新浏览器或回退页面是没有影响的(只要 url 没有发生变化，就不会影响 get 请求发送)<br>4）get 请求可以缓存 (这是什么东西？有待查询) (因为 get 请求的数据一般是公开的…大家都可以看的东西)<br>5）get 请求会保留在浏览器历史记录当中<br>6）get 请求可以被收藏为书签(因为直接收藏 url 就可以了 url 带上了参数)<br>7）get 请求只能进行 url 编码(‘Content-type’: ‘application/x-www-form-urlencoded’)<br>8）get 请求通常是通过 url 地址栏发送请求<br><strong>post 请求</strong><br>1）一般用于提交数据到后台 (比如登录、注册时的操作)<br>2）post 请求的参数放在 请求的 body 中。所以不会再 url 中展示，相对而言比 get 要更加的安全<br>3）发送 post 请求过程中，回退页面，请求重新发送(因为参数会发送变化)<br>4）post 请求不会被缓存 (post 的请求的数据一般来说都是比较私密的…)<br>5）post 不会保存在浏览器历史记录当中<br>6）post 请求不可以被收藏为书签(post 参数放在 body 里面的。书签无法找到对应的参数…)<br>7）post 请求支持多种编码方式(例如 url：’application/x-www-form-urlencoded’ 表单提交：’multipart/form-data’ …有待补充)<br>8）post 请求通常是表单发送请求</p><p><strong>get 和 post 请求比较深入的一些区别如下</strong></p><ul><li>post 请求和 get 请求都是 http 的请求方式。底层都是 tcp/ip 协议。get 产生一个 tcp 数据包。post 产生两个数据包(但是 firefox 只发送一个)<br>有个问题是，这个发送一个数据包或发送两个数据包的区别和意义是什么呢？<br>(在网络好的时候，发一次数据包和发两次数据包 其实效果都差不多。但是当网络条件很差的时候，发一次数据包的效果肯定比发两次数据包的速度要快！)</li><li>get 请求会把 http header 和 data 一起发送出去，服务端反应 200。post 请求先发送 header，等服务端响应了 100 再继续发送 data。服务端再响应 200</li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Set和Map基本使用方法</title>
    <link href="/2021/10/09/Set%E5%92%8CMap%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2021/10/09/Set%E5%92%8CMap%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p><code>Map</code> <strong>(有道翻译)</strong> v.映射<br>的确，<code>Map</code> 强调的就是<strong>对应关系</strong><br>记住两个<strong>关键点</strong>：</p><ol><li>无序, 但有下标且下标唯一</li><li>键值对</li></ol><h5 id="Map-的基本用法"><a href="#Map-的基本用法" class="headerlink" title="Map 的基本用法"></a>Map 的基本用法</h5><p>（一）创建</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> m1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br></code></pre></td></tr></table></figure><p>（二）设置 (Map 可不像对象，键只能放字符，Map 的键可以是各种类型的值（包括对象）都可以当作键，如果你需要“键值对”的数据结构，Map 比 Object 更合适。)</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lasso">m1.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;a1&#x27;</span>, <span class="hljs-string">&#x27;帅得乱七八糟&#x27;</span>)<br>m1.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;a2&#x27;</span>, <span class="hljs-string">&#x27;帅得歪瓜裂枣&#x27;</span>)<br>m1.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;a3&#x27;</span>, <span class="hljs-string">&#x27;帅得一塌糊涂&#x27;</span>)<br>m1.<span class="hljs-built_in">set</span>(() =&gt; &#123; console.<span class="hljs-keyword">log</span>(<span class="hljs-string">&#x27;func&#x27;</span>)&#125;, <span class="hljs-string">&#x27;小呆呆能找到女朋友&#x27;</span> )  <span class="hljs-comment">// 错误</span><br><span class="hljs-comment">// 对于除了字符串类型，最好是赋值到一个变量后再放入set里面去</span><br><span class="hljs-keyword">let</span> b = () =&gt; &#123; console.<span class="hljs-keyword">log</span>(<span class="hljs-string">&#x27;func&#x27;</span>)&#125;;<br>m1.<span class="hljs-built_in">set</span>(b, <span class="hljs-string">&#x27;小呆呆能找到女朋友&#x27;</span>)<br></code></pre></td></tr></table></figure><p>（三）获取</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">console.<span class="hljs-built_in">log</span>(m1.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;a2&#x27;</span>));   <span class="hljs-comment"> // 帅得歪瓜裂枣</span><br>console.<span class="hljs-built_in">log</span>(m1.<span class="hljs-built_in">get</span>(b));      <span class="hljs-comment"> // &#x27;小呆呆能找到女朋友&#x27;</span><br></code></pre></td></tr></table></figure><p>（四）判断 —&gt; 只能放入键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">console.<span class="hljs-built_in">log</span>(m1.has(<span class="hljs-string">&#x27;a2&#x27;</span>));         <span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-literal">true</span><br>console.<span class="hljs-built_in">log</span>(m1.has(<span class="hljs-string">&#x27;帅得一塌糊涂&#x27;</span>)); <span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>（五）删除</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">m1.<span class="hljs-keyword">delete</span>(<span class="hljs-string">&#x27;a3&#x27;</span>)<br>console.log(m1.has(<span class="hljs-string">&#x27;a3&#x27;</span>));  <span class="hljs-regexp">//</span> false<br></code></pre></td></tr></table></figure><p>（六）清空</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">m1.<span class="hljs-built_in">clear</span>();<br>console.<span class="hljs-built_in">log</span>(m1)<br></code></pre></td></tr></table></figure><p>（七）键值对个数</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs processing">m1.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;a1&#x27;</span>, <span class="hljs-string">&#x27;帅得乱七八糟&#x27;</span>)<br>m1.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;a2&#x27;</span>, <span class="hljs-string">&#x27;帅得歪瓜裂枣&#x27;</span>)<br>m1.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;a3&#x27;</span>, <span class="hljs-string">&#x27;帅得一塌糊涂&#x27;</span>)<br>console.<span class="hljs-built_in">log</span>(m1.<span class="hljs-built_in">size</span>)   <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p><strong>再次强调！！</strong> <code>Map</code> 比 <code>对象</code>强的地方在于 <code>Map</code> 的下标(键)比<code>对象</code>的键更灵活，可以是任何类型!</p><p>（八）遍历 Map (注意：遍历其实就是迭代)</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">m1.<span class="hljs-keyword">forEach</span>((item, <span class="hljs-keyword">index</span>) =&gt; console.log(item, <span class="hljs-keyword">index</span>))   //item只会显示值不会显示键而 <span class="hljs-keyword">index</span> 会显示出键，不会显示值<br></code></pre></td></tr></table></figure><hr><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><blockquote><p>巧记： for…of(遍历数组) for…in(遍历对象)</p></blockquote><p>事实上最好别拿 for…in 来遍历数组(for…of 同理，别拿来遍历对象)</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs awk">let arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr.name = <span class="hljs-string">&#x27;我是谁&#x27;</span>;    <span class="hljs-regexp">//</span> 如果有人脑残，在arr中又以这样的方式增添了属性<br><br><span class="hljs-keyword">for</span> (let key <span class="hljs-keyword">in</span> arr) &#123;<br>  console.log(key);   <span class="hljs-regexp">//</span> 不仅arr下标打印还会把name也遍历了...<br>&#125;<br><br><span class="hljs-keyword">for</span> (let key of arr) &#123;<br>  <span class="hljs-regexp">//</span> <span class="hljs-keyword">for</span> of 相较于 forEach map 这些方法 能够有中断遍历功能<br>  <span class="hljs-regexp">//</span> <span class="hljs-keyword">break</span>;<br>  console.log(key);   <span class="hljs-regexp">//</span> 会遍历真正的数组元素。name 不会遍历<br>&#125;<br>let obj = &#123;<br>  name: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>  sex: <span class="hljs-string">&#x27;男&#x27;</span>,<br>  age: <span class="hljs-number">19</span><br>&#125;<br><br><span class="hljs-regexp">//</span> 遍历对象<br><span class="hljs-keyword">for</span> (let k <span class="hljs-keyword">in</span> obj) &#123;<br>  <span class="hljs-regexp">//</span> 如果是obj.k 以为是obj的k属性。但没有在obj里设置k<br>  <span class="hljs-regexp">//</span> 但要注意：如果是obj[k] k会被当成字符串的属性 例如 obj[<span class="hljs-string">&#x27;key&#x27;</span>]<br>  console.log(k, obj[k]);<br>&#125;<br><br>console.log(obj[<span class="hljs-string">&#x27;name&#x27;</span>]);   <span class="hljs-regexp">//</span> 小明<br></code></pre></td></tr></table></figure><hr><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p><strong>Set 容器(集合)</strong> ：无序 不可重复的多个 value 的集合体(不是键值对哦！)<br>理解为特殊数组，元素值不重复</p><p>其实和上面的 Map 的方法一样, 无外乎增删改查</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">// 创建一个空集合</span><br>let set1 = <span class="hljs-keyword">new</span> Set();<br><br><span class="hljs-comment">// 添加元素</span><br>set1.<span class="hljs-built_in">add</span>(<span class="hljs-string">&#x27;a&#x27;</span>)<br>set1.<span class="hljs-built_in">add</span>(<span class="hljs-string">&#x27;c&#x27;</span>)<br><br>console.<span class="hljs-built_in">log</span>(set1);<br>console.<span class="hljs-built_in">log</span>(set1.has(<span class="hljs-string">&#x27;b&#x27;</span>));  <span class="hljs-comment">// 集合中是否含有 &#x27;b&#x27;</span><br>set1.delete(<span class="hljs-string">&#x27;c&#x27;</span>);    <span class="hljs-comment">// 删除 &#x27;c&#x27;</span><br>set1.<span class="hljs-built_in">add</span>(<span class="hljs-string">&#x27;a&#x27;</span>);       <span class="hljs-comment">// 因为重复，所以只保留一个</span><br>console.<span class="hljs-built_in">log</span>(set1);<br>console.<span class="hljs-built_in">log</span>(set1.<span class="hljs-built_in">size</span>);   <span class="hljs-comment">// 元素个数</span><br>set1.<span class="hljs-built_in">clear</span>();        <span class="hljs-comment">// 清空集合</span><br>console.<span class="hljs-built_in">log</span>(set1);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅拷贝和深拷贝</title>
    <link href="/2021/10/08/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <url>/2021/10/08/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<blockquote><p>前置知识：值赋值和引用赋值就不再赘述了, 相对而言挺基础的…</p></blockquote><p>我已知的能够在<code>js</code>里实现<code>拷贝</code>的 3 种现成方法 🧐</p><h4 id="3-种现成的实现拷贝的方法"><a href="#3-种现成的实现拷贝的方法" class="headerlink" title="3 种现成的实现拷贝的方法"></a>3 种现成的实现拷贝的方法</h4><h5 id="1-JSON-大法"><a href="#1-JSON-大法" class="headerlink" title="1. JSON 大法"></a>1. JSON 大法</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> json大法<br>/**<br> * 优点：最简单的实现深拷贝的方式<br> * 缺点：<br> * 支持的数据类型：String<span class="hljs-regexp">/Number/</span>Boolean<span class="hljs-regexp">/Object/</span>Array/null<br> * 不支持的类型： undefined<span class="hljs-regexp">/Symbol/</span>循环引用<span class="hljs-regexp">/函数/</span>Date/RegExp<br> */<br><br> const obj1 = &#123;a: <span class="hljs-number">100</span>, b: &#123;key: <span class="hljs-string">&#x27;123&#x27;</span>&#125;&#125;<br> const obj2 = JSON.parse(JSON.stringify(obj1))<br>console.log(obj1 === obj2) <span class="hljs-regexp">//</span> false<br> 个人评价：事实上，<span class="hljs-number">90</span>%的情况下，上述方法已经够用了，一般不支持的类型这种用得少...<br></code></pre></td></tr></table></figure><h5 id="2-Object-assign-–-gt-浅拷贝"><a href="#2-Object-assign-–-gt-浅拷贝" class="headerlink" title="2.Object.assign() –&gt; 浅拷贝"></a>2.Object.assign() –&gt; 浅拷贝</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj3 = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-attr">sorce</span>: [<span class="hljs-number">88</span>, <span class="hljs-number">100</span>]&#125;<br><span class="hljs-keyword">var</span> obj4 = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, obj3)  <span class="hljs-comment">// obj1 与 &#123;&#125; 合并， 内部的引用还是一样的</span><br><span class="hljs-built_in">console</span>.log(obj3 === obj4) <span class="hljs-comment">// false</span><br><br>个人评价： 用法方便简单，但是注意是浅拷贝，在做一些项目的时候，需要有清晰的脑袋知道自己是在做深拷贝还是浅拷贝<br></code></pre></td></tr></table></figure><h5 id="3-Lodash-库"><a href="#3-Lodash-库" class="headerlink" title="3.Lodash 库"></a>3.Lodash 库</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// _.clone     浅拷贝</span><br><span class="hljs-comment">// _.deepclone 深拷贝</span><br><span class="hljs-keyword">var</span> obj5 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-attr">sorce</span>: [<span class="hljs-number">88</span>, <span class="hljs-number">100</span>]&#125;<br><span class="hljs-keyword">var</span> obj6 = _.cloneDeep(obj5);<br><span class="hljs-built_in">console</span>.log(obj5 === obj6)<br><br>个人评价： 不用说，牛逼！<br></code></pre></td></tr></table></figure><hr><h4 id="深拷贝实现"><a href="#深拷贝实现" class="headerlink" title="深拷贝实现"></a>深拷贝实现</h4><h5 id="本套深拷贝实现方法前置知识"><a href="#本套深拷贝实现方法前置知识" class="headerlink" title="本套深拷贝实现方法前置知识"></a>本套深拷贝实现方法前置知识</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> obj1 为一个普通对象<br>let obj1 = &#123;<br> name: <span class="hljs-string">&#x27;张三&#x27;</span>,<br> sex: <span class="hljs-string">&#x27;男&#x27;</span>,<br> age: <span class="hljs-number">18</span>,<br> friends: [<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-string">&#x27;小玉&#x27;</span>, <span class="hljs-string">&#x27;小萌&#x27;</span>]<br>&#125;<br><br><span class="hljs-regexp">//</span> 创建一个空对象 obj2<br>let obj2 = &#123;&#125;<br><span class="hljs-regexp">//</span> 依次将obj1对象里的属性赋值到obj2里(注意，要判断obj1里的属性是普通类型(值类型)还是引用类型)<br><span class="hljs-regexp">//</span> 值类型 直接复制。如果是引用类型还需要再深层进入引用类型中找到人家的值类型(递归大法)<br>obj2.name = obj1.name   <span class="hljs-regexp">//</span> 是否为普通类型<br>obj2.sex = obj1.sex     <span class="hljs-regexp">//</span> 是否为普通类型<br>obj2.age = obj1.age     <span class="hljs-regexp">//</span> 是否为普通类型<br>obj2.friends = obj1friends <span class="hljs-regexp">//</span> 遍历循环obj1friends。返回新的friends<br><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs awk">/**<br> * 数据类型<br> *<br> * typeof <span class="hljs-number">1</span>      <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;number&quot;</span><br> * typeof <span class="hljs-string">&quot;a&quot;</span>    <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;string&quot;</span><br> * typeof true   <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;boolean&quot;</span><br> * typeof &#123;&#125;     <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;object&quot;</span><br> * typeof []     <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;object&quot;</span><br> * typeof null   <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;object&quot;</span>   &lt;---  这里容易产生误会<br> * typeof undefined      <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;undefined&quot;</span><br> * typeof <span class="hljs-keyword">function</span>()&#123;&#125;   <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;function&quot;</span><br> * typeof Symbol()       <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;symbol&quot;</span><br> *<br> *<br> * Object.prototype.toString.call(<span class="hljs-number">1</span>)         <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;[object Number]&#x27;</span><br> * Object.prototype.toString.call(<span class="hljs-string">&#x27;a&#x27;</span>)       <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;[object String]&#x27;</span><br> * Object.prototype.toString.call(true)      <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;[object Boolean]&#x27;</span><br> * Object.prototype.toString.call(&#123;&#125;)        <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;[object Object]&#x27;</span><br> * Object.prototype.toString.call([])        <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;[object Array]&#x27;</span><br> * Object.prototype.toString.call(null)      <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;[object Null]&#x27;</span><br> * Object.prototype.toString.call(<span class="hljs-regexp">/a/</span>)       <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;[object RegExp]&#x27;</span><br> * Object.prototype.toString.call(undefined) <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;[object Undefined]&#x27;</span><br> * Object.prototype.toString.call(<span class="hljs-keyword">function</span>()&#123;&#125;)  <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;[object Function]&#x27;</span><br> * Object.prototype.toString.call(new Date())    <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;[object Date]&#x27;</span><br> */<br></code></pre></td></tr></table></figure><h5 id="开始实现深拷贝"><a href="#开始实现深拷贝" class="headerlink" title="开始实现深拷贝"></a>开始实现深拷贝</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> deepClone = <span class="hljs-function">(<span class="hljs-params">src</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">type</span> = <span class="hljs-built_in">Object</span>.prototype.toString.call(src).slice(<span class="hljs-number">8</span>, -<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">let</span> dist = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;Number&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> src;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;String&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> src;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;Boolean&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> src;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;Object&#x27;</span>) &#123;<br>    dist = &#123;&#125;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;Array&#x27;</span>) &#123;<br>    dist = []<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;Function&#x27;</span>) &#123;<br>    <span class="hljs-comment">// ... 这个挺有困惑的</span><br>    dist = src.bind(<span class="hljs-built_in">this</span>);   <span class="hljs-comment">// 生成了一个新的函数，this指向的是什么</span><br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> src) &#123;<br>    dist[key] = deepClone(src[key]);<br>  &#125;<br>  <span class="hljs-keyword">return</span> dist;<br>&#125;<br><br><span class="hljs-keyword">let</span> obj1 = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;100&#x27;</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-string">&#x27;200&#x27;</span>,<br>  <span class="hljs-attr">c</span>: &#123;<span class="hljs-attr">d</span>: <span class="hljs-string">&#x27;300&#x27;</span>, <span class="hljs-attr">e</span>: &#123;<span class="hljs-attr">f</span>: <span class="hljs-string">&#x27;500&#x27;</span>&#125;&#125;,<br>  <span class="hljs-attr">fn</span>: <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;this is a function&#x27;</span>)&#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> obj2 = deepClone(obj1);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;obj1 === obj2 ?&#x27;</span>, obj1 === obj2);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;obj2&#x27;</span>, obj2);<br><br></code></pre></td></tr></table></figure><head>  ..  <script src="//cdn.jsdelivr.net/npm/@waline/client"></script>  ...</head><body>  ...  <div id="waline"></div>  <script>    Waline({      el: '#waline',       avatar: 'monsterid',      serverURL: 'https://blog-api-9sizcti78-bruce-shuai.vercel.app/',    });  </script></body>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSON 基础知识 &amp; Ajax 基础知识</title>
    <link href="/2021/10/08/JSON&amp;Ajax%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/10/08/JSON&amp;Ajax%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h4 id="为什么我们要把对象转化为字符串？"><a href="#为什么我们要把对象转化为字符串？" class="headerlink" title="为什么我们要把对象转化为字符串？"></a>为什么我们要把对象转化为字符串？</h4><ol><li><p>在网页开发的时候，我们需要把<code>对象信息</code>进行长期保存, 因此我们需要把这些信息传递给<code>服务器</code>。所以，需要通过把对象(变量)转化为字符串才能传递给<code>服务器</code>。</p></li><li><p>我们采用的是<code>http协议</code>即超文本传输协议(其本质就是由文本的形式进行传输)</p></li><li><p>JSON 字符串是绝大多数编程语言都支持的…</p></li></ol><h4 id="JSON-字符串的特征"><a href="#JSON-字符串的特征" class="headerlink" title="JSON 字符串的特征"></a>JSON 字符串的特征</h4><ol><li><strong>属性名称</strong>必须加<strong>双引号</strong> (因为人家默认规定的字符串外层是<code>单引号</code>，所以内层必须是<code>双引号</code>)</li><li><strong>属性值</strong>如果是字符串则必须加<strong>双引号</strong></li><li>对象当中的<code>方法(函数)</code>不会被转化为字符串</li></ol><p>(注意： JSON 本质就是字符串！！)</p><h4 id="JSON-和-对象的相互转换："><a href="#JSON-和-对象的相互转换：" class="headerlink" title="JSON 和 对象的相互转换："></a>JSON 和 对象的相互转换：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xiaoming&#x27;</span>,<br>  <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;boy&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>  <span class="hljs-function"><span class="hljs-title">say</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;想吃, 想喝, 想爱&#x27;</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 把对象转为JSON字符串</span><br><span class="hljs-keyword">let</span> str1 = <span class="hljs-built_in">JSON</span>.stringify(obj);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;obj&#x27;</span>, obj);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;str1&#x27;</span>, str1);   <span class="hljs-comment">// 纯粹的字符串且没有say方法</span><br><br><span class="hljs-comment">// 把数组转为JSON字符串</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">100</span>, &#123;<span class="hljs-attr">key</span>: <span class="hljs-number">100</span>, <span class="hljs-attr">obj</span>: &#123;&#125;, <span class="hljs-attr">str</span>: <span class="hljs-string">&#x27;测试&#x27;</span>&#125;]<br><span class="hljs-keyword">let</span> str2 = <span class="hljs-built_in">JSON</span>.stringify(arr);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;arr&#x27;</span>, arr);<br><span class="hljs-comment">// 内部的字符串元素全部被强制转化为双引号,数值不加引号，</span><br><span class="hljs-comment">// 对象元素进行深层改造(加双引号..),而且不再是对象，而是字符串了...</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;str2&#x27;</span>, str2);<br></code></pre></td></tr></table></figure><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs openscad"><span class="hljs-comment">// JSON字符串转成对象</span><br><span class="hljs-comment">// JSON 字符串外层是单引号哦!!</span><br><span class="hljs-built_in">let</span> <span class="hljs-built_in">str</span> = &#x27;&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>: <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">18</span>&#125;&#x27;<br><span class="hljs-built_in">let</span> obj = JSON.parse(<span class="hljs-built_in">str</span>);<br>console.<span class="hljs-built_in">log</span>(&#x27;obj.name&#x27;, obj.name);   <span class="hljs-comment">// 小明</span><br></code></pre></td></tr></table></figure><hr><h4 id="手写-ajax-核心方法"><a href="#手写-ajax-核心方法" class="headerlink" title="手写 ajax 核心方法"></a>手写 ajax 核心方法</h4><p>哈哈, 以不负责任的态度来说 🤪</p><blockquote><p><code>前端</code> 是用来显示数据的<br><code>后端</code> 是用来提供数据的</p></blockquote><p>所以，前端有一个非常重要的工作是向后端索要<code>数据</code>并将数据进行页面显示</p><p>如何向后端索要数据呢？</p><h5 id="书写-ajxa-4-个核心步骤"><a href="#书写-ajxa-4-个核心步骤" class="headerlink" title="书写 ajxa 4 个核心步骤"></a>书写 ajxa 4 个核心步骤</h5><blockquote><p>4 个步骤！但要注意执行顺序哦！</p></blockquote><ol><li>创建一个请求对象, js 提供的构造函数 XMLHttpRequest(分开记忆：XML Http Request)</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-constructor">XMLHttpRequest()</span><br></code></pre></td></tr></table></figure><ol start="2"><li><p>设置请求的数据得到返回时的处理函数</p><blockquote><p>xhr.onloadend(分开记忆：on load end) –&gt; 执行方式有点类似 onclick 这类函数</p></blockquote></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">xhr.onloadend = <span class="hljs-keyword">function</span>() &#123;<br>  <span class="hljs-regexp">//</span> 该数据全是服务器返回的json字符串<br>  <span class="hljs-regexp">//</span> 请求的数据放在哪了？请求的数据其实放在了请求对象上面<br>  xhr.responseText<br>  <span class="hljs-regexp">//</span> 进行转化<br>  let stus = JSON.parse(xhr.responseText)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>设置请求信息</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">向谁请求：<br>例如 http:<span class="hljs-regexp">//</span>www.jd.com、http:<span class="hljs-regexp">//</span>www.baidu.com<br>xhr.open(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/todos&#x27;</span>)<br></code></pre></td></tr></table></figure><ol start="4"><li>发送请求</li></ol><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">xhr.<span class="hljs-built_in">send</span>()<br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 整体操作如下：</span><br><br><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-constructor">XMLHttpRequest()</span>;<br>xhr.oploadend = <span class="hljs-keyword">function</span><span class="hljs-literal">()</span> &#123;<br>  <span class="hljs-keyword">let</span> stus = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JSON</span>.</span></span>parse(xhr.responseTest)<br>  show<span class="hljs-constructor">Table(<span class="hljs-params">stus</span>)</span><br>&#125;<br>xhr.<span class="hljs-keyword">open</span>(&#x27;get&#x27;, &#x27;https:<span class="hljs-comment">//jsonplaceholder.typicode.com/todos&#x27;);</span><br>xhr.send<span class="hljs-literal">()</span>;<br></code></pre></td></tr></table></figure><head>  ..  <script src="//cdn.jsdelivr.net/npm/@waline/client"></script>  ...</head><body>  ...  <div id="waline"></div>  <script>    Waline({      el: '#waline',       avatar: 'monsterid',      serverURL: 'https://blog-api-9sizcti78-bruce-shuai.vercel.app/',    });  </script></body>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一篇文章解决Promise...then，async/await执行顺序类型题</title>
    <link href="/2021/10/08/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E8%A7%A3%E5%86%B3Promise-then%EF%BC%8Casync-await%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    <url>/2021/10/08/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E8%A7%A3%E5%86%B3Promise-then%EF%BC%8Casync-await%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E7%B1%BB%E5%9E%8B%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>最近我在沸点里摸鱼的时候，发现了一些掘友在不约而同的讨论一种类型的题，即 Promise…then, async/await 执行顺序类型的题。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61f40af93cec47d281efaa67db337670~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-06-10 下午10.18.25.png"></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdb16e753c6742ae94f531022a41d789~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-06-10 下午10.16.31.png"><br>恰好，在前一段时间我对此种类型的题有所研究 📃。因此，我也想趁这个机会看看是否能把这种类型的题讲述清楚。</p><p>废话就不多说了，先出几道题，大伙试试看，能不能把这几道题做出来！<br>（注：以下题目都是从网上以及掘友发的沸点里获取的）</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">题目一：<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">100</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">200</span>);<br>&#125;)<br><span class="hljs-built_in">Promise</span>.resolve().<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">300</span>);<br>&#125;)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">400</span>);<br>求打印结果：<br></code></pre></td></tr></table></figure><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">题目二：<br><span class="hljs-built_in">Promise</span>.resolve().<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;error1&#x27;</span>)<br>&#125;).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);<br>&#125;)<br>求打印结果：<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript">题目三：<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async1 start&#x27;</span>);<br>  <span class="hljs-keyword">await</span> async2();<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async1 end&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async2&#x27;</span>);<br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script start&#x27;</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>)<br>async1()<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span> (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>  resolve()<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise2&#x27;</span>)<br>&#125;)<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script end&#x27;</span>)<br>求打印结果：<br></code></pre></td></tr></table></figure><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">题目四：<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>);<br>  resolve();<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2&#x27;</span>);<br>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3&#x27;</span>);<br>    resolve();<br>  &#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;4&#x27;</span>);<br>  &#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;5&#x27;</span>);<br>  &#125;)<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;6&#x27;</span>);<br>&#125;)<br><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;7&#x27;</span>);<br>  resolve()<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;8&#x27;</span>);<br>&#125;)<br>求打印结果：<br></code></pre></td></tr></table></figure><p>不知道大家对于上面四道题是否感觉有点恶心？哈哈，如果感到恶心，就对了！跟着这篇文章走，相信大家在文章看完之后能轻松解决上面的几道题！</p><p>废话不多说，如果有兴趣就接着往下看吧！</p><hr><p>首先我们需要知道这类题型实质是在考察以下几个内容</p><ul><li>异步</li><li>event loop 执行机制</li><li>Promise 语法</li><li>async/await 语法</li><li>宏任务、微任务</li></ul><p>其实，掌握了上述的五个内容，无论这类题型怎么变，你都能将题玩于股掌之间(他强任他强，清风拂山岗)。</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>由于能开始思考这道题的兄弟，想必还是有一定的 JS 基础。所以我也不再细讲啥是异步、以及 event loop 执行机制了(这类博文网上一抓一大把~)。我只简单分享一下我对于异步的一些感悟：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-number">1</span>、异步是用来解决JS单线程等待这种问题的<br><span class="hljs-number">2</span>、异步是基于回调函数的形式来实现的<br><span class="hljs-number">3</span>、常见的异步有：<span class="hljs-built_in">setTimeout</span>、ajax、<span class="hljs-built_in">Promise</span>……<span class="hljs-keyword">then</span>、<span class="hljs-keyword">async</span>/<span class="hljs-keyword">await</span>、图片加载、网络请求资源<br><span class="hljs-number">4</span>、牢记<span class="hljs-number">5</span>个版块  Call Stack、 Web APIs、 Browser <span class="hljs-built_in">console</span>、 Callback Queue<br>、 micro task queue 这五个版块透露出异步的执行过程<br><span class="hljs-number">5</span>、宏任务是在DOM渲染后触发，微任务是在DOM渲染前触发<br></code></pre></td></tr></table></figure><h3 id="Promise、-Async-await"><a href="#Promise、-Async-await" class="headerlink" title="Promise、 Async/await"></a>Promise、 Async/await</h3><p>很多讲<code>Promise</code>的文章都说过，<code>Promise</code>的出现是为了解决臭名昭著的<code>callback hell</code>。由于异步是基于回调函数的形式来实现的，那么异步就离不开回调函数。但在上古时期，反人类的嵌套回调让老一辈的程序员们苦不堪言…而 Promise 搭配 then 展现的管道式回调函数，让异步更直观、更优雅的展现出来，广受大家好评！</p><p>而<code>async/await</code> 是 ECMAScript 2017 提出的内容。但事实上它们只是<code>Promise</code>的语法糖，但这颗 🍬 贼甜！</p><p>针对<code>Promise</code>以及<code>async/await</code>的骚用法，我想尝试用千层饼的套路来讲讲~</p><h5 id="第一层："><a href="#第一层：" class="headerlink" title="第一层："></a>第一层：</h5><p>Promise 是一个类（函数），接受一个回调函数作为参数，并且这个回调函数的参数也有两个，这两个参数约定俗成被命名为 <code>resolve</code>, <code>reject</code></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    ...<br>&#125;)<br></code></pre></td></tr></table></figure><h5 id="第二层："><a href="#第二层：" class="headerlink" title="第二层："></a>第二层：</h5><p><code>resolve</code>, <code>reject</code>这两个参数其实也都是函数</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gcode">Promise<span class="hljs-comment">((resolve, reject)</span> =&gt; &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-comment">(...)</span> &#123;<br>        resolve<span class="hljs-comment">(...)</span>;     <span class="hljs-comment">// 执行resolve函数</span><br>    &#125; else &#123;<br>        reject<span class="hljs-comment">(...)</span>;      <span class="hljs-comment">// 执行reject函数</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h5 id="第三层："><a href="#第三层：" class="headerlink" title="第三层："></a>第三层：</h5><p>对于紧跟 Promise 实例的<code>then</code>，其参数等于<code>resolve</code>接受的参数；紧跟 Promise 实例的<code>catch</code>，其参数等于<code>reject</code>接受的参数。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve)</span> =&gt;</span> &#123;    <span class="hljs-regexp">//</span> p为<span class="hljs-built_in">Promise</span>实例<br>    const a = <span class="hljs-number">100</span>;<br>    resolve(a);<br>&#125;)<br><br>p1.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(param)</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;param:&#x27;</span>, param);      <span class="hljs-regexp">//</span> param: <span class="hljs-number">100</span><br>&#125;)<br><br>const p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    const a = <span class="hljs-number">100</span>;<br>    reject(a);<br>&#125;)<br><br>p2.<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">(param)</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;param&#x27;</span>, param);<br>&#125;)<br><br></code></pre></td></tr></table></figure><h5 id="第四层："><a href="#第四层：" class="headerlink" title="第四层："></a>第四层：</h5><p>Promise 的实例有三种状态： <code>pending(加载中)</code>、<code>fulfilled(执行成功)</code>、<code>rejected(执行错误)</code>。其实我们很好理解这三种状态，因为它们恰好对应了<code>异步正在执行</code>和<code>异步执行完的结果</code>(无非成功或失败两种状态)这三种状态</p><p>三种状态的表现：</p><ul><li>pending: Promise 实例处于<code>pending</code>状态时，不会触发 then 和 catch。</li><li>fufilled: Promise 实例处于<code>fulfilled</code>状态时，只会触发 then(不会触发 catch)</li><li>rejected： Promise 实例处于<code>rejected</code>状态时，只会触发 catch(不会触发 then)</li></ul><p>(无论是 then 还是 catch，它们里面都是回调函数)</p><p>那么问题来了，如何判断 Promise 实例对象是处于那种状态呢？</p><p>很简单，看下面代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 啥也没有做~</span><br>&#125;)<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;p&#x27;</span>, p);<br></code></pre></td></tr></table></figure><p>Chrome 控制台显示结果如下图：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a40d9c5af8794683b9660bd378bd0316~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-06-12 下午9.00.33.png"></p><p>截图说明了此时的 Promise 实例是处于<code>pending</code>状态的。其实，当 Promise 内部的回调不执行<code>resolve</code>或<code>reject</code>的时候，Promise 实例就处于<code>pending</code>状态！</p><p>再看下面的代码 👇🏻</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;    <span class="hljs-comment">// p1为Promise实例</span><br>     <span class="hljs-keyword">const</span> a = <span class="hljs-number">100</span>;<br>     resolve(a);<br> &#125;)<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;p1&#x27;</span>, p1)    <span class="hljs-comment">// fulfilled</span><br><br> <span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>     <span class="hljs-keyword">const</span> a = <span class="hljs-number">100</span>;<br>     reject(a);<br> &#125;)<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;p2&#x27;</span>, p2)    <span class="hljs-comment">// rejected</span><br></code></pre></td></tr></table></figure><p>Chrome 控制台显示结果如下图：<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/508e710a9a0847d69cc13e1f79e03ef7~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-06-12 下午9.03.58.png"></p><p>这里的代码是借用的第三层的代码，其实看到这儿就解释了第三层的套路。对于第一个 Promise 实例执行参数<code>resolve</code>就代表了，当前 Promise 实例对象的状态为<code>fulfilled</code>，因此接下来可以触发 then，以及对应的回调。如果 Promise 实例对象执行了<code>reject</code>，则实例对象的状态变为了 <code>rejected</code>，可以触发 catch~ 有兴趣的小伙伴可以试试，在<code>fulfilled</code>状态执行下 catch 或者在<code>rejected</code>状态下执行下 then，试试能否执行代码成功。</p><h5 id="第五层："><a href="#第五层：" class="headerlink" title="第五层："></a>第五层：</h5><p>在第五层有 3 句至理名言需要知道(不需要去死记硬背，下面我会用例子帮助你理解)</p><blockquote><p>无论是 then 还是 catch 里的回调内容只要代码正常执行或者正常返回，则当前新的 Promise 实例为 fulfilled 状态。如果有报错或返回 Promise.reject()则新的 Promise 实例为 rejected 状态。</p></blockquote><blockquote><p>fulfilled 状态能够触发 then 回调</p></blockquote><blockquote><p>rejected 状态能够触发 catch 回调</p></blockquote><p>举例之前我先补充一个小知识！</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Promise</span>.resolve()  表示一个fulfilled状态的<span class="hljs-built_in">Promise</span>实例<br><span class="hljs-built_in">Promise</span>.reject()   表示一个rejected状态的<span class="hljs-built_in">Promise</span>实例<br></code></pre></td></tr></table></figure><p>好，我将放码过来！</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">题目一：<br><span class="hljs-built_in">Promise</span>.resolve().<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>&#125;).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><p>初看此题，感觉似乎此题有点难度~ 不过，结合我的三句至理名言，我们一起来分析一下此题！！</p><p><code>Promise.resolve()</code> 是一个状态为<code>fulfilled</code>状态的 Promise 实例。<code>fulfilled</code>状态能够触发 then 回调。因此，第一个 then 会被执行，并且能够顺利打印结果而不报错！故 Promise.resolve().then(() =&gt; {console.log(1)}) 这个新的 Promise 实例为<code>fulfilled</code>状态，所以可以触发下一个 then，但是无法触发 catch，故 catch 的内容忽略，从而执行第二个 then 的内容。 所以，此题的打印结果为： 1 3</p><p>好了，下面再来看看第二题(此题也是文章开头出的第二题)：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Promise</span>.resolve().<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;error1&#x27;</span>);<br>&#125;).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>有了上一题的经验，做这一道题就轻松很多了~ Promise.resolve()是一个<code>fulfilled</code>状态的实例，所以可以触发 then，而第一个 then 之中有 throw new Error(‘error1’) 这种报错操作，则 Promise.resolve.then(() =&gt; {<br>console.log(1);<br>throw new Error(‘error1’)<br>})就是一个<code>rejected</code>状态的 Promise 实例，所以可以触发 catch，catch 的内容是可以正常执行的，没有报错误，则 Promise.resolve().then(…).catch(…)是一个<code>fulfilled</code>状态的 Promise 实例，可以触发 then，故 then 的内容能够被执行。</p><p>故代码结果为： 1 2 3</p><h5 id="第六层："><a href="#第六层：" class="headerlink" title="第六层："></a>第六层：</h5><p>做了前面两道题，不知道大家有没有一点困惑。感觉我似乎有意回避了 then、catch 的返回值即(return …),而且也没有在 then、catch 里写具体的参数。导致我在第五层的第一句至理名言“无论是 then 或者 catch 里的内容只要正常执行或者正常返回…”也没有完全体现出来。 大家别慌，其实这正是我要讲的第六层套路~</p><p>then、catch 参数的来头其实就是我在第三层套路里就讲过<code>“紧跟Promise实例的then的参数等于resolve接受的参数；紧跟Promise实例的catch的参数等于reject接受的参数。”</code>。如果 then、catch 里的回调，没有写返回内容，则 then 或 catch 后面即将被触发的 then 或 catch 是无法接受到参数的；而如果有返回内容，即 return… 那么无论返回的是普通值还是是 Promise 实例，其实都会对应被转化为 Promise 的实例(Promise.resolve(…)或者 Promise.reject(…))</p><p>结合代码再来理解一下~</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">&#x27;我想出错&#x27;</span>).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">(err)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(err);<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;我不想出错&#x27;</span>;  <span class="hljs-regexp">//</span> 会被自动封装成<span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">&#x27;我不想出错&#x27;</span>)<br>&#125;).<span class="hljs-keyword">then</span>(data =&gt; &#123;<br>  <span class="hljs-built_in">console</span>.log(data);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">&#x27;我不想出错&#x27;</span>)<br>&#125;).<span class="hljs-keyword">then</span>(data =&gt; &#123;<br>  <span class="hljs-built_in">console</span>.log(data);<br>&#125;)<br></code></pre></td></tr></table></figure><p>代码打印结果：<br>我想出错<br>我不想出错<br>我不想出错</p><h5 id="第七层："><a href="#第七层：" class="headerlink" title="第七层："></a>第七层：</h5><p>第七层套路，我来谈谈 async/await。 因为 Promise 的出现主要是为了解决异步的回调地狱问题。将噩梦般的嵌套回调变为了优雅的管道式回调。但这始终是逃不掉“回调”二字。而 async/await 虽说只是 Promise 的语法糖，但让你“脱离”了回调，拥抱了同步代码~</p><p>下面我再分享大家五句经典语录~</p><blockquote><p>执行 async 函数，返回的是 Promise 对象</p></blockquote><blockquote><p>await 必须在 async 包裹之下执行</p></blockquote><blockquote><p>await 相当于 Promise 的 then 并且同一作用域下 await 下面的内容全部作为 then 中回调的内容</p></blockquote><blockquote><p>try……catch 可捕获异常，代替了 Promise 的 catch</p></blockquote><blockquote><p>异步中先执行微任务，再执行宏任务</p></blockquote><p>且看下面的代码分析：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;我是async函数&#x27;</span>;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async:&#x27;</span>, fn());<br></code></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d97ad91369b344ee8e168444253fa1b0~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-06-13 下午10.23.56.png"></p><p>这里的 fn() 相当于 Promise.resolve(‘我是 async 函数’)，验证了第一条语录！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">&#x27;帅得乱七八糟&#x27;</span>);<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> p; <span class="hljs-comment">// await就相当于Promise.then, 故data就是then的参数</span><br>  <span class="hljs-built_in">console</span>.log(data);    <span class="hljs-comment">// 这里的代码为then中回调的内容</span><br>&#125;)()<br></code></pre></td></tr></table></figure><p>上面的这段代码，大家可以试着把<code>async</code>删掉，结果一定会报错！这就验证了第二条语录！上面代码的注释结合第三条语录，大家应该能够体会到<code>await</code>的作用！</p><p>再看下面一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">&#x27;err&#x27;</span>);<br>  <span class="hljs-comment">// await + try...catch 相当于 Promise.catch</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> p;<br>    <span class="hljs-built_in">console</span>.log(res);<br>  &#125; <span class="hljs-keyword">catch</span>(ex) &#123;  <span class="hljs-comment">// ex 来源于reject()里面的数</span><br>    <span class="hljs-built_in">console</span>.error(ex);<br>  &#125;<br>&#125;)()<br></code></pre></td></tr></table></figure><p>打印结果为 err，验证了第四条语录。</p><p>在此补充一点内容：</p><ul><li>常见的微任务： Promise……then、 async/await</li><li>常见的宏任务： setTimeout、setInterval<blockquote><p>考虑过在文章里谈谈宏任务和微任务的执行机制，但限于篇幅以及本篇文章的侧重点在于解题于是就不过多赘述其他内容了，有兴趣的朋友可以在评论区讨论一下。</p></blockquote></li></ul><p>其实看到这儿，文章开始出的所有题目都能够解决了。不信就试试 💪🏻</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript">题目三:<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async1 start&#x27;</span>);<br>  <span class="hljs-keyword">await</span> async2();<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async1 end&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async2&#x27;</span>);<br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script start&#x27;</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>)<br>async1()<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span> (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>  resolve()<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise2&#x27;</span>)<br>&#125;)<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script end&#x27;</span>)<br></code></pre></td></tr></table></figure><p>此题需要注意两个点</p><ol><li>new Promise()内部的回调函数是当成同步函数执行</li><li>执行到 await code 时，会先执行 code，再执行 await</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql">代码分析：<br><span class="hljs-number">1.</span> 先执行同步代码。<br><span class="hljs-number">2.</span> 所以首先执行 console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>);<br><span class="hljs-number">3.</span> setTimeout为宏任务，先不执行<br><span class="hljs-number">4.</span> 执行async1函数 console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async1 start&#x27;</span>); 以及 async2(); await由于是Promise.then的语法糖是异步代码，先不执行<br><span class="hljs-number">5.</span> <span class="hljs-keyword">new</span> Promise() 内部代码要执行，后面的<span class="hljs-keyword">then</span>的内容为微任务先不执行<br><span class="hljs-number">6.</span>执行console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>)<br><span class="hljs-number">7.</span>同步代码执行结束<br><span class="hljs-number">8.</span>开始按代码顺序执行微任务<br><span class="hljs-number">9.</span>先执行 console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async1 end&#x27;</span>); 前面说过，await下面的代码相当于<span class="hljs-keyword">then</span>里回调的内容<br><span class="hljs-number">10.</span><span class="hljs-keyword">new</span> Promise.then里面的内容 console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;promise2&#x27;</span>)<br><span class="hljs-number">11.</span> 最后执行 宏任务代码，即setTimeout里的内容<br><br>执行结果：<br>script <span class="hljs-keyword">start</span><br>async1 <span class="hljs-keyword">start</span><br>async2<br>promise1<br>script <span class="hljs-keyword">end</span><br>async1 <span class="hljs-keyword">end</span><br>promise2<br>setTimeout<br></code></pre></td></tr></table></figure><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">题目四：<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>);<br>  resolve();<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2&#x27;</span>);<br>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3&#x27;</span>);<br>    resolve();<br>  &#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;     <span class="hljs-regexp">//</span> 📌<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;4&#x27;</span>);<br>  &#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;5&#x27;</span>);<br>  &#125;)<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;6&#x27;</span>);   <span class="hljs-regexp">//</span> 📌<br>&#125;)<br><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;7&#x27;</span>);<br>  resolve()<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;8&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql">代码分析：<br><span class="hljs-number">1.</span>先执行同步代码<br><span class="hljs-number">2.</span>setTimeout 为宏任务，先不执行<br><span class="hljs-number">3.</span><span class="hljs-keyword">new</span> Promise里的代码作为同步代码，要执行 console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;1&#x27;</span>); 而<span class="hljs-keyword">then</span>作为微任务，先不执行<br><span class="hljs-number">4.</span>又是一个<span class="hljs-keyword">new</span> Promise,所以和第三步同理。只执行 console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;7&#x27;</span>);<br><span class="hljs-number">5.</span>开始执行异步代码<br><span class="hljs-number">6.</span>执行第一个<span class="hljs-keyword">new</span> Promise里的<span class="hljs-keyword">then</span> 即console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;2&#x27;</span>);以及<span class="hljs-keyword">new</span> Promise的同步代码 console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;3&#x27;</span>);<br><span class="hljs-number">7.</span>这步有点意思，这里不是执行console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;4&#x27;</span>); 而是执行console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;8&#x27;</span>);<br><span class="hljs-number">8.</span>注释为📌的两个<span class="hljs-keyword">then</span>是同层级的，所以按照执行顺序来打印<br><span class="hljs-number">9.</span>执行第三个层级的<span class="hljs-keyword">then</span>，所有微任务代码完成<br><span class="hljs-number">10.</span>执行宏任务代码，即console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;0&#x27;</span>);<br><br>代码结果：<br><span class="hljs-number">1</span><br><span class="hljs-number">7</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">8</span><br><span class="hljs-number">4</span><br><span class="hljs-number">6</span><br><span class="hljs-number">5</span><br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>说有千层饼套路，其实只有 7 层套路，但这每一层套路都是我对于 Promise、async/await 的感悟，有些内容并未细讲，比如微任务、宏任务与 DOM 之间的执行顺序这种相对底层的内容本文并未谈及，毕竟这篇文章的侧重点是在解决 Promise、async/await 执行顺序类型题。本文也可能有内容错误或逻辑错误，也请大家多多包涵，多多指出，谢谢！！</p><p>好了，大功已告成！想必通过这些题，大家已经领悟到了解决此类题型的奥义！</p><head>  ..  <script src="//cdn.jsdelivr.net/npm/@waline/client"></script>  ...</head><body>  ...  <div id="waline"></div>  <script>    Waline({      el: '#waline',       avatar: 'monsterid',      serverURL: 'https://blog-api-9sizcti78-bruce-shuai.vercel.app/',    });  </script></body>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有效括号问题</title>
    <link href="/2021/10/07/%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E9%97%AE%E9%A2%98/"/>
    <url>/2021/10/07/%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs awk">/**<br> * 题目描述：给定一个只包括<span class="hljs-string">&#x27;(&#x27;</span>, <span class="hljs-string">&#x27;)&#x27;</span>, <span class="hljs-string">&#x27;&#123;&#x27;</span>, <span class="hljs-string">&#x27;&#125;&#x27;</span>, <span class="hljs-string">&#x27;[&#x27;</span>, <span class="hljs-string">&#x27;]&#x27;</span>的字符串,判断字符串是否有效<br> * <br> * 记住一个规律： 括号成立 意味着 对称性<br> */<br><br><span class="hljs-regexp">//</span> 括号问题，我们一般首选栈来做    ----&gt;   对称性<br><br><span class="hljs-regexp">//</span> 用一个map来维护左括号和右括号的对应关系<br><span class="hljs-regexp">//</span> map 关系真的非常的好用<br><span class="hljs-regexp">//</span> const leftToRight = &#123;<br><span class="hljs-regexp">//</span>   <span class="hljs-string">&quot;(&quot;</span>:<span class="hljs-string">&quot;)&quot;</span>,<br><span class="hljs-regexp">//</span>   <span class="hljs-string">&quot;&#123;&quot;</span>:<span class="hljs-string">&quot;&#125;&quot;</span>,<br><span class="hljs-regexp">//</span>   <span class="hljs-string">&quot;[&quot;</span>:<span class="hljs-string">&quot;]&quot;</span><br><span class="hljs-regexp">//</span> &#125;<br><br><span class="hljs-regexp">//</span> /**<br><span class="hljs-regexp">//</span>  * @param &#123;string&#125; s<br><span class="hljs-regexp">//</span>  * @return &#123;boolean&#125;<br><span class="hljs-regexp">//</span>  */<br><br><span class="hljs-regexp">//</span> <span class="hljs-regexp">//</span> 有些细节 我<br><span class="hljs-regexp">//</span> const isValid = <span class="hljs-keyword">function</span>(s) &#123;<br><span class="hljs-regexp">//</span>   <span class="hljs-regexp">//</span> 结合题意，空字符串无条件判断为 true<br><span class="hljs-regexp">//</span>   <span class="hljs-keyword">if</span> (!s) &#123;<br><span class="hljs-regexp">//</span>     return true;<br><span class="hljs-regexp">//</span>   &#125;<br><span class="hljs-regexp">//</span>   <span class="hljs-regexp">//</span> 初始化 stack 数组<br><span class="hljs-regexp">//</span>   const stack = [];<br><span class="hljs-regexp">//</span>   <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;<br><span class="hljs-regexp">//</span>     <span class="hljs-keyword">if</span> (s[i] === <span class="hljs-string">&#x27;(&#x27;</span> || s[i] === <span class="hljs-string">&#x27;&#123;&#x27;</span> || s[i] === <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br><span class="hljs-regexp">//</span>       stack.push(leftToRight[s[i]])<br><span class="hljs-regexp">//</span>     &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-regexp">//</span>       <span class="hljs-regexp">//</span> 但是人家写的是!stack.length || stack.pop() !== ch  好奇怪...<br><span class="hljs-regexp">//</span>       <span class="hljs-keyword">if</span> (stack.pop() !== s[i]) &#123;<br><span class="hljs-regexp">//</span>         return false;<br><span class="hljs-regexp">//</span>       &#125;<br><span class="hljs-regexp">//</span>     &#125;<br><span class="hljs-regexp">//</span>   &#125;<br><span class="hljs-regexp">//</span>   <span class="hljs-regexp">//</span> 若所有的括号都能配对成功，那么最后栈应该是空的<br><span class="hljs-regexp">//</span>   <span class="hljs-regexp">//</span> return !stack.length;<br><br><span class="hljs-regexp">//</span>   return true;<br><span class="hljs-regexp">//</span> &#125;<br><br><br><br><span class="hljs-regexp">//</span> 注意： ))))(((( 这种是错误的。左括号必须以正确的顺序闭合<br><br><span class="hljs-regexp">//</span> 对象映射大法 ----&gt;  注意！变量名千万搞错不能出错, 有时要好好检查检查自己的变量名...<br>const leftToRight = &#123;<br>  <span class="hljs-string">&quot;&#123;&quot;</span>:<span class="hljs-string">&quot;&#125;&quot;</span>,<br>  <span class="hljs-string">&quot;(&quot;</span>:<span class="hljs-string">&quot;)&quot;</span>,<br>  <span class="hljs-string">&quot;[&quot;</span>:<span class="hljs-string">&quot;]&quot;</span><br>&#125;<br><br><br><span class="hljs-regexp">//</span> 我自己想到一个方法。设置两个栈。一个栈放入左侧符号的映射。  一个栈放入右侧符号。 两个栈进行一一对比<br>const isValid = (str) =&gt; &#123;<br>  const stack = [];<br>  <span class="hljs-regexp">//</span> 数组缓存<br>  let len = str.length;<br><br>  <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>    <span class="hljs-keyword">if</span> (str[i] === <span class="hljs-string">&#x27;&#123;&#x27;</span> || str[i] === <span class="hljs-string">&#x27;[&#x27;</span> || str[i] === <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>      stack.push(leftToRight[str[i]]);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stack.length !== <span class="hljs-number">0</span> &amp;&amp; str[i] === stack[stack.length - <span class="hljs-number">1</span>]) &#123;<br>      stack.pop();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stack.length === <span class="hljs-number">0</span>) &#123;<br>      return false;<br>    &#125;<br>  &#125;<br>  return stack.length === <span class="hljs-number">0</span>;<br>&#125;<br><br>console.log(<span class="hljs-string">&#x27;test&#x27;</span>, isValid(<span class="hljs-string">&#x27;()[]&#123;&#125;&#x27;</span>));<br></code></pre></td></tr></table></figure><head>  ..  <script src="//cdn.jsdelivr.net/npm/@waline/client"></script>  ...</head><body>  ...  <div id="waline"></div>  <script>    Waline({      el: '#waline',       avatar: 'monsterid',      serverURL: 'https://blog-api-9sizcti78-bruce-shuai.vercel.app/',    });  </script></body>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>栈类相关问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开始我的个人博客之旅啦</title>
    <link href="/2021/10/07/%E5%BC%80%E5%A7%8B%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85%E5%95%A6/"/>
    <url>/2021/10/07/%E5%BC%80%E5%A7%8B%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85%E5%95%A6/</url>
    
    <content type="html"><![CDATA[<p>这篇博客只是用来测试一下网站 哈哈哈<br>祝福看见这篇博客的你 永远快乐哦!</p><head>  ..  <script src="//cdn.jsdelivr.net/npm/@waline/client"></script>  ...</head><body>  ...  <div id="waline"></div>  <script>    Waline({      el: '#waline',      serverURL: 'https://blog-api-9sizcti78-bruce-shuai.vercel.app/',    });  </script></body>]]></content>
    
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/10/06/hello-world/"/>
    <url>/2021/10/06/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
