

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="分享知识、感受生活~">
  <meta name="author" content="帅得乱七八糟">
  <meta name="keywords" content="">
  <meta name="description" content="JS 的执行机制执行上下文 只有理解了 JS 的执行上下文，才能更好地理解 JS 语言本身(包括变量提升、作用域、闭包等)  变量提升在写 JS 代码的时候，会发现一个特性，即：在第一个变量定义之前使用它，不会报错(没定义就使用则会报错)，但是该变量的值会为undefined，而不是定义时的值。在一个函数定义之前使用它，不会出错，且函数能正确执行 出现该特性的原因就是 变量提升 JS 中的声明和赋">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面试之道 JS">
<meta property="og:url" content="http://example.com/2021/12/08/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93-JS/index.html">
<meta property="og:site_name" content="何阳阳阳的小屋">
<meta property="og:description" content="JS 的执行机制执行上下文 只有理解了 JS 的执行上下文，才能更好地理解 JS 语言本身(包括变量提升、作用域、闭包等)  变量提升在写 JS 代码的时候，会发现一个特性，即：在第一个变量定义之前使用它，不会报错(没定义就使用则会报错)，但是该变量的值会为undefined，而不是定义时的值。在一个函数定义之前使用它，不会出错，且函数能正确执行 出现该特性的原因就是 变量提升 JS 中的声明和赋">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-01-10-%E4%B8%8B%E5%8D%885.3dhl918syno0.webp">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-01-10-%E4%B8%8B%E5%8D%885.20j6laeeh90g.webp">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-01-10-%E4%B8%8B%E5%8D%8810.2k6udolwot40.webp">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-01-11-%E4%B8%8A%E5%8D%887.660frge57dc0.webp">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-01-11-%E4%B8%8A%E5%8D%888.6ssjlq61e2g0.webp">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-01-11-%E4%B8%8A%E5%8D%889.4wchdr98vj40.webp">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2021-12-12-%E4%B8%8B%E5%8D%884.10.11.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2021-12-12-%E4%B8%8B%E5%8D%884.26.33.png">
<meta property="article:published_time" content="2021-12-08T11:41:52.000Z">
<meta property="article:modified_time" content="2022-01-11T02:13:16.963Z">
<meta property="article:author" content="帅得乱七八糟">
<meta property="article:tag" content="面试之道">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-01-10-%E4%B8%8B%E5%8D%885.3dhl918syno0.webp">
  
  <title>前端面试之道 JS - 何阳阳阳的小屋</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/custom.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/shubiao.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/toubudaziji.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>何阳阳阳的小屋🛖</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/shuoshuo/">
                <i class="iconfont icon-kakao-talk-fill"></i>
                说说
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                小屋主人
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/bg6.2e551b3dtthc.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="前端面试之道 JS">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-12-08 19:41" pubdate>
        2021年12月8日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      19k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      58 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">前端面试之道 JS</h1>
            
            <div class="markdown-body">
              <h2 id="JS-的执行机制"><a href="#JS-的执行机制" class="headerlink" title="JS 的执行机制"></a>JS 的执行机制</h2><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><blockquote>
<p>只有理解了 JS 的执行上下文，才能更好地理解 JS 语言本身(包括变量提升、作用域、闭包等)</p>
</blockquote>
<h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><p>在写 JS 代码的时候，会发现一个<strong>特性</strong>，即：在第一个变量定义之前使用它，不会报错(没定义就使用则会报错)，但是该变量的值会为<code>undefined</code>，而不是定义时的值。在一个函数定义之前使用它，不会出错，且函数能正确执行</p>
<p>出现该特性的原因就是 <strong>变量提升</strong></p>
<h5 id="JS-中的声明和赋值"><a href="#JS-中的声明和赋值" class="headerlink" title="JS 中的声明和赋值"></a>JS 中的声明和赋值</h5><p>先看看 JS 中变量的声明和赋值：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// 一行普通的代码： var <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;帅得乱七八糟&#x27;</span>;<br>// 上述代码可以看成下面两行代码组成：<br>var <span class="hljs-type">name</span> = undefined;      <span class="hljs-comment">---&gt;  此为声明</span><br><span class="hljs-type">name</span> = <span class="hljs-string">&#x27;帅得乱七八糟&#x27;</span>;       <span class="hljs-comment">---&gt;  此为赋值</span><br></code></pre></td></tr></table></figure>

<p>再来看看 JS 中函数的声明和赋值：</p>
<figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs nim">// 此为一个普通的函数声明<br>function foo() &#123;<br>  console.log(&#x27;foo&#x27;)<br>&#125;<br>// 可以转化为下面的代码<br>function foo = () =&gt; &#123;<br>  console.log(&#x27;foo&#x27;)<br>&#125;<br><br>// 此函数：先声明变量bar，再把函数赋值给bar<br><span class="hljs-keyword">var</span> bar = function() <span class="hljs-meta">&#123;...&#125;</span><br>// 可以拆分为声明和赋值：<br><span class="hljs-keyword">var</span> bar = undefined;    ---&gt;  此为声明<br>bar = function() <span class="hljs-meta">&#123;...&#125;</span>; ---&gt;  此为赋值<br></code></pre></td></tr></table></figure>

<h5 id="变量提升-1"><a href="#变量提升-1" class="headerlink" title="变量提升"></a>变量提升</h5><blockquote>
<p>所谓变量提升，即在 JS 代码<strong>执行之前</strong>中，<strong>JS 引擎</strong>会把<strong>变量的声明部分</strong>和<strong>函数的声明部分</strong>提升到代码开头的“行为” (注意，JS 引擎对非声明操作，不做任何处理)。变量被提升后，会给变量设置默认值，这个默认是即<code>undefined</code></p>
</blockquote>
<h5 id="编译和执行"><a href="#编译和执行" class="headerlink" title="编译和执行"></a>编译和执行</h5><blockquote>
<p>注意：实际上变量和函数声明在代码里的位置是不会改变的，而且是在<strong>编译阶段</strong>被 JavaScript 引擎放入内存中。一段<code>JavaScript</code>代码在执行之前需要被<code>JavaScript</code>引擎编译，编译完成之后，才会进入执行阶段。</p>
</blockquote>
<p>一段 js 代码 -&gt; 先编译 -&gt; 后执行<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-01-10-%E4%B8%8B%E5%8D%885.3dhl918syno0.webp" srcset="/img/loading.gif" lazyload alt="JS代码编译和执行"></p>
<p>上图可见：输入一段代码，经过编译后，会生成两部分内容：执行上下文和可执行代码。并且在执行上下文中存在一个<strong>变量环境对象</strong>，这个对象保存了变量提升的内容</p>
<p>执行阶段：<br>JS 引擎 按照顺序一行一行的执行… 遇见函数执行或者赋值操作，先在环境变量中进行对应查找，找到后进行函数执行或者变量赋值操作</p>
<p><strong>一段代码中出现了相同的变量或者函数该怎么办？</strong><br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-01-10-%E4%B8%8B%E5%8D%885.20j6laeeh90g.webp" srcset="/img/loading.gif" lazyload alt="出现相同的变量或者函数该怎么办"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">例如：<br>showName()<br><span class="hljs-keyword">var</span> showName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showName</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-comment">// 输出1</span><br></code></pre></td></tr></table></figure>

<h4 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h4><p>三种类型：</p>
<ul>
<li>当 JS 在执行全局代码之前，会编译全局代码并创建全局上下文，而且在整个页面的生命周期内，全局执行上下文只有一份。</li>
<li>当调用一个函数的时候(正在执行这个函数)，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁</li>
<li>当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文</li>
</ul>
<p>–&gt; 执行上下文是在代码编译的时候才产生的</p>
<h3 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h3><blockquote>
<p>调用栈是用来管理函数调用关系的一种数据结构</p>
</blockquote>
<h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><blockquote>
<p>所谓函数调用，其实就是运行一个函数，具体使用方式是使用函数名称跟着一对小括号</p>
</blockquote>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br>add();<br></code></pre></td></tr></table></figure>

<p>当刚执行到 add()之前时，全局执行上下文是这样的一个状态：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm">全局执行上下文：<br>  变量环境<br>  a = <span class="hljs-number">2</span><br>  <span class="hljs-keyword">add</span> = <span class="hljs-meta">function</span>() &#123;<span class="hljs-keyword">b</span> = <span class="hljs-number">10</span><span class="hljs-comment">; return a + b&#125;</span><br><br>  词法环境：<br>  ...<br></code></pre></td></tr></table></figure>

<p>当执行到 add 这儿时，JS 会判断这是一个函数调用，那么将执行以下操作：</p>
<ul>
<li>首先，从全局执行上下文中，取出 add 函数代码</li>
<li>其次，对 add 函数的这段代码进行编译，并创建该函数的执行上下文和可执行代码</li>
<li>最后，执行代码，输出结果</li>
</ul>
<p>完整流程如下：<img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-01-10-%E4%B8%8B%E5%8D%8810.2k6udolwot40.webp" srcset="/img/loading.gif" lazyload alt="函数执行上下文步骤"></p>
<p>由于 JS 本身就是面向函数式编程的，函数非常的多，且层次逻辑复杂多样，所以就可能存在多个执行上下文，JS 引擎是如何管理这些执行上下文的呢？<br>答案是：用栈来管理</p>
<h4 id="栈结构管理多个执行上下文-JS-调用栈"><a href="#栈结构管理多个执行上下文-JS-调用栈" class="headerlink" title="栈结构管理多个执行上下文(JS 调用栈)"></a>栈结构管理多个执行上下文(JS 调用栈)</h4><p>JavaScript 引擎正是利用栈的这种结构来管理执行上下文的。通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈。<br>同时调用栈是 JS 引擎追踪函数执行的一个机制(这个机制能很好的找到各个函数之间的调用关系)</p>
<p>在分析复杂结构代码，或者检查 Bug 时，调用栈都是非常有用的(chrome 控制台打断点后，可以看见调用栈)</p>
<h4 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h4><blockquote>
<p>注意：调用栈也是有大小的，当入栈的执行上下文超过一定数目后，JS 引擎就会报错，我们把这种错误叫做<strong>栈溢出</strong></p>
</blockquote>
<p>特别是在写递归代码的时候，很容易出现栈溢出的情况</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">division</span>(a,b)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">division(a,b)</span><br>&#125;<br>console.log(division(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure>

<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>事实上，JS 存在变量提升这种特性，从而导致了很多与直接不符的代码，这也是 JS 的一个重要设计缺陷</p>
<p>思考一个问题，为什么 JS 会存在变量提升呢？ 这需要从作用域讲起…</p>
<p><strong>作用域</strong>是指在程序中定义变量的区域，<strong>该位置决定了变量的生命周期</strong>。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期</p>
<p>所谓的块级作用域：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> <span class="hljs-keyword">if</span> 块<br><span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) &#123;&#125;<br><br><span class="hljs-regexp">//</span> <span class="hljs-keyword">while</span> 块<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;&#125;<br><br><span class="hljs-regexp">//</span> 函数块<br><span class="hljs-keyword">function</span> foo() &#123;&#125;<br><br><span class="hljs-regexp">//</span> <span class="hljs-keyword">for</span> 循环块<br><span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;&#125;<br><br><span class="hljs-regexp">//</span> 单独一个块<br></code></pre></td></tr></table></figure>

<blockquote>
<p>和 Java、C/C++不同，ES6 之前是不支持块级作用域的，因为当初设计这门语言的时候，并没有想到 JavaScript 会火起来，所以只是按照最简单的方式来设计。没有了块级作用域，再把作用域内部的变量统一提升无疑是最快速、最简单的设计，不过这也直接导致了函数中的变量无论是在哪里声明的，在编译阶段都会被提取到执行上下文的变量环境中，所以这些变量在整个函数体内部的任何地方都是能被访问的，这也就是 JavaScript 中的变量提升。 (当时创建 js 的时候，也只是为了图个方便…)</p>
</blockquote>
<h4 id="变量提升所带来的问题"><a href="#变量提升所带来的问题" class="headerlink" title="变量提升所带来的问题"></a>变量提升所带来的问题</h4><ol>
<li>变量容易在不被察觉的情况下被覆盖掉<br>在函数执行过程中，JS 会优先从当前的执行上下文中查找变量</li>
<li>本应该被销毁的变量没有被销毁</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;<br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(i);   <span class="hljs-comment">// 7</span><br>&#125;<br>foo()<br></code></pre></td></tr></table></figure>

<h4 id="ES6-带来的解决变量提升的方法"><a href="#ES6-带来的解决变量提升的方法" class="headerlink" title="ES6 带来的解决变量提升的方法"></a>ES6 带来的解决变量提升的方法</h4><p>ES6 引入了 let 和 const 关键字，从而使 JavaScript 也能像其他语言一样拥有了块级作用域。这解决了变量提升带来的困扰</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">varTest</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">var</span> x = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 同样的变量!</span><br>    <span class="hljs-built_in">console</span>.log(x);  <span class="hljs-comment">// 2</span><br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(x);  <span class="hljs-comment">// 2</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>进行改造</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">letTest</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">let</span> x = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 不同的变量</span><br>    <span class="hljs-built_in">console</span>.log(x);  <span class="hljs-comment">// 2</span><br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(x);  <span class="hljs-comment">// 1</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意：因为 let 关键字(const 同理)是支持块级作用域的，所以在编译阶段，JavaScript 引擎并不会把 if 块中通过 let 声明的变量存放到变量环境中，这也就意味着在 if 块通过 let 声明的关键字，并不会提升到全函数可见。所以在 if 块之内打印出来的值是 2，跳出语块之后，打印出来的值就是 1 了。这种就非常符合我们的编程习惯了：作用块内声明的变量不影响块外面的变量。</p>
<h4 id="JS-是如何支持块级作用域的"><a href="#JS-是如何支持块级作用域的" class="headerlink" title="JS 是如何支持块级作用域的"></a>JS 是如何支持块级作用域的</h4><p>块级变量是在执行上下文中的词法环境存放的(也是一个栈结构)</p>
<p>JS 引擎执行代码的时候，也是先在执行上下文中的词法环境中 从栈顶向下查找， 如果没找到继续在变量环境中查找</p>
<blockquote>
<p>块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript 引擎也就同时支持了变量提升和块级作用域了</p>
</blockquote>
<h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><p>先记住一句话： 变量是通过作用域链来查找的</p>
<p>其实在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为<code>outer</code><br>当一段代码使用了一个变量时，<strong>JavaScript 引擎</strong>首先会在“当前的执行上下文”中查找该变量， 比如一段代码在查找 <code>myName</code> 变量时，如果在当前的变量环境中没有查找到，那么 <strong>JavaScript 引擎</strong>会继续在 outer 所指向的执行上下文中查找。为了直观理解，你可以看下面这张图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-01-11-%E4%B8%8A%E5%8D%887.660frge57dc0.webp" srcset="/img/loading.gif" lazyload alt="外部引用"></p>
<p>我们把这个查找的链条就称为作用域链</p>
<h4 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h4><p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-01-11-%E4%B8%8A%E5%8D%888.6ssjlq61e2g0.webp" srcset="/img/loading.gif" lazyload alt="作用域的层次结构"></p>
<p>词法作用域就是根据代码的位置(代码结构)来决定的，而 JS 作用域链是由词法作用域来决定的，所以词法作用域链的顺序是：foo 函数作用域 –&gt; bar 函数作用域 –&gt; main 函数作用域 –&gt; 全局作用域</p>
<p>词法作用域和执行上下文关系是怎么的呢？</p>
<h4 id="闭包-scope"><a href="#闭包-scope" class="headerlink" title="闭包(scope)"></a>闭包(scope)</h4><blockquote>
<p>在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包</p>
</blockquote>
<h5 id="闭包的回收机制"><a href="#闭包的回收机制" class="headerlink" title="闭包的回收机制"></a>闭包的回收机制</h5><p>通常，如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。</p>
<p>如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。</p>
<p>所以在使用闭包的时候，你要尽量注意一个原则：如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 做一道题：</span><br><span class="hljs-keyword">var</span> bar = &#123;<br>    <span class="hljs-attr">myName</span>:<span class="hljs-string">&quot;time.geekbang.com&quot;</span>, <span class="hljs-comment">// 1</span><br>    <span class="hljs-attr">printName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(myName)     <span class="hljs-comment">// 注意：这里的myName是无法使用1号的myName的，他们两个是平行关系。而词法作用域讲究的是包含关系，所以这里的myName 只能使用 外层函数的myName，即 3 号</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> myName = <span class="hljs-string">&quot; 极客时间 &quot;</span><br>    <span class="hljs-keyword">return</span> bar.printName<br>&#125;<br><span class="hljs-keyword">let</span> myName = <span class="hljs-string">&quot; 极客邦 &quot;</span>        <span class="hljs-comment">// 3</span><br><span class="hljs-keyword">let</span> _printName = foo()<br>_printName()<br>bar.printName()<br><br></code></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">var obj = &#123;<br>  name: <span class="hljs-string">&#x27;jack&#x27;</span>,   <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br>  <span class="hljs-keyword">func</span>: <span class="hljs-keyword">function</span>() &#123;console.log(name)&#125;   <span class="hljs-regexp">//</span> 和<span class="hljs-number">1</span>号是平行关系<br>&#125;<br><br>obj.<span class="hljs-keyword">func</span>();    <span class="hljs-regexp">//</span> undefined  这里是不能使用<span class="hljs-number">1</span>号的<br></code></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">let obj = &#123;<br>  name: <span class="hljs-string">&#x27;jack&#x27;</span>,   <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br>  <span class="hljs-keyword">func</span>: <span class="hljs-keyword">function</span>() &#123;console.log(name)&#125;   <span class="hljs-regexp">//</span> 和<span class="hljs-number">1</span>号还是平行关系<br>&#125;<br><br>obj.<span class="hljs-keyword">func</span>();    <span class="hljs-regexp">//</span> undefined  这里是不能使用<span class="hljs-number">1</span>号的<br></code></pre></td></tr></table></figure>

<h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>上述的代码，我讲了对象内部函数(也是属性)和内部属性是平行关系，无法进行调用，因此 JS 搞出了 this 机制来解决这个问题！！(终于知道了很多来龙去脉)<br>还是用上面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;jack&#x27;</span>,<br>  <span class="hljs-attr">func</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)&#125;<br>&#125;<br>obj.func();<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意：作用域链和 this 是两套不同的系统，二者之间基本没有太多的联系</p>
</blockquote>
<p>完整的执行上下文内容如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2022-01-11-%E4%B8%8A%E5%8D%889.4wchdr98vj40.webp" srcset="/img/loading.gif" lazyload alt="执行上下文"></p>
<p>执行上下文主要分为三种：全局执行上下文、函数执行上下文、eval 执行上下文 故 this 也对应有三种：全局执行上下文的 this、函数中的 this 和 eval 中的 this</p>
<p>注意：使用对象来调用其内部的一个方法，该方法的 this 是指向对象本身的</p>
<p><a target="_blank" rel="noopener" href="https://blog.poetries.top/browser-working-principle/guide/part2/lesson11.html#this-%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%BC%BA%E9%99%B7%E4%BB%A5%E5%8F%8A%E5%BA%94%E5%AF%B9%E6%96%B9%E6%A1%88">this 的设计缺陷以及应对方案</a></p>
<h2 id="作用域-1"><a href="#作用域-1" class="headerlink" title="作用域"></a>作用域</h2><blockquote>
<p>所谓<strong>作用域</strong>即提前约定好的一套存储变量、访问变量的规则,更多时候，我们提到作用域的时候，指的是这个规则约束下的一个变量、函数、标识符可以被访问的区域</p>
</blockquote>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">var</span> <span class="hljs-keyword">name</span> = <span class="hljs-string">&#x27;HeYang&#x27;</span>;<br><br>上述代码在JS 引擎中是这样来理解的<br>* <span class="hljs-keyword">var</span> <span class="hljs-keyword">name</span> (编译时处理)<br>* <span class="hljs-keyword">name</span> = <span class="hljs-string">&#x27;HeYang&#x27;</span> (执行时处理)<br></code></pre></td></tr></table></figure>

<h3 id="JS-代码-lt-gt-编译与执行"><a href="#JS-代码-lt-gt-编译与执行" class="headerlink" title="JS 代码&lt;-&gt;编译与执行"></a>JS 代码&lt;-&gt;编译与执行</h3><p><strong>注意</strong>：JS 代码是一边编译一边执行(所有的 JS 代码片段在执行之前都会被编译，只是这个编译的过程非常短暂（可能就只有几微妙、或者更短的时间)</p>
<p><strong>编译阶段：</strong> <strong>编译器</strong>会找遍<strong>当前作用域</strong>看看是不是已经有一个叫 <code>name</code> 的变量(自由变量)了。如果有，那么就<strong>忽略</strong> <code>var name</code> 这个声明，继续编译下去；如果没有，则在当前作用域里新增一个 <code>name</code>。然后，编译器会为引擎生成运行时所需要的代码，程序就进入了执行阶段</p>
<p><strong>执行阶段：</strong> <strong>JS 引擎</strong>在执行代码的时候，仍然会找遍当前作用域，看看是不是有一个叫 name 的变量(这里说的是定义 name 变量的代码)。如果能找到，那么万事大吉，我来给你赋值。如果找不到，它也不会灰心，它会从当前作用域里 “探出头去”，看看 “外面” 有没有，或者 “外面的外面” 有没有(找定义变量 name 的代码)。如果最终仍然找不到 name 变量(定义变量 name 的代码)，引擎就会抛出一个异常。—&gt; JS 引擎向外找该变量(定义该变量的源头)的过程 其实展示的就是<strong>作用域链</strong></p>
<h3 id="作用域链-1"><a href="#作用域链-1" class="headerlink" title="作用域链"></a>作用域链</h3><p>在 JS 中，一共有三种作用域：</p>
<ul>
<li>全局作用域</li>
<li>函数作用域： 在函数内部定义的变量，拥有函数作用域(函数的参数也属于函数作用域里面的)</li>
<li>块级作用域： 针对的是由 <code>let</code> 和 <code>const</code> 这两个关键词定义的变量, 在一个{} 包裹住，这个{}就拥有块级作用域</li>
</ul>
<p>注意：var 是感受不到块级作用域的！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-keyword">var</span> me = <span class="hljs-string">&#x27;HeYang&#x27;</span>;<br>  <span class="hljs-built_in">console</span>.log(me);    <span class="hljs-comment">// HeYang</span><br>&#125;<br><span class="hljs-built_in">console</span>.log(me);    <span class="hljs-comment">// HeYang</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>自由变量</strong>：在函数中被使用，但它既不是函数参数、也不是函数的局部变量，而是一个不属于当前作用域的变量，此时它相对于当前作用域来说，就是一个自由变量</p>
</blockquote>
<p><strong>引用了自由变量的函数,就叫做<code>闭包</code></strong></p>
<h3 id="LHS、RHS"><a href="#LHS、RHS" class="headerlink" title="LHS、RHS"></a>LHS、RHS</h3><p><code>LHS</code>、<code>RHS</code>，是<strong>JS 引擎</strong>在<strong>执行代码</strong>的时候，查询变量的两种方式</p>
<blockquote>
<p>L、R 分别意味着 <code>Left</code>、<code>Right</code> 。<code>Left</code>、<code>Right</code>是相对于<strong>赋值操作</strong>来说的</p>
</blockquote>
<p>当变量出现在赋值操作的左侧时，执行的就是 LHS 操作，右侧则执行 RHS 操作</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">name</span> = <span class="hljs-string">&#x27;HeYang&#x27;</span><span class="hljs-comment">;    // 变量name出现在左侧。LHS 意味着 变量赋值或将数据写入内存，强调的是 写</span><br></code></pre></td></tr></table></figure>

<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">var</span> myName = <span class="hljs-keyword">name</span>;  <span class="hljs-comment">// 变量name出现在右侧。RHS 意味着 变量查找或从内存中读取， 强调的是 读</span><br></code></pre></td></tr></table></figure>

<h3 id="词法作用域-1"><a href="#词法作用域-1" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>作用域： 词法作用域、动态作用域(冷门，不用了解)</p>
<p>JS 作用域使用的就是 词法作用域(静态作用域)</p>
<p><strong>静态作用域</strong> 是在你写代码的时候，作用域以及作用域之间的关系就已经定下来了(即当你在写代码的时候哪个作用域内定义了什么变量，或者是用的什么自由变量，变量与作用域之间的归属关系就已经被定下来了)</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">var <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;bruce&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-keyword">inner</span>() &#123;<br>  console.log(<span class="hljs-type">name</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-keyword">outer</span>() &#123;<br>  var <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;hy&#x27;</span>;<br>  <span class="hljs-keyword">inner</span>();<br>&#125;<br><br><span class="hljs-keyword">outer</span>();   // <span class="hljs-string">&#x27;bruce&#x27;</span><br></code></pre></td></tr></table></figure>

<p><strong>欺骗词法作用域的方式</strong>： eval 和 with (但是由于 eval 和 with 有强烈的副作用，所以不要使用) 会对作用域做一定的修改 –&gt; 但是不用了解为啥要修改…</p>
<h2 id="闭包真题"><a href="#闭包真题" class="headerlink" title="闭包真题"></a>闭包真题</h2><h3 id="真题一"><a href="#真题一" class="headerlink" title="真题一"></a>真题一</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(i);<br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(i);<br></code></pre></td></tr></table></figure>

<p>打印结果： 5、5、5、5、5 –&gt; 理由：循环了 5 次，则有 5 个同层的函数作用域(function(){console.log(i)})出现。而这 5 个函数作用域的 i 都是同一个自由变量。即父作用域的变量 i。 setTimeout 为异步代码，故隔了 1s 后，这些函数才执行，此时，自由变量 i 已经是 5 了</p>
<p><strong>升级</strong><br>现在我想让代码打印出 0 1 2 3 4</p>
<p><strong>方法一</strong><br>使用 let 让每次 for 循环都产生一个块级作用域</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(i);<br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>方法二</strong><br>使用 setTimeout 的第三个参数(setTimeout 从第三个入参位置开始往后，是可以传入无数个参数的。这些参数会作为回调函数的附加参数存在)<br>原理就是产生了函数作用域</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(j);<br>    &#125;, <span class="hljs-number">1000</span>, i);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>方法三</strong><br>在 setTimeout 外面再套一层立即执行函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>)</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(j);<br>    &#125;, <span class="hljs-number">1000</span>)<br>  &#125;)(i)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="真题二"><a href="#真题二" class="headerlink" title="真题二"></a>真题二</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span> (<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> num = []<br>  <span class="hljs-keyword">var</span> i<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    num[i] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(i)<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> num[<span class="hljs-number">9</span>]<br>&#125;<br><br>test()()   <span class="hljs-comment">// 执行结果为：10 --&gt; 闭包之道</span><br></code></pre></td></tr></table></figure>

<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> test = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> num = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> num++<br>  &#125;<br>&#125;())<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>  test()<br>&#125;<br>console.log(test())   <span class="hljs-comment">// 执行结果为：10 --&gt; 闭包之道</span><br></code></pre></td></tr></table></figure>

<h3 id="真题三"><a href="#真题三" class="headerlink" title="真题三"></a>真题三</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>)</span>&#123;<br>  a = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(a);<br>  &#125;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;<br>&#125;<br>test()();   <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure>

<h2 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h2><h3 id="模拟私有变量的实现"><a href="#模拟私有变量的实现" class="headerlink" title="模拟私有变量的实现"></a>模拟私有变量的实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 利用闭包生成 IIFE，返回 User 类</span><br><br><span class="hljs-keyword">const</span> User = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> _password;<br><br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">username, password</span>)</span> &#123;<br>      <span class="hljs-built_in">this</span>.username = username;<br>      _password = password;   <span class="hljs-comment">// 注意这里，在函数里使用自由变量(闭包大法)</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">login</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.username, _password)<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> User;<br>&#125;)()<br><br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&#x27;HeYang&#x27;</span>, <span class="hljs-string">&#x27;123456&#x27;</span>)<br><br><span class="hljs-built_in">console</span>.log(user.username)   <span class="hljs-comment">// HeYang</span><br><span class="hljs-built_in">console</span>.log(user.password)   <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">console</span>.log(user._password)  <span class="hljs-comment">// undefined</span><br>user.login() <span class="hljs-comment">// HeYang 123456</span><br></code></pre></td></tr></table></figure>

<h3 id="偏函数与柯里化"><a href="#偏函数与柯里化" class="headerlink" title="偏函数与柯里化"></a>偏函数与柯里化</h3><p>柯里化和偏函数并不复杂（只是名字有点拗口），它们都是可以帮我们把需要多个入参的函数，转化为需要更少入参的函数的方法。</p>
<h4 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h4><p>柯里化是把接受 n 个参数的 1 个函数改造为只接受 1 个参数的 n 个互相嵌套的函数的过程。也就是 fn (a, b, c)fn(a,b,c) 会变成 fn (a)(b)(c)fn(a)(b)(c)。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateName</span>(<span class="hljs-params">prefix</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-keyword">type</span></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">itemName</span>) </span>&#123;<br>            <span class="hljs-keyword">return</span> prefix + <span class="hljs-keyword">type</span> + itemName    <span class="hljs-comment">// 使用自由变量的函数 --&gt; 闭包</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 生成大卖网商品名专属函数</span><br><span class="hljs-keyword">var</span> salesName = generateName(<span class="hljs-string">&#x27;大卖网&#x27;</span>)<br><br><span class="hljs-comment">// “记住”prefix，生成大卖网母婴商品名专属函数</span><br><span class="hljs-keyword">var</span> salesBabyName = salesName(<span class="hljs-string">&#x27;母婴&#x27;</span>)<br><br><span class="hljs-comment">// &quot;记住“prefix和type，生成洗菜网生鲜商品名专属函数</span><br><span class="hljs-keyword">var</span> vegFreshName = generateName(<span class="hljs-string">&#x27;洗菜网&#x27;</span>)(<span class="hljs-string">&#x27;生鲜&#x27;</span>)<br><br><span class="hljs-comment">// 输出 &#x27;大卖网母婴奶瓶&#x27;</span><br>salesBabyName(<span class="hljs-string">&#x27;奶瓶&#x27;</span>)<br><span class="hljs-comment">// 输出 &#x27;洗菜网生鲜菠菜&#x27;</span><br>vegFreshName(<span class="hljs-string">&#x27;菠菜&#x27;</span>)<br><br><span class="hljs-comment">// 啥也不记，直接生成一个商品名</span><br><span class="hljs-keyword">var</span> itemFullName = generateName(<span class="hljs-string">&#x27;洗菜网&#x27;</span>)(<span class="hljs-string">&#x27;生鲜&#x27;</span>)(<span class="hljs-string">&#x27;菠菜&#x27;</span>)<br></code></pre></td></tr></table></figure>

<h4 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h4><p>偏函数应用是不强调 “单参数” 这个概念的。它的目标仅仅是把函数的入参拆解为两部分。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateName</span>(<span class="hljs-params">prefix</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>, itemName</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> prefix + <span class="hljs-keyword">type</span> + itemName<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 把3个参数分两部分传入</span><br><span class="hljs-keyword">var</span> itemFullName = generateName(<span class="hljs-string">&#x27;大卖网&#x27;</span>)(<span class="hljs-string">&#x27;母婴&#x27;</span>, <span class="hljs-string">&#x27;奶瓶&#x27;</span>)<br></code></pre></td></tr></table></figure>

<h2 id="JS-内存管理机制解析"><a href="#JS-内存管理机制解析" class="headerlink" title="JS 内存管理机制解析"></a>JS 内存管理机制解析</h2><h3 id="JS-内存生命周期"><a href="#JS-内存生命周期" class="headerlink" title="JS 内存生命周期"></a>JS 内存生命周期</h3><p>内存管理是每一种编程语言都会具备的一种基本能力<br>不过 JS 并没有暴露任何内存操作给开发者，而是自己默默地自动完成了所有的管理动作</p>
<p><strong>JS 的内存生命周期</strong><br>挖坑(分配内存) –&gt; 用坑(内存的读写操作) –&gt; 还坑(内存的释放)</p>
<h3 id="栈内存和堆内存"><a href="#栈内存和堆内存" class="headerlink" title="栈内存和堆内存"></a>栈内存和堆内存</h3><p>栈(线性表)<br>堆(树结构)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">  <span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> b = <span class="hljs-string">&quot;Hello World&quot;</span><br>  <span class="hljs-keyword">let</span> c = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">let</span> d = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;修言&#x27;</span> &#125;;<br>  <span class="hljs-keyword">let</span> e = [<span class="hljs-string">&#x27;修言&#x27;</span>, <span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-string">&#x27;bear&#x27;</span>];<br>&gt;----------------------------------&lt;<br>  a —— <span class="hljs-built_in">Number</span>类型 —— 基本类型 —— 栈内存<br>  b —— <span class="hljs-built_in">String</span>类型 —— 基本类型 —— 栈内存<br>  c —— <span class="hljs-literal">null</span> —— 基本类型 —— 栈内存<br>  d —— <span class="hljs-built_in">Object</span> —— 引用类型 —— 堆内存<br>  e —— <span class="hljs-built_in">Array</span> —— 引用类型 —— 堆内存<br></code></pre></td></tr></table></figure>

<h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>即内存的释放(还坑)<br><strong>每隔一段时间</strong>，JS 的<strong>垃圾收集器</strong>就会对变量做 “巡检”。当它判断一个变量不再被需要之后，它就会把这个变量所占用的内存空间给释放掉，这个过程叫做<strong>垃圾回收</strong></p>
<p>JS 是如何知道一个变量是否不被需要的呢？ 使用的就是垃圾回收算法！<br>在 JS 中，我们讨论的垃圾回收算法有两种 &lt;——&gt; 引用计数法和标记清除法</p>
<h4 id="引用计数法-过时，现代浏览器没有再使用这个的了"><a href="#引用计数法-过时，现代浏览器没有再使用这个的了" class="headerlink" title="引用计数法 (过时，现代浏览器没有再使用这个的了)"></a>引用计数法 (过时，现代浏览器没有再使用这个的了)</h4><p>这里的引用 指的是用一个变量指向了一个值，那么就创建了一个针对这个值的 “引用”：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">const <span class="hljs-keyword">user</span> <span class="hljs-title">= [name</span>: &#x27;帅得乱七八糟&#x27;, age: <span class="hljs-number">21</span>]<br></code></pre></td></tr></table></figure>

<p>具体分析一下： 赋值表达式是从右向左读的。这行代码首先是开辟了一块内存，把右侧这个数组塞了进去，此时这个数组就占据了一块内存。随后 user 变量指向它，这就是创建了一个指向该数组的 “引用”。此时数组的引用计数就是 1</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xl"><br><span class="hljs-function"><span class="hljs-title">user</span> --1--&gt;</span>  [<span class="hljs-keyword">name</span>: <span class="hljs-string">&#x27;帅得乱七八糟&#x27;</span>, age: <span class="hljs-number">21</span>]<br></code></pre></td></tr></table></figure>

<blockquote>
<p>在<code>引用计数法</code>的机制下，内存中的每一个值都会对应一个引用计数。当垃圾收集器感知到某个值的引用计数为 0 时，就判断它 “没用” 了，随即这块内存就会被释放。</p>
</blockquote>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">user</span> <span class="hljs-title">= null</span>;   // 则计数就会变成<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<h4 id="引用计数法的局限性"><a href="#引用计数法的局限性" class="headerlink" title="引用计数法的局限性"></a>引用计数法的局限性</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">function badCycle() &#123;<br>  <span class="hljs-selector-tag">var</span> cycleObj1 = &#123;&#125;<br>  <span class="hljs-selector-tag">var</span> cycleObj2 = &#123;&#125;<br>  cycleObj1<span class="hljs-selector-class">.target</span> = cycleObj2<br>  cycleObj2<span class="hljs-selector-class">.target</span> = cycleObj1<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">badCycle</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>

<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck">         --<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">1</span>--<span class="hljs-literal">-</span>&gt;<br><span class="hljs-comment">cycleObj1</span>         <span class="hljs-comment">cycleObj2</span><br>         &lt;--<span class="hljs-literal">-</span><span class="hljs-comment">1</span>--<span class="hljs-literal">-</span><br></code></pre></td></tr></table></figure>

<p>即便 badCycle 函数执行完。引用计数仍未被清 0</p>
<blockquote>
<p><code>引用计数法</code>无法甄别循环引用场景下的 “垃圾”！</p>
</blockquote>
<h4 id="标记清除法-目前都是用的这种方法"><a href="#标记清除法-目前都是用的这种方法" class="headerlink" title="标记清除法(目前都是用的这种方法)"></a>标记清除法(目前都是用的这种方法)</h4><p>在标记清除算法中，一个变量是否被需要的判断标准，是它是否可抵达<br>这个算法有两个阶段，分别是标记阶段和清除阶段：<br><strong>标记阶段</strong>:垃圾收集器会先找到根对象，在浏览器里，根对象是 Window；在 Node 里，根对象是 Global。从根对象出发，垃圾收集器会扫描所有可以通过根对象触及的变量，这些对象会被标记为 “可抵达”。<br><strong>清除阶段</strong>:没有被标记为 “可抵达” 的变量，就会被认为是不需要的变量，这波变量会被清除</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">function badCycle() &#123;<br>  <span class="hljs-selector-tag">var</span> cycleObj1 = &#123;&#125;<br>  <span class="hljs-selector-tag">var</span> cycleObj2 = &#123;&#125;<br>  cycleObj1<span class="hljs-selector-class">.target</span> = cycleObj2<br>  cycleObj2<span class="hljs-selector-class">.target</span> = cycleObj1<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">badCycle</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>

<p>badCycle 执行完毕后，从根对象 Window 出发，cycleObj1 和 cycleObj2 都会被识别为不可达的对象，它们会按照预期被清除掉。这样一来，循环引用的问题，就被标记清除干脆地解决掉了。</p>
<h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>内存泄露：该释放的变量（内存垃圾）没有被释放，仍然霸占着原有的内存不松手，导致内存占用不断攀高，带来性能恶化、系统崩溃等一系列问题，这种现象就叫内存泄漏</p>
<h4 id="闭包的错误使用造成的内存泄露"><a href="#闭包的错误使用造成的内存泄露" class="headerlink" title="闭包的错误使用造成的内存泄露"></a>闭包的错误使用造成的内存泄露</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> theThing = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">var</span> replaceThing = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> originalThing = theThing;<br>  <span class="hljs-keyword">var</span> unused = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (originalThing) <span class="hljs-comment">// 自由变量的使用，闭包操作</span><br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;嘿嘿嘿&quot;</span>);<br>  &#125;;<br>  theThing = &#123;<br>    <span class="hljs-attr">longStr</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1000000</span>).join(<span class="hljs-string">&#x27;*&#x27;</span>),<br>    <span class="hljs-attr">someMethod</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;哈哈哈&quot;</span>);<br>    &#125;<br>  &#125;;<br>&#125;;<br><span class="hljs-built_in">setInterval</span>(replaceThing, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure>

<p><strong>在 V8 中，一旦不同的作用域位于同一个父级作用域下，那么它们会共享这个父级作用域</strong></p>
<p>注意：unused 是一个闭包。 并且，unused 和 someMethod 都位于同一个父级作用域下，共享这个父级作用域<br>无法被回收的无用 originalThing 越堆积越多，最终导致严重的内存泄漏<br><strong>—&gt; 此题有点懵…没看懂…</strong></p>
<h4 id="内存泄漏成因分析"><a href="#内存泄漏成因分析" class="headerlink" title="内存泄漏成因分析"></a>内存泄漏成因分析</h4><ol>
<li>误写全局变量</li>
</ol>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>&#123;<br>  test = <span class="hljs-string">&#x27;123&#x27;</span>;  <span class="hljs-comment">// test 就是全局变量</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>根据垃圾回收策略，本来 me 这个变量，如果被 var 声明过，它作为函数作用域内的变量，在函数调用结束后就会消失 —— 这也是我们所期望的。但现在它是一个全局变量了，永远无法被清除。这样的变量一多，问题就来了</p>
<ol start="2">
<li><p>忘记清除的 setInterval 和 setTimeout<br>在 setInterval 和链式调用的 setTimeout 这两种场景下，定时器的工作可以说都是无穷无尽的。当定时器囊括的函数逻辑不再被需要、而我们又忘记手动清除定时器时，它们就会永远保持对内存的占用。因此当我们使用定时器时，一定要先问问自己：我打算什么时候干掉这玩意儿？</p>
</li>
<li><p>清除不当的 DOM</p>
</li>
</ol>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const myDiv = document.get<span class="hljs-constructor">ElementById(&#x27;<span class="hljs-params">myDiv</span>&#x27;)</span><br><br><span class="hljs-keyword">function</span> handle<span class="hljs-constructor">MyDiv()</span> &#123;<br>    <span class="hljs-comment">// 一些与myDiv相关的逻辑</span><br>&#125;<br><br><span class="hljs-comment">// 使用myDiv</span><br>handle<span class="hljs-constructor">MyDiv()</span><br><br><span class="hljs-comment">// 尝试”删除“ myDiv</span><br>document.body.remove<span class="hljs-constructor">Child(<span class="hljs-params">document</span>.<span class="hljs-params">getElementById</span>(&#x27;<span class="hljs-params">myDiv</span>&#x27;)</span>);<br><br></code></pre></td></tr></table></figure>

<p>因为 myDiv 这个变量对这个 DOM 的引用仍然存在，它仍然是一块 “可抵达” 的内存。这种你以为已经清除、但其实活得好好的 DOM 一旦堆积，将带来不可预期的内存隐患。 <strong>(为什么会出现这种情况 我还不知道啊…)</strong></p>
<h2 id="this-1"><a href="#this-1" class="headerlink" title="this"></a>this</h2><h3 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h3><p>多数情况下，this 指向<strong>调用它</strong>所在方法的<strong>那个对象</strong>(谁调的函数，this 就归谁。当调用方法没有明确对象时，this 就指向全局对象。在浏览器中，指向 window；在 Node 中，指向 Global。（严格模式下，指向 undefined))</p>
<p><strong>this 的指向是在调用时决定的，而不是在书写时决定的。这点和闭包恰恰相反</strong></p>
<h4 id="区分-“声明位置”-与-“调用位置”"><a href="#区分-“声明位置”-与-“调用位置”" class="headerlink" title="区分 “声明位置” 与 “调用位置”"></a>区分 “声明位置” 与 “调用位置”</h4><p>js 是词法作用域模型，无论我是一个对象也好，一个方法也好，它的生命周期只和我们声明它的位置有关。我把它写在哪个位置，它就活在哪个位置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 声明位置</span><br><span class="hljs-keyword">var</span> me = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xiuyan&#x27;</span>,<br>  <span class="hljs-attr">hello</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`你好，我是<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>`</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> you = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xiaoming&#x27;</span>,<br>  <span class="hljs-attr">hello</span>: me.hello<br>&#125;<br><br><span class="hljs-comment">// 调用位置</span><br>me.hello() <span class="hljs-comment">// xiuyan</span><br>you.hello() <span class="hljs-comment">// xiaoming</span><br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 声明位置</span><br><span class="hljs-keyword">var</span> me = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xiuyan&#x27;</span>,<br>  <span class="hljs-attr">hello</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`你好，我是<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>`</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> you = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xiaoming&#x27;</span>,<br>  <span class="hljs-attr">hello</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> targetFunc = me.hello  <span class="hljs-comment">// 获取的只是 functioin() &#123;console.log(`你好，我是$&#123;this.name&#125;`)&#125; 这块堆空间的地址</span><br>    targetFunc() <span class="hljs-comment">// --恒等于--&gt;  functioin() &#123;console.log(`你好，我是$&#123;this.name&#125;`)&#125; 的执行结果(调用这段代码的是全局对象)</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;BigBear&#x27;</span><br><br><span class="hljs-comment">// 调用位置</span><br>you.hello()   <span class="hljs-comment">// BigBear</span><br></code></pre></td></tr></table></figure>

<h4 id="特殊情况下的-this-指向"><a href="#特殊情况下的-this-指向" class="headerlink" title="特殊情况下的 this 指向"></a>特殊情况下的 this 指向</h4><p>好消息！在三种特殊情境下，this 会 100% 指向 window：</p>
<ul>
<li>立即执行函数（IIFE）</li>
<li>setTimeout 中传入的函数</li>
<li>setInterval 中传入的函数</li>
</ul>
<p>直接秒杀~</p>
<p>原因：<br>立即执行函数作为<strong>一个匿名函数</strong>，在被调用的时候，我们往往就是直接调用，而不会（也无法）通过属性访问器（ 即 xx.xxx） 这样的形式来给它指定一个所在对象，所以它的 this 是非常确定的，就是默认的全局对象 window</p>
<p>setTimeout 和 setInterval，都是在全局作用域下实现的。无论是 setTimeout 还是 setInterval 里传入的函数，都会首先被交付到全局对象手上</p>
<h4 id="严格模式的局限"><a href="#严格模式的局限" class="headerlink" title="严格模式的局限"></a>严格模式的局限</h4><h5 id="普通函数-非箭头函数-在严格模式下的表现"><a href="#普通函数-非箭头函数-在严格模式下的表现" class="headerlink" title="普通函数(非箭头函数)在严格模式下的表现"></a>普通函数(非箭头函数)在严格模式下的表现</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showThis</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>&#125;<br><br>showThis() <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure>

<h5 id="全局代码中的-this-在严格模式下的表现"><a href="#全局代码中的-this-在严格模式下的表现" class="headerlink" title="全局代码中的 this 在严格模式下的表现"></a>全局代码中的 this 在严格模式下的表现</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)  <span class="hljs-comment">// Window对象</span><br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span><br><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;BigBear&#x27;</span><br><br><span class="hljs-keyword">var</span> me = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xiuyan&#x27;</span>,<br>  <span class="hljs-attr">hello</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 全局作用域下实现的延时函数</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`你好，我是<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>`</span>)<br>    &#125;)<br>  &#125;<br>&#125;<br><br>me.hello() <span class="hljs-comment">// 你好，我是BigBear</span><br></code></pre></td></tr></table></figure>

<p><strong>像这样处于全局代码中的 this， 不管它是否处于严格模式下，它的 this 都指向 Window（这点要特别注意，区分度非常高，很多同学面试的时候会误以为这里也是 undefined ）</strong><br>见到 ‘use strict’ 就立刻认为 this 会是 undefined ， 无疑是件更危险的事情</p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数中的 this 比较特别，它和严格模式、非严格模式啥的都没关系。它和闭包很相似，都是认“词法作用域”的家伙。所以说箭头函数中的 this，和你如何调用它无关，由你书写它的位置决定（和咱们普通函数的 this 规则恰恰相反～）</p>
<p><strong>箭头函数的 this 指向是静态的，“一次便是一生”，指向不会再改变</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;BigBear&#x27;</span><br><span class="hljs-keyword">var</span> me = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xiuyan&#x27;</span>,<br>  <span class="hljs-comment">// 声明位置</span><br>  <span class="hljs-attr">hello</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)   <span class="hljs-comment">// 因为 this 在书写的时候，它所在的作用域是全局作用域(忽视箭头函数的作用域)，于是这个 this 就和全局对象绑在了一起(注意，这里无块级作用域，块级作用域 需要关键字 let const)</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 调用位置</span><br>me.hello() <span class="hljs-comment">// BigBear</span><br></code></pre></td></tr></table></figure>

<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> = <span class="hljs-number">1</span><br><span class="hljs-selector-tag">var</span> obj = &#123;<br>  <span class="hljs-selector-tag">a</span>: <span class="hljs-number">2</span>,<br>  func2: () =&gt; &#123;<br>    console<span class="hljs-selector-class">.log</span>(this.a)<br>  &#125;,<br><br>  func3: function() &#123;<br>    console<span class="hljs-selector-class">.log</span>(this.a)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// func1</span><br><span class="hljs-selector-tag">var</span> func1  = () =&gt; &#123;<br>  console<span class="hljs-selector-class">.log</span>(this.a)<br>&#125;<br><br><span class="hljs-comment">// func2</span><br><span class="hljs-selector-tag">var</span> func2 = obj<span class="hljs-selector-class">.func2</span><br><span class="hljs-comment">// func3</span><br><span class="hljs-selector-tag">var</span> func3 = obj<span class="hljs-selector-class">.func3</span><br><br><span class="hljs-function"><span class="hljs-title">func1</span><span class="hljs-params">()</span></span>    <span class="hljs-comment">// 1</span><br><span class="hljs-function"><span class="hljs-title">func2</span><span class="hljs-params">()</span></span>    <span class="hljs-comment">// 1</span><br><span class="hljs-function"><span class="hljs-title">func3</span><span class="hljs-params">()</span></span>    <span class="hljs-comment">// 1</span><br>obj<span class="hljs-selector-class">.func2</span>()  <span class="hljs-comment">// 1</span><br>obj<span class="hljs-selector-class">.func3</span>()  <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure>

<h3 id="this-指向的改变"><a href="#this-指向的改变" class="headerlink" title="this 指向的改变"></a>this 指向的改变</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust">                                                     ___call --&gt; <span class="hljs-keyword">fn</span>.call(target, arg1, arg2, arg3)<br>                      |-----改变后直接进行函数调用----&gt; |___apply -&gt; <span class="hljs-keyword">fn</span>.apply(target,[arg1, arg2, arg3])<br>改变函数的this指向 ---&gt; |<br>                      |-------仅做改变，不做执行-----&gt; bind ---&gt; <span class="hljs-keyword">fn</span>.bind(target, arg1, arg2)<br></code></pre></td></tr></table></figure>

<p>手写 call、apply、bind (这个在手写博客那一章里…)</p>
<h2 id="执行上下文与调用栈"><a href="#执行上下文与调用栈" class="headerlink" title="执行上下文与调用栈"></a>执行上下文与调用栈</h2><p>执行上下文：JS 引擎在执行过程中对代码进行了又一次的 “划分”，这样做的目的，是为了分解复杂度</p>
<h3 id="执行上下文-1"><a href="#执行上下文-1" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>执行上下文，从定义上理解，是 “执行代码的环境”</p>
<h4 id="执行上下文的分类"><a href="#执行上下文的分类" class="headerlink" title="执行上下文的分类"></a>执行上下文的分类</h4><ul>
<li>全局上下文 —— 全局代码所处的环境，不在函数中的代码都在全局执行上下文中</li>
<li>函数上下文 —— 在函数调用时创建的上下文</li>
<li>Eval 执行上下文 —— 运行 Eval 函数中的代码时所创建的环境，Eval 被前端诟病多年，故不在讨论范围</li>
</ul>
<p>代码执行阶段才会有的~</p>
<p><strong>全局上下文</strong>： JS 脚本跑起来之后，第一个被创建的执行上下文就是全局上下文</p>
<h4 id="执行上下文的生命周期"><a href="#执行上下文的生命周期" class="headerlink" title="执行上下文的生命周期"></a>执行上下文的生命周期</h4><p>创建阶段 —— 执行上下文的初始化状态，此时<strong>一行代码都还没有执行</strong>，只是做了一些准备工作<br>执行阶段 —— 逐行执行脚本里的代码(执行上下文在执行阶段里其实始终是处在一个动态)</p>
<p><strong>站在上下文角度，才能真正理解 “变量提升” 的本质</strong></p>
<p><strong>函数上下文</strong>： 在函数被调用的时候才会产生…</p>
<h4 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h4><p><strong>作用域其实就是当前所处的执行上下文</strong><br><strong>调用栈是在执行的过程中形成的，而作用域链可是在书写阶段就决定了</strong></p>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>es6 的 class 也是原型的一个语法糖而已</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, age</span>)</span> &#123;<br>   <span class="hljs-built_in">this</span>.name = name<br>   <span class="hljs-built_in">this</span>.age = age<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;肉骨头真好吃&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码等价于下面的代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Dog</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><br>Dog.prototype.eat = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;肉骨头真好吃~&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>关键字：实例、构造函数、原型对象<br>在 JavaScript 中，每个构造函数都拥有一个 <strong>prototype</strong> 属性，它指向构造函数的原型对象，这个原型对象中有一个 <strong>construtor</strong> 属性指回构造函数；每个实例都有一个<strong>proto</strong>属性，当我们使用构造函数去创建实例时，实例的<strong>proto</strong>属性就会指向构造函数的原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个Dog构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Dog</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name<br>  <span class="hljs-built_in">this</span>.age = age<br>&#125;<br>Dog.prototype.eat = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;肉骨头真好吃&#x27;</span>)<br>&#125;<br><span class="hljs-comment">// 使用Dog构造函数创建dog实例</span><br><span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&#x27;旺财&#x27;</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure>

<p>上述关系：<br><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2021-12-12-%E4%B8%8B%E5%8D%884.10.11.png" srcset="/img/loading.gif" lazyload alt="原型"></p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 输出<span class="hljs-string">&quot;肉骨头真好吃&quot;</span><br>dog.eat()<br><span class="hljs-regexp">//</span> 输出<span class="hljs-string">&quot;[object Object]&quot;</span><br>dog.toString()<br></code></pre></td></tr></table></figure>

<p>明明没有在 dog 实例里手动定义 eat 方法和 toString 方法，它们还是被成功地调用了。这是因为当我试图访问一个 JavaScript 实例的属性 / 方法时，它首先搜索这个实例本身；当发现实例没有定义对应的属性 / 方法时，它会转而去搜索实例的原型对象；如果原型对象中也搜索不到，它就去搜索原型对象的原型对象，这个搜索的轨迹，就叫做原型链</p>
<p><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/imgs/%E6%88%AA%E5%B1%8F2021-12-12-%E4%B8%8B%E5%8D%884.26.33.png" srcset="/img/loading.gif" lazyload alt="原型链"></p>
<p><strong>这些彼此相连的 prototype，就构成了所谓的 “原型链”</strong></p>
<p>注： 几乎所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例，除了 Object.prototype（当然，如果我们手动用 Object.create(null) 创建一个没有任何原型的对象，那它也不是 Object 的实例）</p>
<h3 id="原型-amp-原型链题目"><a href="#原型-amp-原型链题目" class="headerlink" title="原型&amp;原型链题目"></a>原型&amp;原型链题目</h3><h4 id="原型基础-构造函数基础"><a href="#原型基础-构造函数基础" class="headerlink" title="原型基础 + 构造函数基础"></a>原型基础 + 构造函数基础</h4><p><strong>此题易错！</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> A = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;<br>A.prototype.n = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> A();<br>A.prototype = &#123;<br>  <span class="hljs-attr">n</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">m</span>: <span class="hljs-number">3</span><br>&#125;<br><span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> A();<br><br><span class="hljs-built_in">console</span>.log(b.n);  <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.log(b.m);  <span class="hljs-comment">// undefined</span><br><br><span class="hljs-built_in">console</span>.log(c.n);  <span class="hljs-comment">// 2</span><br><span class="hljs-built_in">console</span>.log(c.m);  <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure>

<p><strong>注意：b 实例明明和 c 实例继承自一个原型，却有着不同的表现</strong></p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs elm">因为<br><span class="hljs-type">A</span>.proto<span class="hljs-keyword">type</span> = &#123;<br>  n: 2,<br>  m: 3<br>&#125;<br>切断了旧的proto<span class="hljs-keyword">type</span>。而b引用的是旧的prototype。而c引用的是新的prototype<br></code></pre></td></tr></table></figure>

<p>这是一道坑爹题…</p>
<h4 id="自有属性与原型继承属性"><a href="#自有属性与原型继承属性" class="headerlink" title="自有属性与原型继承属性"></a>自有属性与原型继承属性</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;a&#x27;</span><br>  <span class="hljs-built_in">this</span>.color = [<span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;yellow&#x27;</span>]<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span>(<span class="hljs-params"></span>) </span>&#123;<br><br>&#125;<br>B.prototype = <span class="hljs-keyword">new</span> A()<br><span class="hljs-keyword">var</span> b1 = <span class="hljs-keyword">new</span> B()<br><span class="hljs-keyword">var</span> b2 = <span class="hljs-keyword">new</span> B()<br><br>b1.name = <span class="hljs-string">&#x27;change&#x27;</span><br>b1.color.push(<span class="hljs-string">&#x27;black&#x27;</span>)<br><br><span class="hljs-built_in">console</span>.log(b2.name) <span class="hljs-comment">// &#x27;a&#x27;</span><br><span class="hljs-built_in">console</span>.log(b2.color)<br></code></pre></td></tr></table></figure>

<h2 id="变量提升与暂时性死区"><a href="#变量提升与暂时性死区" class="headerlink" title="变量提升与暂时性死区"></a>变量提升与暂时性死区</h2><h3 id="变量提升-2"><a href="#变量提升-2" class="headerlink" title="变量提升"></a>变量提升</h3><p>在 “var” 时代，有一个特别的现象：<strong>不管我们的变量声明是写在程序的哪个角落，最后都会被提到作用域的顶端去</strong></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart">console.log(<span class="hljs-built_in">num</span>);   <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">var</span> <span class="hljs-built_in">num</span> = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>// 等价于下面的代码</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">var</span> <span class="hljs-built_in">num</span>;<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">num</span>);<br><span class="hljs-built_in">num</span> = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>在函数作用域里，也会有类似的现象发生</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNum</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(num)<br>  <span class="hljs-keyword">var</span> num = <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNum</span>() &#123;</span><br>  var <span class="hljs-built_in">num</span><br>  console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">num</span>)<br>  <span class="hljs-built_in">num</span> = <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="变量提升的原理"><a href="#变量提升的原理" class="headerlink" title="变量提升的原理"></a>变量提升的原理</h3><p>跟 js 编译过程有关<br>所有的 JS 代码片段在执行之前都会被编译，只是这个编译的过程非常短暂（可能就只有几微妙、或者更短的时间），紧接着这段代码就会被执行<br>正是在这个短暂的编译阶段里，JS 引擎会搜集所有的变量声明，并且提前让声明生效。至于剩下的语句，则需要等到执行阶段、等到执行到具体的某一句的时候才会生效</p>
<h3 id="被禁用的变量提升"><a href="#被禁用的变量提升" class="headerlink" title="被禁用的变量提升"></a>被禁用的变量提升</h3><blockquote>
<p>用 let 和 const 的变量提升仅仅是声明提升，var 的变量提升是声明提升加初始化提升</p>
</blockquote>
<blockquote>
<p>const 声明的变量，必须在声明同时被初始化，否则会报错;const 声明的变量，在赋值过后，值不可以再被更改。否则同样会报错</p>
</blockquote>
<h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> me = <span class="hljs-string">&#x27;xiuyan&#x27;</span>;<br><br>&#123;<br>	me = <span class="hljs-string">&#x27;bear&#x27;</span>;   <span class="hljs-comment">// 这里是暂时性死区</span><br>	<span class="hljs-keyword">let</span> me;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码报错！</p>
<h3 id="细小知识点"><a href="#细小知识点" class="headerlink" title="细小知识点"></a>细小知识点</h3><h4 id="typeof-操作符的用法"><a href="#typeof-操作符的用法" class="headerlink" title="typeof 操作符的用法"></a>typeof 操作符的用法</h4><p><code>typeof</code>用来返回一个值的变量类型，对于不同类型的变量其返回值如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span> === <span class="hljs-string">&#x27;undefined&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span> === <span class="hljs-string">&#x27;boolean&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-number">89</span> === <span class="hljs-string">&#x27;number&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-string">&#x27;Hey&#x27;</span> === <span class="hljs-string">&#x27;string&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span>() === <span class="hljs-string">&#x27;symbol&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-built_in">BigInt</span>(<span class="hljs-number">1</span>) === <span class="hljs-string">&#x27;bigint&#x27;</span>;<br><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&#x27;abc&#x27;</span>) === <span class="hljs-string">&#x27;object&#x27;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span> === <span class="hljs-string">&#x27;object&#x27;</span>   <span class="hljs-comment">// 这里要注意</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125; === <span class="hljs-string">&#x27;function&#x27;</span><br><span class="hljs-keyword">typeof</span> &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>&#125; === <span class="hljs-string">&#x27;object&#x27;</span><br></code></pre></td></tr></table></figure>

<p>注意 typeof 是用来返回值的类型，而不是返回<strong>变量的类型</strong>因为 JavaScript 中的变量是没有类型的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a) <span class="hljs-comment">// &#x27;number&#x27;</span><br>a = <span class="hljs-string">&#x27;1&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a) <span class="hljs-comment">// &#x27;string&#x27;</span><br></code></pre></td></tr></table></figure>

<p>a 变量是没有类型的，但是赋给 a 变量的值确是有类型的</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/">面试篇</a>
                    
                      <a class="hover-with-bg" href="/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/%E5%9F%BA%E6%9C%AC%E5%8A%9F/">基本功</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93/">面试之道</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/12/10/HTML%E4%B9%8B%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">HTML之语义化标签</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/12/08/JS%E7%9A%84%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">
                        <span class="hidden-mobile">JS的编译原理</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                

              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
      <div class="col-lg-7 mx-auto nopadding-x-md">
        <div class="container custom mx-auto">
          <div style="display: flex"><img src="https://cdn.jsdelivr.net/gh/Bruce-shuai/picBed@master/footer_img2.ukcnbthf4fk.svg" srcset="/img/loading.gif" lazyload alt="" style="height: 200px; margin: 0 auto;"></div>
        </div>
      </div>
    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://juejin.cn/user/862446490487725" target="_blank" rel="nofollow noopener"><span>稀土掘金</span></a> <i class="iconfont icon-aixin" style="color: red;"></i> <a href="https://codesandbox.io/dashboard/home?workspace=3beb9911-b3bc-41d0-8b31-3fe9ca0f09d6" target="_blank" rel="nofollow noopener"><span>CodeSandbox</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>














  
<script src="/js/custom.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/daxuehua.js"></script>
<script src="//cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/metowolf/Metingjs@1.2/dist/Meting.min.js"></script>



<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":200,"height":350},"mobile":{"show":true},"react":{"opacity":0.9},"log":false});</script></body>
</html>
